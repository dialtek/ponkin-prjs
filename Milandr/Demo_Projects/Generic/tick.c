/******************************************************************************
 * @File: tick.c
 * @Author: Milandr, L.
 * @Project: Generic
 * @Version: 1.0.0
 * @Compiler: ARM Compiler V5.06 (build 750)
 * @Microcontroller: К1986ВЕ92QI
 * @Device: Отладочная плата «МилКиТЭС»
 * @Date: 20.03.2020
 * @Purpose: Реализация временной базы
 ******************************************************************************/

// Подключение заголовка
#include "tick.h"

// Инициализация глобальных переменных
// Массив для хранения квантовых меток
uint32_t ticks_mark[WAIT_NUMBER] = {0};

// Кванты работы системы
// (по умолчанию 1 квант = 1 миллисекунде)
uint32_t system_ticks = 0;

// Инициализация системного таймера
void TICK_Init(void)
{
  // Деинициализация
  SysTick->CTRL = 0;
  SysTick->LOAD = 0;
  SysTick->VAL  = 0;

  // Установка периода перезагрузки
  SysTick->LOAD = (SystemCoreClock / SYSTEM_TICK_RATE) - 1;

  // Конфигурация
  SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos)      // Работа таймера (включён)
                | (1 << SysTick_CTRL_TICKINT_Pos)     // Запрос на прерывание (разрешён)
                | (1 << SysTick_CTRL_CLKSOURCE_Pos);  // Истичник тактирования таймера (HCLK)

  // Конфигурация контроллера NVIC
  NVIC_SetPriority(SysTick_IRQn, 7);  // Приоритет прерываний
  NVIC_EnableIRQ(SysTick_IRQn);       // Разрешение обработки прерываний
}

// Реализация интервала ожидания:
// true - ожидание в процессе; false - ожидание завершено или неактивно
bool Wait(uint32_t *ticks_mark, uint32_t wait_ticks)
{
  // Создание квантовой метки
  if (*ticks_mark == 0) {

    // Метка задаётся как сумма текущих системных квантов
    // и заданных квантов ожидания
    *ticks_mark = system_ticks + wait_ticks;

    // Негативный выход:
    // требуется, чтобы задержка начиналась
    // ПОСЛЕ первого выполнения блока кода
    return false;
  }

  // Если значение системных квантов превышает значение метки,
  // то выполняется деинициализация (сброс) этой метки
  // (т.е. интервал ожидания истёк)
  if (system_ticks >= *ticks_mark) {
    *ticks_mark = 0;
  }

  // Позитивный выход
  return true;
}

// Обработчик аппаратных прерываний от SysTick
void SysTick_Handler(void)
{
  // Инкремент значения системных квантов
  system_ticks++;
}
