#include "MDR32Fx.h" // подключение библиотеки МК
#include "stdint.h"

uint8_t adc_lvl_flag = 0; // флаг выхода измерений за допустимые границы
/*------------------------------------------------------------------*/
void MCU_ADC_init()
{
MDR_RST_CLK->PER_CLOCK |= (1 << 17); //вкл. тактирование АЦП
MDR_ADC->ADC1_CFG = (1 // вкл. АЦП
|(0 << 1) // сброс бита «начала преобразования»
|(0 << 2) // источник синхросигнала - CPU_CLK
|(1 << 3) // автоматич. запуск после завершения предыдущ. преобразования
|(0 << 4) // номер канала преобразования будет уст. позже
|(0 << 9) // переключение каналов выкл
|(0 << 10) // автоматический контроль уровней откл.
|(0 << 11) // источник опорного напряжения - внутренний (AUсс = VDD = 3.3В)
|(3 << 12) // коэффициент деления частоты ADC_clk = HCLK/8 = 10 М
|(0 << 16) // работа двух АЦП одновременно откл.
|(0 << 17) // датчик температуры и источника опорного напряжения откл.
|(0 << 18) // усилитель для датчика температуры и ист. опорного напр.откл
|(0 << 19) // оцифровка датчика температуры откл.
|(0 << 20)); // оцифровка источника опорного напряжения на 1.23 В откл.
}
/*------------------------------------------------------------------*/

/*------------------------------------------------------------------*/
void MCU_ADC_set_ch(uint8_t channel)
{
// проверка номера канала и возврат в случае выхода из допустимого диапазона
if (channel > 15) return;
MDR_ADC->ADC1_CFG |= channel << 4; // уст. канала АЦП
}
/*------------------------------------------------------------------*/

/*------------------------------------------------------------------*/
void MCU_ADC_start_conv(void)
{
MDR_ADC->ADC1_CFG |= 1 << 1; // команда начала преобразования
}
/*------------------------------------------------------------------*/

/*------------------------------------------------------------------*/
uint32_t MCU_ADC_read(void)
{
uint32_t ADC_data = 0; // локальная переменная для хранения результата преобр.
MCU_ADC_start_conv(); // команда начала преобразования
// пустой цикл - ожидание окончания преобразования
while(!(MDR_ADC->ADC1_STATUS) & (1<<2)) { }
ADC_data = MDR_ADC->ADC1_RESULT; // чтение результата преобразований
// очистка битов содержащих номер канала преобразования – обнуление старшего
// полубайта регистра
ADC_data = ADC_data & 0x0FFF;
return ADC_data; // возврат результата преобразования
}
/*------------------------------------------------------------------*/
void MCU_ADC_lvl_ctrl_init(uint16_t l_level, uint16_t h_level)
{
// обнуление старшего полубайта уровней, число не более 12 бит
l_level = l_level & 0x0FFF;
h_level = h_level & 0x0FFF;
MDR_ADC->ADC1_CFG |= 1 << 10; // разрешение автоматического контроля уровней
// разрешение генерир. прерывание по событию выхода за допустимые границы
MDR_ADC->ADC1_STATUS = 1 << 3;
MDR_ADC->ADC1_L_LEVEL = l_level; // верхняя граница зоны допуска
MDR_ADC->ADC1_H_LEVEL = h_level; // нижняя граница зоны допуска
}
/*------------------------------------------------------------------*/
void ADC_IRQHandler(void)
{
adc_lvl_flag = 1; // уст. флага выхода измерений за допустимые границы
// разрешение генерир. прерывание по событию выхода за допустимые границы
MDR_ADC->ADC1_STATUS = 1 << 3;
}
/*------------------------------------------------------------------*/