CCS PCH C Compiler, Version 4.065, 38112               12-èþë-11 11:59

               Filename: vmeter.lst

               ROM used: 6294 bytes (77%)
                         Largest free fragment is 1894
               RAM used: 58 (11%) at main() level
                         94 (18%) worst case
               Stack:    7 worst case (6 in main + 1 for interrupts)

*
0000:  GOTO   1454
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FF2.5
004E:  GOTO   0058
0052:  BTFSC  FF2.2
0054:  GOTO   09A2
0058:  MOVFF  0F,00
005C:  MOVFF  10,01
0060:  MOVFF  11,02
0064:  MOVFF  12,03
0068:  MOVFF  13,04
006C:  BSF    0E.7
006E:  MOVFF  0D,FE9
0072:  MOVFF  08,FEA
0076:  MOVFF  09,FE1
007A:  MOVFF  0A,FE2
007E:  MOVFF  0B,FD9
0082:  MOVFF  0C,FDA
0086:  MOVFF  14,FF3
008A:  MOVFF  15,FF4
008E:  MOVFF  16,FFA
0092:  MOVF   05,W
0094:  MOVFF  07,FE0
0098:  MOVFF  06,FD8
009C:  RETFIE 0
.................... //#include "C:\PRJ\BMT1\vmeter.h" 
....................  
.................... #include <18F2320.h> 
.................... //////// Standard Header file for the PIC18F2320 device //////////////// 
.................... #device PIC18F2320 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #IF !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #ENDIF 
....................  
.................... #IF defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #ENDIF 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #IF defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    int8  data1,data2; 
....................    #endif 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #IF !defined(__PCD__) 
....................      *((unsigned int8 *)(&y)) = 0x7E;  
.................... #ENDIF 
....................  
.................... #IF defined(__PCD__) // Takes care of IEEE format 
.................... *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................  *(((unsigned int8 *)(&y))+2) = data1; 
.................... #ENDIF 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #IF !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #ENDIF 
.................... #IF defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
.................... { 
....................      bit_set(data1,0); 
.................... } 
....................     n = data1 - 0x7E; 
.................... #ENDIF 
....................  
....................       if (n<0) 
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int8  data1,data2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................  *(((unsigned int8 *)(&y))+2) = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
.................... { 
....................      bit_set(data1,0); 
.................... } 
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int8  data1,data2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................  *(((unsigned int8 *)(&y))+2) = data1; 
....................  
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................   
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
.................... { 
....................      bit_set(data1,0); 
.................... } 
....................     n = data1 - 0x7E; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(___PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................       (*p)--; 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES H4                       //High speed osc with HW enabled 4X PLL 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... #FUSES BORV45                   //Brownout reset at 4.5V 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
....................  
.................... #use delay(clock=40000000) 
*
09B6:  CLRF   FEA
09B8:  MOVLW  3A
09BA:  MOVWF  FE9
09BC:  MOVF   FEF,W
09BE:  BZ    09DC
09C0:  MOVLW  0C
09C2:  MOVWF  01
09C4:  CLRF   00
09C6:  DECFSZ 00,F
09C8:  BRA    09C6
09CA:  DECFSZ 01,F
09CC:  BRA    09C4
09CE:  MOVLW  F7
09D0:  MOVWF  00
09D2:  DECFSZ 00,F
09D4:  BRA    09D2
09D6:  BRA    09D8
09D8:  DECFSZ FEF,F
09DA:  BRA    09C0
09DC:  RETLW  00
*
0A2E:  MOVLW  02
0A30:  SUBWF  36,F
0A32:  BNC   0A4A
0A34:  CLRF   FEA
0A36:  MOVLW  36
0A38:  MOVWF  FE9
0A3A:  MOVF   FEF,W
0A3C:  BZ    0A4A
0A3E:  MOVLW  02
0A40:  MOVWF  00
0A42:  DECFSZ 00,F
0A44:  BRA    0A42
0A46:  DECFSZ FEF,F
0A48:  BRA    0A3E
0A4A:  RETLW  00
.................... #use rs232(UART1,baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... #BYTE TRISA = 0xF92 
.................... #BYTE TRISB = 0xF93 
.................... #BYTE TRISC = 0xF94  
....................  
.................... #BYTE PORTA = 0xF80 
.................... #BYTE PORTB = 0xF81 
....................  
....................  
.................... #BIT RA2 = PORTA.2 
.................... #BIT TRA2 = TRISA.2 
.................... #BIT LCD_RS = PORTB.3 
.................... #BIT LCD_RW = PORTB.0 
.................... #BIT LCD_E = PORTB.2 
.................... #BIT PORTB4 = PORTB.4 
.................... #BIT PORTB5 = PORTB.5 
.................... #BIT PORTB6 = PORTB.6 
.................... #BIT PORTB7 = PORTB.7 
....................  
....................  
....................  
....................  
.................... typedef unsigned int32 U32; 
.................... typedef int16 U16; 
.................... typedef signed int16 S16; 
.................... typedef int8 U8; 
....................  
.................... // Incremented by timer 0 interrupt 
.................... static U8 buf; 
.................... #BIT buf4=buf.4 
.................... #BIT buf5=buf.5 
.................... #BIT buf6=buf.6 
.................... #BIT buf7=buf.7 
....................  
.................... unsigned int16 CONST TABLE [901]= { 
.................... 2394   , 
.................... 2371   , 
.................... 2348   , 
.................... 2325   , 
.................... 2303   , 
.................... 2282   , 
.................... 2261   , 
.................... 2240   , 
.................... 2220   , 
.................... 2200   , 
.................... 2181   , 
.................... 2162   , 
.................... 2143   , 
.................... 2125   , 
.................... 2107   , 
.................... 2089   , 
.................... 2072   , 
.................... 2055   , 
.................... 2039   , 
.................... 2022   , 
.................... 2006   , 
.................... 1991   , 
.................... 1975   , 
.................... 1960   , 
.................... 1945   , 
.................... 1931   , 
.................... 1916   , 
.................... 1902   , 
.................... 1888   , 
.................... 1874   , 
.................... 1861   , 
.................... 1847   , 
.................... 1834   , 
.................... 1821   , 
.................... 1809   , 
.................... 1796   , 
.................... 1784   , 
.................... 1772   , 
.................... 1759   , 
.................... 1748   , 
.................... 1736   , 
.................... 1724   , 
.................... 1713   , 
.................... 1702   , 
.................... 1690   , 
.................... 1679   , 
.................... 1668   , 
.................... 1658   , 
.................... 1647   , 
.................... 1636   , 
.................... 1626   , 
.................... 1616   , 
.................... 1605   , 
.................... 1595   , 
.................... 1585   , 
.................... 1575   , 
.................... 1565   , 
.................... 1556   , 
.................... 1546   , 
.................... 1536   , 
.................... 1527   , 
.................... 1518   , 
.................... 1508   , 
.................... 1499   , 
.................... 1490   , 
.................... 1481   , 
.................... 1472   , 
.................... 1463   , 
.................... 1454   , 
.................... 1445   , 
.................... 1436   , 
.................... 1427   , 
.................... 1419   , 
.................... 1410   , 
.................... 1402   , 
.................... 1393   , 
.................... 1385   , 
.................... 1376   , 
.................... 1368   , 
.................... 1360   , 
.................... 1352   , 
.................... 1343   , 
.................... 1335   , 
.................... 1327   , 
.................... 1319   , 
.................... 1311   , 
.................... 1303   , 
.................... 1295   , 
.................... 1288   , 
.................... 1280   , 
.................... 1272   , 
.................... 1264   , 
.................... 1257   , 
.................... 1249   , 
.................... 1242   , 
.................... 1234   , 
.................... 1227   , 
.................... 1219   , 
.................... 1212   , 
.................... 1204   , 
.................... 1197   , 
.................... 1190   , 
.................... 1182   , 
.................... 1175   , 
.................... 1168   , 
.................... 1161   , 
.................... 1154   , 
.................... 1147   , 
.................... 1140   , 
.................... 1133   , 
.................... 1126   , 
.................... 1119   , 
.................... 1112   , 
.................... 1106   , 
.................... 1099   , 
.................... 1092   , 
.................... 1085   , 
.................... 1079   , 
.................... 1072   , 
.................... 1066   , 
.................... 1059   , 
.................... 1053   , 
.................... 1046   , 
.................... 1040   , 
.................... 1033   , 
.................... 1027   , 
.................... 1021   , 
.................... 1014   , 
.................... 1008   , 
.................... 1002   , 
.................... 9960   , 
.................... 9899   , 
.................... 9839   , 
.................... 9779   , 
.................... 9719   , 
.................... 9660   , 
.................... 9601   , 
.................... 9542   , 
.................... 9484   , 
.................... 9427   , 
.................... 9369   , 
.................... 9313   , 
.................... 9256   , 
.................... 9200   , 
.................... 9145   , 
.................... 9089   , 
.................... 9035   , 
.................... 8980   , 
.................... 8926   , 
.................... 8872   , 
.................... 8819   , 
.................... 8766   , 
.................... 8714   , 
.................... 8662   , 
.................... 8610   , 
.................... 8559   , 
.................... 8508   , 
.................... 8458   , 
.................... 8408   , 
.................... 8358   , 
.................... 8309   , 
.................... 8260   , 
.................... 8212   , 
.................... 8164   , 
.................... 8116   , 
.................... 8069   , 
.................... 8022   , 
.................... 7976   , 
.................... 7930   , 
.................... 7884   , 
.................... 7839   , 
.................... 7794   , 
.................... 7749   , 
.................... 7705   , 
.................... 7662   , 
.................... 7618   , 
.................... 7575   , 
.................... 7532   , 
.................... 7490   , 
.................... 7448   , 
.................... 7407   , 
.................... 7366   , 
.................... 7325   , 
.................... 7284   , 
.................... 7244   , 
.................... 7205   , 
.................... 7165   , 
.................... 7126   , 
.................... 7088   , 
.................... 7049   , 
.................... 7011   , 
.................... 6974   , 
.................... 6936   , 
.................... 6900   , 
.................... 6863   , 
.................... 6827   , 
.................... 6791   , 
.................... 6755   , 
.................... 6720   , 
.................... 6685   , 
.................... 6650   , 
.................... 6616   , 
.................... 6582   , 
.................... 6548   , 
.................... 6515   , 
.................... 6481   , 
.................... 6449   , 
.................... 6416   , 
.................... 6384   , 
.................... 6352   , 
.................... 6320   , 
.................... 6289   , 
.................... 6258   , 
.................... 6227   , 
.................... 6197   , 
.................... 6166   , 
.................... 6136   , 
.................... 6107   , 
.................... 6077   , 
.................... 6048   , 
.................... 6019   , 
.................... 5990   , 
.................... 5962   , 
.................... 5934   , 
.................... 5906   , 
.................... 5878   , 
.................... 5850   , 
.................... 5823   , 
.................... 5796   , 
.................... 5769   , 
.................... 5743   , 
.................... 5716   , 
.................... 5690   , 
.................... 5664   , 
.................... 5638   , 
.................... 5613   , 
.................... 5588   , 
.................... 5562   , 
.................... 5538   , 
.................... 5513   , 
.................... 5488   , 
.................... 5464   , 
.................... 5440   , 
.................... 5416   , 
.................... 5392   , 
.................... 5368   , 
.................... 5345   , 
.................... 5321   , 
.................... 5298   , 
.................... 5275   , 
.................... 5252   , 
.................... 5230   , 
.................... 5207   , 
.................... 5185   , 
.................... 5163   , 
.................... 5141   , 
.................... 5119   , 
.................... 5097   , 
.................... 5075   , 
.................... 5054   , 
.................... 5032   , 
.................... 5011   , 
.................... 4990   , 
.................... 4969   , 
.................... 4948   , 
.................... 4927   , 
.................... 4907   , 
.................... 4886   , 
.................... 4866   , 
.................... 4845   , 
.................... 4825   , 
.................... 4805   , 
.................... 4785   , 
.................... 4765   , 
.................... 4745   , 
.................... 4726   , 
.................... 4706   , 
.................... 4687   , 
.................... 4667   , 
.................... 4648   , 
.................... 4629   , 
.................... 4610   , 
.................... 4591   , 
.................... 4572   , 
.................... 4553   , 
.................... 4534   , 
.................... 4515   , 
.................... 4496   , 
.................... 4478   , 
.................... 4459   , 
.................... 4441   , 
.................... 4423   , 
.................... 4404   , 
.................... 4386   , 
.................... 4368   , 
.................... 4350   , 
.................... 4332   , 
.................... 4314   , 
.................... 4296   , 
.................... 4278   , 
.................... 4260   , 
.................... 4243   , 
.................... 4225   , 
.................... 4207   , 
.................... 4190   , 
.................... 4173   , 
.................... 4155   , 
.................... 4138   , 
.................... 4120   , 
.................... 4103   , 
.................... 4086   , 
.................... 4069   , 
.................... 4052   , 
.................... 4035   , 
.................... 4018   , 
.................... 4001   , 
.................... 3984   , 
.................... 3967   , 
.................... 3951   , 
.................... 3934   , 
.................... 3917   , 
.................... 3901   , 
.................... 3884   , 
.................... 3868   , 
.................... 3851   , 
.................... 3835   , 
.................... 3819   , 
.................... 3802   , 
.................... 3786   , 
.................... 3770   , 
.................... 3754   , 
.................... 3738   , 
.................... 3722   , 
.................... 3706   , 
.................... 3690   , 
.................... 3674   , 
.................... 3658   , 
.................... 3643   , 
.................... 3627   , 
.................... 3611   , 
.................... 3596   , 
.................... 3580   , 
.................... 3565   , 
.................... 3550   , 
.................... 3534   , 
.................... 3519   , 
.................... 3504   , 
.................... 3489   , 
.................... 3474   , 
.................... 3459   , 
.................... 3444   , 
.................... 3429   , 
.................... 3414   , 
.................... 3399   , 
.................... 3384   , 
.................... 3370   , 
.................... 3355   , 
.................... 3341   , 
.................... 3326   , 
.................... 3312   , 
.................... 3298   , 
.................... 3283   , 
.................... 3269   , 
.................... 3255   , 
.................... 3241   , 
.................... 3227   , 
.................... 3213   , 
.................... 3200   , 
.................... 3186   , 
.................... 3172   , 
.................... 3159   , 
.................... 3145   , 
.................... 3132   , 
.................... 3119   , 
.................... 3105   , 
.................... 3092   , 
.................... 3079   , 
.................... 3066   , 
.................... 3053   , 
.................... 3040   , 
.................... 3028   , 
.................... 3015   , 
.................... 3002   , 
.................... 2990   , 
.................... 2977   , 
.................... 2965   , 
.................... 2953   , 
.................... 2941   , 
.................... 2929   , 
.................... 2917   , 
.................... 2905   , 
.................... 2893   , 
.................... 2881   , 
.................... 2870   , 
.................... 2858   , 
.................... 2847   , 
.................... 2835   , 
.................... 2824   , 
.................... 2813   , 
.................... 2802   , 
.................... 2791   , 
.................... 2780   , 
.................... 2770   , 
.................... 2759   , 
.................... 2748   , 
.................... 2738   , 
.................... 2727   , 
.................... 2717   , 
.................... 2707   , 
.................... 2697   , 
.................... 2687   , 
.................... 2677   , 
.................... 2667   , 
.................... 2658   , 
.................... 2648   , 
.................... 2638   , 
.................... 2629   , 
.................... 2620   , 
.................... 2611   , 
.................... 2602   , 
.................... 2593   , 
.................... 2584   , 
.................... 2575   , 
.................... 2566   , 
.................... 2557   , 
.................... 2549   , 
.................... 2541   , 
.................... 2532   , 
.................... 2524   , 
.................... 2516   , 
.................... 2508   , 
.................... 2500   , 
.................... 2492   , 
.................... 2484   , 
.................... 2477   , 
.................... 2469   , 
.................... 2462   , 
.................... 2454   , 
.................... 2447   , 
.................... 2440   , 
.................... 2433   , 
.................... 2426   , 
.................... 2419   , 
.................... 2412   , 
.................... 2405   , 
.................... 2398   , 
.................... 2392   , 
.................... 2385   , 
.................... 2379   , 
.................... 2373   , 
.................... 2366   , 
.................... 2360   , 
.................... 2354   , 
.................... 2348   , 
.................... 2342   , 
.................... 2336   , 
.................... 2331   , 
.................... 2325   , 
.................... 2319   , 
.................... 2314   , 
.................... 2308   , 
.................... 2303   , 
.................... 2298   , 
.................... 2292   , 
.................... 2287   , 
.................... 2282   , 
.................... 2277   , 
.................... 2272   , 
.................... 2267   , 
.................... 2262   , 
.................... 2257   , 
.................... 2252   , 
.................... 2248   , 
.................... 2243   , 
.................... 2239   , 
.................... 2234   , 
.................... 2229   , 
.................... 2225   , 
.................... 2221   , 
.................... 2216   , 
.................... 2212   , 
.................... 2208   , 
.................... 2203   , 
.................... 2199   , 
.................... 2195   , 
.................... 2191   , 
.................... 2187   , 
.................... 2183   , 
.................... 2179   , 
.................... 2175   , 
.................... 2171   , 
.................... 2167   , 
.................... 2163   , 
.................... 2159   , 
.................... 2155   , 
.................... 2152   , 
.................... 2148   , 
.................... 2144   , 
.................... 2140   , 
.................... 2137   , 
.................... 2133   , 
.................... 2129   , 
.................... 2125   , 
.................... 2122   , 
.................... 2118   , 
.................... 2114   , 
.................... 2110   , 
.................... 2107   , 
.................... 2103   , 
.................... 2099   , 
.................... 2096   , 
.................... 2092   , 
.................... 2088   , 
.................... 2084   , 
.................... 2081   , 
.................... 2077   , 
.................... 2073   , 
.................... 2069   , 
.................... 2066   , 
.................... 2062   , 
.................... 2058   , 
.................... 2054   , 
.................... 2050   , 
.................... 2046   , 
.................... 2042   , 
.................... 2038   , 
.................... 2034   , 
.................... 2030   , 
.................... 2026   , 
.................... 2022   , 
.................... 2018   , 
.................... 2014   , 
.................... 2010   , 
.................... 2006   , 
.................... 2001   , 
.................... 1997   , 
.................... 1993   , 
.................... 1988   , 
.................... 1984   , 
.................... 1980   , 
.................... 1975   , 
.................... 1971   , 
.................... 1966   , 
.................... 1961   , 
.................... 1957   , 
.................... 1952   , 
.................... 1947   , 
.................... 1942   , 
.................... 1937   , 
.................... 1932   , 
.................... 1927   , 
.................... 1922   , 
.................... 1917   , 
.................... 1912   , 
.................... 1907   , 
.................... 1902   , 
.................... 1896   , 
.................... 1891   , 
.................... 1885   , 
.................... 1880   , 
.................... 1874   , 
.................... 1869   , 
.................... 1863   , 
.................... 1857   , 
.................... 1852   , 
.................... 1846   , 
.................... 1840   , 
.................... 1834   , 
.................... 1828   , 
.................... 1822   , 
.................... 1816   , 
.................... 1809   , 
.................... 1803   , 
.................... 1797   , 
.................... 1791   , 
.................... 1784   , 
.................... 1778   , 
.................... 1771   , 
.................... 1764   , 
.................... 1758   , 
.................... 1751   , 
.................... 1744   , 
.................... 1738   , 
.................... 1731   , 
.................... 1724   , 
.................... 1717   , 
.................... 1710   , 
.................... 1703   , 
.................... 1695   , 
.................... 1688   , 
.................... 1681   , 
.................... 1674   , 
.................... 1666   , 
.................... 1659   , 
.................... 1652   , 
.................... 1644   , 
.................... 1637   , 
.................... 1629   , 
.................... 1622   , 
.................... 1614   , 
.................... 1606   , 
.................... 1599   , 
.................... 1591   , 
.................... 1583   , 
.................... 1575   , 
.................... 1568   , 
.................... 1560   , 
.................... 1552   , 
.................... 1544   , 
.................... 1536   , 
.................... 1528   , 
.................... 1520   , 
.................... 1512   , 
.................... 1504   , 
.................... 1496   , 
.................... 1488   , 
.................... 1480   , 
.................... 1472   , 
.................... 1464   , 
.................... 1456   , 
.................... 1448   , 
.................... 1440   , 
.................... 1432   , 
.................... 1423   , 
.................... 1415   , 
.................... 1407   , 
.................... 1399   , 
.................... 1391   , 
.................... 1383   , 
.................... 1375   , 
.................... 1367   , 
.................... 1359   , 
.................... 1351   , 
.................... 1343   , 
.................... 1335   , 
.................... 1327   , 
.................... 1319   , 
.................... 1311   , 
.................... 1304   , 
.................... 1296   , 
.................... 1288   , 
.................... 1280   , 
.................... 1273   , 
.................... 1265   , 
.................... 1257   , 
.................... 1250   , 
.................... 1242   , 
.................... 1235   , 
.................... 1227   , 
.................... 1220   , 
.................... 1213   , 
.................... 1206   , 
.................... 1198   , 
.................... 1191   , 
.................... 1184   , 
.................... 1177   , 
.................... 1170   , 
.................... 1163   , 
.................... 1156   , 
.................... 1150   , 
.................... 1143   , 
.................... 1136   , 
.................... 1130   , 
.................... 1123   , 
.................... 1117   , 
.................... 1111   , 
.................... 1104   , 
.................... 1098   , 
.................... 1092   , 
.................... 1086   , 
.................... 1080   , 
.................... 1074   , 
.................... 1069   , 
.................... 1063   , 
.................... 1057   , 
.................... 1052   , 
.................... 1047   , 
.................... 1041   , 
.................... 1036   , 
.................... 1031   , 
.................... 1026   , 
.................... 1021   , 
.................... 1016   , 
.................... 1011   , 
.................... 1007   , 
.................... 1002   , 
.................... 9974   , 
.................... 9930   , 
.................... 9887   , 
.................... 9844   , 
.................... 9803   , 
.................... 9762   , 
.................... 9722   , 
.................... 9684   , 
.................... 9646   , 
.................... 9608   , 
.................... 9572   , 
.................... 9537   , 
.................... 9502   , 
.................... 9468   , 
.................... 9435   , 
.................... 9241   , 
.................... 9183   , 
.................... 9124   , 
.................... 9066   , 
.................... 9008   , 
.................... 8950   , 
.................... 8892   , 
.................... 8834   , 
.................... 8777   , 
.................... 8719   , 
.................... 8662   , 
.................... 8605   , 
.................... 8548   , 
.................... 8491   , 
.................... 8434   , 
.................... 8378   , 
.................... 8322   , 
.................... 8265   , 
.................... 8209   , 
.................... 8153   , 
.................... 8097   , 
.................... 8042   , 
.................... 7986   , 
.................... 7931   , 
.................... 7875   , 
.................... 7820   , 
.................... 7765   , 
.................... 7710   , 
.................... 7655   , 
.................... 7601   , 
.................... 7546   , 
.................... 7492   , 
.................... 7437   , 
.................... 7383   , 
.................... 7329   , 
.................... 7275   , 
.................... 7221   , 
.................... 7168   , 
.................... 7114   , 
.................... 7060   , 
.................... 7007   , 
.................... 6954   , 
.................... 6900   , 
.................... 6847   , 
.................... 6794   , 
.................... 6741   , 
.................... 6688   , 
.................... 6636   , 
.................... 6583   , 
.................... 6530   , 
.................... 6478   , 
.................... 6426   , 
.................... 6373   , 
.................... 6321   , 
.................... 6269   , 
.................... 6217   , 
.................... 6165   , 
.................... 6113   , 
.................... 6061   , 
.................... 6010   , 
.................... 5958   , 
.................... 5906   , 
.................... 5855   , 
.................... 5804   , 
.................... 5752   , 
.................... 5701   , 
.................... 5650   , 
.................... 5599   , 
.................... 5548   , 
.................... 5497   , 
.................... 5446   , 
.................... 5395   , 
.................... 5344   , 
.................... 5294   , 
.................... 5243   , 
.................... 5193   , 
.................... 5142   , 
.................... 5092   , 
.................... 5041   , 
.................... 4991   , 
.................... 4941   , 
.................... 4891   , 
.................... 4841   , 
.................... 4791   , 
.................... 4741   , 
.................... 4691   , 
.................... 4641   , 
.................... 4591   , 
.................... 4542   , 
.................... 4492   , 
.................... 4443   , 
.................... 4393   , 
.................... 4344   , 
.................... 4295   , 
.................... 4245   , 
.................... 4196   , 
.................... 4147   , 
.................... 4098   , 
.................... 4049   , 
.................... 4000   , 
.................... 3952   , 
.................... 3903   , 
.................... 3854   , 
.................... 3806   , 
.................... 3757   , 
.................... 3709   , 
.................... 3661   , 
.................... 3612   , 
.................... 3564   , 
.................... 3516   , 
.................... 3468   , 
.................... 3421   , 
.................... 3373   , 
.................... 3325   , 
.................... 3278   , 
.................... 3230   , 
.................... 3183   , 
.................... 3136   , 
.................... 3089   , 
.................... 3042   , 
.................... 2995   , 
.................... 2948   , 
.................... 2901   , 
.................... 2855   , 
.................... 2809   , 
.................... 2762   , 
.................... 2716   , 
.................... 2670   , 
.................... 2625   , 
.................... 2579   , 
.................... 2533   , 
.................... 2488   , 
.................... 2443   , 
.................... 2398   , 
.................... 2353   , 
.................... 2308   , 
.................... 2264   , 
.................... 2219   , 
.................... 2175   , 
.................... 2131   , 
.................... 2087   , 
.................... 2044   , 
.................... 2001   , 
.................... 1957   , 
.................... 1914   , 
.................... 1872   , 
.................... 1829   , 
.................... 1787   , 
.................... 1745   , 
.................... 1703   , 
.................... 1662   , 
.................... 1620   , 
.................... 1579   , 
.................... 1539   , 
.................... 1498   , 
.................... 1458   , 
.................... 1418   , 
.................... 1379   , 
.................... 1339   , 
.................... 1300   , 
.................... 1262   , 
.................... 1224   , 
.................... 1186   , 
.................... 1148   , 
.................... 1111   , 
.................... 1074   , 
.................... 1037   , 
.................... 1001   , 
.................... 9652   , 
.................... 9298   , 
.................... 8948   , 
.................... 8603   , 
.................... 8261   , 
.................... 7924   , 
.................... 7591   , 
.................... 7262   , 
.................... 6939   , 
.................... 6619   , 
.................... 6305   , 
.................... 5996   , 
.................... 5691   , 
.................... 5392   , 
.................... 5098   , 
.................... 4809   , 
.................... 4525   , 
.................... 4247   , 
.................... 3975   , 
.................... 3709   , 
.................... 3448   , 
.................... 3194   , 
.................... 2945   , 
.................... 2703   , 
.................... 2467   , 
.................... 2238   , 
.................... 2015   , 
.................... 1799   , 
.................... 1590   , 
.................... 1388   , 
.................... 1193   , 
.................... 1005}; 
....................  
....................  
.................... Static U16 Ih,Ut; 
.................... static U8 TMR0fl=0; 
.................... static U8 ff1=0; 
.................... static U16 pwm_val=535;// íà÷àëüíîå çíà÷åíèå òîêà íàãðåâàòåëÿ 
....................  
.................... //Çàïèñü è ÷òåíèå EEPROM 
....................  
.................... static U16 U16EERead(U8 Adr){ 
.................... U8 value; 
.................... U16 DATA; 
.................... DATA = read_eeprom(Adr+1);//ñò.áàéò 
*
0B7E:  MOVLW  01
0B80:  ADDWF  3A,W
0B82:  MOVWF  3E
0B84:  MOVFF  FF2,3F
0B88:  BCF    FF2.7
0B8A:  MOVFF  3E,FA9
0B8E:  BCF    FA6.6
0B90:  BCF    FA6.7
0B92:  BSF    FA6.0
0B94:  MOVF   FA8,W
0B96:  BTFSC  3F.7
0B98:  BSF    FF2.7
0B9A:  CLRF   3D
0B9C:  MOVWF  3C
.................... DATA=DATA<<8; 
0B9E:  MOVFF  3C,3D
0BA2:  CLRF   3C
.................... DATA = DATA+read_eeprom(Adr);//ìë.áàéò 
0BA4:  MOVFF  FF2,3E
0BA8:  BCF    FF2.7
0BAA:  MOVFF  3A,FA9
0BAE:  BCF    FA6.6
0BB0:  BCF    FA6.7
0BB2:  BSF    FA6.0
0BB4:  MOVF   FA8,W
0BB6:  BTFSC  3E.7
0BB8:  BSF    FF2.7
0BBA:  ADDWF  3C,F
0BBC:  MOVLW  00
0BBE:  ADDWFC 3D,F
.................... return DATA; 
0BC0:  MOVFF  3C,01
0BC4:  MOVFF  3D,02
.................... } 
0BC8:  RETLW  00
....................  
....................  
.................... static U8 U16EEWrite(U16 Data, U8 Adr){ 
.................... U8 value; 
.................... value=DATA; 
*
13BE:  MOVFF  36,39
.................... write_eeprom (Adr, value);//ìë.áàéò 
13C2:  MOVFF  38,FA9
13C6:  MOVFF  39,FA8
13CA:  BCF    FA6.6
13CC:  BCF    FA6.7
13CE:  BSF    FA6.2
13D0:  MOVFF  FF2,00
13D4:  BCF    FF2.7
13D6:  MOVLB  F
13D8:  MOVLW  55
13DA:  MOVWF  FA7
13DC:  MOVLW  AA
13DE:  MOVWF  FA7
13E0:  BSF    FA6.1
13E2:  BTFSC  FA6.1
13E4:  BRA    13E2
13E6:  BCF    FA6.2
13E8:  MOVF   00,W
13EA:  IORWF  FF2,F
.................... value=DATA>>8; 
13EC:  MOVFF  37,39
.................... write_eeprom (Adr+1, value);//ñò.áàéò 
13F0:  MOVLW  01
13F2:  ADDWF  38,W
13F4:  MOVWF  3A
13F6:  MOVWF  FA9
13F8:  MOVFF  39,FA8
13FC:  BCF    FA6.6
13FE:  BCF    FA6.7
1400:  BSF    FA6.2
1402:  MOVFF  FF2,00
1406:  BCF    FF2.7
1408:  MOVLW  55
140A:  MOVWF  FA7
140C:  MOVLW  AA
140E:  MOVWF  FA7
1410:  BSF    FA6.1
1412:  BTFSC  FA6.1
1414:  BRA    1412
1416:  BCF    FA6.2
1418:  MOVF   00,W
141A:  IORWF  FF2,F
.................... delay_ms(10); 
141C:  MOVLW  0A
141E:  MOVWF  3A
1420:  MOVLB  0
1422:  CALL   09B6
.................... if(U16EERead(Adr)==DATA) return 1; 
1426:  MOVFF  38,3A
142A:  CALL   0B7E
142E:  MOVFF  02,3B
1432:  MOVFF  01,3A
1436:  MOVF   36,W
1438:  SUBWF  01,W
143A:  BNZ   144A
143C:  MOVF   37,W
143E:  SUBWF  3B,W
1440:  BNZ   144A
1442:  MOVLW  01
1444:  MOVWF  01
1446:  BRA    1450
....................  else return 0; 
1448:  BRA    1450
144A:  MOVLW  00
144C:  MOVWF  01
144E:  BRA    1450
.................... } 
1450:  GOTO   188E (RETURN)
....................   
....................  
....................  
....................  
.................... /***************** LCD functions *****************/ 
....................  
.................... static void LCDWriteNibble(unsigned char uc) /* RS must be set/reset before calling */ 
.................... {                                           //Çàïèñü ïîëîâèíû áàéòà 
....................   uc=uc << 4; /* Align with bits 7-4*/ 
*
09DE:  SWAPF  54,F
09E0:  MOVLW  F0
09E2:  ANDWF  54,F
....................   LCD_RW=0; 
09E4:  BCF    F81.0
....................   //TRISB=0b00000010; /* Set to output bits 7-4 */ 
....................   //PORTB=uc; 
....................   buf=uc; 
09E6:  MOVFF  54,18
....................   PORTB4=buf4; 
09EA:  BTFSS  18.4
09EC:  BCF    F81.4
09EE:  BTFSC  18.4
09F0:  BSF    F81.4
....................   PORTB5=buf5; 
09F2:  BTFSS  18.5
09F4:  BCF    F81.5
09F6:  BTFSC  18.5
09F8:  BSF    F81.5
....................   PORTB6=buf6; 
09FA:  BTFSS  18.6
09FC:  BCF    F81.6
09FE:  BTFSC  18.6
0A00:  BSF    F81.6
....................   PORTB7=buf7; 
0A02:  BTFSS  18.7
0A04:  BCF    F81.7
0A06:  BTFSC  18.7
0A08:  BSF    F81.7
....................   delay_us(1); 
0A0A:  MOVLW  03
0A0C:  MOVWF  00
0A0E:  DECFSZ 00,F
0A10:  BRA    0A0E
....................   LCD_E=1; 
0A12:  BSF    F81.2
....................   delay_us(2); 
0A14:  MOVLW  06
0A16:  MOVWF  00
0A18:  DECFSZ 00,F
0A1A:  BRA    0A18
0A1C:  NOP   
....................   LCD_E=0; 
0A1E:  BCF    F81.2
....................   delay_us(2); 
0A20:  MOVLW  06
0A22:  MOVWF  00
0A24:  DECFSZ 00,F
0A26:  BRA    0A24
0A28:  NOP   
....................   LCD_RW=1;  
0A2A:  BSF    F81.0
....................   //TRISB=0b11110010; /* Set to input bits 7-4 */   
.................... } 
0A2C:  RETLW  00
....................  
.................... static U8 PBScan(U8 pb){ 
.................... // ñêàíèðîâàíèå êíîïîê 
.................... //pb-íîìåð êíîïêè(0-3); 
....................  U8 uc=1; 
*
1370:  MOVLW  01
1372:  MOVWF  37
....................    uc=uc<<(4+pb); 
1374:  MOVLW  04
1376:  ADDWF  36,W
1378:  MOVWF  01
137A:  MOVF   01,F
137C:  BZ    1386
137E:  BCF    FD8.0
1380:  RLCF   37,F
1382:  DECFSZ 01,F
1384:  BRA    137E
....................    buf=uc; 
1386:  MOVFF  37,18
....................    //óñòàíàâëèâàåì â 1 ñîîòâ. ëèíèþ 
....................     PORTB4=buf4; 
138A:  BTFSS  18.4
138C:  BCF    F81.4
138E:  BTFSC  18.4
1390:  BSF    F81.4
....................     PORTB5=buf5; 
1392:  BTFSS  18.5
1394:  BCF    F81.5
1396:  BTFSC  18.5
1398:  BSF    F81.5
....................     PORTB6=buf6; 
139A:  BTFSS  18.6
139C:  BCF    F81.6
139E:  BTFSC  18.6
13A0:  BSF    F81.6
....................     PORTB7=buf7; 
13A2:  BTFSS  18.7
13A4:  BCF    F81.7
13A6:  BTFSC  18.7
13A8:  BSF    F81.7
....................     delay_us(10); 
13AA:  MOVLW  21
13AC:  MOVWF  00
13AE:  DECFSZ 00,F
13B0:  BRA    13AE
....................    return RA2; 
13B2:  MOVLW  00
13B4:  BTFSC  F80.2
13B6:  MOVLW  01
13B8:  MOVWF  01
....................        
.................... } 
13BA:  GOTO   1778 (RETURN)
....................  
....................  
....................  
....................  
....................  
....................  
.................... static void LCDWriteData(unsigned char uc) 
.................... { 
....................    
....................     LCD_RS=0; 
*
0AFA:  BCF    F81.3
....................      delay_us(50); 
0AFC:  MOVLW  A6
0AFE:  MOVWF  00
0B00:  DECFSZ 00,F
0B02:  BRA    0B00
0B04:  NOP   
....................     LCD_RS=1; 
0B06:  BSF    F81.3
....................     LCD_RW=1;// Âîññòàíîâëåíèå áàéòîâîé ñèíõðîíèçàöèè 
0B08:  BSF    F81.0
....................     LCDWriteNibble(uc>>4); 
0B0A:  SWAPF  52,W
0B0C:  MOVWF  53
0B0E:  MOVLW  0F
0B10:  ANDWF  53,F
0B12:  MOVFF  53,54
0B16:  RCALL  09DE
....................     LCDWriteNibble(uc); 
0B18:  MOVFF  52,54
0B1C:  RCALL  09DE
....................    
.................... } 
0B1E:  GOTO   0B28 (RETURN)
....................  
....................  
....................  
.................... static void LCDCommand(unsigned char uc) 
.................... { 
....................    
....................     LCD_RS=0; /* Instruction mode */ 
*
0A4C:  BCF    F81.3
....................     delay_us(50); 
0A4E:  MOVLW  A6
0A50:  MOVWF  00
0A52:  DECFSZ 00,F
0A54:  BRA    0A52
0A56:  NOP   
....................     LCD_RW=1;// Âîññòàíîâëåíèå áàéòîâîé ñèíõðîíèçàöèè 
0A58:  BSF    F81.0
....................     LCDWriteNibble(uc>>4); 
0A5A:  SWAPF  41,W
0A5C:  MOVWF  42
0A5E:  MOVLW  0F
0A60:  ANDWF  42,F
0A62:  MOVFF  42,54
0A66:  RCALL  09DE
....................     LCDWriteNibble(uc); 
0A68:  MOVFF  41,54
0A6C:  RCALL  09DE
....................    
.................... } 
0A6E:  RETLW  00
....................  
....................  
.................... static void LCDSetCursor(unsigned char ucPos) 
.................... { 
....................    
....................    
....................     LCDCommand(0x80 | ucPos); 
*
0B32:  MOVF   3F,W
0B34:  IORLW  80
0B36:  MOVWF  40
0B38:  MOVWF  41
0B3A:  RCALL  0A4C
....................    
.................... } 
0B3C:  RETLW  00
....................  
.................... static void LCDClear(void) 
.................... { 
....................   
....................     LCDCommand(0x1); 
*
0AEC:  MOVLW  01
0AEE:  MOVWF  41
0AF0:  RCALL  0A4C
....................     Delay_ms(2); 
0AF2:  MOVLW  02
0AF4:  MOVWF  3A
0AF6:  RCALL  09B6
....................    
.................... } 
0AF8:  RETLW  00
....................  
....................  
.................... static void LCDInit(void) 
....................  
.................... { 
....................     
....................   LCD_E=0; 
*
0A70:  BCF    F81.2
....................   LCD_RS=0; 
0A72:  BCF    F81.3
....................   Delay_ms(1000); // 
0A74:  MOVLW  04
0A76:  MOVWF  36
0A78:  MOVLW  FA
0A7A:  MOVWF  3A
0A7C:  RCALL  09B6
0A7E:  DECFSZ 36,F
0A80:  BRA    0A78
....................   LCDWriteNibble(3); 
0A82:  MOVLW  03
0A84:  MOVWF  54
0A86:  RCALL  09DE
....................   Delay_us(200); 
0A88:  MOVLW  C8
0A8A:  MOVWF  36
0A8C:  RCALL  0A2E
....................   LCDWriteNibble(3); 
0A8E:  MOVLW  03
0A90:  MOVWF  54
0A92:  RCALL  09DE
....................   Delay_us(200); 
0A94:  MOVLW  C8
0A96:  MOVWF  36
0A98:  RCALL  0A2E
....................   LCDWriteNibble(3); 
0A9A:  MOVLW  03
0A9C:  MOVWF  54
0A9E:  RCALL  09DE
....................   Delay_us(200); 
0AA0:  MOVLW  C8
0AA2:  MOVWF  36
0AA4:  RCALL  0A2E
....................   LCDWriteNibble(2); 
0AA6:  MOVLW  02
0AA8:  MOVWF  54
0AAA:  RCALL  09DE
....................   Delay_us(200); 
0AAC:  MOVLW  C8
0AAE:  MOVWF  36
0AB0:  RCALL  0A2E
....................    
....................    
....................   LCDCommand(0x28);//4-áèòíûé ðåæèì, 2 ñòðîêè, øðèôò 5x8 òî÷åê 
0AB2:  MOVLW  28
0AB4:  MOVWF  41
0AB6:  RCALL  0A4C
....................    
....................   LCDCommand(0x08);// Âûêëþ÷èòü äèñïëåé, âûêëþ÷èòü êóðñîð, âûêëþ÷èòü ìîðãàíèå êóðñîðà 
0AB8:  MOVLW  08
0ABA:  MOVWF  41
0ABC:  RCALL  0A4C
....................   LCDCommand(0x0F);// Âêëþ÷èòü äèñïëåé, âêëþ÷èòü êóðñîð, âêëþ÷èòü ìîðãàíèå êóðñîðà 
0ABE:  MOVLW  0F
0AC0:  MOVWF  41
0AC2:  RCALL  0A4C
....................   LCDCommand(0x06);// Êóðñîð áóäåò äâèãàòüñÿ âïðàâî ïðè âûâîäå òåêñòà 
0AC4:  MOVLW  06
0AC6:  MOVWF  41
0AC8:  RCALL  0A4C
....................   LCDCommand(0x1);// Î÷èñòêà ýêðàíà è ïåðåìåùåíèå êóðñîðà â ïåðâóþ ïîçèöèþ  
0ACA:  MOVLW  01
0ACC:  MOVWF  41
0ACE:  RCALL  0A4C
....................    delay_ms(2); 
0AD0:  MOVLW  02
0AD2:  MOVWF  3A
0AD4:  RCALL  09B6
....................   LCDCommand(0x06);// Êóðñîð áóäåò äâèãàòüñÿ âïðàâî ïðè âûâîäå òåêñòà  
0AD6:  MOVLW  06
0AD8:  MOVWF  41
0ADA:  RCALL  0A4C
....................   LCDCommand(0x40);//Óñòàíîâêà àäðåñà DRAM 
0ADC:  MOVLW  40
0ADE:  MOVWF  41
0AE0:  RCALL  0A4C
....................   delay_ms(10); 
0AE2:  MOVLW  0A
0AE4:  MOVWF  3A
0AE6:  RCALL  09B6
....................  } 
0AE8:  GOTO   151C (RETURN)
.................... static void LCDPutCh(char c) 
.................... { 
....................   LCDWriteData(c); 
*
0B22:  MOVFF  51,52
0B26:  BRA    0AFA
.................... } 
0B28:  RETLW  00
....................  
.................... static void LCDPutU16(U32 _u16,U8 u8NumDigs) 
.................... { 
....................   
....................    
....................     U32 u16a ,u16b; 
....................      
....................     u16a=_u16/10000; 
*
0D9C:  MOVFF  46,53
0DA0:  MOVFF  45,52
0DA4:  MOVFF  44,51
0DA8:  MOVFF  43,50
0DAC:  CLRF   57
0DAE:  CLRF   56
0DB0:  MOVLW  27
0DB2:  MOVWF  55
0DB4:  MOVLW  10
0DB6:  MOVWF  54
0DB8:  RCALL  0C1E
0DBA:  MOVFF  03,4B
0DBE:  MOVFF  02,4A
0DC2:  MOVFF  01,49
0DC6:  MOVFF  00,48
....................     u16b=u16a*10000; 
0DCA:  MOVFF  4B,53
0DCE:  MOVFF  4A,52
0DD2:  MOVFF  49,51
0DD6:  MOVFF  48,50
0DDA:  CLRF   57
0DDC:  CLRF   56
0DDE:  MOVLW  27
0DE0:  MOVWF  55
0DE2:  MOVLW  10
0DE4:  MOVWF  54
0DE6:  RCALL  0BCA
0DE8:  MOVFF  03,4F
0DEC:  MOVFF  02,4E
0DF0:  MOVFF  01,4D
0DF4:  MOVFF  00,4C
....................  
....................     if (u8NumDigs>=5) 
0DF8:  MOVF   47,W
0DFA:  SUBLW  04
0DFC:  BC    0E08
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0DFE:  MOVLW  30
0E00:  ADDWF  48,W
0E02:  MOVWF  50
0E04:  MOVWF  51
0E06:  RCALL  0B22
....................     } 
....................  
....................     _u16-=u16b; 
0E08:  MOVF   4C,W
0E0A:  SUBWF  43,F
0E0C:  MOVF   4D,W
0E0E:  SUBWFB 44,F
0E10:  MOVF   4E,W
0E12:  SUBWFB 45,F
0E14:  MOVF   4F,W
0E16:  SUBWFB 46,F
....................     u16a=_u16/1000; 
0E18:  MOVFF  46,53
0E1C:  MOVFF  45,52
0E20:  MOVFF  44,51
0E24:  MOVFF  43,50
0E28:  CLRF   57
0E2A:  CLRF   56
0E2C:  MOVLW  03
0E2E:  MOVWF  55
0E30:  MOVLW  E8
0E32:  MOVWF  54
0E34:  RCALL  0C1E
0E36:  MOVFF  03,4B
0E3A:  MOVFF  02,4A
0E3E:  MOVFF  01,49
0E42:  MOVFF  00,48
....................     u16b=u16a*1000; 
0E46:  MOVFF  4B,53
0E4A:  MOVFF  4A,52
0E4E:  MOVFF  49,51
0E52:  MOVFF  48,50
0E56:  CLRF   57
0E58:  CLRF   56
0E5A:  MOVLW  03
0E5C:  MOVWF  55
0E5E:  MOVLW  E8
0E60:  MOVWF  54
0E62:  RCALL  0BCA
0E64:  MOVFF  03,4F
0E68:  MOVFF  02,4E
0E6C:  MOVFF  01,4D
0E70:  MOVFF  00,4C
....................     if (u8NumDigs>=4) 
0E74:  MOVF   47,W
0E76:  SUBLW  03
0E78:  BC    0E84
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0E7A:  MOVLW  30
0E7C:  ADDWF  48,W
0E7E:  MOVWF  50
0E80:  MOVWF  51
0E82:  RCALL  0B22
....................     } 
....................  
....................     _u16-=u16b; 
0E84:  MOVF   4C,W
0E86:  SUBWF  43,F
0E88:  MOVF   4D,W
0E8A:  SUBWFB 44,F
0E8C:  MOVF   4E,W
0E8E:  SUBWFB 45,F
0E90:  MOVF   4F,W
0E92:  SUBWFB 46,F
....................     u16a=_u16/100; 
0E94:  MOVFF  46,53
0E98:  MOVFF  45,52
0E9C:  MOVFF  44,51
0EA0:  MOVFF  43,50
0EA4:  CLRF   57
0EA6:  CLRF   56
0EA8:  CLRF   55
0EAA:  MOVLW  64
0EAC:  MOVWF  54
0EAE:  RCALL  0C1E
0EB0:  MOVFF  03,4B
0EB4:  MOVFF  02,4A
0EB8:  MOVFF  01,49
0EBC:  MOVFF  00,48
....................     u16b=u16a*100; 
0EC0:  MOVFF  4B,53
0EC4:  MOVFF  4A,52
0EC8:  MOVFF  49,51
0ECC:  MOVFF  48,50
0ED0:  CLRF   57
0ED2:  CLRF   56
0ED4:  CLRF   55
0ED6:  MOVLW  64
0ED8:  MOVWF  54
0EDA:  RCALL  0BCA
0EDC:  MOVFF  03,4F
0EE0:  MOVFF  02,4E
0EE4:  MOVFF  01,4D
0EE8:  MOVFF  00,4C
....................     if (u8NumDigs>=3) 
0EEC:  MOVF   47,W
0EEE:  SUBLW  02
0EF0:  BC    0EFC
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0EF2:  MOVLW  30
0EF4:  ADDWF  48,W
0EF6:  MOVWF  50
0EF8:  MOVWF  51
0EFA:  RCALL  0B22
....................     } 
....................  
....................     _u16-=u16b; 
0EFC:  MOVF   4C,W
0EFE:  SUBWF  43,F
0F00:  MOVF   4D,W
0F02:  SUBWFB 44,F
0F04:  MOVF   4E,W
0F06:  SUBWFB 45,F
0F08:  MOVF   4F,W
0F0A:  SUBWFB 46,F
....................     u16a=_u16/10; 
0F0C:  MOVFF  46,53
0F10:  MOVFF  45,52
0F14:  MOVFF  44,51
0F18:  MOVFF  43,50
0F1C:  CLRF   57
0F1E:  CLRF   56
0F20:  CLRF   55
0F22:  MOVLW  0A
0F24:  MOVWF  54
0F26:  RCALL  0C1E
0F28:  MOVFF  03,4B
0F2C:  MOVFF  02,4A
0F30:  MOVFF  01,49
0F34:  MOVFF  00,48
....................     u16b=u16a*10; 
0F38:  MOVFF  4B,53
0F3C:  MOVFF  4A,52
0F40:  MOVFF  49,51
0F44:  MOVFF  48,50
0F48:  CLRF   57
0F4A:  CLRF   56
0F4C:  CLRF   55
0F4E:  MOVLW  0A
0F50:  MOVWF  54
0F52:  RCALL  0BCA
0F54:  MOVFF  03,4F
0F58:  MOVFF  02,4E
0F5C:  MOVFF  01,4D
0F60:  MOVFF  00,4C
....................     if (u8NumDigs>=2) 
0F64:  MOVF   47,W
0F66:  SUBLW  01
0F68:  BC    0F74
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0F6A:  MOVLW  30
0F6C:  ADDWF  48,W
0F6E:  MOVWF  50
0F70:  MOVWF  51
0F72:  RCALL  0B22
....................     } 
....................  
....................     _u16-=u16b; 
0F74:  MOVF   4C,W
0F76:  SUBWF  43,F
0F78:  MOVF   4D,W
0F7A:  SUBWFB 44,F
0F7C:  MOVF   4E,W
0F7E:  SUBWFB 45,F
0F80:  MOVF   4F,W
0F82:  SUBWFB 46,F
....................     if (u8NumDigs>=1) 
0F84:  MOVF   47,W
0F86:  SUBLW  00
0F88:  BC    0F94
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
0F8A:  MOVLW  30
0F8C:  ADDWF  43,W
0F8E:  MOVWF  50
0F90:  MOVWF  51
0F92:  RCALL  0B22
....................     } 
....................    
.................... } 
0F94:  RETLW  00
....................  
.................... static void LCDPutS16(S16 s16a,U8 u8NumDigs) 
.................... { 
....................   char c='+'; 
*
1142:  MOVLW  2B
1144:  MOVWF  42
....................  
....................   if (s16a<0) 
1146:  BTFSC  40.7
1148:  BRA    114C
114A:  BRA    115A
....................   { 
....................     s16a=-s16a; 
114C:  COMF   3F,F
114E:  COMF   40,F
1150:  INCF   3F,F
1152:  BTFSC  FD8.2
1154:  INCF   40,F
....................     c='-'; 
1156:  MOVLW  2D
1158:  MOVWF  42
....................   } 
....................   LCDPutCh(c); 
115A:  MOVFF  42,51
115E:  RCALL  0B22
....................   LCDPutU16((U16)s16a,u8NumDigs); 
1160:  CLRF   46
1162:  CLRF   45
1164:  MOVFF  40,44
1168:  MOVFF  3F,43
116C:  MOVFF  41,47
1170:  RCALL  0D9C
.................... } 
1172:  RETLW  00
....................  
....................  
.................... static void LCDMsg(char c) 
.................... { 
....................    
....................     LCDPutCh(c); 
*
0B2A:  MOVFF  40,51
0B2E:  RCALL  0B22
....................    
.................... } 
0B30:  RETLW  00
....................  
....................  
....................  static void LCDWelcome(void) 
.................... { 
....................   
....................    
....................     U16 u16a; 
....................     LCDClear(); 
*
0B3E:  RCALL  0AEC
....................     LCDMsg("VM PMT-2,PMT-4M"); 
0B40:  CLRF   38
0B42:  MOVF   38,W
0B44:  RCALL  07C0
0B46:  IORLW  00
0B48:  BZ    0B52
0B4A:  INCF   38,F
0B4C:  MOVWF  40
0B4E:  RCALL  0B2A
0B50:  BRA    0B42
....................     LCDSetCursor(0x40); 
0B52:  MOVLW  40
0B54:  MOVWF  3F
0B56:  RCALL  0B32
....................     LCDMsg("Firmware v0.2"); 
0B58:  CLRF   38
0B5A:  MOVF   38,W
0B5C:  RCALL  07EA
0B5E:  IORLW  00
0B60:  BZ    0B6A
0B62:  INCF   38,F
0B64:  MOVWF  40
0B66:  RCALL  0B2A
0B68:  BRA    0B5A
....................     Delay_ms(2000); 
0B6A:  MOVLW  08
0B6C:  MOVWF  38
0B6E:  MOVLW  FA
0B70:  MOVWF  3A
0B72:  RCALL  09B6
0B74:  DECFSZ 38,F
0B76:  BRA    0B6E
....................     LCDClear(); 
0B78:  RCALL  0AEC
....................    
.................... } 
0B7A:  GOTO   1520 (RETURN)
....................  
.................... static void Ih_LCDUpdate(U8 ns){ 
.................... //Âûâîä çíà÷åíèÿ òîêà íàãðåâàòåëÿ  
.................... U16 num1,num2; 
.................... U16 mod; 
....................  if(ns == 1) LCDSetCursor(0x0);//Óñò. êóðñîð íà ïåðâóþ ñòðîêó 
*
0F96:  DECFSZ 36,W
0F98:  BRA    0FA0
0F9A:  CLRF   3F
0F9C:  RCALL  0B32
....................     else LCDSetCursor(0x40);//Óñò. êóðñîð íà âòîðóþ ñòðîêó 
0F9E:  BRA    0FA6
0FA0:  MOVLW  40
0FA2:  MOVWF  3F
0FA4:  RCALL  0B32
....................  
.................... LCDMsg("Ih= "); 
0FA6:  CLRF   3D
0FA8:  MOVF   3D,W
0FAA:  RCALL  0812
0FAC:  IORLW  00
0FAE:  BZ    0FB8
0FB0:  INCF   3D,F
0FB2:  MOVWF  40
0FB4:  RCALL  0B2A
0FB6:  BRA    0FA8
.................... num1=Ih/10; 
0FB8:  MOVFF  1A,40
0FBC:  MOVFF  19,3F
0FC0:  CLRF   42
0FC2:  MOVLW  0A
0FC4:  MOVWF  41
0FC6:  RCALL  0D3C
0FC8:  MOVFF  02,38
0FCC:  MOVFF  01,37
.................... num2=num1*10; 
0FD0:  MOVFF  38,40
0FD4:  MOVFF  37,3F
0FD8:  CLRF   42
0FDA:  MOVLW  0A
0FDC:  MOVWF  41
0FDE:  RCALL  0D7E
0FE0:  MOVFF  02,3A
0FE4:  MOVFF  01,39
.................... mod=Ih-num2; 
0FE8:  MOVF   39,W
0FEA:  SUBWF  19,W
0FEC:  MOVWF  3B
0FEE:  MOVF   3A,W
0FF0:  SUBWFB 1A,W
0FF2:  MOVWF  3C
.................... LCDPutU16(num1,3); 
0FF4:  CLRF   46
0FF6:  CLRF   45
0FF8:  MOVFF  38,44
0FFC:  MOVFF  37,43
1000:  MOVLW  03
1002:  MOVWF  47
1004:  RCALL  0D9C
.................... LCDMsg("."); 
1006:  CLRF   3D
1008:  MOVF   3D,W
100A:  RCALL  0832
100C:  IORLW  00
100E:  BZ    1018
1010:  INCF   3D,F
1012:  MOVWF  40
1014:  RCALL  0B2A
1016:  BRA    1008
.................... LCDPutU16(mod,1); 
1018:  CLRF   46
101A:  CLRF   45
101C:  MOVFF  3C,44
1020:  MOVFF  3B,43
1024:  MOVLW  01
1026:  MOVWF  47
1028:  RCALL  0D9C
.................... LCDMsg(' '); 
102A:  MOVLW  20
102C:  MOVWF  40
102E:  RCALL  0B2A
.................... LCDMsg(0xBC);//ì 
1030:  MOVLW  BC
1032:  MOVWF  40
1034:  RCALL  0B2A
.................... LCDMsg(0x41);//À 
1036:  MOVLW  41
1038:  MOVWF  40
103A:  RCALL  0B2A
....................  if(ff1){ 
103C:  MOVF   1E,F
103E:  BZ    1068
....................     LCDMsg(' '); 
1040:  MOVLW  20
1042:  MOVWF  40
1044:  RCALL  0B2A
....................     LCDMsg(0xD9); 
1046:  MOVLW  D9
1048:  MOVWF  40
104A:  RCALL  0B2A
....................     LCDMsg(0xDA); 
104C:  MOVLW  DA
104E:  MOVWF  40
1050:  RCALL  0B2A
....................     LCDMsg(" "); 
1052:  CLRF   3D
1054:  MOVF   3D,W
1056:  CALL   084E
105A:  IORLW  00
105C:  BZ    1066
105E:  INCF   3D,F
1060:  MOVWF  40
1062:  RCALL  0B2A
1064:  BRA    1054
....................      } else LCDMsg("    "); 
1066:  BRA    107C
1068:  CLRF   3D
106A:  MOVF   3D,W
106C:  CALL   086A
1070:  IORLW  00
1072:  BZ    107C
1074:  INCF   3D,F
1076:  MOVWF  40
1078:  RCALL  0B2A
107A:  BRA    106A
.................... } 
107C:  GOTO   175A (RETURN)
....................  
....................  
....................  
.................... static void Ut_LCDUpdate(U8 ns){ 
.................... //Âûâîä çíà÷åíèÿ ÝÄÑ òåðìîïàðû 
.................... U16 num1,num2; 
.................... U16 mod; 
....................  if(ns == 1) LCDSetCursor(0x0);//Óñò. êóðñîð íà ïåðâóþ ñòðîêó 
1080:  DECFSZ 36,W
1082:  BRA    108A
1084:  CLRF   3F
1086:  RCALL  0B32
....................     else LCDSetCursor(0x40);//Óñò. êóðñîð íà âòîðóþ ñòðîêó 
1088:  BRA    1090
108A:  MOVLW  40
108C:  MOVWF  3F
108E:  RCALL  0B32
....................      
.................... LCDMsg("Ut= "); 
1090:  CLRF   3D
1092:  MOVF   3D,W
1094:  CALL   088A
1098:  IORLW  00
109A:  BZ    10A4
109C:  INCF   3D,F
109E:  MOVWF  40
10A0:  RCALL  0B2A
10A2:  BRA    1092
.................... num1=Ut/100; 
10A4:  MOVFF  1C,40
10A8:  MOVFF  1B,3F
10AC:  CLRF   42
10AE:  MOVLW  64
10B0:  MOVWF  41
10B2:  RCALL  0D3C
10B4:  MOVFF  02,38
10B8:  MOVFF  01,37
.................... num2=num1*100; 
10BC:  MOVFF  38,40
10C0:  MOVFF  37,3F
10C4:  CLRF   42
10C6:  MOVLW  64
10C8:  MOVWF  41
10CA:  RCALL  0D7E
10CC:  MOVFF  02,3A
10D0:  MOVFF  01,39
.................... mod=Ut-num2; 
10D4:  MOVF   39,W
10D6:  SUBWF  1B,W
10D8:  MOVWF  3B
10DA:  MOVF   3A,W
10DC:  SUBWFB 1C,W
10DE:  MOVWF  3C
.................... LCDPutU16(num1,2); 
10E0:  CLRF   46
10E2:  CLRF   45
10E4:  MOVFF  38,44
10E8:  MOVFF  37,43
10EC:  MOVLW  02
10EE:  MOVWF  47
10F0:  RCALL  0D9C
.................... LCDMsg("."); 
10F2:  CLRF   3D
10F4:  MOVF   3D,W
10F6:  CALL   0832
10FA:  IORLW  00
10FC:  BZ    1106
10FE:  INCF   3D,F
1100:  MOVWF  40
1102:  RCALL  0B2A
1104:  BRA    10F4
.................... LCDPutU16(mod,2); 
1106:  CLRF   46
1108:  CLRF   45
110A:  MOVFF  3C,44
110E:  MOVFF  3B,43
1112:  MOVLW  02
1114:  MOVWF  47
1116:  RCALL  0D9C
.................... LCDMsg(' '); 
1118:  MOVLW  20
111A:  MOVWF  40
111C:  RCALL  0B2A
.................... LCDMsg(0xBC);//ì 
111E:  MOVLW  BC
1120:  MOVWF  40
1122:  RCALL  0B2A
.................... LCDMsg(0x42);//Â 
1124:  MOVLW  42
1126:  MOVWF  40
1128:  RCALL  0B2A
.................... LCDMsg("    "); 
112A:  CLRF   3D
112C:  MOVF   3D,W
112E:  CALL   086A
1132:  IORLW  00
1134:  BZ    113E
1136:  INCF   3D,F
1138:  MOVWF  40
113A:  RCALL  0B2A
113C:  BRA    112C
.................... } 
113E:  GOTO   176A (RETURN)
....................  
.................... static void Pa_LCDUpdate(U8 ns){ 
.................... U16 num1,num2,pres; 
.................... U16 mod; 
.................... //Âûâîä çíà÷åíèÿ äàâëåíèÿ â Ïà 
.................... if(ns == 1) LCDSetCursor(0x0);//Óñò. êóðñîð íà ïåðâóþ ñòðîêó 
*
1174:  DECFSZ 36,W
1176:  BRA    117E
1178:  CLRF   3F
117A:  RCALL  0B32
....................     else LCDSetCursor(0x40);//Óñò. êóðñîð íà âòîðóþ ñòðîêó 
117C:  BRA    1184
117E:  MOVLW  40
1180:  MOVWF  3F
1182:  RCALL  0B32
....................     
....................  
.................... if (Ut<100){ 
1184:  MOVF   1C,F
1186:  BNZ   11B2
1188:  MOVF   1B,W
118A:  SUBLW  63
118C:  BNC   11B2
....................          LCDMsg("P> "); 
118E:  CLRF   3F
1190:  MOVF   3F,W
1192:  CALL   08AA
1196:  IORLW  00
1198:  BZ    11A2
119A:  INCF   3F,F
119C:  MOVWF  40
119E:  RCALL  0B2A
11A0:  BRA    1190
....................           pres=2394; 
11A2:  MOVLW  09
11A4:  MOVWF  3C
11A6:  MOVLW  5A
11A8:  MOVWF  3B
....................            Ut=100; 
11AA:  CLRF   1C
11AC:  MOVLW  64
11AE:  MOVWF  1B
....................   } else if(Ut>1000){ 
11B0:  BRA    1232
11B2:  MOVF   1C,W
11B4:  SUBLW  02
11B6:  BC    11E8
11B8:  XORLW  FF
11BA:  BNZ   11C2
11BC:  MOVF   1B,W
11BE:  SUBLW  E8
11C0:  BC    11E8
....................            LCDMsg("P< "); 
11C2:  CLRF   3F
11C4:  MOVF   3F,W
11C6:  CALL   08C8
11CA:  IORLW  00
11CC:  BZ    11D6
11CE:  INCF   3F,F
11D0:  MOVWF  40
11D2:  RCALL  0B2A
11D4:  BRA    11C4
....................           pres=1005; 
11D6:  MOVLW  03
11D8:  MOVWF  3C
11DA:  MOVLW  ED
11DC:  MOVWF  3B
....................            Ut=1000; 
11DE:  MOVLW  03
11E0:  MOVWF  1C
11E2:  MOVLW  E8
11E4:  MOVWF  1B
....................   } else{ 
11E6:  BRA    1232
....................   pres = table[ut-100]; 
11E8:  MOVLW  64
11EA:  SUBWF  1B,W
11EC:  MOVWF  3F
11EE:  MOVLW  00
11F0:  SUBWFB 1C,W
11F2:  MOVWF  40
11F4:  BCF    FD8.0
11F6:  RLCF   3F,W
11F8:  MOVWF  02
11FA:  RLCF   40,W
11FC:  MOVWF  03
11FE:  MOVF   02,W
1200:  MOVFF  FF2,41
1204:  BCF    FF2.7
1206:  MOVFF  03,FF7
120A:  CALL   009E
120E:  TBLRD*+
1210:  MOVFF  FF5,03
1214:  BTFSC  41.7
1216:  BSF    FF2.7
1218:  MOVWF  3B
121A:  MOVFF  03,3C
....................   LCDMsg("P= "); 
121E:  CLRF   3F
1220:  MOVF   3F,W
1222:  CALL   08E6
1226:  IORLW  00
1228:  BZ    1232
122A:  INCF   3F,F
122C:  MOVWF  40
122E:  RCALL  0B2A
1230:  BRA    1220
....................   } 
....................  
.................... num1=Pres/1000; 
1232:  MOVFF  3C,40
1236:  MOVFF  3B,3F
123A:  MOVLW  03
123C:  MOVWF  42
123E:  MOVLW  E8
1240:  MOVWF  41
1242:  RCALL  0D3C
1244:  MOVFF  02,38
1248:  MOVFF  01,37
.................... num2=num1*1000; 
124C:  MOVFF  38,40
1250:  MOVFF  37,3F
1254:  MOVLW  03
1256:  MOVWF  42
1258:  MOVLW  E8
125A:  MOVWF  41
125C:  RCALL  0D7E
125E:  MOVFF  02,3A
1262:  MOVFF  01,39
.................... mod=Pres-num2; 
1266:  MOVF   39,W
1268:  SUBWF  3B,W
126A:  MOVWF  3D
126C:  MOVF   3A,W
126E:  SUBWFB 3C,W
1270:  MOVWF  3E
....................  
.................... LCDPutU16(num1,1); 
1272:  CLRF   46
1274:  CLRF   45
1276:  MOVFF  38,44
127A:  MOVFF  37,43
127E:  MOVLW  01
1280:  MOVWF  47
1282:  RCALL  0D9C
.................... LCDMsg("."); 
1284:  CLRF   3F
1286:  MOVF   3F,W
1288:  CALL   0832
128C:  IORLW  00
128E:  BZ    1298
1290:  INCF   3F,F
1292:  MOVWF  40
1294:  RCALL  0B2A
1296:  BRA    1286
.................... LCDPutU16(mod,3); 
1298:  CLRF   46
129A:  CLRF   45
129C:  MOVFF  3E,44
12A0:  MOVFF  3D,43
12A4:  MOVLW  03
12A6:  MOVWF  47
12A8:  RCALL  0D9C
.................... LCDMsg("E"); 
12AA:  CLRF   3F
12AC:  MOVF   3F,W
12AE:  CALL   0904
12B2:  IORLW  00
12B4:  BZ    12BE
12B6:  INCF   3F,F
12B8:  MOVWF  40
12BA:  RCALL  0B2A
12BC:  BRA    12AC
....................  
.................... if ((99<Ut)&&(Ut<230)) 
12BE:  MOVF   1C,F
12C0:  BNZ   12C8
12C2:  MOVF   1B,W
12C4:  SUBLW  63
12C6:  BC    12E0
12C8:  MOVF   1C,F
12CA:  BNZ   12E0
12CC:  MOVF   1B,W
12CE:  SUBLW  E5
12D0:  BNC   12E0
.................... {LCDPutS16(1,2); 
12D2:  CLRF   40
12D4:  MOVLW  01
12D6:  MOVWF  3F
12D8:  MOVLW  02
12DA:  MOVWF  41
12DC:  RCALL  1142
.................... } 
.................... else if ((229<Ut)&&(Ut<785)) 
12DE:  BRA    133E
12E0:  MOVF   1C,F
12E2:  BNZ   12EA
12E4:  MOVF   1B,W
12E6:  SUBLW  E5
12E8:  BC    1304
12EA:  MOVF   1C,W
12EC:  SUBLW  03
12EE:  BNC   1304
12F0:  BNZ   12F8
12F2:  MOVF   1B,W
12F4:  SUBLW  10
12F6:  BNC   1304
.................... {LCDPutS16(0,2); 
12F8:  CLRF   40
12FA:  CLRF   3F
12FC:  MOVLW  02
12FE:  MOVWF  41
1300:  RCALL  1142
.................... } 
.................... else if ((784<Ut)&&(Ut<969)) 
1302:  BRA    133E
1304:  MOVF   1C,W
1306:  SUBLW  02
1308:  BC    1330
130A:  XORLW  FF
130C:  BNZ   1314
130E:  MOVF   1B,W
1310:  SUBLW  10
1312:  BC    1330
1314:  MOVF   1C,W
1316:  SUBLW  03
1318:  BNC   1330
131A:  BNZ   1322
131C:  MOVF   1B,W
131E:  SUBLW  C8
1320:  BNC   1330
.................... {LCDPutS16(-1,2); 
1322:  MOVLW  FF
1324:  MOVWF  40
1326:  MOVWF  3F
1328:  MOVLW  02
132A:  MOVWF  41
132C:  RCALL  1142
.................... } 
.................... else 
132E:  BRA    133E
.................... {LCDPutS16(-2,2); 
1330:  MOVLW  FF
1332:  MOVWF  40
1334:  MOVLW  FE
1336:  MOVWF  3F
1338:  MOVLW  02
133A:  MOVWF  41
133C:  RCALL  1142
.................... } 
....................  
.................... //LCDMsg(" Pa"); 
.................... //Ïà 
.................... LCDMsg(' '); 
133E:  MOVLW  20
1340:  MOVWF  40
1342:  CALL   0B2A
.................... LCDMsg(0xA8); 
1346:  MOVLW  A8
1348:  MOVWF  40
134A:  CALL   0B2A
.................... LCDMsg(0x61); 
134E:  MOVLW  61
1350:  MOVWF  40
1352:  CALL   0B2A
.................... LCDMsg(" "); 
1356:  CLRF   3F
1358:  MOVF   3F,W
135A:  CALL   084E
135E:  IORLW  00
1360:  BZ    136C
1362:  INCF   3F,F
1364:  MOVWF  40
1366:  CALL   0B2A
136A:  BRA    1358
....................  
.................... } 
136C:  GOTO   176A (RETURN)
....................  
.................... #int_TIMER0 
.................... void  TIMER0_isr(void)  
.................... { 
.................... // ïðåðûâàíèå êàæäûå 0.5 ñåê. 
.................... tmr0fl=1; 
*
09A2:  MOVLW  01
09A4:  MOVWF  1D
.................... set_timer0(46000);    
09A6:  MOVLW  B3
09A8:  MOVWF  FD7
09AA:  MOVLW  B0
09AC:  MOVWF  FD6
....................  
.................... clear_interrupt(int_timer0); 
09AE:  BCF    FF2.2
.................... } 
....................  
....................  
09B0:  BCF    FF2.2
09B2:  GOTO   0058
.................... void main() 
.................... { 
*
1454:  CLRF   FF8
1456:  BCF    FD0.7
1458:  BSF    0D.7
145A:  CLRF   FEA
145C:  CLRF   FE9
145E:  MOVLW  40
1460:  MOVWF  FAF
1462:  MOVLW  A2
1464:  MOVWF  FAC
1466:  MOVLW  90
1468:  MOVWF  FAB
146A:  MOVF   FC1,W
146C:  ANDLW  C0
146E:  IORLW  0F
1470:  MOVWF  FC1
1472:  MOVLW  07
1474:  MOVWF  FB4
1476:  CLRF   18
1478:  CLRF   19
147A:  CLRF   1A
147C:  CLRF   1B
147E:  CLRF   1C
1480:  CLRF   1D
1482:  CLRF   1E
1484:  MOVLW  17
1486:  MOVWF  1F
1488:  MOVLW  02
148A:  MOVWF  20
.................... char ch; 
.................... U8 i,ff=0xff; 
148C:  MOVLW  FF
148E:  MOVWF  23
.................... U16 val=0; 
1490:  CLRF   24
1492:  CLRF   25
.................... U32 ADC_value; 
.................... U8 t_out[4]={0,0,0,0}; 
1494:  CLRF   2A
1496:  CLRF   2B
1498:  CLRF   2C
149A:  CLRF   2D
.................... U8 b_hold[4]={0,0,0,0}; 
149C:  CLRF   2E
149E:  CLRF   2F
14A0:  CLRF   30
14A2:  CLRF   31
.................... U8 b_push[4]={0,0,0,0}; 
14A4:  CLRF   32
14A6:  CLRF   33
14A8:  CLRF   34
14AA:  CLRF   35
....................  
....................    setup_adc_ports(AN0_TO_AN1|VSS_VREF); 
14AC:  MOVF   FC1,W
14AE:  ANDLW  C0
14B0:  IORLW  1D
14B2:  MOVWF  FC1
....................    setup_adc(ADC_OFF|ADC_TAD_MUL_20); 
14B4:  MOVF   FC0,W
14B6:  ANDLW  C0
14B8:  IORLW  38
14BA:  MOVWF  FC0
14BC:  BSF    FC0.7
14BE:  BSF    FC2.0
....................     
....................    setup_spi(SPI_SS_DISABLED); 
14C0:  BCF    FC6.5
14C2:  BCF    F94.5
14C4:  BSF    F94.4
14C6:  BCF    F94.3
14C8:  MOVLW  01
14CA:  MOVWF  FC6
14CC:  MOVLW  00
14CE:  MOVWF  FC7
....................    setup_wdt(WDT_OFF); 
14D0:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256); 
14D2:  MOVLW  87
14D4:  MOVWF  FD5
....................    set_timer0(46000);    
14D6:  MOVLW  B3
14D8:  MOVWF  FD7
14DA:  MOVLW  B0
14DC:  MOVWF  FD6
....................    setup_timer_1(T1_DISABLED); 
14DE:  CLRF   FCD
....................    
....................   //êîíôèãóðèðîâàíèå PWM 
....................    setup_timer_2(T2_DIV_BY_4 ,255,1); 
14E0:  MOVLW  00
14E2:  IORLW  05
14E4:  MOVWF  FCA
14E6:  MOVLW  FF
14E8:  MOVWF  FCB
....................    setup_ccp1(CCP_PWM); 
14EA:  BCF    F94.2
14EC:  BCF    F8B.2
14EE:  MOVLW  0C
14F0:  MOVWF  FBD
....................     
....................     
....................    setup_comparator(NC_NC_NC_NC); 
14F2:  MOVLW  07
14F4:  MOVWF  FB4
14F6:  MOVF   F92,W
14F8:  MOVLW  21
14FA:  MOVWF  00
14FC:  DECFSZ 00,F
14FE:  BRA    14FC
1500:  MOVF   FB4,W
1502:  BCF    FA1.6
....................    setup_vref(FALSE); 
1504:  CLRF   FB5
.................... //Setup_Oscillator parameter not selected from Intr Oscillator Config tab 
....................  
....................    // TODO: USER CODE!! 
....................    //óñòàíîâêà ðåæèìà ÀÖÏ 
....................    setup_adc(ADC_CLOCK_DIV_64|ADC_TAD_MUL_20); 
1506:  MOVF   FC0,W
1508:  ANDLW  C0
150A:  IORLW  3E
150C:  MOVWF  FC0
150E:  BSF    FC0.7
1510:  BSF    FC2.0
....................     
....................  
....................  
....................  
....................   
.................... TRA2=1;//   RA2 - âõîä îïðîñà êíîïîê  
1512:  BSF    F92.2
.................... TRISB=0b00000010; 
1514:  MOVLW  02
1516:  MOVWF  F93
....................  
.................... LCDInit(); 
1518:  GOTO   0A70
....................  // Welcome message on LCD 
....................  LCDWelcome(); 
151C:  GOTO   0B3E
....................  //Óñòàíîâêà çíà÷åíèÿ PWM (0-1023) 
.................... //746 - 140 mA 
.................... //535 - 100 mA 
.................... //0.189mA íà åäèíèöó êîäà PWM 
.................... val=U16EERead(0); 
1520:  CLRF   3A
1522:  CALL   0B7E
1526:  MOVFF  02,25
152A:  MOVFF  01,24
....................  if(val<535||val>746){ 
152E:  MOVF   25,W
1530:  SUBLW  02
1532:  BNC   153C
1534:  BNZ   154C
1536:  MOVF   24,W
1538:  SUBLW  16
153A:  BC    154C
153C:  MOVF   25,W
153E:  SUBLW  01
1540:  BC    1558
1542:  XORLW  FF
1544:  BNZ   154C
1546:  MOVF   24,W
1548:  SUBLW  EA
154A:  BC    1558
....................    pwm_val=536; 
154C:  MOVLW  02
154E:  MOVWF  20
1550:  MOVLW  18
1552:  MOVWF  1F
....................    ch=0; 
1554:  CLRF   21
....................  } 
....................    else { 
1556:  BRA    1564
....................    pwm_val=val; 
1558:  MOVFF  25,20
155C:  MOVFF  24,1F
....................    ch=1; 
1560:  MOVLW  01
1562:  MOVWF  21
....................    } 
....................    set_pwm1_duty(pwm_val); 
1564:  MOVFF  20,02
1568:  MOVFF  1F,01
156C:  RRCF   02,F
156E:  RRCF   01,F
1570:  RRCF   02,F
1572:  RRCF   01,F
1574:  RRCF   02,F
1576:  MOVFF  01,FBE
157A:  RRCF   02,F
157C:  RRCF   02,W
157E:  ANDLW  30
1580:  MOVWF  00
1582:  MOVF   FBD,W
1584:  ANDLW  CF
1586:  IORWF  00,W
1588:  MOVWF  FBD
....................    LCDClear(); 
158A:  CALL   0AEC
....................    LCDSetCursor(0); 
158E:  CLRF   3F
1590:  CALL   0B32
....................    if(ch) LCDMsg("EE READ OK"); 
1594:  MOVF   21,F
1596:  BZ    15B0
1598:  CLRF   36
159A:  MOVF   36,W
159C:  CALL   0920
15A0:  IORLW  00
15A2:  BZ    15AE
15A4:  INCF   36,F
15A6:  MOVWF  40
15A8:  CALL   0B2A
15AC:  BRA    159A
....................      else  LCDMsg("EE READ ERR"); 
15AE:  BRA    15C6
15B0:  CLRF   36
15B2:  MOVF   36,W
15B4:  CALL   0946
15B8:  IORLW  00
15BA:  BZ    15C6
15BC:  INCF   36,F
15BE:  MOVWF  40
15C0:  CALL   0B2A
15C4:  BRA    15B2
....................     
....................    delay_ms(1000); 
15C6:  MOVLW  04
15C8:  MOVWF  36
15CA:  MOVLW  FA
15CC:  MOVWF  3A
15CE:  CALL   09B6
15D2:  DECFSZ 36,F
15D4:  BRA    15CA
....................     
....................    enable_interrupts(INT_TIMER0); 
15D6:  BSF    FF2.5
.................... enable_interrupts(GLOBAL); 
15D8:  MOVLW  C0
15DA:  IORWF  FF2,F
....................  
....................    
....................   
.................... while(true) { 
....................  
.................... //*******Èçìåðåíèå,âûâîä íà COM è LCD************************** 
....................    if(tmr0fl){ 
15DC:  MOVF   1D,F
15DE:  BTFSC  FD8.2
15E0:  BRA    176A
....................     tmr0fl=0;// ôëàã TMR0,ïîÿâëÿåòñÿ êàæäûå 0.5 ñåê. 
15E2:  CLRF   1D
....................    //Èçìåðÿåì òîê íàãðåâàòåëÿ 
....................    set_adc_channel(1);//Óñò. êàíàë 1 ÀÖÏ (An1) 
15E4:  MOVLW  04
15E6:  MOVWF  01
15E8:  MOVF   FC2,W
15EA:  ANDLW  C3
15EC:  IORWF  01,W
15EE:  MOVWF  FC2
....................    delay_us(20); 
15F0:  MOVLW  42
15F2:  MOVWF  00
15F4:  DECFSZ 00,F
15F6:  BRA    15F4
15F8:  NOP   
....................      ADC_value = read_adc();//ïîëó÷àåì ðåçóëüòàò ïðåîáðàçîâàíèÿ 
15FA:  BSF    FC2.1
15FC:  BTFSC  FC2.1
15FE:  BRA    15FC
1600:  MOVFF  FC3,26
1604:  MOVFF  FC4,27
1608:  CLRF   28
160A:  CLRF   29
....................     // f=(ADC_Value*4)/25.7; ìA 
....................      Ih=(ADC_Value*400)/257; 
160C:  MOVFF  29,53
1610:  MOVFF  28,52
1614:  MOVFF  27,51
1618:  MOVFF  26,50
161C:  CLRF   57
161E:  CLRF   56
1620:  MOVLW  01
1622:  MOVWF  55
1624:  MOVLW  90
1626:  MOVWF  54
1628:  CALL   0BCA
162C:  MOVFF  03,39
1630:  MOVFF  02,38
1634:  MOVFF  01,37
1638:  MOVFF  00,36
163C:  MOVFF  03,53
1640:  MOVFF  02,52
1644:  MOVFF  01,51
1648:  MOVFF  00,50
164C:  CLRF   57
164E:  CLRF   56
1650:  MOVLW  01
1652:  MOVWF  55
1654:  MOVWF  54
1656:  CALL   0C1E
165A:  MOVFF  01,1A
165E:  MOVFF  00,19
....................      
....................     //Èçìåðÿåì ÝÄÑ òåðìîïàðû 
....................     set_adc_channel(0);//Óñò. êàíàë 0 ÀÖÏ (An0) 
1662:  MOVLW  00
1664:  MOVWF  01
1666:  MOVF   FC2,W
1668:  ANDLW  C3
166A:  IORWF  01,W
166C:  MOVWF  FC2
....................     delay_us(20); 
166E:  MOVLW  42
1670:  MOVWF  00
1672:  DECFSZ 00,F
1674:  BRA    1672
1676:  NOP   
....................      
....................     ADC_value = read_adc();//ïîëó÷àåì ðåçóëüòàò ïðåîáðàçîâàíèÿ 
1678:  BSF    FC2.1
167A:  BTFSC  FC2.1
167C:  BRA    167A
167E:  MOVFF  FC3,26
1682:  MOVFF  FC4,27
1686:  CLRF   28
1688:  CLRF   29
....................     
....................    //f=(ADC_value*4)/381.0;//ìB 
....................     ut=(ADC_value*400)/381; 
168A:  MOVFF  29,53
168E:  MOVFF  28,52
1692:  MOVFF  27,51
1696:  MOVFF  26,50
169A:  CLRF   57
169C:  CLRF   56
169E:  MOVLW  01
16A0:  MOVWF  55
16A2:  MOVLW  90
16A4:  MOVWF  54
16A6:  CALL   0BCA
16AA:  MOVFF  03,39
16AE:  MOVFF  02,38
16B2:  MOVFF  01,37
16B6:  MOVFF  00,36
16BA:  MOVFF  03,53
16BE:  MOVFF  02,52
16C2:  MOVFF  01,51
16C6:  MOVFF  00,50
16CA:  CLRF   57
16CC:  CLRF   56
16CE:  MOVLW  01
16D0:  MOVWF  55
16D2:  MOVLW  7D
16D4:  MOVWF  54
16D6:  CALL   0C1E
16DA:  MOVFF  01,1C
16DE:  MOVFF  00,1B
....................     //Âûâîä íà com-ïîðò 
....................        printf("Ut = %Lu mV Ih = %Lu mA \n\r", ut, Ih); 
16E2:  CLRF   36
16E4:  MOVF   36,W
16E6:  CALL   096C
16EA:  INCF   36,F
16EC:  MOVWF  00
16EE:  MOVF   00,W
16F0:  BTFSS  F9E.4
16F2:  BRA    16F0
16F4:  MOVWF  FAD
16F6:  MOVLW  05
16F8:  SUBWF  36,W
16FA:  BNZ   16E4
16FC:  MOVLW  10
16FE:  MOVWF  FE9
1700:  MOVFF  1C,39
1704:  MOVFF  1B,38
1708:  CALL   0C98
170C:  MOVLW  08
170E:  MOVWF  37
1710:  MOVF   37,W
1712:  CALL   096C
1716:  INCF   37,F
1718:  MOVWF  00
171A:  MOVF   00,W
171C:  BTFSS  F9E.4
171E:  BRA    171C
1720:  MOVWF  FAD
1722:  MOVLW  11
1724:  SUBWF  37,W
1726:  BNZ   1710
1728:  MOVLW  10
172A:  MOVWF  FE9
172C:  MOVFF  1A,39
1730:  MOVFF  19,38
1734:  CALL   0C98
1738:  MOVLW  14
173A:  MOVWF  38
173C:  MOVF   38,W
173E:  CALL   096C
1742:  INCF   38,F
1744:  MOVWF  00
1746:  MOVF   00,W
1748:  BTFSS  F9E.4
174A:  BRA    1748
174C:  MOVWF  FAD
174E:  MOVLW  1A
1750:  SUBWF  38,W
1752:  BNZ   173C
....................      //Âûâîä íà LCD   
....................      Ih_LCDUpdate(1); 
1754:  MOVLW  01
1756:  MOVWF  36
1758:  BRA    0F96
....................       if(ff) Ut_LCDUpdate(2); 
175A:  MOVF   23,F
175C:  BZ    1764
175E:  MOVLW  02
1760:  MOVWF  36
1762:  BRA    1080
....................          else Pa_LCDUpdate(2); 
1764:  MOVLW  02
1766:  MOVWF  36
1768:  BRA    1174
....................         
....................      //Ut_LCDUpdate(2); 
....................      //Pa_LCDUpdate(2); 
....................   } 
....................  
.................... //****************îáðàáîòêà íàæàòèÿ êíîïîê***************** 
....................  
.................... for(i=0; i<4; ++i){ 
176A:  CLRF   22
176C:  MOVF   22,W
176E:  SUBLW  03
1770:  BNC   17FE
.................... //íàæàòà ëè êíîïêà? 
....................  if (PBScan(i)){ 
1772:  MOVFF  22,36
1776:  BRA    1370
1778:  MOVF   01,F
177A:  BZ    17DA
....................   //êíîïêà íàæàòà 
....................    //ïîðîã ïîäàâëåíèÿ äðåáåçãà äîñòèãíóò? 
....................    if(t_out[i]==20) { 
177C:  CLRF   03
177E:  MOVF   22,W
1780:  ADDLW  2A
1782:  MOVWF  FE9
1784:  MOVLW  00
1786:  ADDWFC 03,W
1788:  MOVWF  FEA
178A:  MOVF   FEF,W
178C:  SUBLW  14
178E:  BNZ   17C8
....................           //äà 
....................           //ôëàã "óäåðæèâàåòñÿ" óñòàíîâëåí? 
....................           if(!b_hold[i]){ 
1790:  CLRF   03
1792:  MOVF   22,W
1794:  ADDLW  2E
1796:  MOVWF  FE9
1798:  MOVLW  00
179A:  ADDWFC 03,W
179C:  MOVWF  FEA
179E:  MOVF   FEF,F
17A0:  BNZ   17C6
....................             //íåò 
....................             b_hold[i]=1;//óñòàíîâèòü ôëàã "óäåðæèâàåòñÿ" 
17A2:  CLRF   03
17A4:  MOVF   22,W
17A6:  ADDLW  2E
17A8:  MOVWF  FE9
17AA:  MOVLW  00
17AC:  ADDWFC 03,W
17AE:  MOVWF  FEA
17B0:  MOVLW  01
17B2:  MOVWF  FEF
....................             b_push[i]=1;//óñòàíîâèòü ôëàã "íàæàòî" 
17B4:  CLRF   03
17B6:  MOVF   22,W
17B8:  ADDLW  32
17BA:  MOVWF  FE9
17BC:  MOVLW  00
17BE:  ADDWFC 03,W
17C0:  MOVWF  FEA
17C2:  MOVLW  01
17C4:  MOVWF  FEF
....................            } 
....................           //äà 
....................        } 
....................       else 
17C6:  BRA    17D8
....................       //ïîðîã ïîäàâëåíèÿ äðåáåçãà íå äîñòèãíóò 
....................       { 
....................       ++t_out[i];//èíêðåìåíò ïåðåìåííîé ïîäàâëåíèÿ äðåáåçãà 
17C8:  CLRF   03
17CA:  MOVF   22,W
17CC:  ADDLW  2A
17CE:  MOVWF  FE9
17D0:  MOVLW  00
17D2:  ADDWFC 03,W
17D4:  MOVWF  FEA
17D6:  INCF   FEF,F
....................       } 
....................    } 
....................    else 
17D8:  BRA    17FA
....................    // êíîïêà íå íàæàòà 
....................    { 
....................    t_out[i]=0; //îáíóëåíèå ïåðåìåííîé ïîäàâëåíèÿ äðåáåçãà 
17DA:  CLRF   03
17DC:  MOVF   22,W
17DE:  ADDLW  2A
17E0:  MOVWF  FE9
17E2:  MOVLW  00
17E4:  ADDWFC 03,W
17E6:  MOVWF  FEA
17E8:  CLRF   FEF
....................    b_hold[i]=0; //ñáðîñ ôëàãà "óäåðæèâàåòñÿ" 
17EA:  CLRF   03
17EC:  MOVF   22,W
17EE:  ADDLW  2E
17F0:  MOVWF  FE9
17F2:  MOVLW  00
17F4:  ADDWFC 03,W
17F6:  MOVWF  FEA
17F8:  CLRF   FEF
....................    } 
.................... } //for    
17FA:  INCF   22,F
17FC:  BRA    176C
....................   //***********êíîïêè îáðàáîòàíû*********************** 
....................   //Óâåëè÷åíèå òîêà íàãðåâàòåëÿ 
....................   if (b_push[0]&& ff1){ 
17FE:  MOVF   32,F
1800:  BZ    1836
1802:  MOVF   1E,F
1804:  BZ    1836
....................        b_push[0]=0; 
1806:  CLRF   32
....................        pwm_val=pwm_val+1; 
1808:  MOVLW  01
180A:  ADDWF  1F,F
180C:  MOVLW  00
180E:  ADDWFC 20,F
....................        set_pwm1_duty(pwm_val); 
1810:  MOVFF  20,02
1814:  MOVFF  1F,01
1818:  RRCF   02,F
181A:  RRCF   01,F
181C:  RRCF   02,F
181E:  RRCF   01,F
1820:  RRCF   02,F
1822:  MOVFF  01,FBE
1826:  RRCF   02,F
1828:  RRCF   02,W
182A:  ANDLW  30
182C:  MOVWF  00
182E:  MOVF   FBD,W
1830:  ANDLW  CF
1832:  IORWF  00,W
1834:  MOVWF  FBD
....................   } 
....................   //Óìåíüøåíèå òîêà íàãðåâàòåëÿ 
....................   if (b_push[1] && ff1){ 
1836:  MOVF   33,F
1838:  BZ    186E
183A:  MOVF   1E,F
183C:  BZ    186E
....................        b_push[1]=0; 
183E:  CLRF   33
....................        pwm_val=pwm_val-1; 
1840:  MOVLW  01
1842:  SUBWF  1F,F
1844:  MOVLW  00
1846:  SUBWFB 20,F
....................        set_pwm1_duty(pwm_val); 
1848:  MOVFF  20,02
184C:  MOVFF  1F,01
1850:  RRCF   02,F
1852:  RRCF   01,F
1854:  RRCF   02,F
1856:  RRCF   01,F
1858:  RRCF   02,F
185A:  MOVFF  01,FBE
185E:  RRCF   02,F
1860:  RRCF   02,W
1862:  ANDLW  30
1864:  MOVWF  00
1866:  MOVF   FBD,W
1868:  ANDLW  CF
186A:  IORWF  00,W
186C:  MOVWF  FBD
....................   } 
....................    
....................   //Ðåæèì îòîáðàæåíèÿ äàâëåíèÿ  
....................   if (b_push[3]){ 
186E:  MOVF   35,F
1870:  BZ    1876
....................        b_push[3]=0; 
1872:  CLRF   35
....................        ff=~ff; 
1874:  COMF   23,F
....................     } 
....................      
....................    //Ðåæèì óñòàíîâêè òîêà íàãðåâàòåëÿ 
....................   if (b_push[2]){ 
1876:  MOVF   34,F
1878:  BZ    188E
....................        b_push[2]=0; 
187A:  CLRF   34
....................        ff1=~ff1; 
187C:  COMF   1E,F
....................        if(ff1==0) U16EEWrite(pwm_val,0);//çàïèñü â EEPROM 
187E:  MOVF   1E,F
1880:  BNZ   188E
1882:  MOVFF  20,37
1886:  MOVFF  1F,36
188A:  CLRF   38
188C:  BRA    13BE
....................     } 
....................      
....................      
....................   delay_ms(1); 
188E:  MOVLW  01
1890:  MOVWF  3A
1892:  CALL   09B6
.................... }    
1896:  BRA    15DC
.................... }   
....................    
....................  
....................  
1898:  SLEEP 

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 0E02   BROWNOUT WDT128 NOWDT BORV45 PUT
   Word  3: 8300   CCP2C1 MCLR PBADEN
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOCPD NOPROTECT NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
