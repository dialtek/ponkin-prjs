CCS PCD C Compiler, Version 4.140, 5967               19-апр-13 17:30

               Filename:   C:\Program Files (x86)\PICC\my prj\Pic24hJ\main.lst

               ROM used:   2270 bytes (3%)
                           Largest free fragment is 63266
               RAM used:   161 (2%) at main() level
                           189 (2%) worst case
               Stack size: 128

*
00000:  GOTO    81C
.................... #include <24HJ128GP506.h> 
.................... //////// Standard Header file for the PIC24HJ128GP506 device //////////////// 
.................... #device PIC24HJ128GP506 
.................... #list 
....................  
.................... #include <Termo3.h> 
.................... //#FUSES WPRES32                //Watch Dog Timer PreScalar 1:32 
.................... //#FUSES WPOSTS1                //Watch Dog Timer PostScalar 1:1 
.................... //#FUSES PROTECT_HIGH           //General Segment Code Protect High Security 
.................... //#FUSES CKSFSM                 //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... //#FUSES PR                        //Primary Oscillator 
.................... #FUSES PR_PLL                  //Primary Oscillator with PLL 
.................... #FUSES HS                       // High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #use delay(clock=80M) 
*
00274:  CP0     W0
00276:  BTSC.B  42.1
00278:  BRA     28A
0027A:  REPEAT  #1C3B
0027C:  NOP     
0027E:  REPEAT  #3FFE
00280:  NOP     
00282:  REPEAT  #3FFE
00284:  NOP     
00286:  DEC     W0,W0
00288:  BRA     NZ,27A
0028A:  RETURN  
.................... #use rs232(UART2,baud=9600,parity=N,bits=8) 
.................... //#use spi(spi2, BAUD=100000, DI=PIN_G7, DO=PIN_G8, CLK=PIN_G6, ENABLE=PIN_B2, BITS=8) 
.................... #use spi(spi2, FORCE_HW) 
....................  
.................... #WORD AD1PCFGL=0x032C 
.................... #WORD ADCFGL=AD1PCFGL 
.................... #WORD AD1PCFGH=0x032A 
.................... #WORD ADCFGH=AD1PCFGH 
....................  
.................... #use fixed_io(B_outputs=PIN_B1, PIN_B2) 
....................  
.................... #WORD CLKDIV=0x0744  // osc con reg 
.................... #BIT PLLPOST1=CLKDIV.7 
.................... #BIT PLLPOST0=CLKDIV.6 
.................... #BIT PLLPRE4=CLKDIV.4 
.................... #BIT PLLPRE3=CLKDIV.3 
.................... #BIT PLLPRE2=CLKDIV.2 
.................... #BIT PLLPRE1=CLKDIV.1 
.................... #BIT PLLPRE0=CLKDIV.0 
....................  
.................... #WORD LATA=0x02C4  
.................... #WORD LATB=0x02CA 
.................... #WORD LATD=0x02D6 
.................... #WORD LATF=0x02E2 
.................... #WORD LATG=0x02E8   
....................  
.................... #WORD PLLFBD=0x0746 // osc PLL div reg 
.................... #WORD U2BRG=0x0238 
.................... #WORD U2MODE=0x0230 
....................  
.................... #WORD SPI2STAT=0x0260 
.................... #BIT SPIEN=SPI2STAT.15 //1  = Enables module and configures SCKx, SDOx, SDIx and SSx as serial port pins 
.................... #BIT SPIROV=SPI2STAT.6 // Receive Overflow Flag bit 
....................                        // 1   =  A  new  byte/word  is  completely  received  and  discarded.  The  user  software  has  not  read  the 
....................                        //previous data in the SPIxBUF register 0  = No overflow has occurred 
....................  
.................... #BIT SPITBF=SPI2STAT.1 //SPIx Transmit Buffer Full Status bit 
....................                        //1  = Transmit not yet started, SPIxTXB is full 
....................                        //0  = Transmit started, SPIxTXB is empty 
....................                        //Automatically set in hardware when CPU writes SPIxBUF location, loading SPIxTXB. 
....................                        //Automatically cleared in hardware when SPIx module transfers data from SPIxTXB to SPIxSR. 
....................  
.................... #BIT SPIRBF=SPI2STAT.0 //SPIx Receive Buffer Full Status bit 
....................                        //1  = Receive complete, SPIxRXB is full 
....................                        //0  = Receive is not complete, SPIxRXB is empty 
....................                        //Automatically set in hardware when SPIx transfers data from SPIxSR to SPIxRXB. 
....................                        //Automatically cleared in hardware when core reads SPIxBUF location, reading SPIxRXB. 
.................... #BYTE RegValue = 0x00 
.................... #BIT  ADC_DRDY = RegValue.0 
....................  
....................                       
.................... #define STATUS 0x00     // ADC1256 Register map 
.................... #define MUX 0x01  
.................... #define ADCON 0x02 
.................... #define DRATE 0x03 
.................... #define IO 0x04 
.................... #define OFCO 0x05 
.................... #define OFC1 0x06 
.................... #define OFC2 0x07 
.................... #define FSCO 0x08 
.................... #define FSC1 0x09 
.................... #define FSC2 0x0A 
....................  
.................... #WORD SPI2CON1=0x0262 
.................... #WORD SPI2CON2=0x0264 
.................... #WORD SPI2BUF=0x0268 
....................  
.................... #WORD PORTB=0x02C8 
.................... #WORD TRISB=0x02C6 
.................... #WORD LATB=0x02CA 
.................... #BIT  TRB0=TRISB.0 
.................... #BIT  TRB1=TRISB.1 
.................... #BIT  TRB5=TRISB.5 
.................... #BIT  TRB14=TRISB.14 
.................... #BIT  TRB15=TRISB.15 
....................  
.................... #WORD PORTC=0x02CE 
.................... #WORD LATC=0x02D0 
.................... #WORD TRISC=0x02CC 
.................... //#BIT RC13=LATC.13 
.................... //#BIT RC14=LATC.14 
.................... #BIT RC13=PORTC.13 
.................... #BIT RC14=PORTC.14 
.................... #BIT  TRC13=TRISC.13 
.................... #BIT  TRC14=TRISC.14 
.................... #BIT  TRC1=TRISC.1 
.................... #BIT  TRC2=TRISC.2 
.................... #BIT  TRC4=TRISC.4 
.................... //_______________________________________ 
.................... #WORD PORTD=0x02D4 
.................... #WORD TRISD=0x02D2 
.................... #WORD ODCD=0x06D2 
.................... #BIT  TRD0=TRISD.0 
.................... #BIT  TRD1=TRISD.1 
.................... #BIT  TRD2=TRISD.2 
.................... #BIT  TRD3=TRISD.3 
.................... #BIT  TRD4=TRISD.4 
.................... #BIT  TRD5=TRISD.5 
.................... #BIT  TRD6=TRISD.6 
.................... #BIT  TRD7=TRISD.7 
.................... #BIT  TRD8=TRISD.8 
.................... #BIT  TRD9=TRISD.9 
.................... #BIT  TRD10=TRISD.10 
.................... #BIT  TRD11=TRISD.11 
....................  
.................... #BIT  RD0=LATD.0 
.................... #BIT  RD1=LATD.1 
.................... #BIT  RD2=LATD.2 
.................... #BIT  RD3=LATD.3 
.................... #BIT  RD4=LATD.4 
.................... #BIT  RD5=LATD.5 
.................... #BIT  RD6=LATD.6 
.................... #BIT  RD7=LATD.7 
.................... #BIT  RD8=LATD.8 
.................... #BIT  RD9=LATD.9 
.................... #BIT  RD10=LATD.10 
.................... #BIT  RD11=LATD.11 
.................... //_________________________________________________ 
.................... #WORD PORTF=0x02E0 
.................... #WORD TRISF=0x02DE 
.................... #BIT  UART2_RX_TRIS=TRISF.4 
.................... #BIT  UART2_TX_TRIS=TRISF.5 
....................  
.................... #WORD PORTG=0x02E6 
.................... #WORD TRISG=0x02E4 
.................... #BIT RG0=LATG.0 
.................... #BIT RG1=LATG.1 
.................... #BIT RG2=LATG.2 
.................... #BIT RG3=LATG.3 
.................... #BIT RG15=LATG.15 
.................... #BIT SCK2=LATG.6 // SPI2 pins 
.................... #BIT SDI2=LATG.7 
.................... #BIT SDO2=LATG.8 
.................... #BIT SS2=LATG.9 
.................... #BIT SCK2_TRIS=TRISG.6 // SPI2 tris 
.................... #BIT SDI2_TRIS=TRISG.7 
.................... #BIT SDO2_TRIS=TRISG.8 
.................... //#BIT SS2_TRIS=TRISG.9 
....................  
.................... #define ADC_Dout SDI2 //нога Din МК 
.................... #define ADC_Din SDO2  //нога Dout МК 
....................  
....................  
.................... #BIT  ADC_RESET_TRIS=TRISB.3 
.................... #BIT  ADC_RESET=LATB.3 
.................... #BIT  ADC_SYNC_TRIS=TRISB.4 
.................... #BIT  ADC_SYNC=LATB.4 
....................  
.................... #BIT  SS2_TRIS=TRISB.2 
.................... #BIT  ADC_CS = LATB.2 
....................  
....................  
.................... typedef unsigned int16 U16; 
.................... typedef unsigned int8 U8; 
.................... typedef unsigned int32 U32; 
.................... typedef signed int16 S16; 
....................  
.................... unsigned int16 Buf; 
.................... #BIT Buf0=Buf.0 
.................... #BIT Buf1=Buf.1 
.................... #BIT Buf2=Buf.2 
.................... #BIT Buf3=Buf.3 
.................... #BIT Buf4=Buf.4 
.................... #BIT Buf5=Buf.5 
.................... #BIT Buf6=Buf.6 
.................... #BIT Buf7=Buf.7 
.................... #BIT Buf8=Buf.8 
.................... #BIT Buf9=Buf.9 
.................... #BIT Buf10=Buf.10 
.................... #BIT Buf11=Buf.11 
.................... #BIT Buf12=Buf.12 
.................... #BIT Buf13=Buf.13 
.................... #BIT Buf14=Buf.14 
.................... #BIT Buf15=Buf.15 
....................  
.................... static U16 BufG;///////////////////////////////////////////////////////////////// 
.................... #BIT   BufG4=BufG.4 
.................... #BIT   BufG5=BufG.5 
.................... #BIT   BufG6=BufG.6 
.................... #BIT   BufG7=BufG.7 
.................... #BIT   BufG8=BufG.8 
.................... #BIT LCD_D7=BufG.3 
.................... #BIT LCD_D6=BufG.2 
.................... #BIT LCD_D5=BufG.1 
.................... #BIT LCD_D4=BufG.0 
.................... #BIT LCD_RW=BufG.12 
.................... #BIT LCD_RS=BufG.13 
.................... #BIT LCD_E=BufG.14 
....................  
.................... static U16 BufB; 
.................... #BIT   BufB0=BufB.0 
.................... #BIT   BufB1=BufB.1 
.................... #BIT   BufB2=BufB.2 
.................... #BIT   BufB3=BufB.3 
.................... #BIT   BufB4=BufB.4 
.................... #BIT   BufB5=BufB.5 
.................... #BIT   BufB6=BufB.6 
.................... #BIT   BufB7=BufB.7 
.................... #BIT   BufB8=BufB.8 
.................... #BIT   BufB9=BufB.9 
.................... #BIT   BufB10=BufB.10 
.................... #BIT   BufB11=BufB.11 
.................... #BIT   BufB12=BufB.12 
.................... #BIT   BufB13=BufB.13 
.................... #BIT   BufB14=BufB.14 
.................... #BIT   BufB15=BufB.15 
....................  
.................... static U16 BufC; 
.................... #BIT   BufC0=BufC.0 
.................... #BIT   BufC1=BufC.1 
.................... #BIT   BufC2=BufC.2 
.................... #BIT   BufC3=BufC.3 
.................... #BIT   BufC4=BufC.4 
.................... #BIT   BufC5=BufC.5 
.................... #BIT   BufC6=BufC.6 
.................... #BIT   BufC7=BufC.7 
.................... #BIT   BufC8=BufC.8 
.................... #BIT   BufC9=BufC.9 
.................... #BIT   BufC10=BufC.10 
.................... #BIT   BufC11=BufC.11 
.................... #BIT   BufC12=BufC.12 
.................... #BIT   BufC13=BufC.13 
.................... #BIT   BufC14=BufC.14 
.................... #BIT   BufC15=BufC.15 
....................  
.................... static U16 BufD; 
.................... #BIT   BufD0=BufD.0 
.................... #BIT   BufD1=BufD.1 
.................... #BIT   BufD2=BufD.2 
.................... #BIT   BufD3=BufD.3 
.................... #BIT   BufD4=BufD.4 
.................... #BIT   BufD5=BufD.5 
.................... #BIT   BufD6=BufD.6 
.................... #BIT   BufD7=BufD.7 
.................... #BIT   BufD8=BufD.8 
.................... #BIT   BufD9=BufD.9 
.................... #BIT   BufD10=BufD.10 
.................... #BIT   BufD11=BufD.11 
.................... #BIT   BufD12=BufD.12 
.................... #BIT   BufD13=BufD.13 
.................... #BIT   BufD14=BufD.14 
.................... #BIT   BufD15=BufD.15 
....................  
.................... static U16 BufF; 
.................... #BIT   BufF0=BufF.0 
.................... #BIT   BufF1=BufF.1 
.................... #BIT   BufF2=BufF.2 
.................... #BIT   BufF3=BufF.3 
.................... #BIT   BufF4=BufF.4 
.................... #BIT   BufF5=BufF.5 
.................... #BIT   BufF6=BufF.6 
.................... #BIT   BufF7=BufF.7 
.................... #BIT   BufF8=BufF.8 
.................... #BIT   BufF9=BufF.9 
.................... #BIT   BufF10=BufF.10 
.................... #BIT   BufF11=BufF.11 
.................... #BIT   BufF12=BufF.12 
.................... #BIT   BufF13=BufF.13 
.................... #BIT   BufF14=BufF.14 
.................... #BIT   BufF15=BufF.15 
....................  
.................... #define FCY      40000000 
.................... #define BAUDRATE 9600                 
.................... #define BRGVAL   ((FCY/BAUDRATE)/16)-1 
....................  
....................  
....................  
....................  
.................... #include <LCD_16X4_Termo3.h> 
.................... /***************** LCD functions *****************/ 
.................... static void LCDWriteNibble(unsigned char uc)  
.................... {                                            
....................   
....................   buf=uc; 
0028C:  MOV.B   83C,W0L
0028E:  MOV.B   W0L,800
00290:  CLR.B   801
....................   LCD_D4=Buf0; 
00292:  BCLR.B  802.0
00294:  BTSC.B  800.0
00296:  BSET.B  802.0
....................   LCD_D5=Buf1; 
00298:  BCLR.B  802.1
0029A:  BTSC.B  800.1
0029C:  BSET.B  802.1
....................   LCD_D6=Buf2; 
0029E:  BCLR.B  802.2
002A0:  BTSC.B  800.2
002A2:  BSET.B  802.2
....................   LCD_D7=Buf3; 
002A4:  BCLR.B  802.3
002A6:  BTSC.B  800.3
002A8:  BSET.B  802.3
....................   LCD_RW=0; 
002AA:  BCLR.B  803.4
....................   PORTG=BufG; 
002AC:  PUSH    802
002AE:  POP     2E6
....................   delay_us(1); 
002B0:  REPEAT  #26
002B2:  NOP     
....................   LCD_E=1; 
002B4:  BSET.B  803.6
....................   PORTG=BufG; 
002B6:  PUSH    802
002B8:  POP     2E6
....................   delay_us(2); 
002BA:  REPEAT  #4E
002BC:  NOP     
....................   LCD_E=0; 
002BE:  BCLR.B  803.6
....................   PORTG=BufG; 
002C0:  PUSH    802
002C2:  POP     2E6
....................   delay_us(2); 
002C4:  REPEAT  #4E
002C6:  NOP     
....................   LCD_RW=1;  
002C8:  BSET.B  803.4
....................   PORTG=BufG; 
002CA:  PUSH    802
002CC:  POP     2E6
....................  
.................... } 
002CE:  RETURN  
....................  
.................... static void LCDWriteData(unsigned char uc) 
.................... { 
*
00392:  MOV     W5,[W15++]
....................    
....................     LCD_RS=0; 
00394:  BCLR.B  803.5
....................     PORTG=BufG; 
00396:  PUSH    802
00398:  POP     2E6
....................     delay_us(50); 
0039A:  REPEAT  #7CE
0039C:  NOP     
....................     LCD_RS=1; 
0039E:  BSET.B  803.5
....................     PORTG=BufG; 
003A0:  PUSH    802
003A2:  POP     2E6
....................     LCD_RW=1; 
003A4:  BSET.B  803.4
....................     PORTG=BufG; 
003A6:  PUSH    802
003A8:  POP     2E6
....................     LCDWriteNibble(uc>>4); 
003AA:  MOV     838,W5
003AC:  CLR.B   B
003AE:  LSR     W5,#4,W5
003B0:  PUSH    83C
003B2:  MOV.B   W5L,[W15-#2]
003B4:  POP     83C
003B6:  CALL    28C
....................     LCDWriteNibble(uc); 
003BA:  MOV.B   838,W0L
003BC:  MOV.B   W0L,83C
003BE:  CALL    28C
....................   
.................... } 
003C2:  MOV     [--W15],W5
003C4:  RETURN  
....................  
.................... static void LCDCommand(unsigned char uc) 
.................... { 
*
002D0:  MOV     W5,[W15++]
....................    
....................     LCD_RS=0; 
002D2:  BCLR.B  803.5
....................     PORTG=BufG; 
002D4:  PUSH    802
002D6:  POP     2E6
....................     delay_us(50); 
002D8:  REPEAT  #7CE
002DA:  NOP     
....................     LCD_RW=1; 
002DC:  BSET.B  803.4
....................     PORTG=BufG; 
002DE:  PUSH    802
002E0:  POP     2E6
....................     LCDWriteNibble(uc>>4); 
002E2:  MOV     820,W5
002E4:  CLR.B   B
002E6:  LSR     W5,#4,W5
002E8:  PUSH    83C
002EA:  MOV.B   W5L,[W15-#2]
002EC:  POP     83C
002EE:  CALL    28C
....................     LCDWriteNibble(uc); 
002F2:  MOV.B   820,W0L
002F4:  MOV.B   W0L,83C
002F6:  CALL    28C
....................    
.................... } 
002FA:  MOV     [--W15],W5
002FC:  RETURN  
....................  
.................... static void LCDSetCursor(unsigned char ucPos) 
.................... { 
*
003DA:  MOV     W5,[W15++]
....................   LCDCommand(0x80 | ucPos); 
003DC:  MOV     81C,W5
003DE:  IOR.B   #80,W5L
003E0:  PUSH    820
003E2:  MOV.B   W5L,[W15-#2]
003E4:  POP     820
003E6:  CALL    2D0
.................... } 
003EA:  MOV     [--W15],W5
003EC:  RETURN  
....................  
.................... static void LCDClear(void) 
.................... { 
....................    LCDCommand(0x1); 
*
00382:  MOV.B   #1,W0L
00384:  MOV.B   W0L,820
00386:  CALL    2D0
....................    //Delay_ms(1); 
....................    delay_ms(5); 
0038A:  MOV     #5,W0
0038C:  CALL    274
.................... } 
00390:  RETURN  
....................  
.................... static void LCDInit(void) 
....................  
.................... { 
....................     
....................   LCD_E=0; 
*
002FE:  BCLR.B  803.6
....................   //PORTB=BufB; 
....................   LCD_RS=0; 
00300:  BCLR.B  803.5
....................   PORTG=BufG; 
00302:  PUSH    802
00304:  POP     2E6
....................   Delay_ms(1000); // 
00306:  MOV     #3E8,W0
00308:  CALL    274
....................   LCDWriteNibble(3); 
0030C:  MOV.B   #3,W0L
0030E:  MOV.B   W0L,83C
00310:  CALL    28C
....................   Delay_us(200); 
00314:  REPEAT  #1F3E
00316:  NOP     
....................   LCDWriteNibble(3); 
00318:  MOV.B   #3,W0L
0031A:  MOV.B   W0L,83C
0031C:  CALL    28C
....................   Delay_us(200); 
00320:  REPEAT  #1F3E
00322:  NOP     
....................   LCDWriteNibble(3); 
00324:  MOV.B   #3,W0L
00326:  MOV.B   W0L,83C
00328:  CALL    28C
....................   Delay_us(200); 
0032C:  REPEAT  #1F3E
0032E:  NOP     
....................   LCDWriteNibble(2); 
00330:  MOV.B   #2,W0L
00332:  MOV.B   W0L,83C
00334:  CALL    28C
....................   Delay_us(200); 
00338:  REPEAT  #1F3E
0033A:  NOP     
....................    
....................   LCDCommand(0x28); // 4-aeoiue ?a?ei, 2 no?iee, o?eoo 5x8 oi?ae 
0033C:  MOV.B   #28,W0L
0033E:  MOV.B   W0L,820
00340:  CALL    2D0
....................   LCDCommand(0x08); // Auee??eou aenieae, auee??eou eo?ni?, auee??eou ii?aaiea eo?ni?a 
00344:  MOV.B   #8,W0L
00346:  MOV.B   W0L,820
00348:  CALL    2D0
....................   LCDCommand(0x0F); // Aee??eou aenieae, aee??eou eo?ni?, aee??eou ii?aaiea eo?ni?a 
0034C:  MOV.B   #F,W0L
0034E:  MOV.B   W0L,820
00350:  CALL    2D0
....................   LCDCommand(0x06); // Eo?ni? aoaao aaeaaouny ai?aai i?e aaiaa oaenoa 
00354:  MOV.B   #6,W0L
00356:  MOV.B   W0L,820
00358:  CALL    2D0
....................   LCDCommand(0x1);  // I?enoea ye?aia e ia?aiauaiea eo?ni?a a ia?ao? iiceoe? 
0035C:  MOV.B   #1,W0L
0035E:  MOV.B   W0L,820
00360:  CALL    2D0
....................   delay_ms(2); 
00364:  MOV     #2,W0
00366:  CALL    274
....................   LCDCommand(0x06);// eo?ni? aoaao aaeaaouny ai?aai i?e auaiaa oaenoa  
0036A:  MOV.B   #6,W0L
0036C:  MOV.B   W0L,820
0036E:  CALL    2D0
....................   LCDCommand(0x40);// onoaiiaea aa?ana DRAM 
00372:  MOV.B   #40,W0L
00374:  MOV.B   W0L,820
00376:  CALL    2D0
....................   delay_ms(10); 
0037A:  MOV     #A,W0
0037C:  CALL    274
.................... } 
00380:  RETURN  
....................   
.................... static void LCDPutCh(char c) 
.................... { 
....................   LCDWriteData(c); 
*
003C6:  MOV.B   836,W0L
003C8:  MOV.B   W0L,838
003CA:  CALL    392
.................... } 
003CE:  RETURN  
....................  
.................... static void LCDPutU32(U32 _u16,U8 u8NumDigs) 
.................... { 
*
00608:  MOV     W5,[W15++]
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000000; 
0060A:  BCLR.B  43.0
0060C:  MOV     822,W0
0060E:  MOV     824,W1
00610:  MOV     #9680,W2
00612:  MOV     #98,W3
00614:  CALL    584
00618:  MOV     W0,828
0061A:  MOV     W1,82A
....................    u16b=u16a*10000000; 
0061C:  MOV     828,W0
0061E:  MOV     82A,W1
00620:  MOV     #9680,W2
00622:  MOV     #98,W3
00624:  CALL    5D8
00628:  MOV     W0,82C
0062A:  MOV     W1,82E
....................  
....................     if (u8NumDigs>=7) 
0062C:  MOV     826,W4
0062E:  CP.B    W4L,#7
00630:  BRA     NC,642
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
00632:  MOV     #30,W4
00634:  MOV     828,W3
00636:  ADD.B   W3L,W4L,W5L
00638:  PUSH    836
0063A:  MOV.B   W5L,[W15-#2]
0063C:  POP     836
0063E:  CALL    3C6
....................     } 
....................       _u16-=u16b; 
00642:  MOV     822,W4
00644:  MOV     82C,W3
00646:  SUB     W4,W3,W0
00648:  MOV     W0,822
0064A:  MOV     824,W4
0064C:  MOV     82E,W3
0064E:  SUBB    W4,W3,W0
00650:  MOV     W0,824
....................        
....................    u16a=_u16/1000000; 
00652:  BCLR.B  43.0
00654:  MOV     822,W0
00656:  MOV     824,W1
00658:  MOV     #4240,W2
0065A:  MOV     #F,W3
0065C:  CALL    584
00660:  MOV     W0,828
00662:  MOV     W1,82A
....................    u16b=u16a*1000000; 
00664:  MOV     828,W0
00666:  MOV     82A,W1
00668:  MOV     #4240,W2
0066A:  MOV     #F,W3
0066C:  CALL    5D8
00670:  MOV     W0,82C
00672:  MOV     W1,82E
....................        
....................     if (u8NumDigs>=6) 
00674:  MOV     826,W4
00676:  CP.B    W4L,#6
00678:  BRA     NC,68A
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0067A:  MOV     #30,W4
0067C:  MOV     828,W3
0067E:  ADD.B   W3L,W4L,W5L
00680:  PUSH    836
00682:  MOV.B   W5L,[W15-#2]
00684:  POP     836
00686:  CALL    3C6
....................     } 
....................       _u16-=u16b; 
0068A:  MOV     822,W4
0068C:  MOV     82C,W3
0068E:  SUB     W4,W3,W0
00690:  MOV     W0,822
00692:  MOV     824,W4
00694:  MOV     82E,W3
00696:  SUBB    W4,W3,W0
00698:  MOV     W0,824
....................        
....................    u16a=_u16/100000; 
0069A:  BCLR.B  43.0
0069C:  MOV     822,W0
0069E:  MOV     824,W1
006A0:  MOV     #86A0,W2
006A2:  MOV     #1,W3
006A4:  CALL    584
006A8:  MOV     W0,828
006AA:  MOV     W1,82A
....................    u16b=u16a*100000; 
006AC:  MOV     828,W0
006AE:  MOV     82A,W1
006B0:  MOV     #86A0,W2
006B2:  MOV     #1,W3
006B4:  CALL    5D8
006B8:  MOV     W0,82C
006BA:  MOV     W1,82E
....................  
....................     if (u8NumDigs>=5) 
006BC:  MOV     826,W4
006BE:  CP.B    W4L,#5
006C0:  BRA     NC,6D2
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
006C2:  MOV     #30,W4
006C4:  MOV     828,W3
006C6:  ADD.B   W3L,W4L,W5L
006C8:  PUSH    836
006CA:  MOV.B   W5L,[W15-#2]
006CC:  POP     836
006CE:  CALL    3C6
....................     } 
....................  
....................     _u16-=u16b; 
006D2:  MOV     822,W4
006D4:  MOV     82C,W3
006D6:  SUB     W4,W3,W0
006D8:  MOV     W0,822
006DA:  MOV     824,W4
006DC:  MOV     82E,W3
006DE:  SUBB    W4,W3,W0
006E0:  MOV     W0,824
....................     u16a=_u16/10000; 
006E2:  BCLR.B  43.0
006E4:  MOV     822,W0
006E6:  MOV     824,W1
006E8:  MOV     #2710,W2
006EA:  MOV     #0,W3
006EC:  CALL    584
006F0:  MOV     W0,828
006F2:  MOV     W1,82A
....................     u16b=u16a*10000; 
006F4:  MOV     828,W0
006F6:  MOV     82A,W1
006F8:  MOV     #2710,W2
006FA:  MOV     #0,W3
006FC:  CALL    5D8
00700:  MOV     W0,82C
00702:  MOV     W1,82E
....................     if (u8NumDigs>=4) 
00704:  MOV     826,W4
00706:  CP.B    W4L,#4
00708:  BRA     NC,71A
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0070A:  MOV     #30,W4
0070C:  MOV     828,W3
0070E:  ADD.B   W3L,W4L,W5L
00710:  PUSH    836
00712:  MOV.B   W5L,[W15-#2]
00714:  POP     836
00716:  CALL    3C6
....................     } 
....................  
....................     _u16-=u16b; 
0071A:  MOV     822,W4
0071C:  MOV     82C,W3
0071E:  SUB     W4,W3,W0
00720:  MOV     W0,822
00722:  MOV     824,W4
00724:  MOV     82E,W3
00726:  SUBB    W4,W3,W0
00728:  MOV     W0,824
....................     u16a=_u16/1000; 
0072A:  BCLR.B  43.0
0072C:  MOV     822,W0
0072E:  MOV     824,W1
00730:  MOV     #3E8,W2
00732:  MOV     #0,W3
00734:  CALL    584
00738:  MOV     W0,828
0073A:  MOV     W1,82A
....................     u16b=u16a*1000; 
0073C:  MOV     828,W0
0073E:  MOV     82A,W1
00740:  MOV     #3E8,W2
00742:  MOV     #0,W3
00744:  CALL    5D8
00748:  MOV     W0,82C
0074A:  MOV     W1,82E
....................     if (u8NumDigs>=3) 
0074C:  MOV     826,W4
0074E:  CP.B    W4L,#3
00750:  BRA     NC,762
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
00752:  MOV     #30,W4
00754:  MOV     828,W3
00756:  ADD.B   W3L,W4L,W5L
00758:  PUSH    836
0075A:  MOV.B   W5L,[W15-#2]
0075C:  POP     836
0075E:  CALL    3C6
....................        
....................     } 
....................  
....................     _u16-=u16b; 
00762:  MOV     822,W4
00764:  MOV     82C,W3
00766:  SUB     W4,W3,W0
00768:  MOV     W0,822
0076A:  MOV     824,W4
0076C:  MOV     82E,W3
0076E:  SUBB    W4,W3,W0
00770:  MOV     W0,824
....................     u16a=_u16/100; 
00772:  BCLR.B  43.0
00774:  MOV     822,W0
00776:  MOV     824,W1
00778:  MOV     #64,W2
0077A:  MOV     #0,W3
0077C:  CALL    584
00780:  MOV     W0,828
00782:  MOV     W1,82A
....................     u16b=u16a*100; 
00784:  MOV     828,W0
00786:  MOV     82A,W1
00788:  MOV     #64,W2
0078A:  MOV     #0,W3
0078C:  CALL    5D8
00790:  MOV     W0,82C
00792:  MOV     W1,82E
....................    if (u8NumDigs>=2) 
00794:  MOV     826,W4
00796:  CP.B    W4L,#2
00798:  BRA     NC,7AA
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0079A:  MOV     #30,W4
0079C:  MOV     828,W3
0079E:  ADD.B   W3L,W4L,W5L
007A0:  PUSH    836
007A2:  MOV.B   W5L,[W15-#2]
007A4:  POP     836
007A6:  CALL    3C6
....................     } 
....................  
....................    _u16-=u16b; 
007AA:  MOV     822,W4
007AC:  MOV     82C,W3
007AE:  SUB     W4,W3,W0
007B0:  MOV     W0,822
007B2:  MOV     824,W4
007B4:  MOV     82E,W3
007B6:  SUBB    W4,W3,W0
007B8:  MOV     W0,824
....................     u16a=_u16/10; 
007BA:  BCLR.B  43.0
007BC:  MOV     822,W0
007BE:  MOV     824,W1
007C0:  MOV     #A,W2
007C2:  MOV     #0,W3
007C4:  CALL    584
007C8:  MOV     W0,828
007CA:  MOV     W1,82A
....................     u16b=u16a*10; 
007CC:  MOV     828,W0
007CE:  MOV     82A,W1
007D0:  MOV     #A,W2
007D2:  MOV     #0,W3
007D4:  CALL    5D8
007D8:  MOV     W0,82C
007DA:  MOV     W1,82E
....................    if (u8NumDigs>=2) 
007DC:  MOV     826,W4
007DE:  CP.B    W4L,#2
007E0:  BRA     NC,7F2
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
007E2:  MOV     #30,W4
007E4:  MOV     828,W3
007E6:  ADD.B   W3L,W4L,W5L
007E8:  PUSH    836
007EA:  MOV.B   W5L,[W15-#2]
007EC:  POP     836
007EE:  CALL    3C6
....................     } 
....................  
....................     _u16-=u16b; 
007F2:  MOV     822,W4
007F4:  MOV     82C,W3
007F6:  SUB     W4,W3,W0
007F8:  MOV     W0,822
007FA:  MOV     824,W4
007FC:  MOV     82E,W3
007FE:  SUBB    W4,W3,W0
00800:  MOV     W0,824
....................     if (u8NumDigs>=1) 
00802:  MOV     826,W4
00804:  CP.B    W4L,#1
00806:  BRA     NC,818
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
00808:  MOV     #30,W4
0080A:  MOV     822,W3
0080C:  ADD.B   W3L,W4L,W5L
0080E:  PUSH    836
00810:  MOV.B   W5L,[W15-#2]
00812:  POP     836
00814:  CALL    3C6
....................     } 
....................    
.................... } 
00818:  MOV     [--W15],W5
0081A:  RETURN  
....................  
.................... static void LCDPutU16(U32 _u16,U8 u8NumDigs) 
.................... { 
....................     
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000; 
....................    u16b=u16a*10000; 
....................  
....................     if (u8NumDigs>=5) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/1000; 
....................     u16b=u16a*1000; 
....................     if (u8NumDigs>=4) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/100; 
....................     u16b=u16a*100; 
....................     if (u8NumDigs>=3) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................        
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/10; 
....................     u16b=u16a*10; 
....................    if (u8NumDigs>=2) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     if (u8NumDigs>=1) 
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
....................     } 
....................    
.................... } 
....................  
.................... /* 
....................  static void LCDPutU16(U32 _u16,U8 u8NumDigs) 
.................... { 
....................     
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000; 
....................    u16b=u16a*10000; 
....................  
....................     if (u8NumDigs>=5) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/1000; 
....................     u16b=u16a*1000; 
....................     if (u8NumDigs>=4) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/100; 
....................     u16b=u16a*100; 
....................     if (u8NumDigs>=3) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................        
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/10; 
....................     u16b=u16a*10; 
....................    if (u8NumDigs>=2) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     if (u8NumDigs>=1) 
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
....................     } 
....................    
.................... } 
.................... */ 
.................... static void LCDPutS16(S16 s16a,U8 u8NumDigs) 
.................... { 
....................   char c='+'; 
....................  
....................   if (s16a<0) 
....................   { 
....................     s16a=-s16a; 
....................     c='-'; 
....................   } 
....................   LCDPutCh(c); 
....................   LCDPutU16((U16)s16a,u8NumDigs); 
.................... } 
....................  
.................... static void LCDMsg(char c) 
.................... { 
....................     LCDPutCh(c); 
*
003D0:  MOV.B   820,W0L
003D2:  MOV.B   W0L,836
003D4:  CALL    3C6
.................... } 
003D8:  RETURN  
....................  
....................  static void LCDWelcome(void) 
.................... { 
*
003EE:  MOV     W5,[W15++]
....................     //U16 u16a; 
....................     LCDClear(); 
003F0:  CALL    382
....................     LCDMsg("    KRION-6T    "); 
003F4:  MOV     #0,W5
003F6:  MOV     W5,W0
003F8:  CALL    200
003FC:  IOR.B   #0,W0L
003FE:  BTSC.B  42.1
00400:  BRA     40C
00402:  INC     W5,W5
00404:  MOV.B   W0L,820
00406:  CALL    3D0
0040A:  BRA     3F6
....................     //Delay_ms(2000); 
....................     LCDSetCursor(0x40); 
0040C:  MOV.B   #40,W0L
0040E:  MOV.B   W0L,81C
00410:  CALL    3DA
....................     LCDMsg("  THERMOMETRY   "); 
00414:  MOV     #0,W5
00416:  MOV     W5,W0
00418:  CALL    21E
0041C:  IOR.B   #0,W0L
0041E:  BTSC.B  42.1
00420:  BRA     42C
00422:  INC     W5,W5
00424:  MOV.B   W0L,820
00426:  CALL    3D0
0042A:  BRA     416
....................     LCDSetCursor(0x50); 
0042C:  MOV.B   #50,W0L
0042E:  MOV.B   W0L,81C
00430:  CALL    3DA
....................     LCDMsg("   LHEP JINR   "); 
00434:  MOV     #0,W5
00436:  MOV     W5,W0
00438:  CALL    23C
0043C:  IOR.B   #0,W0L
0043E:  BTSC.B  42.1
00440:  BRA     44C
00442:  INC     W5,W5
00444:  MOV.B   W0L,820
00446:  CALL    3D0
0044A:  BRA     436
....................     Delay_ms(2000); 
0044C:  MOV     #7D0,W0
0044E:  CALL    274
....................     LCDClear();    
00452:  CALL    382
.................... } 
00456:  MOV     [--W15],W5
00458:  RETURN  
....................  
....................  
....................    U32 ADC_RByte1,ADC_RByte2,ADC_RByte3 = 0; 
....................    U32 ADC_RByte_Sum = 0; 
....................  
....................    void OscSetup(){ 
....................   //Fcy=Fosc/2 
....................   //Fin=10M 
....................   //Fosc=Fin(M/(N1*N2)) 
....................   U2BRG = 259;// BAUD Rate Setting for 9600 
*
00258:  MOV     #103,W4
0025A:  MOV     W4,238
....................   U2MODE = 0b1010101010010000; 
0025C:  MOV     #AA90,W4
0025E:  MOV     W4,230
....................   PLLFBD = 30; // уст. коэф. формулы PLL M = 30 
00260:  MOV     #1E,W4
00262:  MOV     W4,746
....................    
....................   PLLPRE4 = 0; // уст. коэф. формулы PLL N1 = 2 
00264:  BCLR.B  744.4
....................   PLLPRE3 = 0; 
00266:  BCLR.B  744.3
....................   PLLPRE2 = 0; 
00268:  BCLR.B  744.2
....................   PLLPRE1 = 0; 
0026A:  BCLR.B  744.1
....................   PLLPRE0 = 0; 
0026C:  BCLR.B  744.0
....................    
....................   PLLPOST0=0; // уст. коэф. формулы PLL N2 = 2 
0026E:  BCLR.B  744.6
....................   PLLPOST1=0; 
00270:  BCLR.B  744.7
....................      
....................    } 
00272:  RETURN  
....................  
....................    void SPI2_setup(){ 
....................     
....................    SPIEN = 1; 
....................    SPI2CON1 = 0b0000001110100000; 
....................    SPI2CON2 = 0b1000000000000000;   
....................    }  
....................   
.................... /***************** ADC1256 functions *****************/ 
....................  
....................  
.................... static int1 RdStatus() 
.................... { 
....................    //U8 RegValue = 0; 
....................    //1st Command Byte: 0001 rrrr where rrrr is the address of the first register to read. 
....................    //2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to read – 1 
....................    ADC_CS = 0; 
....................    delay_us(1); 
....................    Spi_write2(0x10); // 1st Command Byte,команда записи 
....................    Spi_write2(0x00); // 1st Command Byte, читаем только один байт 
....................    delay_us(8); // 50 CLK_IN PEDIODS 
....................    RegValue = Spi_read2(0); 
....................    delay_us(1); 
....................    ADC_CS =1; 
....................    delay_us(1); 
....................    Return ADC_SYNC;   
.................... } 
....................  
.................... static U8 RdReg(U8 RegName) 
.................... { 
....................    //U8 RegValue = 0;  
....................    //1st Command Byte: 0001 rrrr where rrrr is the address of the first register to read. 
....................    //2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to read – 1 
....................    ADC_CS = 0; 
....................    delay_us(1); 
....................    Spi_write2(0x10+RegName); // 1st Command Byte,команда чтения 
....................    Spi_write2(0x00); // 1st Command Byte, читаем только один байт 
....................    delay_us(8); // 50 CLK_IN PEDIODS 
....................    RegValue = Spi_read2(0); 
....................    delay_us(1); 
....................    ADC_CS =1; 
....................    delay_us(1); 
....................    Return RegValue;   
.................... } 
....................  
.................... static void WrReg(U8 RegName,CommandByte) 
.................... { 
....................    ADC_CS = 0; 
....................    delay_us(1); 
....................    Spi_write2(0b0101+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written. 
....................    Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1. 
....................    Spi_write2(CommandByte); 
....................    delay_us(1); 
....................    ADC_CS = 1; 
....................    delay_us(20); 
.................... } 
....................  
.................... static void ADC_Init(U8 StartRegId,CommandByte1,CommandByte2,CommandByte3,CommandByte4) 
....................  
.................... { 
*
0045A:  MOV     W5,[W15++]
....................  
....................    ADC_CS = 0; 
0045C:  BCLR.B  2CA.2
....................    delay_us(1); 
0045E:  REPEAT  #26
00460:  NOP     
....................    Spi_write2(0x50+StartRegId); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written. 
00462:  MOV     #50,W0
00464:  ADD.B   81C,W0L
00466:  MOV.B   W0L,A
00468:  BCLR.B  260.6
0046A:  BTSS.B  260.0
0046C:  BRA     472
0046E:  MOV.B   268,W0L
00470:  BRA     46A
00472:  PUSH    268
00474:  MOV.B   W5L,[W15-#2]
00476:  POP     268
00478:  BTSS.B  260.0
0047A:  BRA     478
....................    Spi_write2(3);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1. 
0047C:  BCLR.B  260.6
0047E:  BTSS.B  260.0
00480:  BRA     486
00482:  MOV.B   268,W0L
00484:  BRA     47E
00486:  MOV.B   #3,W0L
00488:  MOV.B   W0L,268
0048A:  BTSS.B  260.0
0048C:  BRA     48A
....................    Spi_write2(CommandByte1); 
0048E:  BCLR.B  260.6
00490:  BTSS.B  260.0
00492:  BRA     498
00494:  MOV.B   268,W0L
00496:  BRA     490
00498:  MOV.B   81D,W0L
0049A:  MOV.B   W0L,268
0049C:  BTSS.B  260.0
0049E:  BRA     49C
....................    Spi_write2(CommandByte2); 
004A0:  BCLR.B  260.6
004A2:  BTSS.B  260.0
004A4:  BRA     4AA
004A6:  MOV.B   268,W0L
004A8:  BRA     4A2
004AA:  MOV.B   81E,W0L
004AC:  MOV.B   W0L,268
004AE:  BTSS.B  260.0
004B0:  BRA     4AE
....................    Spi_write2(CommandByte3); 
004B2:  BCLR.B  260.6
004B4:  BTSS.B  260.0
004B6:  BRA     4BC
004B8:  MOV.B   268,W0L
004BA:  BRA     4B4
004BC:  MOV.B   81F,W0L
004BE:  MOV.B   W0L,268
004C0:  BTSS.B  260.0
004C2:  BRA     4C0
....................    Spi_write2(CommandByte4); 
004C4:  BCLR.B  260.6
004C6:  BTSS.B  260.0
004C8:  BRA     4CE
004CA:  MOV.B   268,W0L
004CC:  BRA     4C6
004CE:  MOV.B   820,W0L
004D0:  MOV.B   W0L,268
004D2:  BTSS.B  260.0
004D4:  BRA     4D2
....................    delay_us(1); 
004D6:  REPEAT  #26
004D8:  NOP     
....................    ADC_CS = 1; 
004DA:  BSET.B  2CA.2
....................     
.................... } 
004DC:  MOV     [--W15],W5
004DE:  RETURN  
....................  
.................... static U32 ADC_RDataC() 
....................      { 
004E0:  MOV     W5,[W15++]
004E2:  MOV     W6,[W15++]
....................      ADC_CS = 0; 
004E4:  BCLR.B  2CA.2
....................      delay_us(10); 
004E6:  REPEAT  #18E
004E8:  NOP     
....................      Spi_write2(0x03); 
004EA:  BCLR.B  260.6
004EC:  BTSS.B  260.0
004EE:  BRA     4F4
004F0:  MOV.B   268,W0L
004F2:  BRA     4EC
004F4:  MOV.B   #3,W0L
004F6:  MOV.B   W0L,268
004F8:  BTSS.B  260.0
004FA:  BRA     4F8
....................      ADC_CS = 1; 
004FC:  BSET.B  2CA.2
....................      delay_ms(22); // 50 clk periods 
004FE:  MOV     #16,W0
00500:  CALL    274
....................     // l1: 
....................      //RdReg(STATUS); 
....................      //if(!ADC_SYNC){ 
....................      ADC_CS = 0; 
00504:  BCLR.B  2CA.2
....................      delay_us(10); 
00506:  REPEAT  #18E
00508:  NOP     
....................      ADC_Rbyte1 = Spi_read2(0); 
0050A:  BCLR.B  260.6
0050C:  BTSS.B  260.0
0050E:  BRA     514
00510:  MOV.B   268,W0L
00512:  BRA     50C
00514:  CLR.B   268
00516:  BTSS.B  260.0
00518:  BRA     516
0051A:  MOV.B   268,W0L
0051C:  MOV.B   W0L,80C
0051E:  CLR.B   80D
00520:  CLR     80E
....................      ADC_Rbyte2 = Spi_read2(0); 
00522:  BCLR.B  260.6
00524:  BTSS.B  260.0
00526:  BRA     52C
00528:  MOV.B   268,W0L
0052A:  BRA     524
0052C:  CLR.B   268
0052E:  BTSS.B  260.0
00530:  BRA     52E
00532:  MOV.B   268,W0L
00534:  MOV.B   W0L,810
00536:  CLR.B   811
00538:  CLR     812
....................      ADC_Rbyte3 = Spi_read2(0); 
0053A:  BCLR.B  260.6
0053C:  BTSS.B  260.0
0053E:  BRA     544
00540:  MOV.B   268,W0L
00542:  BRA     53C
00544:  CLR.B   268
00546:  BTSS.B  260.0
00548:  BRA     546
0054A:  MOV.B   268,W0L
0054C:  MOV.B   W0L,814
0054E:  CLR.B   815
00550:  CLR     816
....................      delay_us(10); 
00552:  REPEAT  #18E
00554:  NOP     
....................      ADC_CS = 1;  
00556:  BSET.B  2CA.2
....................      ADC_RByte_Sum = (ADC_Rbyte1<<16) + (ADC_Rbyte2<<8) + ADC_Rbyte3; 
00558:  MOV     80C,W6
0055A:  MOV     #0,W5
0055C:  MOV.B   812,W0L
0055E:  MOV.B   W0L,3
00560:  MOV.B   811,W0L
00562:  MOV.B   W0L,W1L
00564:  MOV.B   810,W0L
00566:  MOV.B   W0L,1
00568:  CLR.B   W0
0056A:  ADD     W0,W5,W5
0056C:  ADDC    W1,W6,W6
0056E:  MOV     W5,W0
00570:  ADD     814,W0
00572:  MOV     W0,818
00574:  MOV     816,W4
00576:  ADDC    W6,W4,W0
00578:  MOV     W0,81A
....................      return ADC_RByte_Sum; 
0057A:  MOV     818,W0
0057C:  MOV     81A,W1
....................     // }      
....................     // else goto l1; 
....................      } 
0057E:  MOV     [--W15],W6
00580:  MOV     [--W15],W5
00582:  RETURN  
....................  
.................... static U32 ADC_Rdata(){ 
....................        
....................      ADC_CS = 0; 
....................      delay_us(1); 
....................      Spi_write2(0x01); 
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      delay_ms(30); //  
....................      ADC_CS = 0; 
....................      delay_us(1); 
....................      ADC_Rbyte1 = Spi_read2(0); 
....................      ADC_Rbyte2 = Spi_read2(0); 
....................      ADC_Rbyte3 = Spi_read2(0); 
....................      ADC_CS = 1;  
....................      delay_ms(1); 
....................       
....................      ADC_RByte_Sum = (ADC_Rbyte1<<16) + (ADC_Rbyte2<<8) + ADC_Rbyte3; 
....................      return ADC_RByte_Sum; 
.................... } 
....................  
.................... /***************** ADC1256 functions *****************/ 
....................  
.................... /* 
.................... #int_timer1 
.................... void  TIMER1_isr(void) 
.................... { 
....................        set_timer1(65526); // 65536 отсчетов таймера -> 1 отсчет - 200 нс -> 10 отсчетов 2 мкс 
....................      //прерывание по таймеру каждые 2 мкс, переполнение один раз вызывает прерывание 
....................        RdReg(STATUS); 
....................        RD1 = ADC_DRDY; // status.0 bit 
....................         
....................       clear_interrupt(int_timer1); 
.................... } 
....................  
.................... */ 
.................... void main() 
.................... {    
*
0081C:  BSET.B  81.7
0081E:  MOV     #8000,W4
00820:  MOV     W4,230
00822:  MOV     #400,W4
00824:  MOV     W4,232
00826:  MOV     #103,W4
00828:  MOV     W4,238
0082A:  BCLR.B  261.7
0082C:  BCLR.B  2E5.0
0082E:  BSET.B  2E4.7
00830:  BCLR.B  2E4.6
00832:  BCLR.B  260.6
00834:  MOV     #3B,W4
00836:  MOV     W4,262
00838:  BSET.B  261.7
0083A:  CLR     814
0083C:  CLR     816
0083E:  CLR     818
00840:  CLR     81A
00842:  SETM    32C
00844:  SETM    32A
00846:  MOV     #1F80,W15
00848:  MOV     #1FFF,W0
0084A:  MOV     W0,20
0084C:  NOP     
0084E:  CLR     802
00850:  CLR     804
00852:  CLR     806
00854:  CLR     808
00856:  CLR     80A
00858:  MOV     #1F80,W15
0085A:  MOV     #1FFF,W0
0085C:  MOV     W0,20
0085E:  NOP     
....................  // unsignedint16 temp; 
....................    
....................    OscSetup(); 
00860:  CALL    258
....................    // SPI2_setup(); 
....................    SETUP_SPI2(SPI_MASTER|SPI_SCK_IDLE_LOW|SPI_XMIT_H_TO_L|SPI_MODE_8B|SPI_SAMPLE_AT_END|SPI_SS_ENABLED|SPI_CLK_DIV_128); 
00864:  BCLR.B  261.7
00866:  BCLR.B  260.6
00868:  MOV     #2A1,W4
0086A:  MOV     W4,262
0086C:  BSET.B  261.7
....................    // f SCLK SPI = 312,5 кГц 
....................     
....................    //ENABLE_INTERRUPTS(INTR_GLOBAL); 
....................   // ENABLE_INTERRUPTS(INT_TIMER1); 
....................     
....................    //setup_timer1(TMR_INTERNAL|TMR_DIV_BY_8, 1);  
....................    // 65536 отсчетов таймера -> 1 отсчет - 200 нс -> 10 отсчетов 2 мкс 
....................    // прерывание по таймеру каждые 2 мкс, переполнение один раз вызывает прерывание 
....................     
....................    TRISG=0x0000; // LCD_RS,LCD-RW,LCD_E 
0086E:  CLR     2E4
....................    UART2_RX_TRIS = 0; //Xport tx 
00870:  BCLR.B  2DE.4
....................    UART2_TX_TRIS = 1; //Xport rx 
00872:  BSET.B  2DE.5
....................    SCK2_TRIS=0; // SPI2 tris 
00874:  BCLR.B  2E4.6
....................    SDI2_TRIS=1; 
00876:  BSET.B  2E4.7
....................    SDO2_TRIS=0; 
00878:  BCLR.B  2E5.0
....................    SS2_TRIS=0; 
0087A:  BCLR.B  2C6.2
....................    ADC_RESET_TRIS = 0; 
0087C:  BCLR.B  2C6.3
....................    ADC_SYNC_TRIS = 0; 
0087E:  BCLR.B  2C6.4
....................        
....................    TRC13 = 0; 
00880:  BCLR.B  2CD.5
....................    TRC14 = 0; 
00882:  BCLR.B  2CD.6
....................     
....................    TRD1=0; 
00884:  BCLR.B  2D2.1
....................  
....................    LCDInit(); 
00886:  CALL    2FE
....................    LCDWelcome(); 
0088A:  CALL    3EE
....................     
....................    ADC_CS = 1; 
0088E:  BSET.B  2CA.2
....................    ADC_RESET = 0; //When using the RESET pin, take it low to force a reset. 
00890:  BCLR.B  2CA.3
....................    delay_us(50); 
00892:  REPEAT  #7CE
00894:  NOP     
....................    ADC_SYNC =1; 
00896:  BSET.B  2CA.4
....................    delay_us(50); 
00898:  REPEAT  #7CE
0089A:  NOP     
....................    ADC_SYNC = 0; //To use the SYNC/PDWN pin, take it low and then high 
0089C:  BCLR.B  2CA.4
....................     
....................    ADC_Init(STATUS,0x06,0x76,0x03,0x63); 
0089E:  CLR.B   81C
008A0:  MOV.B   #6,W0L
008A2:  MOV.B   W0L,81D
008A4:  MOV.B   #76,W0L
008A6:  MOV.B   W0L,81E
008A8:  MOV.B   #3,W0L
008AA:  MOV.B   W0L,81F
008AC:  MOV.B   #63,W0L
008AE:  MOV.B   W0L,820
008B0:  CALL    45A
....................    //Spi_write2(0xF0); 
....................    //delay_ms(30); 
....................  //WrReg(STATUS,0x06); 
....................  //WrReg(MUX,0x76); 
....................  //WrReg(ADCON,0x03); 
....................  //WrReg(DRATE,0b01100011);   
....................        //t18 
....................    //set_timer1(65526); 
....................    //ADC_Dout SDI2 - нога Din МК   
....................    //ADC_Din SDO2 - нога Dout МК 
....................     
.................... WHILE(1) { 
....................          
....................       
....................     lcdsetcursor(0x00); 
008B4:  CLR.B   81C
008B6:  CALL    3DA
....................     LCDputU32(ADC_RDataC(),8); 
008BA:  CALL    4E0
008BE:  MOV     W0,W5
008C0:  MOV     W1,W6
008C2:  MOV     W0,[W15++]
008C4:  MOV.B   #8,W0L
008C6:  MOV.B   W0L,826
008C8:  MOV     [--W15],W0
008CA:  MOV     W5,822
008CC:  MOV     W6,824
008CE:  CALL    608
....................      
....................     delay_ms(100); 
008D2:  MOV     #64,W0
008D4:  CALL    274
....................       
....................       
....................       
....................     /*  
....................     
....................      ADC_CS = 0;  
....................      delay_us(1); 
....................      //Spi_write2(0xFC); // SYNC 
....................      SPI_Write2(0x01); 
....................      delay_us(1); 
....................      ADC_CS = 1;      
....................      delay_ms(22); 
....................     // m1: 
....................     // RdStatus(); 
....................     // if(!adc_drdy) 
....................     // {  
....................      //Spi_write2(0); 
....................      ADC_CS = 0;  
....................      delay_us(1); 
....................      Spi_read2(0); 
....................      Spi_read2(0); 
....................      Spi_read2(0); 
....................      delay_us(1); 
....................      ADC_CS = 0;  
....................     // } 
....................      //else goto m1; 
....................      
....................  */ 
....................   
....................     
....................     
....................     
....................    } 
008D8:  GOTO    8B4
.................... } 
008DC:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0083   PR_PLL IESO
          H: FF00  
   Word  5L: 00C6   HS NOOSCIO
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 00E7   PUT128
          H: FF00  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: FF00  
