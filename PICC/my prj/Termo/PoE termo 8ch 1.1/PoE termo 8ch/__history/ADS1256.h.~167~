// изменена для версии PoE без дисплея
// 28.05.15

static U8 RdReg(U8 RegName)
{
   U8 RegValue = 0; 
   //1st Command Byte: 0001 rrrr where rrrr is the address of the first register to read.
   //2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to read – 1
   ADC_CS = 0;
   delay_us(1);
   Spi_write2(0x10+RegName); // 1st Command Byte,??????? ??????
   Spi_write2(0x00); // 1st Command Byte, ?????? ?????? ???? ????
   delay_us(8); // 50 CLK_IN PEDIODS
   RegValue = Spi_read2(0);
   delay_us(1);
   ADC_CS =1;
   delay_us(1);
   Return RegValue;  
}

static void WrReg(U8 RegName,CommandByte)
{
   ADC_CS = 0;
   ADC2_CS = 0;
   delay_us(5);
   Spi_write2(0x50+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written.
   delay_us(10);
   Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1.
   delay_us(10);
   Spi_write2(CommandByte);
   delay_us(10);
   ADC_CS = 1;
   ADC2_CS = 1;
 
   delay_us(20);
}

static void ADC_sps_set(U8 SPS){

   //ADC_StopRd();                                                              
   Sps_buf = SPS;
   WrReg(DRATE,SPS); 
   delay_us(20);
                 
        
}

static void ADC_set_PGA(u8 PGA_val){
  
  PGA = PGA_val;

/* PGA
000 = 1 (default)
001 = 2
010 = 4
011 = 8
100 = 16
101 = 32
110 = 64
111 = 64*/
/**/

   switch (PGA_val){
      case 1:
       WrReg(ADCON,0);
      break;
      
      case 2:
       WrReg(ADCON,1);
      break;
      
      case 4:
       WrReg(ADCON,2);
      break;
      
      case 8:
       WrReg(ADCON,3);
      break;
      
      case 16:
       WrReg(ADCON,4);
      break;
      
      case 32:
       WrReg(ADCON,5);
      break;
      
      case 64:
       WrReg(ADCON,6);
      break; 
   }
   delay_us(20);
}

static void ADC_SelfCal(){
                     
   ADC_CS = 0;
   ADC2_CS = 0;
   delay_us(1);
   
   Spi_write2(0xF0);
   delay_us(1);
   
   ADC_CS = 1;
   ADC2_CS = 1;
   
   While(ADC_DRDY | ADC2_DRDY) { }   // ждем готовности обоих АЦП
    
   /*
   Switch (Sps_buf) {     
    
      case 0xF0:   
       delay_us(220);        
        break;                      
      
      case 0xE0:
       delay_us(255); 
        break;
        
      case 0xD0:
       delay_us(315); 
        break;
        
      case 0xC0:
       delay_us(445); 
        break;
        
      case 0xB0:
       delay_us(685); 
        break;
        
      case 0xA1:
       delay_ms(1);
       delay_us(185);               
        break;      
        
      case 0x92:
       delay_ms(5);
        break;
        
      case 0x82:
       delay_ms(10);
       delay_us(200);
        break;
                   
      case 0x63:
       delay_ms(21); 
        break;
        
      case 0x43:
       delay_ms(41); 
        break;
        
      case 0x23:
       delay_ms(101); 
        break;         
            
      case 0x13:
       delay_ms(201); 
        break;                          
     }
     */
}

static void ADC_setCh(U8 Ch_Number){

  Spi_write2(0x50+MUX);    
  delay_us(10);
  Spi_write2(0);         
  delay_us(10);
  Spi_write2(Mx_ch_code[Ch_Number]);
  delay_us(20);  
}

static S32 ADC_vol_average(U8 NumSamples){
   
   S32 A,Sum = 0;               
   U8 i;
   
   for (i=0;i<NumSamples;i++){
       
       //A = Read_ADC_vol_in(uV);
       Sum = Sum + A;    
   }                                  
   return Sum/NumSamples;
}

static void ADC_init(){
   
  WrReg(STATUS,2);   // вкл. входной буфер
  delay_us(20);

   if(ADC_sps_var>7)  ADC_sps_var = 7;
   // установка sps
   switch (ADC_sps_var){                // передача величины скорости измерений АЦП 
    
      case 0: ADC_sps_set(0x13);  break; // 5   sps
      case 1: ADC_sps_set(0x23);  break; // 10   sps
      case 2: ADC_sps_set(0x43);  break; // 25   sps
      case 3: ADC_sps_set(0x63);  break; // 50   sps
      case 4: ADC_sps_set(0x82);  break; // 100  sps
      case 5: ADC_sps_set(0x91);  break; // 500  sps
      case 6: ADC_sps_set(0xA1);  break; // 1000 sps
      case 7: ADC_sps_set(0xC0);  break; // 3750 sps
      }
      
   ADC_set_PGA(8);    // Уст. PGA
   ADC_SelfCal();     // Автокалибровка обоих АЦП 
}

static float power(float t, U8 k) // возведение t в степень k
{
  float res = 1.0;
  while (k) 
      {
        if (k & 1) 
           res *= t;
        t *= t;
        k >>= 1;
      }
  return res;
}

static void ADC_select(U8 command)
  {
   switch(command)
   {
         case 0: ADC_CS = 1; ADC2_CS = 1; break;
         case 1: ADC_CS = 0; ADC2_CS = 1; break;
         case 2: ADC_CS = 1; ADC2_CS = 0; break;
   }
  }
  
static S32 ADC_read()
  {
  
  S32 ADC_RByte_Sum;
  float Vin;
  
  //Spi_write2(0x03);        // команда чтения RdataC
  Spi_write2(0x01);        // команда чтения Rdata
  delay_us(20);
  ADC_Rbyte1 = Spi_read2(0);   // чтение
  ADC_Rbyte2 = Spi_read2(0);
  ADC_Rbyte3 = Spi_read2(0);
  
  ADC_RByte_Sum = ((S32)ADC_Rbyte1<<24) | ((S32)ADC_Rbyte2<<16) | ((S32)ADC_Rbyte3<<8);
  ADC_RByte_Sum = ADC_RByte_Sum/256;
  
  Vin = ((ADC_RByte_Sum*5)/(8388608.0*PGA));
  
  return Vin*uV;
  
  }
