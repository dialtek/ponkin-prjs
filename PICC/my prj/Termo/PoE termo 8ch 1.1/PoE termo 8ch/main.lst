CCS PCD C Compiler, Version 5.015, 5967               11-дек-15 15:51

               Filename:   E:\work\Projects\PICC\my prj\PoE termo 8ch 1.1\PoE termo 8ch\main.lst

               ROM used:   6146 bytes (7%)
                           Largest free fragment is 59390
               RAM used:   4358 (53%) at main() level
                           4452 (54%) worst case
               Stack size: 128

*
00000:  GOTO    171C
*
0001A:  DATA    4C,03,00
*
00050:  DATA    74,03,00
.................... #include <main.h> 
.................... #include <24HJ128GP506A.h> 
.................... //////////// Standard Header file for the PIC24HJ128GP506A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24HJ128GP506A 
*
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    73,74,00
0020E:  DATA    6F,70,00
00210:  DATA    70,65,00
00212:  DATA    64,0A,00
00214:  DATA    0D,00,00
00216:  CLR     32
00218:  MOV     #222,W3
0021A:  ADD     W3,W0,W0
0021C:  TBLRDL.B[W0],W0L
0021E:  CLR.B   1
00220:  RETURN  
00222:  DATA    65,72,00
00224:  DATA    72,20,00
00226:  DATA    0D,0A,00
00228:  DATA    00,00,00
0022A:  CLR     32
0022C:  MOV     #236,W3
0022E:  ADD     W3,W0,W0
00230:  TBLRDL.B[W0],W0L
00232:  CLR.B   1
00234:  RETURN  
00236:  DATA    50,47,00
00238:  DATA    41,20,00
0023A:  DATA    65,72,00
0023C:  DATA    72,20,00
0023E:  DATA    0D,0A,00
00240:  DATA    00,00,00
00242:  CLR     32
00244:  MOV     #24E,W3
00246:  ADD     W3,W0,W0
00248:  TBLRDL.B[W0],W0L
0024A:  CLR.B   1
0024C:  RETURN  
0024E:  DATA    50,47,00
00250:  DATA    41,3D,00
00252:  DATA    25,75,00
00254:  DATA    20,0D,00
00256:  DATA    0A,00,00
00258:  CLR     32
0025A:  MOV     #264,W3
0025C:  ADD     W3,W0,W0
0025E:  TBLRDL.B[W0],W0L
00260:  CLR.B   1
00262:  RETURN  
00264:  DATA    50,47,00
00266:  DATA    41,20,00
00268:  DATA    6F,75,00
0026A:  DATA    74,20,00
0026C:  DATA    6F,66,00
0026E:  DATA    20,72,00
00270:  DATA    61,6E,00
00272:  DATA    67,65,00
00274:  DATA    0D,0A,00
00276:  DATA    00,00,00
00278:  CLR     32
0027A:  MOV     #284,W3
0027C:  ADD     W3,W0,W0
0027E:  TBLRDL.B[W0],W0L
00280:  CLR.B   1
00282:  RETURN  
00284:  DATA    53,50,00
00286:  DATA    53,20,00
00288:  DATA    65,72,00
0028A:  DATA    72,20,00
0028C:  DATA    0D,0A,00
0028E:  DATA    00,00,00
00290:  CLR     32
00292:  MOV     #29C,W3
00294:  ADD     W3,W0,W0
00296:  TBLRDL.B[W0],W0L
00298:  CLR.B   1
0029A:  RETURN  
0029C:  DATA    53,50,00
0029E:  DATA    53,3D,00
002A0:  DATA    25,75,00
002A2:  DATA    20,0D,00
002A4:  DATA    0A,00,00
002A6:  CLR     32
002A8:  MOV     #2B2,W3
002AA:  ADD     W3,W0,W0
002AC:  TBLRDL.B[W0],W0L
002AE:  CLR.B   1
002B0:  RETURN  
002B2:  DATA    53,50,00
002B4:  DATA    53,20,00
002B6:  DATA    6F,75,00
002B8:  DATA    74,20,00
002BA:  DATA    6F,66,00
002BC:  DATA    20,72,00
002BE:  DATA    61,6E,00
002C0:  DATA    67,65,00
002C2:  DATA    0D,0A,00
002C4:  DATA    00,00,00
002C6:  CLR     32
002C8:  MOV     #2D2,W3
002CA:  ADD     W3,W0,W0
002CC:  TBLRDL.B[W0],W0L
002CE:  CLR.B   1
002D0:  RETURN  
002D2:  DATA    65,72,00
002D4:  DATA    72,20,00
002D6:  DATA    70,31,00
002D8:  DATA    20,0D,00
002DA:  DATA    0A,00,00
002DC:  CLR     32
002DE:  MOV     #2E8,W3
002E0:  ADD     W3,W0,W0
002E2:  TBLRDL.B[W0],W0L
002E4:  CLR.B   1
002E6:  RETURN  
002E8:  DATA    65,72,00
002EA:  DATA    72,20,00
002EC:  DATA    70,32,00
002EE:  DATA    20,0D,00
002F0:  DATA    0A,00,00
002F2:  CLR     32
002F4:  MOV     #2FE,W3
002F6:  ADD     W3,W0,W0
002F8:  TBLRDL.B[W0],W0L
002FA:  CLR.B   1
002FC:  RETURN  
002FE:  DATA    65,72,00
00300:  DATA    72,20,00
00302:  DATA    70,33,00
00304:  DATA    20,0D,00
00306:  DATA    0A,00,00
00308:  CLR     32
0030A:  MOV     #314,W3
0030C:  ADD     W3,W0,W0
0030E:  TBLRDL.B[W0],W0L
00310:  CLR.B   1
00312:  RETURN  
00314:  DATA    61,76,00
00316:  DATA    65,72,00
00318:  DATA    20,62,00
0031A:  DATA    75,66,00
0031C:  DATA    20,73,00
0031E:  DATA    69,7A,00
00320:  DATA    65,3D,00
00322:  DATA    25,75,00
00324:  DATA    20,0D,00
00326:  DATA    0A,00,00
00328:  CLR     32
0032A:  MOV     #334,W3
0032C:  ADD     W3,W0,W0
0032E:  TBLRDL.B[W0],W0L
00330:  CLR.B   1
00332:  RETURN  
00334:  DATA    61,76,00
00336:  DATA    65,72,00
00338:  DATA    20,62,00
0033A:  DATA    75,66,00
0033C:  DATA    20,6F,00
0033E:  DATA    75,74,00
00340:  DATA    20,6F,00
00342:  DATA    66,20,00
00344:  DATA    72,61,00
00346:  DATA    6E,67,00
00348:  DATA    65,0D,00
0034A:  DATA    0A,00,00
*
00744:  MOV     W5,[W15++]
00746:  MOV     #C,W5
00748:  REPEAT  #3
0074A:  MOV     [W5++],[W15++]
0074C:  MOV     #0,W9
0074E:  BTSC.B  43.0
00750:  MOV     #1,W9
00752:  MOV     W9,[W15++]
00754:  XOR     W1,W3,W9
00756:  BTSS    W1.F
00758:  BRA     760
0075A:  COM     W1,W1
0075C:  NEG     W0,W0
0075E:  ADDC    W1,#0,W1
00760:  BTSS    W3.F
00762:  BRA     76A
00764:  COM     W3,W3
00766:  NEG     W2,W2
00768:  ADDC    W3,#0,W3
0076A:  XOR     W2,W3,W4
0076C:  BRA     Z,798
0076E:  CLR     W4
00770:  CLR     W5
00772:  CLR     W6
00774:  CLR     W7
00776:  MOV     #20,W8
00778:  BCLR.B  42.0
0077A:  RLC     W0,W0
0077C:  RLC     W1,W1
0077E:  RLC     W4,W4
00780:  RLC     W5,W5
00782:  CP      W5,W3
00784:  BRA     NZ,788
00786:  CPB     W4,W2
00788:  BRA     NC,790
0078A:  SUB     W4,W2,W4
0078C:  SUBB    W5,W3,W5
0078E:  BSET.B  42.0
00790:  RLC     W6,W6
00792:  RLC     W7,W7
00794:  DEC     W8,W8
00796:  BRA     NZ,778
00798:  BTSS    W9.F
0079A:  BRA     7AA
0079C:  NEG     W6,W0
0079E:  BRA     Z,7A2
007A0:  BRA     NZ,7A6
007A2:  NEG     W7,W1
007A4:  BRA     7B0
007A6:  COM     W7,W1
007A8:  BRA     7B0
007AA:  MOV     W7,W1
007AC:  MOV     W6,W0
007AE:  BRA     7B0
007B0:  MOV     [--W15],W9
007B2:  CP0     W9
007B4:  BRA     Z,7B8
007B6:  MOV.D   W4,W0
007B8:  MOV     #12,W5
007BA:  REPEAT  #3
007BC:  MOV     [--W15],[W5--]
007BE:  MOV     [--W15],W5
007C0:  RETURN  
007C2:  MOV     W5,[W15++]
007C4:  MOV     #C,W5
007C6:  REPEAT  #3
007C8:  MOV     [W5++],[W15++]
007CA:  MUL.UU  W0,W2,W4
007CC:  BTSS    W3.F
007CE:  BRA     7D4
007D0:  MUL.SS  W0,W3,W6
007D2:  BRA     7D6
007D4:  MUL.UU  W0,W3,W6
007D6:  BCLR.B  42.0
007D8:  ADD     W6,W5,W5
007DA:  ADDC    W7,#0,W8
007DC:  BTSS    W1.F
007DE:  BRA     7E4
007E0:  MUL.SS  W1,W2,W6
007E2:  BRA     7E6
007E4:  MUL.UU  W1,W2,W6
007E6:  ADDC    W6,W5,W5
007E8:  ADDC    W7,W8,W8
007EA:  ADDC    #0,W9
007EC:  MUL.SS  W1,W3,W6
007EE:  ADDC    W6,W8,W8
007F0:  ADDC    W9,W7,W7
007F2:  MOV     W7,W3
007F4:  MOV     W8,W2
007F6:  MOV     W5,W1
007F8:  MOV     W4,W0
007FA:  MOV     #12,W5
007FC:  REPEAT  #3
007FE:  MOV     [--W15],[W5--]
00800:  MOV     [--W15],W5
00802:  RETURN  
00804:  MOV     W5,[W15++]
00806:  MOV     #C,W5
00808:  REPEAT  #3
0080A:  MOV     [W5++],[W15++]
0080C:  MOV     W0,W4
0080E:  MOV     W1,W5
00810:  MOV     W2,W6
00812:  MOV     W3,W7
00814:  CLR     W0
00816:  CLR     W1
00818:  CLR     W2
0081A:  CLR     W3
0081C:  BCLR    W8.0
0081E:  BTSS    W7.F
00820:  BRA     82C
00822:  BSET    W8.0
00824:  NEG     W4,W4
00826:  COM     W5,W5
00828:  COM     W6,W6
0082A:  COM     W7,W7
0082C:  IOR      W4,  W5,W9
0082E:  BRA     NZ,834
00830:  IOR      W6,  W7,W9
00832:  BRA     Z,85E
00834:  MOV     #473,W9
00836:  BTSC    W3.4
00838:  BRA     850
0083A:  BCLR.B  42.0
0083C:  RLC     W4,W4
0083E:  RLC     W5,W5
00840:  RLC     W6,W6
00842:  RLC     W7,W7
00844:  RLC     W0,W0
00846:  RLC     W1,W1
00848:  RLC     W2,W2
0084A:  RLC     W3,W3
0084C:  DEC     W9,W9
0084E:  BRA     NZ,836
00850:  SL      W9,#4,W9
00852:  BCLR.B  42.0
00854:  BCLR    W9.F
00856:  BCLR    W3.4
00858:  XOR     W9,W3,W3
0085A:  BTSC    W8.0
0085C:  BSET    W3.F
0085E:  MOV     #12,W5
00860:  REPEAT  #3
00862:  MOV     [--W15],[W5--]
00864:  MOV     [--W15],W5
00866:  RETURN  
00868:  MOV     W8,[W15++]
0086A:  MOV     #12,W8
0086C:  REPEAT  #4
0086E:  MOV     [W8++],[W15++]
00870:  CLR     W11
00872:  MUL.UU  W12,#0,W12
00874:  MOV     W3,W8
00876:  MOV     W7,W9
00878:  MOV     #7FF,W10
0087A:  BCLR.B  42.0
0087C:  BCLR.B  42.1
0087E:  ASR     W8,#4,W8
00880:  AND     W10,W8,W8
00882:  CP0     W8
00884:  BRA     Z,968
00886:  BCLR.B  42.0
00888:  BCLR.B  42.1
0088A:  ASR     W9,#4,W9
0088C:  AND     W10,W9,W9
0088E:  CP0     W9
00890:  BRA     Z,968
00892:  ADD     W9,W8,W8
00894:  BTSC    W9.B
00896:  BRA     8A0
00898:  SUB     #3FF,W8
0089A:  BRA     Z,968
0089C:  BRA     NC,968
0089E:  BRA     8A6
008A0:  MOV     #401,W10
008A2:  ADD.B   W10L,W5L,W5L
008A4:  BRA     C,968
008A6:  XOR     W3,W7,W13
008A8:  BCLR.B  42.0
008AA:  BCLR.B  42.1
008AC:  AND     #F,W3
008AE:  BSET    W3.4
008B0:  AND     #F,W7
008B2:  BSET    W7.4
008B4:  MOV     W8,[W15++]
008B6:  MUL.UU  W4,W1,W8
008B8:  MUL.UU  W5,W0,W10
008BA:  ADD     W8,W10,W10
008BC:  ADDC    W9,W11,W11
008BE:  ADDC    #0,W12
008C0:  MUL.UU  W4,W2,W8
008C2:  ADD     W8,W11,W11
008C4:  ADDC    W9,W12,W12
008C6:  MUL.UU  W5,W1,W8
008C8:  CLR     W10
008CA:  ADD     W8,W11,W11
008CC:  ADDC    W9,W12,W12
008CE:  ADDC    #0,W10
008D0:  MUL.UU  W6,W0,W8
008D2:  ADD     W8,W11,W11
008D4:  ADDC    W9,W12,W12
008D6:  ADDC    #0,W10
008D8:  CLR     W11
008DA:  MUL.UU  W4,W3,W8
008DC:  ADD     W8,W12,W12
008DE:  ADDC    W9,W10,W10
008E0:  ADDC    #0,W11
008E2:  MUL.UU  W5,W2,W8
008E4:  ADD     W8,W12,W12
008E6:  ADDC    W9,W10,W10
008E8:  ADDC    #0,W11
008EA:  MUL.UU  W6,W1,W8
008EC:  ADD     W8,W12,W12
008EE:  ADDC    W9,W10,W10
008F0:  ADDC    #0,W11
008F2:  MUL.UU  W7,W0,W8
008F4:  ADD     W8,W12,W12
008F6:  ADDC    W9,W10,W10
008F8:  ADDC    #0,W11
008FA:  MOV     W12,W0
008FC:  CLR     W12
008FE:  MUL.UU  W5,W3,W8
00900:  ADD     W8,W10,W10
00902:  ADDC    W9,W11,W11
00904:  ADDC    #0,W12
00906:  MUL.UU  W6,W2,W8
00908:  ADD     W8,W10,W10
0090A:  ADDC    W9,W11,W11
0090C:  ADDC    #0,W12
0090E:  MUL.UU  W6,W3,W8
00910:  ADD     W8,W11,W11
00912:  ADDC    W9,W12,W12
00914:  MUL.UU  W7,W1,W8
00916:  ADD     W8,W10,W10
00918:  ADDC    W9,W11,W11
0091A:  ADDC    #0,W12
0091C:  MUL.UU  W7,W2,W8
0091E:  ADD     W8,W11,W11
00920:  ADDC    W9,W12,W12
00922:  MUL.UU  W7,W3,W8
00924:  ADD     W8,W12,W12
00926:  MOV     W10,W1
00928:  MOV     W11,W2
0092A:  MOV     W12,W3
0092C:  MOV     #5,W4
0092E:  BCLR.B  42.0
00930:  RRC     W3,W3
00932:  RRC     W2,W2
00934:  RRC     W1,W1
00936:  RRC     W0,W0
00938:  DEC     W4,W4
0093A:  BRA     NZ,92E
0093C:  MOV     [--W15],W8
0093E:  INC     W8,W8
00940:  IOR      W0,  W1,W6
00942:  BRA     Z,946
00944:  BRA     94A
00946:  IOR      W2,  W3,W6
00948:  BRA     Z,95A
0094A:  BTSC    W3.4
0094C:  BRA     95A
0094E:  BCLR.B  42.0
00950:  RLC     W0,W0
00952:  RLC     W1,W1
00954:  RLC     W2,W2
00956:  RLC     W3,W3
00958:  DEC     W8,W8
0095A:  SL      W8,#4,W8
0095C:  BCLR    W3.F
0095E:  BTSC    W13.F
00960:  BSET    W3.F
00962:  BCLR    W3.4
00964:  XOR     W8,W3,W3
00966:  BRA     96E
00968:  MUL.UU  W0,#0,W0
0096A:  MUL.UU  W0,#0,W2
0096C:  BRA     96E
0096E:  MOV     #1A,W8
00970:  REPEAT  #4
00972:  MOV     [--W15],[W8--]
00974:  MOV     [--W15],W8
00976:  RETURN  
00978:  MOV     W5,[W15++]
0097A:  MOV     #C,W5
0097C:  REPEAT  #3
0097E:  MOV     [W5++],[W15++]
00980:  MOV     W0,W4
00982:  MOV     W1,W5
00984:  MOV     W2,W6
00986:  MOV     W3,W7
00988:  CLR     W0
0098A:  CLR     W1
0098C:  CLR     W2
0098E:  CLR     W3
00990:  BCLR    W8.0
00992:  BTSS    W7.F
00994:  BRA     9A0
00996:  BSET    W8.0
00998:  NEG     W4,W4
0099A:  COM     W5,W5
0099C:  COM     W6,W6
0099E:  COM     W7,W7
009A0:  IOR      W4,  W5,W9
009A2:  BRA     NZ,9A8
009A4:  IOR      W6,  W7,W9
009A6:  BRA     Z,9D2
009A8:  MOV     #473,W9
009AA:  BTSC    W3.4
009AC:  BRA     9C4
009AE:  BCLR.B  42.0
009B0:  RLC     W4,W4
009B2:  RLC     W5,W5
009B4:  RLC     W6,W6
009B6:  RLC     W7,W7
009B8:  RLC     W0,W0
009BA:  RLC     W1,W1
009BC:  RLC     W2,W2
009BE:  RLC     W3,W3
009C0:  DEC     W9,W9
009C2:  BRA     NZ,9AA
009C4:  SL      W9,#4,W9
009C6:  BCLR.B  42.0
009C8:  BCLR    W9.F
009CA:  BCLR    W3.4
009CC:  XOR     W9,W3,W3
009CE:  BTSC    W8.0
009D0:  BSET    W3.F
009D2:  MOV     #12,W5
009D4:  REPEAT  #3
009D6:  MOV     [--W15],[W5--]
009D8:  MOV     [--W15],W5
009DA:  RETURN  
009DC:  MOV     W8,[W15++]
009DE:  MOV     #12,W8
009E0:  REPEAT  #4
009E2:  MOV     [W8++],[W15++]
009E4:  XOR     W3,W7,W13
009E6:  MOV     W3,W8
009E8:  MOV     W7,W9
009EA:  MOV     #7FF,W10
009EC:  BCLR.B  42.0
009EE:  BCLR.B  42.1
009F0:  ASR     W8,#4,W8
009F2:  AND     W10,W8,W8
009F4:  CP0     W8
009F6:  BRA     Z,AD0
009F8:  BCLR.B  42.0
009FA:  BCLR.B  42.1
009FC:  ASR     W9,#4,W9
009FE:  AND     W10,W9,W9
00A00:  CP0     W9
00A02:  BRA     Z,AD0
00A04:  CLR     W10
00A06:  SUB     W8,W9,W12
00A08:  BRA     NC,A10
00A0A:  ADD     #3FF,W12
00A0C:  BRA     C,AD0
00A0E:  BRA     A18
00A10:  MOV     #401,W11
00A12:  SUB     W12,W11,W12
00A14:  BRA     NC,AD0
00A16:  BRA     Z,AD0
00A18:  CLR     W8
00A1A:  CLR     W9
00A1C:  CLR     W10
00A1E:  CLR     W11
00A20:  AND     #1F,W3
00A22:  BSET    W3.4
00A24:  AND     #1F,W7
00A26:  BSET    W7.4
00A28:  MOV     W12,[W15++]
00A2A:  MOV     #36,W12
00A2C:  SUB     W0,W4,W0
00A2E:  SUBB    W1,W5,W1
00A30:  SUBB    W2,W6,W2
00A32:  SUBB    W3,W7,W3
00A34:  BRA     N,A3A
00A36:  BRA     C,A44
00A38:  BRA     NZ,A46
00A3A:  ADD     W0,W4,W0
00A3C:  ADDC    W1,W5,W1
00A3E:  ADDC    W2,W6,W2
00A40:  ADDC    W3,W7,W3
00A42:  BRA     A46
00A44:  BSET    W8.0
00A46:  DEC     W12,W12
00A48:  BRA     Z,A60
00A4A:  BCLR.B  42.0
00A4C:  RLC     W0,W0
00A4E:  RLC     W1,W1
00A50:  RLC     W2,W2
00A52:  RLC     W3,W3
00A54:  BCLR.B  42.0
00A56:  RLC     W8,W8
00A58:  RLC     W9,W9
00A5A:  RLC     W10,W10
00A5C:  RLC     W11,W11
00A5E:  BRA     A2C
00A60:  MOV     [--W15],W12
00A62:  BTSC    W11.5
00A64:  BRA     A68
00A66:  BRA     A74
00A68:  BCLR.B  42.0
00A6A:  RRC     W11,W11
00A6C:  RRC     W10,W10
00A6E:  RRC     W9,W9
00A70:  RRC     W8,W8
00A72:  BRA     A7A
00A74:  DEC     W12,W12
00A76:  BCLR.B  42.0
00A78:  BRA     Z,AD0
00A7A:  BTSC.B  42.0
00A7C:  BRA     A90
00A7E:  RLC     W0,W0
00A80:  RLC     W1,W1
00A82:  RLC     W2,W2
00A84:  RLC     W3,W3
00A86:  SUB     W0,W4,W4
00A88:  SUBB    W1,W5,W5
00A8A:  SUBB    W2,W6,W6
00A8C:  SUBB    W3,W7,W7
00A8E:  BRA     NC,ABA
00A90:  INC     W8,W8
00A92:  BRA     NZ,ABA
00A94:  INC     W9,W9
00A96:  BRA     NZ,ABA
00A98:  INC     W10,W10
00A9A:  BRA     NZ,ABA
00A9C:  INC     W11,W11
00A9E:  BRA     NZ,ABA
00AA0:  INC     W12,W12
00AA2:  BRA     Z,AD0
00AA4:  BRA     ABA
00AA6:  DEC     W12,W12
00AA8:  BRA     Z,AD0
00AAA:  BTSC    W11.4
00AAC:  BRA     ABA
00AAE:  BCLR.B  42.0
00AB0:  RLC     W8,W8
00AB2:  RLC     W9,W9
00AB4:  RLC     W10,W10
00AB6:  RLC     W11,W11
00AB8:  BRA     AAA
00ABA:  SL      W12,#4,W12
00ABC:  BCLR.B  42.0
00ABE:  BCLR    W12.F
00AC0:  BTSC    W13.F
00AC2:  BSET    W12.F
00AC4:  BCLR    W11.4
00AC6:  XOR     W12,W11,W3
00AC8:  MOV     W10,W2
00ACA:  MOV     W9,W1
00ACC:  MOV     W8,W0
00ACE:  BRA     ADA
00AD0:  MOV     #0,W0
00AD2:  MOV     #0,W1
00AD4:  MOV     #0,W2
00AD6:  MOV     #0,W3
00AD8:  BRA     ADA
00ADA:  MOV     #1A,W8
00ADC:  REPEAT  #4
00ADE:  MOV     [--W15],[W8--]
00AE0:  MOV     [--W15],W8
00AE2:  RETURN  
00AE4:  MOV     W5,[W15++]
00AE6:  MOV     W6,[W15++]
00AE8:  MOV     W3,W4
00AEA:  MOV     W3,W6
00AEC:  BCLR.B  42.0
00AEE:  ASR     W4,#4,W4
00AF0:  MOV     #7FF,W5
00AF2:  AND     W5,W4,W4
00AF4:  BRA     NZ,AFC
00AF6:  MUL.UU  W0,#0,W0
00AF8:  CLR     W2
00AFA:  BRA     B22
00AFC:  SUB     #380,W4
00AFE:  AND     #F,W3
00B00:  MOV     #3,W7
00B02:  BCLR.B  42.0
00B04:  RLC     W0,W0
00B06:  RLC     W1,W1
00B08:  RLC     W2,W2
00B0A:  RLC     W3,W3
00B0C:  DEC     W7,W7
00B0E:  BRA     NZ,B02
00B10:  MOV     W1,W0
00B12:  MOV     W2,W1
00B14:  BCLR    W3.7
00B16:  SWAP    W4
00B18:  BCLR.B  42.0
00B1A:  RRC     W4,W4
00B1C:  BTSC    W6.F
00B1E:  BSET    W4.F
00B20:  XOR     W4,W3,W2
00B22:  MOV     [--W15],W6
00B24:  MOV     [--W15],W5
00B26:  RETURN  
00B28:  MOV     W5,[W15++]
00B2A:  MOV     #C,W5
00B2C:  REPEAT  #4
00B2E:  MOV     [W5++],[W15++]
00B30:  MOV     W0,W4
00B32:  MOV     W1,W5
00B34:  MOV     W3,W7
00B36:  MOV     W2,W6
00B38:  BCLR.B  42.0
00B3A:  BCLR.B  42.1
00B3C:  RLC     W1,W1
00B3E:  SWAP    W1
00B40:  AND     #FF,W1
00B42:  CP0     W1
00B44:  BRA     Z,BDC
00B46:  BCLR.B  42.0
00B48:  BCLR.B  42.1
00B4A:  RLC     W3,W3
00B4C:  SWAP    W3
00B4E:  AND     #FF,W3
00B50:  CP0     W3
00B52:  BRA     Z,BDC
00B54:  ZE      W0,W0
00B56:  ADD.B   W3L,W1L,W0L
00B58:  BRA     C,B62
00B5A:  SUB     #7F,W0
00B5C:  BRA     Z,BDC
00B5E:  BRA     NC,BDC
00B60:  BRA     B66
00B62:  ADD.B   #81,W0L
00B64:  BRA     C,BDC
00B66:  XOR     W5,W7,W10
00B68:  BCLR.B  42.0
00B6A:  BCLR.B  42.1
00B6C:  AND     #FF,W5
00B6E:  BSET    W5.7
00B70:  BCLR.B  42.0
00B72:  AND     #FF,W7
00B74:  BSET    W7.7
00B76:  MUL.UU  W4,W6,W2
00B78:  MUL.UU  W5,W6,W8
00B7A:  ADDC    W8,W3,W3
00B7C:  MOV     W9,W1
00B7E:  BTSC.B  42.0
00B80:  INC     W1,W1
00B82:  BCLR.B  42.0
00B84:  MUL.UU  W7,W4,W8
00B86:  ADDC    W8,W3,W3
00B88:  ADDC    W9,W1,W1
00B8A:  MUL.UU  W5,W7,W8
00B8C:  ADDC    W8,W1,W1
00B8E:  INC     W0,W0
00B90:  CP0     W1
00B92:  BTSC.B  42.1
00B94:  BRA     B98
00B96:  BRA     B9E
00B98:  CP0     W3
00B9A:  BTSC.B  42.1
00B9C:  BRA     BA8
00B9E:  BTSC    W1.F
00BA0:  BRA     BA8
00BA2:  RLC     W3,W3
00BA4:  RLC     W1,W1
00BA6:  DEC     W0,W0
00BA8:  MOV     W1,W2
00BAA:  BCLR.B  42.0
00BAC:  BTSS    W3.7
00BAE:  BRA     BC2
00BB0:  MOV     #FF00,W7
00BB2:  AND     W3,W7,W3
00BB4:  ADD     #100,W3
00BB6:  ADDC    W2,#0,W2
00BB8:  CP0     W2
00BBA:  BRA     NZ,BC2
00BBC:  CP0     W3
00BBE:  BRA     NZ,BC2
00BC0:  INC     W0,W0
00BC2:  SWAP    W0
00BC4:  BCLR.B  42.0
00BC6:  BCLR.B  42.1
00BC8:  RRC     W0,W1
00BCA:  BTSC    W10.F
00BCC:  BSET    W1.F
00BCE:  BCLR    W2.F
00BD0:  SWAP    W2
00BD2:  XOR.B   W2L,W1L,W1L
00BD4:  SWAP    W3
00BD6:  MOV.B   W3L,W2L
00BD8:  MOV     W2,W0
00BDA:  BRA     BE2
00BDC:  MOV     #0,W0
00BDE:  MOV     #0,W1
00BE0:  BRA     BE2
00BE2:  MOV     #14,W5
00BE4:  REPEAT  #4
00BE6:  MOV     [--W15],[W5--]
00BE8:  MOV     [--W15],W5
00BEA:  RETURN  
00BEC:  MOV     W5,[W15++]
00BEE:  MOV     W1,W5
00BF0:  MOV     W0,W2
00BF2:  MOV     #B6,W4
00BF4:  RLC     W1,W1
00BF6:  SWAP    W1
00BF8:  AND     #FF,W1
00BFA:  SUB.B   W4L,W1L,W4L
00BFC:  MOV.B   W5L,W3L
00BFE:  BSET    W3.7
00C00:  AND     #FF,W3
00C02:  CLR     W0
00C04:  CLR     W1
00C06:  CP      W4,#1F
00C08:  BRA     N,C28
00C0A:  BCLR.B  42.0
00C0C:  RRC     W3,W3
00C0E:  RRC     W2,W2
00C10:  RRC     W1,W1
00C12:  RRC     W0,W0
00C14:  DEC     W4,W4
00C16:  BRA     NZ,C0A
00C18:  BTSS    W5.F
00C1A:  BRA     C28
00C1C:  NEG     W0,W0
00C1E:  BRA     Z,C24
00C20:  COM     W1,W1
00C22:  BRA     C28
00C24:  NEG     W1,W1
00C26:  BRA     C28
00C28:  MOV     [--W15],W5
00C2A:  RETURN  
*
00E82:  MOV     W6,[W15++]
00E84:  MOV     W7,[W15++]
00E86:  MOV     W8,[W15++]
00E88:  MOV     W9,[W15++]
00E8A:  CLR     W4
00E8C:  CLR     W5
00E8E:  CLR     W6
00E90:  CLR     W7
00E92:  XOR     W2,W3,W8
00E94:  BRA     Z,EB8
00E96:  MOV     #20,W8
00E98:  BCLR.B  42.0
00E9A:  RLC     W0,W0
00E9C:  RLC     W1,W1
00E9E:  RLC     W4,W4
00EA0:  RLC     W5,W5
00EA2:  CP      W5,W3
00EA4:  BRA     NZ,EA8
00EA6:  CPB     W4,W2
00EA8:  BRA     NC,EB0
00EAA:  SUB     W4,W2,W4
00EAC:  SUBB    W5,W3,W5
00EAE:  BSET.B  42.0
00EB0:  RLC     W6,W6
00EB2:  RLC     W7,W7
00EB4:  DEC     W8,W8
00EB6:  BRA     NZ,E98
00EB8:  MOV     W7,W1
00EBA:  MOV     W6,W0
00EBC:  MOV     [--W15],W9
00EBE:  MOV     [--W15],W8
00EC0:  MOV     [--W15],W7
00EC2:  MOV     [--W15],W6
00EC4:  RETURN  
00EC6:  MOV     W5,[W15++]
00EC8:  MOV     #C,W5
00ECA:  REPEAT  #7
00ECC:  MOV     [W5++],[W15++]
00ECE:  BTSS    W1.F
00ED0:  BRA     EE0
00ED2:  NEG     W0,W0
00ED4:  BRA     Z,ED8
00ED6:  BRA     NZ,EDC
00ED8:  NEG     W1,W1
00EDA:  BRA     EDE
00EDC:  COM     W1,W1
00EDE:  BSET    W4.8
00EE0:  CLR     W5
00EE2:  MOV     W0,W6
00EE4:  MOV     W1,W7
00EE6:  MOV     W4,W12
00EE8:  BCLR    W4.F
00EEA:  CP0.B   W4L
00EEC:  BRA     NZ,EF0
00EEE:  BRA     F20
00EF0:  SUB.B   W4L,#B,W5L
00EF2:  BRA     NC,F20
00EF4:  SUB.B   W4L,W5L,W4L
00EF6:  BTSS    W12.F
00EF8:  BRA     F10
00EFA:  BTSS    W4.8
00EFC:  BRA     F0C
00EFE:  MOV     #2D,W0
00F00:  BTSC.B  233.1
00F02:  BRA     F00
00F04:  MOV     W0,234
00F06:  BCLR    W4.8
00F08:  DEC     W5,W5
00F0A:  BRA     N,F20
00F0C:  MOV     #30,W0
00F0E:  BRA     F12
00F10:  MOV     #20,W0
00F12:  BTSC.B  233.1
00F14:  BRA     F12
00F16:  MOV     W0,234
00F18:  DEC     W5,W5
00F1A:  BRA     NN,F12
00F1C:  BTSC    W4.8
00F1E:  DEC.B   W4L,W4L
00F20:  MOV     #E,W8
00F22:  MOV     #0,W9
00F24:  LNK     #10
00F26:  MOV     W12,[W14+W8]
00F28:  DEC2    W8,W8
00F2A:  BRA     NN,F26
00F2C:  MOV     W4,W5
00F2E:  MOV     #A,W4
00F30:  BTSC    W5.8
00F32:  INC     W4,W4
00F34:  BSET    W5.E
00F36:  BTSC    W12.F
00F38:  BSET    W5.F
00F3A:  CP0.B   W5L
00F3C:  BRA     Z,F40
00F3E:  DEC.B   W5L,W5L
00F40:  MOV     W4,[W14]
00F42:  MOV     W5,[W14+#2]
00F44:  MOV     W6,W0
00F46:  MOV     W7,W1
00F48:  MOV     #CA00,W2
00F4A:  MOV     #3B9A,W3
00F4C:  MOV     #2710,W8
00F4E:  BCLR    W13.F
00F50:  BCLR.B  43.0
00F52:  CALL    E82
00F56:  BTG     W13.F
00F58:  BTSC    W13.F
00F5A:  BRA     F6A
00F5C:  MOV     W0,[W14+#8]
00F5E:  MOV     W1,[W14+#A]
00F60:  MOV     W0,W2
00F62:  MOV     W1,W3
00F64:  MOV     [W14+#4],W0
00F66:  MOV     [W14+#6],W1
00F68:  BRA     F50
00F6A:  MOV     W2,[W14+#8]
00F6C:  MOV     W3,[W14+#A]
00F6E:  MOV     W4,[W14+#4]
00F70:  MOV     W5,[W14+#6]
00F72:  MOV     [W14],W4
00F74:  MOV     [W14+#2],W5
00F76:  MOV     #30,W6
00F78:  CP0     W0
00F7A:  BRA     NZ,F9E
00F7C:  BTSS    W5.E
00F7E:  BRA     FA2
00F80:  DEC     W4,W4
00F82:  MOV     W4,[W14]
00F84:  CP0     W4
00F86:  BRA     Z,FA2
00F88:  CP.B    W4L,W5L
00F8A:  BRA     Z,F90
00F8C:  BTSC.B  42.0
00F8E:  BRA     FC0
00F90:  BTSS    W5.F
00F92:  BRA     F9A
00F94:  BTSS    W5.8
00F96:  BRA     FB8
00F98:  BRA     FA8
00F9A:  MOV     #20,W6
00F9C:  BRA     FB8
00F9E:  BCLR    W5.E
00FA0:  MOV     W5,[W14+#2]
00FA2:  MOV     [W14+#2],W5
00FA4:  BTSS    W5.8
00FA6:  BRA     FB8
00FA8:  BCLR    W5.8
00FAA:  MOV     W5,[W14+#2]
00FAC:  MOV     W0,W10
00FAE:  MOV     #2D,W0
00FB0:  BTSC.B  233.1
00FB2:  BRA     FB0
00FB4:  MOV     W0,234
00FB6:  MOV     W10,W0
00FB8:  ADD.B   W6L,W0L,W0L
00FBA:  BTSC.B  233.1
00FBC:  BRA     FBA
00FBE:  MOV     W0,234
00FC0:  MOV     [W14+#8],W0
00FC2:  MOV     [W14+#A],W1
00FC4:  MOV     #A,W2
00FC6:  CLR     W3
00FC8:  CP      W0,#1
00FCA:  BRA     Z,FCE
00FCC:  BRA     F50
00FCE:  ULNK    
00FD0:  MOV     #1A,W5
00FD2:  REPEAT  #7
00FD4:  MOV     [--W15],[W5--]
00FD6:  MOV     [--W15],W5
00FD8:  RETURN  
*
010A6:  MOV     W5,[W15++]
010A8:  MOV     #C,W5
010AA:  REPEAT  #3
010AC:  MOV     [W5++],[W15++]
010AE:  MOV     W0,W7
010B0:  MOV     W4,W9
010B2:  BCLR    W4.F
010B4:  CP0     W4
010B6:  BRA     NZ,10C4
010B8:  BTSC    W9.F
010BA:  BRA     10C0
010BC:  MOV     #0,W5
010BE:  BRA     10DE
010C0:  MOV     #0,W5
010C2:  BRA     10DE
010C4:  SUB.B   W4L,#6,W5L
010C6:  BRA     NC,10DC
010C8:  MOV     #30,W0
010CA:  BTSS    W9.F
010CC:  MOV     #20,W0
010CE:  BTSC.B  233.1
010D0:  BRA     10CE
010D2:  MOV     W0,234
010D4:  DEC     W5,W5
010D6:  BRA     NN,10CE
010D8:  MOV     #5,W5
010DA:  BRA     10DE
010DC:  MOV     W4,W5
010DE:  MOV     #6,W4
010E0:  BSET    W5.E
010E2:  BTSC    W9.F
010E4:  BSET    W5.F
010E6:  MOV     #2710,W8
010E8:  REPEAT  #11
010EA:  DIV.U   W7,W8
010EC:  CALL    1120
010F0:  MOV     W1,W7
010F2:  MOV     #3E8,W8
010F4:  REPEAT  #11
010F6:  DIV.U   W7,W8
010F8:  CALL    1120
010FC:  MOV     W1,W7
010FE:  MOV     #64,W8
01100:  REPEAT  #11
01102:  DIV.U   W7,W8
01104:  CALL    1120
01108:  MOV     W1,W7
0110A:  MOV     #A,W8
0110C:  REPEAT  #11
0110E:  DIV.U   W7,W8
01110:  CALL    1120
01114:  MOV     #30,W0
01116:  ADD.B   W1L,W0L,W0L
01118:  BTSC.B  233.1
0111A:  BRA     1118
0111C:  MOV     W0,234
0111E:  BRA     114E
01120:  MOV     #30,W6
01122:  CP0     W0
01124:  BRA     NZ,1142
01126:  BTSS    W5.E
01128:  BRA     1144
0112A:  DEC     W4,W4
0112C:  CP.B    W4L,W5L
0112E:  BRA     Z,1134
01130:  BTSC.B  42.0
01132:  RETURN  
01134:  CP0     W0
01136:  BRA     NZ,1142
01138:  BTSS    W5.E
0113A:  BRA     1144
0113C:  BTSS    W5.F
0113E:  MOV     #20,W6
01140:  BRA     1144
01142:  BCLR    W5.E
01144:  ADD.B   W6L,W0L,W0L
01146:  BTSC.B  233.1
01148:  BRA     1146
0114A:  MOV     W0,234
0114C:  RETURN  
0114E:  MOV     #12,W5
01150:  REPEAT  #3
01152:  MOV     [--W15],[W5--]
01154:  MOV     [--W15],W5
01156:  RETURN  
....................  
.................... #list 
....................  
....................  
....................  
.................... //#FUSES PROTECT_HIGH            //General Segment Code Protect High Security 
.................... #FUSES WRTB                      //Boot block write protected 
.................... #FUSES CKSFSM                    //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES WDT                       //no Watch Dog Timer 
.................... #FUSES WPOSTS14                  //Watch Dog Timer PreScalar 1:8192 
.................... #FUSES PR_PLL                    //Primary Oscillator with PLL 
.................... #FUSES HS                        //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOWRT                     //Program memory not write protected 
.................... #use delay(clock=80M) 
....................  
.................... #WORD PLLFBD=0x0746 // osc PLL div reg 
....................  
.................... #WORD CLKDIV=0x0744  // osc con reg 
.................... #BIT PLLPOST1=CLKDIV.7 
.................... #BIT PLLPOST0=CLKDIV.6 
.................... #BIT PLLPRE4=CLKDIV.4 
.................... #BIT PLLPRE3=CLKDIV.3 
.................... #BIT PLLPRE2=CLKDIV.2 
.................... #BIT PLLPRE1=CLKDIV.1 
.................... #BIT PLLPRE0=CLKDIV.0 
....................  
.................... #WORD LATA=0x02C4  
.................... #WORD LATB=0x02CA 
.................... #WORD LATD=0x02D6 
.................... #WORD LATF=0x02E2 
.................... #WORD LATG=0x02E8   
.................... #WORD LATC=0x02D0 
....................  
.................... #use spi(spi2, FORCE_HW) 
.................... #use standard_io(B)//(B_outputs=PIN_B1, PIN_B2) 
....................  
.................... #define STATUS 0x00     // ADC1256 Register map 
.................... #define MUX 0x01  
.................... #define ADCON 0x02 
.................... #define DRATE 0x03 
.................... #define IO 0x04 
.................... #define OFCO 0x05 
.................... #define OFC1 0x06 
.................... #define OFC2 0x07 
.................... #define FSCO 0x08 
.................... #define FSC1 0x09 
.................... #define FSC2 0x0A 
....................  
.................... #define uV 10000000  // для калибровки  
.................... //#define uV 100000 // по умолчанию 
.................... #define mV 1000 
....................  
.................... #WORD PORTB=0x02C8 
.................... #WORD TRISB=0x02C6 
.................... #BIT  TRB0=TRISB.0 
.................... #BIT  TRB1=TRISB.1 
.................... #BIT  CN1_TRIS=TRISB.5 
.................... #BIT  CN2_TRIS=TRISB.4 
.................... #BIT  CN4_TRIS=TRISB.3 
.................... #BIT  CN3_TRIS=TRISB.2 
.................... #BIT  CN1=PORTB.5 
.................... #BIT  CN4=PORTB.3 
.................... #BIT  CN2=PORTB.4 
.................... #BIT  CN3=PORTB.2 
.................... #BIT  XPORT_RST_n=TRISB.15 
.................... #BIT  Status_LED_TRIS=TRISB.13 
.................... #BIT  TRB14=TRISB.14 
.................... #BIT  XPORT_RST_TRIS=TRISB.15 
.................... #BIT  RB1=LATB.1 
.................... #BIT  RB0=LATB.0 
.................... #BIT  Status_LED=LATB.13 
....................  
.................... #WORD PORTC=0x02CE 
.................... #WORD TRISC=0x02CC 
.................... //#BIT RC13=LATC.13 
.................... //#BIT RC14=LATC.14 
.................... #BIT RC13=PORTC.13 
.................... #BIT RC14=PORTC.14 
.................... #BIT  TRC13=TRISC.13 
.................... #BIT  TRC14=TRISC.14 
.................... #BIT  TRC1=TRISC.1 
.................... #BIT  TRC2=TRISC.2 
.................... #BIT  TRC4=TRISC.4 
.................... //_______________________________________ 
.................... #WORD PORTD=0x02D4 
.................... #WORD TRISD=0x02D2 
.................... #WORD ODCD=0x06D2 
....................  
.................... #BIT  TRD4=TRISD.4 
.................... #BIT  TRD5=TRISD.5 
.................... #BIT  TRD6=TRISD.6 
.................... #BIT  TRD7=TRISD.7 
.................... #BIT  TRD8=TRISD.8 
....................  
.................... #BIT  RD4=LATD.4 
.................... #BIT  RD5=LATD.5 
.................... #BIT  RD6=LATD.6 
.................... #BIT  RD7=LATD.7 
.................... #BIT  RD8=LATD.8 
.................... //_________________________________________________ 
.................... #WORD PORTF=0x02E0 
.................... #WORD TRISF=0x02DE 
.................... #BIT  UART2_RX_TRIS=TRISF.4 
.................... #BIT  UART2_TX_TRIS=TRISF.5 
....................  
.................... #WORD PORTG=0x02E6 
.................... #WORD TRISG=0x02E4 
.................... #BIT RG0=LATG.0 
.................... #BIT RG1=LATG.1 
.................... #BIT LCD_RW=LATG.12 
.................... #BIT LCD_RS=LATG.13 
.................... #BIT LCD_E=LATG.14 
.................... #BIT RG15=LATG.15 
.................... #BIT SCK2=LATG.6 // SPI2 pins 
.................... #BIT SDI2=LATG.7 
.................... #BIT SDO2=LATG.8 
.................... //#BIT SS2=LATG.9 
.................... #BIT SCK2_TRIS=TRISG.6 // SPI2 tris 
.................... #BIT SDI2_TRIS=TRISG.7 
.................... #BIT SDO2_TRIS=TRISG.8 
.................... #BIT TRG0=TRISG.0 
.................... #BIT TRG1=TRISG.1 
.................... #BIT LCD_RW_TRIS=TRISG.12 
.................... #BIT LCD_RS_TRIS=TRISG.13 
.................... #BIT LCD_E_TRIS=TRISG.14 
....................  
.................... //#BIT SS2_TRIS=TRISG.9 
....................  
.................... #define ADC_Dout SDI2 //???? Din ?? 
.................... #define ADC_Din SDO2  //???? Dout ?? 
....................  
.................... #BIT  ADC_RESET_TRIS=TRISD.3 
.................... #BIT  ADC2_RESET_TRIS=TRISD.0 
.................... #BIT  ADC_RESET=LATD.3 
.................... #BIT  ADC2_RESET=LATD.0 
....................  
.................... #BIT  ADC_SYNC_TRIS=TRISD.2 
.................... #BIT  ADC2_SYNC_TRIS=TRISD.11 
.................... #BIT  ADC_SYNC=LATD.2 
.................... #BIT  ADC2_SYNC=LATD.11 
....................  
.................... #BIT  ADC_CS_TRIS =TRISG.9 
.................... #BIT  ADC2_CS_TRIS=TRISD.10 
.................... #BIT  ADC_CS = LATG.9 
.................... #BIT  ADC2_CS= LATD.10 
....................  
.................... #BIT  ADC_DRDY_TRIS = TRISD.1 
.................... #BIT  ADC2_DRDY_TRIS= TRISD.9 
.................... #BIT  ADC_DRDY = PORTD.1 
.................... #BIT  ADC2_DRDY= PORTD.9 
....................  
.................... #byte U2TXREG = 0x0234  
.................... #byte U2RXREG = 0x0236 // регистр принимаемых Uart2 данных   
.................... #Word U2STA = 0x0232 
.................... #WORD U2BRG=0x0238 
.................... #WORD U2MODE=0x0230 
....................  
.................... #define FCY      40000000 
.................... #define BAUDRATE 9600                 
.................... #define BRGVAL   ((FCY/BAUDRATE)/16)-1 
....................  
.................... #define CK_FLASH_END       (getenv("PROGRAM_MEMORY")-1)       
.................... #define CK_FLASH_PAGE_SIZE (getenv("FLASH_ERASE_SIZE")/2)  
.................... #define CK_NUM_PAGES (CK_FLASH_END/CK_FLASH_PAGE_SIZE)  
....................  
.................... #define CK_USER_PAGE (CK_FLASH_PAGE_SIZE*(CK_NUM_PAGES-1))  
....................  
.................... #org CK_USER_PAGE,CK_FLASH_END {}  
....................  
....................    typedef unsigned int16 U16; 
....................    typedef unsigned int8 U8; 
....................    typedef unsigned int32 U32; 
....................    typedef signed int32 S32; 
....................    typedef signed int16 S16; 
....................    typedef signed int8 S8; 
....................  
....................  
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #use rs232(UART2,xmit=PIN_F5,rcv=PIN_F4,baud=115200,BRGH1OK,ERRORS,parity=N,bits=8) 
....................   
....................     // коды каналов мультиплексора.. 
....................     U8 Mx_ch_code[9] = {0, 0x76, 0x54, 0x32, 0x10};//0x10 76 
....................  
....................     U8 PGA; 
....................     U8 PGA_val = 3; // PGA = 8 
....................     U8 Sps_buf=0; 
....................     //S16 ADCaddCoef = 1; 
....................     //float ADCmulCoef = 1; 
....................     
....................    U8 flash_wr_data [] = {0,0,0,0}; // заготовка массива для записи во флэш 
....................    U8 Aver_Wr = 0; 
....................    U8 Sps_Wr = 0; 
....................    U8 CRC_Wr = 0; 
....................    U8 ADC_select = 0; // флаг выбора АЦП: 1ый или 2ой 
....................  
....................    int1 meas_stop_fl = 0; 
....................    int1 reset_fl = 0;    // флаг сброса системы 
....................    int1 stop_fl = 0; 
....................     
....................    U8 NumAver = 1;       // размер усреднения 
....................    U8 ADC_sps_var = 1;   // переменная усреднения данных АЦП  
....................    U8 CRC1=0xFF,CRC2=0xFF, CRC_buf;   // константы EEPROM CRC 
....................    U8 flash_rd_data[4]; // заготовка массива для чтения из флэш 
....................  
....................    //Ma - Moving Average 
....................    S32 Ch_buf[8][128];  // буфер скользящего среднего для к1 
....................    S32 Ch_buf_sum;     // сумма буфера скользящего среднего для к1 
....................  
....................    U8 Ma_buf_index = 0; // индекс элемента скользящ. средн. 
....................    U8 Ma_buf_size = 16;  // РАЗМЕР БУФЕРА!!! 
....................     
....................    U8 RXd_buf[64]; // буфер для приема UART данных  
....................    U8 state; 
....................    U16 tmp=0; 
....................     
....................    static U8 wrptr=0,rdptr=0; 
....................    static U8 RxData[16];  
....................     
.................... #include <ADS1256.h> 
.................... // изменена для версии PoE без дисплея 
.................... // 28.05.15 
....................  
.................... //-------------------- работа с регистрами АЦП ------------------------------// 
....................  
.................... static U8 RdReg(U8 RegName) 
.................... { 
....................    U8 RegValue = 0;  
....................    //1st Command Byte: 0001 rrrr where rrrr is the address of the first register to read. 
....................    //2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to read – 1 
....................    ADC_CS = 0; 
....................    delay_us(1); 
....................    Spi_write2(0x10+RegName); // 1st Command Byte,??????? ?????? 
....................    Spi_write2(0x00); // 1st Command Byte, ?????? ?????? ???? ???? 
....................    delay_us(8); // 50 CLK_IN PEDIODS 
....................    RegValue = Spi_read2(0); 
....................    delay_us(1); 
....................    ADC_CS =1; 
....................    delay_us(1); 
....................    Return RegValue;   
.................... } 
....................  
.................... static void WrReg(U8 RegName,CommandByte) 
*
00458:  MOV     W5,[W15++]
.................... { 
....................    ADC_CS = 0; 
0045A:  BCLR.B  2E9.1
....................    ADC2_CS = 0; 
0045C:  BCLR.B  2D7.2
....................    delay_us(5); 
0045E:  REPEAT  #C6
00460:  NOP     
....................    Spi_write2(0x50+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written. 
00462:  MOV     188E,W4
00464:  CLR.B   9
00466:  MOV     #50,W3
00468:  ADD     W3,W4,W5
0046A:  BCLR.B  260.6
0046C:  BTSS.B  260.0
0046E:  BRA     474
00470:  MOV.B   268,W0L
00472:  BRA     46C
00474:  PUSH    268
00476:  MOV.B   W5L,[W15-#2]
00478:  POP     268
0047A:  BTSS.B  260.0
0047C:  BRA     47A
....................    delay_us(10); 
0047E:  REPEAT  #18E
00480:  NOP     
....................    Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1. 
00482:  BCLR.B  260.6
00484:  BTSS.B  260.0
00486:  BRA     48C
00488:  MOV.B   268,W0L
0048A:  BRA     484
0048C:  CLR.B   268
0048E:  BTSS.B  260.0
00490:  BRA     48E
....................    delay_us(10); 
00492:  REPEAT  #18E
00494:  NOP     
....................    Spi_write2(CommandByte); 
00496:  BCLR.B  260.6
00498:  BTSS.B  260.0
0049A:  BRA     4A0
0049C:  MOV.B   268,W0L
0049E:  BRA     498
004A0:  MOV.B   188F,W0L
004A2:  MOV.B   W0L,268
004A4:  BTSS.B  260.0
004A6:  BRA     4A4
....................    delay_us(10); 
004A8:  REPEAT  #18E
004AA:  NOP     
....................    ADC_CS = 1; 
004AC:  BSET.B  2E9.1
....................    ADC2_CS = 1; 
004AE:  BSET.B  2D7.2
....................   
....................    delay_us(20); 
004B0:  REPEAT  #31E
004B2:  NOP     
004B4:  MOV     [--W15],W5
004B6:  RETURN  
.................... } 
.................... //---------------------------------------------------------------------------// 
....................  
.................... //==================== настройка и нинициализация АЦП =======================// 
....................  
.................... static void ADC_sps_set(U8 SPS){ 
....................                                                            
....................    Sps_buf = SPS; 
004B8:  MOV.B   188C,W0L
004BA:  MOV.B   W0L,813
....................    WrReg(DRATE,SPS);  
004BC:  MOV.B   #3,W0L
004BE:  MOV.B   W0L,188E
004C0:  MOV.B   188C,W0L
004C2:  MOV.B   W0L,188F
004C4:  CALL    458
....................    delay_us(20); 
004C8:  REPEAT  #31E
004CA:  NOP     
004CC:  RETURN  
....................                   
....................          
.................... } 
....................  
.................... static void ADC_set_PGA(u8 PGA_val){ 
....................    
.................... /* PGA 
.................... 000 = 1 (default) 
.................... 001 = 2 
.................... 010 = 4 
.................... 011 = 8 
.................... 100 = 16 
.................... 101 = 32 
.................... 110 = 64 
.................... 111 = 64*/ 
.................... /**/ 
....................  
.................... // PGA присваевается для расчета  
....................  
....................    switch (PGA_val){ 
004CE:  MOV.B   188C,W0L
004D0:  CLR.B   1
004D2:  XOR     #0,W0
004D4:  BRA     Z,4F0
004D6:  XOR     #1,W0
004D8:  BRA     Z,502
004DA:  XOR     #3,W0
004DC:  BRA     Z,516
004DE:  XOR     #1,W0
004E0:  BRA     Z,52A
004E2:  XOR     #7,W0
004E4:  BRA     Z,53E
004E6:  XOR     #1,W0
004E8:  BRA     Z,552
004EA:  XOR     #3,W0
004EC:  BRA     Z,566
004EE:  BRA     57A
....................       case 0: 
....................        WrReg(ADCON,0); 
004F0:  MOV.B   #2,W0L
004F2:  MOV.B   W0L,188E
004F4:  CLR.B   188F
004F6:  CALL    458
....................        PGA = 1; 
004FA:  MOV.B   #1,W0L
004FC:  MOV.B   W0L,811
....................       break; 
004FE:  GOTO    57A
....................        
....................       case 1: 
....................        WrReg(ADCON,1); 
00502:  MOV.B   #2,W0L
00504:  MOV.B   W0L,188E
00506:  MOV.B   #1,W0L
00508:  MOV.B   W0L,188F
0050A:  CALL    458
....................        PGA = 2; 
0050E:  MOV.B   #2,W0L
00510:  MOV.B   W0L,811
....................       break; 
00512:  GOTO    57A
....................        
....................       case 2: 
....................        WrReg(ADCON,2); 
00516:  MOV.B   #2,W0L
00518:  MOV.B   W0L,188E
0051A:  MOV.B   #2,W0L
0051C:  MOV.B   W0L,188F
0051E:  CALL    458
....................        PGA = 4; 
00522:  MOV.B   #4,W0L
00524:  MOV.B   W0L,811
....................       break; 
00526:  GOTO    57A
....................        
....................       case 3: 
....................        WrReg(ADCON,3); 
0052A:  MOV.B   #2,W0L
0052C:  MOV.B   W0L,188E
0052E:  MOV.B   #3,W0L
00530:  MOV.B   W0L,188F
00532:  CALL    458
....................        PGA = 8; 
00536:  MOV.B   #8,W0L
00538:  MOV.B   W0L,811
....................       break; 
0053A:  GOTO    57A
....................        
....................       case 4: 
....................        WrReg(ADCON,4); 
0053E:  MOV.B   #2,W0L
00540:  MOV.B   W0L,188E
00542:  MOV.B   #4,W0L
00544:  MOV.B   W0L,188F
00546:  CALL    458
....................        PGA = 16; 
0054A:  MOV.B   #10,W0L
0054C:  MOV.B   W0L,811
....................       break; 
0054E:  GOTO    57A
....................        
....................       case 5: 
....................        WrReg(ADCON,5); 
00552:  MOV.B   #2,W0L
00554:  MOV.B   W0L,188E
00556:  MOV.B   #5,W0L
00558:  MOV.B   W0L,188F
0055A:  CALL    458
....................        PGA = 32; 
0055E:  MOV.B   #20,W0L
00560:  MOV.B   W0L,811
....................       break; 
00562:  GOTO    57A
....................        
....................       case 6: 
....................        WrReg(ADCON,6); 
00566:  MOV.B   #2,W0L
00568:  MOV.B   W0L,188E
0056A:  MOV.B   #6,W0L
0056C:  MOV.B   W0L,188F
0056E:  CALL    458
....................        PGA = 64; 
00572:  MOV.B   #40,W0L
00574:  MOV.B   W0L,811
....................       break;  
00576:  GOTO    57A
....................    } 
....................    delay_us(20); 
0057A:  REPEAT  #31E
0057C:  NOP     
0057E:  RETURN  
.................... } 
....................  
.................... static void ADC_SelfCal(){ 
00580:  MOV     W5,[W15++]
00582:  MOV     W6,[W15++]
....................                       
....................    ADC_CS = 0; 
00584:  BCLR.B  2E9.1
....................    ADC2_CS = 0; 
00586:  BCLR.B  2D7.2
....................    delay_us(1); 
00588:  REPEAT  #26
0058A:  NOP     
....................     
....................    Spi_write2(0xF0); 
0058C:  BCLR.B  260.6
0058E:  BTSS.B  260.0
00590:  BRA     596
00592:  MOV.B   268,W0L
00594:  BRA     58E
00596:  MOV.B   #F0,W0L
00598:  MOV.B   W0L,268
0059A:  BTSS.B  260.0
0059C:  BRA     59A
....................    delay_us(1); 
0059E:  REPEAT  #26
005A0:  NOP     
....................     
....................    ADC_CS = 1; 
005A2:  BSET.B  2E9.1
....................    ADC2_CS = 1; 
005A4:  BSET.B  2D7.2
....................     
....................    While(ADC_DRDY | ADC2_DRDY) { }   // ждем готовности обоих АЦП 
005A6:  CLR     W0
005A8:  BTSC.B  2D4.1
005AA:  INC     W0,W0
005AC:  MOV.B   W0L,W6L
005AE:  CLR     W0
005B0:  BTSC.B  2D5.1
005B2:  INC     W0,W0
005B4:  IOR.B    W6L,  W0L,W0L
005B6:  CP0.B   W0L
005B8:  BRA     Z,5BE
005BA:  GOTO    5A6
005BE:  MOV     [--W15],W6
005C0:  MOV     [--W15],W5
005C2:  RETURN  
....................      
....................    /* 
....................    Switch (Sps_buf) {      
....................      
....................       case 0xF0:    
....................        delay_us(220);         
....................         break;                       
....................        
....................       case 0xE0: 
....................        delay_us(255);  
....................         break; 
....................          
....................       case 0xD0: 
....................        delay_us(315);  
....................         break; 
....................          
....................       case 0xC0: 
....................        delay_us(445);  
....................         break; 
....................          
....................       case 0xB0: 
....................        delay_us(685);  
....................         break; 
....................          
....................       case 0xA1: 
....................        delay_ms(1); 
....................        delay_us(185);                
....................         break;       
....................          
....................       case 0x92: 
....................        delay_ms(5); 
....................         break; 
....................          
....................       case 0x82: 
....................        delay_ms(10); 
....................        delay_us(200); 
....................         break; 
....................                     
....................       case 0x63: 
....................        delay_ms(21);  
....................         break; 
....................          
....................       case 0x43: 
....................        delay_ms(41);  
....................         break; 
....................          
....................       case 0x23: 
....................        delay_ms(101);  
....................         break;          
....................              
....................       case 0x13: 
....................        delay_ms(201);  
....................         break;                           
....................      } 
....................      */ 
.................... } 
....................  
.................... static void ADC_init(){ 
....................     
....................   WrReg(STATUS,2);   // вкл. входной буфер 
005C4:  CLR.B   188E
005C6:  MOV.B   #2,W0L
005C8:  MOV.B   W0L,188F
005CA:  CALL    458
....................   delay_us(20); 
005CE:  REPEAT  #31E
005D0:  NOP     
....................  
....................    if(ADC_sps_var>8)  ADC_sps_var = 8; 
005D2:  MOV     81E,W4
005D4:  CP.B    W4L,#8
005D6:  BRA     LEU,5DC
005D8:  MOV.B   #8,W0L
005DA:  MOV.B   W0L,81E
....................    // установка sps 
....................    switch (ADC_sps_var){                // передача величины скорости измерений АЦП  
005DC:  MOV.B   81E,W0L
005DE:  CLR.B   1
005E0:  XOR     #0,W0
005E2:  BRA     Z,606
005E4:  XOR     #1,W0
005E6:  BRA     Z,612
005E8:  XOR     #3,W0
005EA:  BRA     Z,61E
005EC:  XOR     #1,W0
005EE:  BRA     Z,62A
005F0:  XOR     #7,W0
005F2:  BRA     Z,636
005F4:  XOR     #1,W0
005F6:  BRA     Z,642
005F8:  XOR     #3,W0
005FA:  BRA     Z,64E
005FC:  XOR     #1,W0
005FE:  BRA     Z,65A
00600:  XOR     #F,W0
00602:  BRA     Z,666
00604:  BRA     672
....................      
....................       case 0: ADC_sps_set(0x03);  break; // 2,5   sps 
00606:  MOV.B   #3,W0L
00608:  MOV.B   W0L,188C
0060A:  CALL    4B8
0060E:  GOTO    672
....................       case 1: ADC_sps_set(0x13);  break; // 5   sps 
00612:  MOV.B   #13,W0L
00614:  MOV.B   W0L,188C
00616:  CALL    4B8
0061A:  GOTO    672
....................       case 2: ADC_sps_set(0x23);  break; // 10   sps 
0061E:  MOV.B   #23,W0L
00620:  MOV.B   W0L,188C
00622:  CALL    4B8
00626:  GOTO    672
....................       case 3: ADC_sps_set(0x43);  break; // 25   sps 
0062A:  MOV.B   #43,W0L
0062C:  MOV.B   W0L,188C
0062E:  CALL    4B8
00632:  GOTO    672
....................       case 4: ADC_sps_set(0x63);  break; // 50   sps 
00636:  MOV.B   #63,W0L
00638:  MOV.B   W0L,188C
0063A:  CALL    4B8
0063E:  GOTO    672
....................       case 5: ADC_sps_set(0x82);  break; // 100  sps 
00642:  MOV.B   #82,W0L
00644:  MOV.B   W0L,188C
00646:  CALL    4B8
0064A:  GOTO    672
....................       case 6: ADC_sps_set(0x91);  break; // 500  sps 
0064E:  MOV.B   #91,W0L
00650:  MOV.B   W0L,188C
00652:  CALL    4B8
00656:  GOTO    672
....................       case 7: ADC_sps_set(0xA1);  break; // 1000 sps 
0065A:  MOV.B   #A1,W0L
0065C:  MOV.B   W0L,188C
0065E:  CALL    4B8
00662:  GOTO    672
....................       case 8: ADC_sps_set(0xC0);  break; // 3750 sps 
00666:  MOV.B   #C0,W0L
00668:  MOV.B   W0L,188C
0066A:  CALL    4B8
0066E:  GOTO    672
....................       } 
....................        
....................    ADC_set_PGA(PGA_val);    // Уст. PGA 
00672:  MOV.B   812,W0L
00674:  MOV.B   W0L,188C
00676:  CALL    4CE
....................    ADC_SelfCal();      // Автокалибровка обоих АЦП  
0067A:  CALL    580
0067E:  RETURN  
.................... } 
.................... //===========================================================================// 
....................  
....................  
.................... //---------------------- уст. каналов и чтение АЦП --------------------------// 
....................  
.................... static void SYNC_ADC(U8 command) 
....................   { /// синхронизация АЦП 
....................    
....................    //command 0 - не выбран ни один АЦП 
....................    //command 1 - выбран АЦП 1 
....................    //command 2 - выбран АЦП 2 
....................     
....................    switch(command) 
*
00710:  MOV.B   188C,W0L
00712:  CLR.B   1
00714:  XOR     #0,W0
00716:  BRA     Z,722
00718:  XOR     #1,W0
0071A:  BRA     Z,72A
0071C:  XOR     #3,W0
0071E:  BRA     Z,736
00720:  BRA     742
....................    { 
....................          case 0:      
....................             ADC_SYNC = 1;  
00722:  BSET.B  2D6.2
....................             ADC2_SYNC = 1; 
00724:  BSET.B  2D7.3
....................          break; 
00726:  GOTO    742
....................           
....................          case 1:  
....................             ADC_SYNC = 0;  
0072A:  BCLR.B  2D6.2
....................             delay_us(20); 
0072C:  REPEAT  #31E
0072E:  NOP     
....................             ADC_SYNC = 1; 
00730:  BSET.B  2D6.2
....................          break; 
00732:  GOTO    742
....................           
....................          case 2:  
....................             ADC2_SYNC = 0;  
00736:  BCLR.B  2D7.3
....................             delay_us(20); 
00738:  REPEAT  #31E
0073A:  NOP     
....................             ADC2_SYNC = 1;  
0073C:  BSET.B  2D7.3
....................          break; 
0073E:  GOTO    742
....................    } 
00742:  RETURN  
....................   } 
....................  
.................... static void ADC_select(U8 command) 
....................   { /// выбор АЦП 
....................    
....................    //command 0 - не выбран ни один АЦП 
....................    //command 1 - выбран АЦП 1 
....................    //command 2 - выбран АЦП 2 
....................     
....................    switch(command) 
*
00680:  MOV.B   18B6,W0L
00682:  CLR.B   1
00684:  XOR     #0,W0
00686:  BRA     Z,692
00688:  XOR     #1,W0
0068A:  BRA     Z,69A
0068C:  XOR     #3,W0
0068E:  BRA     Z,6A2
00690:  BRA     6AA
....................    { 
....................          case 0: ADC_CS = 1; ADC2_CS = 1; break; 
00692:  BSET.B  2E9.1
00694:  BSET.B  2D7.2
00696:  GOTO    6AA
....................          case 1: ADC_CS = 0; ADC2_CS = 1; break; 
0069A:  BCLR.B  2E9.1
0069C:  BSET.B  2D7.2
0069E:  GOTO    6AA
....................          case 2: ADC_CS = 1; ADC2_CS = 0; break; 
006A2:  BSET.B  2E9.1
006A4:  BCLR.B  2D7.2
006A6:  GOTO    6AA
....................    } 
006AA:  RETURN  
....................   } 
....................  
.................... static void ADC_setCh(U8 Ch_Number, U8 ADC_number){ 
006AC:  MOV     W5,[W15++]
....................  
....................  // уст. каналоа АЦП 
....................  // 1 канал пользователя - 4 канал АЦП по факту (13(+) и 12(-) ножки) и тд. 
....................   
....................   ADC_select(ADC_number); // выбор АЦП 
006AE:  MOV.B   188D,W0L
006B0:  MOV.B   W0L,18B6
006B2:  CALL    680
....................   delay_us(2); 
006B6:  REPEAT  #4E
006B8:  NOP     
....................   
....................   Spi_write2(0x50+MUX);  // уст. канал АЦП    
006BA:  BCLR.B  260.6
006BC:  BTSS.B  260.0
006BE:  BRA     6C4
006C0:  MOV.B   268,W0L
006C2:  BRA     6BC
006C4:  MOV.B   #51,W0L
006C6:  MOV.B   W0L,268
006C8:  BTSS.B  260.0
006CA:  BRA     6C8
....................   delay_us(10); 
006CC:  REPEAT  #18E
006CE:  NOP     
....................   Spi_write2(0);          
006D0:  BCLR.B  260.6
006D2:  BTSS.B  260.0
006D4:  BRA     6DA
006D6:  MOV.B   268,W0L
006D8:  BRA     6D2
006DA:  CLR.B   268
006DC:  BTSS.B  260.0
006DE:  BRA     6DC
....................   delay_us(10); 
006E0:  REPEAT  #18E
006E2:  NOP     
....................   Spi_write2(Mx_ch_code[Ch_Number]); 
006E4:  MOV     188C,W4
006E6:  CLR.B   9
006E8:  MOV     #808,W3
006EA:  ADD     W4,W3,W0
006EC:  MOV.B   [W0],W5L
006EE:  BCLR.B  260.6
006F0:  BTSS.B  260.0
006F2:  BRA     6F8
006F4:  MOV.B   268,W0L
006F6:  BRA     6F0
006F8:  PUSH    268
006FA:  MOV.B   W5L,[W15-#2]
006FC:  POP     268
006FE:  BTSS.B  260.0
00700:  BRA     6FE
....................    
....................   ADC_select(0); 
00702:  CLR.B   18B6
00704:  CALL    680
....................   delay_us(20);   
00708:  REPEAT  #31E
0070A:  NOP     
0070C:  MOV     [--W15],W5
0070E:  RETURN  
.................... } 
....................  
.................... static S32 ADC_read(U8 ADC_number) 
*
00C2C:  MOV     W5,[W15++]
00C2E:  MOV     #C,W5
00C30:  REPEAT  #4
00C32:  MOV     [W5++],[W15++]
....................   { 
....................    
....................   ADC_select(ADC_number); // выбор АЦП 
00C34:  MOV.B   1898,W0L
00C36:  MOV.B   W0L,18B6
00C38:  CALL    680
....................    
....................   S32 ADC_RByte1=0;  // ст. байт данных АЦП 
....................   S32 ADC_RByte2=0;  // ср. байт данных АЦП 
....................   S32 ADC_RByte3=0;  // мл. байт данных АЦП 
....................    
....................   S32 ADC_RByte_Sum; // суммарные отсчеты АЦП - 24 бита 
....................    
....................   float Vin;         // измеренное напряжение  
00C3C:  CLR     189A
00C3E:  CLR     189C
00C40:  CLR     189E
00C42:  CLR     18A0
00C44:  CLR     18A2
00C46:  CLR     18A4
....................  
....................   Spi_write2(0x01);        // команда чтения Rdata 
00C48:  BCLR.B  260.6
00C4A:  BTSS.B  260.0
00C4C:  BRA     C52
00C4E:  MOV.B   268,W0L
00C50:  BRA     C4A
00C52:  MOV.B   #1,W0L
00C54:  MOV.B   W0L,268
00C56:  BTSS.B  260.0
00C58:  BRA     C56
....................   delay_us(20); 
00C5A:  REPEAT  #31E
00C5C:  NOP     
....................   ADC_Rbyte1 = Spi_read2(0);   // чтение 
00C5E:  BCLR.B  260.6
00C60:  BTSS.B  260.0
00C62:  BRA     C68
00C64:  MOV.B   268,W0L
00C66:  BRA     C60
00C68:  CLR.B   268
00C6A:  BTSS.B  260.0
00C6C:  BRA     C6A
00C6E:  MOV.B   268,W0L
00C70:  CLR.B   1
00C72:  MOV     #0,W1
00C74:  MOV     W0,189A
00C76:  MOV     W1,189C
....................   ADC_Rbyte2 = Spi_read2(0); 
00C78:  BCLR.B  260.6
00C7A:  BTSS.B  260.0
00C7C:  BRA     C82
00C7E:  MOV.B   268,W0L
00C80:  BRA     C7A
00C82:  CLR.B   268
00C84:  BTSS.B  260.0
00C86:  BRA     C84
00C88:  MOV.B   268,W0L
00C8A:  CLR.B   1
00C8C:  MOV     #0,W1
00C8E:  MOV     W0,189E
00C90:  MOV     W1,18A0
....................   ADC_Rbyte3 = Spi_read2(0); 
00C92:  BCLR.B  260.6
00C94:  BTSS.B  260.0
00C96:  BRA     C9C
00C98:  MOV.B   268,W0L
00C9A:  BRA     C94
00C9C:  CLR.B   268
00C9E:  BTSS.B  260.0
00CA0:  BRA     C9E
00CA2:  MOV.B   268,W0L
00CA4:  CLR.B   1
00CA6:  MOV     #0,W1
00CA8:  MOV     W0,18A2
00CAA:  MOV     W1,18A4
....................    
....................   ADC_select(0); // сброс выбора АЦП 
00CAC:  CLR.B   18B6
00CAE:  CALL    680
....................    
....................   // склеивание трех байт отсчетов АЦП 
....................   ADC_RByte_Sum = ((S32)ADC_Rbyte1<<24) | ((S32)ADC_Rbyte2<<16) | ((S32)ADC_Rbyte3<<8); 
00CB2:  MOV.B   189A,W0L
00CB4:  MOV.B   W0L,D
00CB6:  CLR.B   W6
00CB8:  CLR.B   B
00CBA:  CLR.B   W5
00CBC:  MOV     189E,W1
00CBE:  MOV     #0,W0
00CC0:  IOR      W5,  W0,W5
00CC2:  IOR      W6,  W1,W6
00CC4:  MOV.B   18A4,W0L
00CC6:  MOV.B   W0L,3
00CC8:  MOV.B   18A3,W0L
00CCA:  MOV.B   W0L,W1L
00CCC:  MOV.B   18A2,W0L
00CCE:  MOV.B   W0L,1
00CD0:  CLR.B   W0
00CD2:  IOR      W6,  W1,W1
00CD4:  IOR      W5,  W0,W0
00CD6:  MOV     W0,18A6
00CD8:  MOV     W1,18A8
....................   ADC_RByte_Sum = ADC_RByte_Sum/256; // приведение 24 бит к 32-битной переменной 
00CDA:  BCLR.B  43.0
00CDC:  MOV     18A6,W0
00CDE:  MOV     18A8,W1
00CE0:  MOV     #100,W2
00CE2:  MOV     #0,W3
00CE4:  CALL    744
00CE8:  MOV     W0,18A6
00CEA:  MOV     W1,18A8
....................   if(ADC_RByte_Sum > 0x7FFFFF) 
00CEC:  MOV     18A8,W4
00CEE:  MOV     #7F,W3
00CF0:  CP      W3,W4
00CF2:  BRA     GT,D74
00CF4:  BRA     LT,CFE
00CF6:  MOV     18A6,W4
00CF8:  MOV     #FFFF,W3
00CFA:  CP      W3,W4
00CFC:  BRA     C,D74
....................   { 
....................   Vin = ((ADC_RByte_Sum*-5)/(8388608.0*PGA)); // расчет -U 
00CFE:  MOV     18A6,W0
00D00:  MOV     18A8,W1
00D02:  MOV     #FFFB,W2
00D04:  MOV     #FFFF,W3
00D06:  CALL    7C2
00D0A:  MOV     W0,W5
00D0C:  MOV     W1,W6
00D0E:  MOV     #0,W1
00D10:  MOV     #0,W2
00D12:  MOV     #0,W3
00D14:  MOV.B   811,W0L
00D16:  CLR.B   1
00D18:  CALL    804
00D1C:  MOV     W5,[W15++]
00D1E:  MOV     W6,[W15++]
00D20:  MOV     W0,W4
00D22:  MOV     W1,W5
00D24:  MOV     W2,W6
00D26:  MOV     W3,W7
00D28:  MOV     #0,W0
00D2A:  MOV     #0,W1
00D2C:  MOV     #0,W2
00D2E:  MOV     #4160,W3
00D30:  CALL    868
00D34:  MOV     [--W15],W6
00D36:  MOV     [--W15],W5
00D38:  MOV     W0,W7
00D3A:  MOV     W1,W8
00D3C:  MOV     W2,W9
00D3E:  MOV     W3,W10
00D40:  MOV     W5,W0
00D42:  MOV     W6,W1
00D44:  CLR     W3
00D46:  BTSC    W1.F
00D48:  SETM    W3
00D4A:  MOV     W3,W2
00D4C:  CALL    978
00D50:  MOV     W5,[W15++]
00D52:  MOV     W6,[W15++]
00D54:  MOV     W7,[W15++]
00D56:  MOV     W7,W4
00D58:  MOV     W8,W5
00D5A:  MOV     W9,W6
00D5C:  MOV     W10,W7
00D5E:  CALL    9DC
00D62:  MOV     [--W15],W7
00D64:  MOV     [--W15],W6
00D66:  MOV     [--W15],W5
00D68:  CALL    AE4
00D6C:  MOV     W1,18AA
00D6E:  MOV     W2,18AC
....................   } 
00D70:  GOTO    DE6
....................   else Vin = ((ADC_RByte_Sum*5)/(8388608.0*PGA)); // расчет U 
00D74:  MOV     18A6,W0
00D76:  MOV     18A8,W1
00D78:  MOV     #5,W2
00D7A:  MOV     #0,W3
00D7C:  CALL    7C2
00D80:  MOV     W0,W5
00D82:  MOV     W1,W6
00D84:  MOV     #0,W1
00D86:  MOV     #0,W2
00D88:  MOV     #0,W3
00D8A:  MOV.B   811,W0L
00D8C:  CLR.B   1
00D8E:  CALL    804
00D92:  MOV     W5,[W15++]
00D94:  MOV     W6,[W15++]
00D96:  MOV     W0,W4
00D98:  MOV     W1,W5
00D9A:  MOV     W2,W6
00D9C:  MOV     W3,W7
00D9E:  MOV     #0,W0
00DA0:  MOV     #0,W1
00DA2:  MOV     #0,W2
00DA4:  MOV     #4160,W3
00DA6:  CALL    868
00DAA:  MOV     [--W15],W6
00DAC:  MOV     [--W15],W5
00DAE:  MOV     W0,W7
00DB0:  MOV     W1,W8
00DB2:  MOV     W2,W9
00DB4:  MOV     W3,W10
00DB6:  MOV     W5,W0
00DB8:  MOV     W6,W1
00DBA:  CLR     W3
00DBC:  BTSC    W1.F
00DBE:  SETM    W3
00DC0:  MOV     W3,W2
00DC2:  CALL    978
00DC6:  MOV     W5,[W15++]
00DC8:  MOV     W6,[W15++]
00DCA:  MOV     W7,[W15++]
00DCC:  MOV     W7,W4
00DCE:  MOV     W8,W5
00DD0:  MOV     W9,W6
00DD2:  MOV     W10,W7
00DD4:  CALL    9DC
00DD8:  MOV     [--W15],W7
00DDA:  MOV     [--W15],W6
00DDC:  MOV     [--W15],W5
00DDE:  CALL    AE4
00DE2:  MOV     W1,18AA
00DE4:  MOV     W2,18AC
....................    
....................   return Vin*uV; // возврат масштабированного U  
00DE6:  MOV     18AA,W0
00DE8:  MOV     18AC,W1
00DEA:  MOV     #9680,W2
00DEC:  MOV     #4B18,W3
00DEE:  CALL    B28
00DF2:  CALL    BEC
00DF6:  MOV.D   W0,W0
00DF8:  MOV     #14,W5
00DFA:  REPEAT  #4
00DFC:  MOV     [--W15],[W5--]
00DFE:  MOV     [--W15],W5
00E00:  RETURN  
....................    
....................   } 
....................  
.................... static S32 ADC_read_aver(U8 ADC_number,U8 ADC_ch) 
00E02:  MOV     W5,[W15++]
.................... { 
....................  S32 _Ch_buf_sum; // переменн. для хранения текущ. усредн. значения 
....................   
....................  Ch_buf[ADC_ch][Ma_buf_index] = ADC_read(ADC_number); // считываем текщее изм. в буфер 
00E04:  MOV.B   188D,W0L
00E06:  CLR.B   1
00E08:  SL      W0,#9,W5
00E0A:  MOV.B   182A,W0L
00E0C:  CLR.B   1
00E0E:  SL      W0,#2,W0
00E10:  ADD     W0,W5,W0
00E12:  MOV     #826,W4
00E14:  ADD     W0,W4,W5
00E16:  MOV.B   188C,W0L
00E18:  MOV.B   W0L,1898
00E1A:  CALL    C2C
00E1E:  MOV     #0,W4
00E20:  MOV     [W4++],[W5++]
00E22:  MOV     [W4++],[W5++]
....................   
....................  for(U8 i = 0; i < Ma_buf_size; i++)                  // суммируем весь буфер 
00E24:  CLR.B   1892
00E26:  MOV.B   1892,W0L
00E28:  MOV     182A,W4
00E2A:  LSR     W4,#8,W4
00E2C:  CP.B    W4L,W0L
00E2E:  BRA     LEU,E58
....................  { 
....................    Ch_buf_sum += Ch_buf[ADC_ch][i];   // меняем элемент буфера на новый 
00E30:  MOV.B   188D,W0L
00E32:  CLR.B   1
00E34:  SL      W0,#9,W5
00E36:  MOV.B   1892,W0L
00E38:  CLR.B   1
00E3A:  SL      W0,#2,W0
00E3C:  ADD     W0,W5,W0
00E3E:  MOV     #826,W4
00E40:  ADD     W0,W4,W0
00E42:  MOV     W0,W4
00E44:  MOV     #0,W3
00E46:  MOV     [W4++],[W3++]
00E48:  MOV     [W4++],[W3++]
00E4A:  ADD     1826
00E4C:  MOV     W1,W0
00E4E:  ADDC    1828,W0
00E50:  MOV     W0,1828
00E52:  INC.B   1892
00E54:  GOTO    E26
....................  }   
....................  Ch_buf_sum = Ch_buf_sum/Ma_buf_size; // вычисляем среднее 
00E58:  BCLR.B  43.0
00E5A:  MOV.B   182B,W0L
00E5C:  MOV.B   W0L,W2L
00E5E:  CLR.B   5
00E60:  MOV     #0,W3
00E62:  MOV     1826,W0
00E64:  MOV     1828,W1
00E66:  CALL    744
00E6A:  MOV     W0,1826
00E6C:  MOV     W1,1828
....................   
....................  _Ch_buf_sum = Ch_buf_sum; // пересохраняем для возврата 
00E6E:  PUSH    1826
00E70:  POP     188E
00E72:  PUSH    1828
00E74:  POP     1890
....................   
....................  Ch_buf_sum = 0;           // сброс глоб переменной 
00E76:  CLR     1826
00E78:  CLR     1828
....................   
....................  return _Ch_buf_sum; 
00E7A:  MOV     188E,W0
00E7C:  MOV     1890,W1
00E7E:  MOV     [--W15],W5
00E80:  RETURN  
....................  
.................... } 
....................  
.................... //---------------------------------------------------------------------------// 
....................  
....................  
.................... /*############################################################################*/ 
....................  
.................... static void Rd_Flash(){ 
....................  
....................   read_program_memory(CK_USER_PAGE,flash_rd_data,4); 
....................   delay_ms(5); 
....................   NumAver = flash_rd_data[1];  
....................   ADC_sps_var = flash_rd_data[0]; 
....................   CRC_buf = flash_rd_data[2]; 
....................  
.................... } 
....................  
.................... static void Wr_Flash(){ 
....................  
....................   flash_wr_data[0] = Aver_Wr;  
....................   flash_wr_data[1] = Sps_Wr; 
....................   flash_wr_data[2] = CRC_Wr; 
....................   //flash_wr_data[4] = 0x00; 
....................   write_program_memory(CK_USER_PAGE,flash_wr_data,4); 
....................   delay_ms(2); 
....................  
....................  //if(Rd_Flash(buf_index)==in_wr_data) return 1; else return 0; 
.................... } 
....................  
.................... unsigned char Crc8(unsigned char *pcBlock, unsigned int len) 
.................... { 
....................  
....................   //Name  : CRC-8 
....................   //Poly  : 0x31    x^8 + x^5 + x^4 + 1 
....................   //Init  : 0xFF 
....................   //Revert: false 
....................   //XorOut: 0x00 
....................   //Check : 0xF7 ("123456789") 
....................   //MaxLen: 15 байт(127 бит) - обнаружение 
....................   // одинарных, двойных, тройных и всех нечетных ошибок 
....................  
....................     unsigned char crc = 0xFF; 
....................     unsigned int i; 
....................   
....................     while (len--) 
....................     { 
....................         crc ^= *pcBlock++; 
....................   
....................         for (i = 0; i < 8; i++) 
....................             crc = crc & 0x80 ? (crc << 1) ^ 0x31 : crc << 1; 
....................     } 
....................   
....................     return crc; 
.................... } 
....................  
.................... static void UART2_init(){ 
....................  
....................    U2MODE = (1<<15 | // UARTx is enabled 
....................              1<<13 | // Discontinue operation when device enters Idle mode  
....................              0<<12 | // IrDA encoder and decoder disabled 
....................              1<<11 | // 1 - UxRTS in Simplex mode, 0 - flow control mode 
....................              2<<9  | // UxTX, UxRX, UxCTS and UxRTS pins are enabled and used 
....................              1<<7  | // 1 = Wake-up enabled 
....................              0<<6  | // 0 = Loopback mode is disabled 
....................              0<<5  | // Auto-Baud Enable bit, disabled 
....................              1<<4  | // Receive Polarity Inversion bit, 1 = UxRX Idle state is '0' 
....................              0<<3  | // BRGH: High Baud Rate Select bit , 0 = Low speed 
....................              0<<2  | // 00 = 8-bit data, no parity 
....................              0      // 0 = One Stop bit 
....................    ); 
....................  
.................... } 
....................  
.................... static void OscSetup(){ 
....................   //Fcy=Fosc/2 
....................   //Fin=10M 
....................   //Fosc=Fin(M/(N1*N2)) 
....................    
....................   //U2BRG = 259;// BAUD Rate Setting for 9600 
....................   //U2MODE = 0b1010101010000000; // brgh = 0 
....................   U2BRG = 21;// BAUD Rate Setting for 115200 
*
003B0:  MOV     #15,W4
003B2:  MOV     W4,238
....................   U2MODE = 0b1010101010000000; // brgh = 0 
003B4:  MOV     #AA80,W4
003B6:  MOV     W4,230
....................    
....................   PLLFBD = 30; // ???. ????. ??????? PLL M = 30 
003B8:  MOV     #1E,W4
003BA:  MOV     W4,746
....................    
....................   PLLPRE4 = 0; // ???. ????. ??????? PLL N1 = 2 
003BC:  BCLR.B  744.4
....................   PLLPRE3 = 0; 
003BE:  BCLR.B  744.3
....................   PLLPRE2 = 0; 
003C0:  BCLR.B  744.2
....................   PLLPRE1 = 0; 
003C2:  BCLR.B  744.1
....................   PLLPRE0 = 0; 
003C4:  BCLR.B  744.0
....................    
....................   PLLPOST0=0; // ???. ????. ??????? PLL N2 = 2 
003C6:  BCLR.B  744.6
....................   PLLPOST1=0; 
003C8:  BCLR.B  744.7
003CA:  RETURN  
....................      
....................    } 
....................  
.................... static void EnableInt (){ 
....................  
....................   enable_interrupts(INT_RDA); // UART Int 
003CC:  BSET.B  95.3
....................   enable_interrupts(INT_RDA2); // UART Int 
003CE:  BSET.B  97.6
....................    
....................   enable_interrupts(INT_TIMER1); 
003D0:  BSET.B  94.3
....................   EXT_INT_EDGE(L_TO_H); 
003D2:  BCLR.B  82.0
....................   ENABLE_INTERRUPTS(INTR_GLOBAL); 
003D4:  BCLR.B  81.7
003D6:  CLR     42
003D8:  BSET.B  81.7
003DA:  RETURN  
.................... } 
....................  
.................... static void MCU_init(){ 
....................  
....................   setup_timer1(TMR_INTERNAL | TMR_DIV_BY_64); // таймер 1 сбрасывает собачий таймер 
003DC:  CLR     104
003DE:  SETM    102
003E0:  MOV     #8020,W4
003E2:  MOV     W4,104
....................   set_timer1(20000); //reset the timer. 
003E4:  MOV     #4E20,W4
003E6:  MOV     W4,100
....................    
....................    SETUP_SPI2(SPI_MASTER|SPI_SCK_IDLE_LOW|SPI_XMIT_H_TO_L|SPI_MODE_8B|SPI_SAMPLE_AT_END|SPI_SS_DISABLED|SPI_CLK_DIV_128); 
003E8:  BCLR.B  261.7
003EA:  BCLR.B  260.6
003EC:  MOV     #221,W4
003EE:  MOV     W4,262
003F0:  BSET.B  261.7
....................    //f SCLK SPI = 312,5 kHz 
....................    //setup_timer1(TMR_DISABLED|TMR_DIV_BY_1); 
....................    //enable_interrupts(INT_EXT0); 
....................    //enable_interrupts(INT_TIMER1); 
....................    
....................  SCK2_TRIS=0; // SPI2 tris 
003F2:  BCLR.B  2E4.6
....................  SDI2_TRIS=1; 
003F4:  BSET.B  2E4.7
....................  SDO2_TRIS=0; 
003F6:  BCLR.B  2E5.0
....................   
....................  ADC_CS_TRIS=0;      ADC2_CS_TRIS=0; 
003F8:  BCLR.B  2E5.1
003FA:  BCLR.B  2D3.2
....................  ADC_RESET_TRIS=0;   ADC2_RESET_TRIS=0; 
003FC:  BCLR.B  2D2.3
003FE:  BCLR.B  2D2.0
....................  ADC_SYNC_TRIS=0;    ADC2_SYNC_TRIS=0; 
00400:  BCLR.B  2D2.2
00402:  BCLR.B  2D3.3
....................  ADC_DRDY_TRIS=1;    ADC2_DRDY_TRIS=1;       // опрос готовнсти данных АЦП 
00404:  BSET.B  2D2.1
00406:  BSET.B  2D3.1
....................   
....................  UART2_RX_TRIS=1; 
00408:  BSET.B  2DE.4
....................  UART2_TX_TRIS=0; 
0040A:  BCLR.B  2DE.5
....................  //XPORT_RST_TRIS=0; 
....................   
....................  //XPORT_RST_n = 0; 
....................  //delay_us(500); 
....................  //XPORT_RST_n = 1; 
....................  EnableInt(); 
0040C:  CALL    3CC
00410:  RETURN  
.................... } 
....................  
.................... static void Full_dev_reset(){ 
....................  
....................   OscSetup(); 
....................   MCU_init(); 
....................   reset_fl = 0; 
....................   //ADC_wakeUp(); 
....................   //ADC_wakeUp();  
....................   ADC_init(); 
....................   ADC_set_PGA(8); 
....................   ADC_sps_set(0x23); //0x023 - 10 sps, 0x43 - 25 sps, 0x63 - 50 sps 
....................                      //0x82 - 100 sps, 0x91 - 500 sps 
....................                      //0xA1 - 1000 sps, 0xC0 - 3750 sps 
....................   ADC_SelfCal(); 
....................   meas_stop_fl = 0; // вкл. режим измерений 
....................   NumAver = 10;      // сброс величины усреднения данных АЦП 
....................  
.................... } 
....................  
.................... static void Clr_bufs(void) 
00412:  MOV     W5,[W15++]
.................... { 
....................   for (U8 i = 0; i < 8; i++) 
00414:  CLR.B   188C
00416:  MOV     188C,W4
00418:  CP.B    W4L,#8
0041A:  BRA     C,454
....................   { 
....................   // заполнение буферов скольз. ср. нулями 
....................    for (U8 j = 0; j < Ma_buf_size; j++)  
0041C:  CLR.B   188D
0041E:  MOV.B   188D,W0L
00420:  MOV     182A,W4
00422:  LSR     W4,#8,W4
00424:  CP.B    W4L,W0L
00426:  BRA     LEU,44E
....................       { 
....................          Ch_buf[i][j] = 0; 
00428:  MOV.B   188C,W0L
0042A:  CLR.B   1
0042C:  SL      W0,#9,W5
0042E:  MOV.B   188D,W0L
00430:  CLR.B   1
00432:  SL      W0,#2,W0
00434:  ADD     W0,W5,W0
00436:  MOV     #826,W4
00438:  ADD     W0,W4,W5
0043A:  CLR.B   [W5]
0043C:  MOV.B   #0,W0L
0043E:  MOV.B   W0L,[W5+#1]
00440:  MOV.B   #0,W0L
00442:  MOV.B   W0L,[W5+#2]
00444:  MOV.B   #0,W0L
00446:  MOV.B   W0L,[W5+#3]
00448:  INC.B   188D
0044A:  GOTO    41E
....................       } 
0044E:  INC.B   188C
00450:  GOTO    416
....................   } 
00454:  MOV     [--W15],W5
00456:  RETURN  
.................... } 
....................  
.................... static U8 ch_to_int(char ch){ 
*
0101E:  MOV.B   #FF,W0L
01020:  MOV.B   W0L,188D
.................... U8 dg=-1; 
....................  switch (ch){ 
01022:  MOV.B   188C,W0L
01024:  CLR.B   1
01026:  XOR     #30,W0
01028:  BRA     Z,1050
0102A:  XOR     #1,W0
0102C:  BRA     Z,1056
0102E:  XOR     #3,W0
01030:  BRA     Z,105E
01032:  XOR     #1,W0
01034:  BRA     Z,1066
01036:  XOR     #7,W0
01038:  BRA     Z,106E
0103A:  XOR     #1,W0
0103C:  BRA     Z,1076
0103E:  XOR     #3,W0
01040:  BRA     Z,107E
01042:  XOR     #1,W0
01044:  BRA     Z,1086
01046:  XOR     #F,W0
01048:  BRA     Z,108E
0104A:  XOR     #1,W0
0104C:  BRA     Z,1096
0104E:  BRA     109E
....................       case '0' : dg=0; 
01050:  CLR.B   188D
....................       break; 
01052:  GOTO    10A2
....................       case '1' : dg=1; 
01056:  MOV.B   #1,W0L
01058:  MOV.B   W0L,188D
....................       break; 
0105A:  GOTO    10A2
....................       case '2' : dg=2; 
0105E:  MOV.B   #2,W0L
01060:  MOV.B   W0L,188D
....................       break; 
01062:  GOTO    10A2
....................       case '3' : dg=3; 
01066:  MOV.B   #3,W0L
01068:  MOV.B   W0L,188D
....................       break; 
0106A:  GOTO    10A2
....................       case '4' : dg=4; 
0106E:  MOV.B   #4,W0L
01070:  MOV.B   W0L,188D
....................       break; 
01072:  GOTO    10A2
....................       case '5' : dg=5; 
01076:  MOV.B   #5,W0L
01078:  MOV.B   W0L,188D
....................       break; 
0107A:  GOTO    10A2
....................       case '6' : dg=6; 
0107E:  MOV.B   #6,W0L
01080:  MOV.B   W0L,188D
....................       break; 
01082:  GOTO    10A2
....................       case '7' : dg=7; 
01086:  MOV.B   #7,W0L
01088:  MOV.B   W0L,188D
....................       break; 
0108A:  GOTO    10A2
....................       case '8' : dg=8; 
0108E:  MOV.B   #8,W0L
01090:  MOV.B   W0L,188D
....................       break; 
01092:  GOTO    10A2
....................       case '9' : dg=9; 
01096:  MOV.B   #9,W0L
01098:  MOV.B   W0L,188D
....................       break; 
0109A:  GOTO    10A2
....................       default: dg=-1; 
0109E:  MOV.B   #FF,W0L
010A0:  MOV.B   W0L,188D
....................  } 
.................... return dg; 
010A2:  MOV.B   188D,W0L
010A4:  RETURN  
.................... } 
....................  
.................... static unsigned char getrxch (void){ 
*
00FDA:  MOV     W5,[W15++]
....................  
.................... unsigned char rch; 
....................  
.................... if(rdptr < wrptr){ 
00FDC:  MOV.B   1870,W0L
00FDE:  MOV     186C,W4
00FE0:  LSR     W4,#8,W4
00FE2:  CP.B    W4L,W0L
00FE4:  BRA     LEU,FFC
....................  // есть символ, считываем 
....................    rdptr ++; 
00FE6:  INC.B   1870
....................    rch=RxData[rdptr& 0x0F];// прочитали символ 
00FE8:  MOV.B   1870,W0L
00FEA:  CLR.B   1
00FEC:  AND     W0,#F,W5
00FEE:  MOV     #1872,W4
00FF0:  ADD     W5,W4,W0
00FF2:  MOV     188C,W4
00FF4:  MOV.B   [W0+#0],W4L
00FF6:  MOV     W4,188C
.................... } else rch = 'x';//символов нет 
00FF8:  GOTO    1000
00FFC:  MOV.B   #78,W0L
00FFE:  MOV.B   W0L,188C
....................    //обнуление указателей 
....................    disable_interrupts(INT_RDA2); 
01000:  BCLR.B  97.6
....................   if((wrptr==rdptr) && (wrptr > 15))  
01002:  MOV.B   186D,W0L
01004:  CP.B    1870
01006:  BRA     NZ,1014
01008:  MOV     186C,W4
0100A:  LSR     W4,#8,W4
0100C:  CP.B    W4L,#F
0100E:  BRA     LEU,1014
....................   { 
....................   wrptr=0; 
01010:  CLR.B   186D
....................   rdptr=0; 
01012:  CLR.B   1870
....................   }  
....................   enable_interrupts(INT_RDA2); 
01014:  BSET.B  97.6
....................   return rch; 
01016:  MOV.B   188C,W0L
01018:  MOV.B   W0L,0
0101A:  MOV     [--W15],W5
0101C:  RETURN  
.................... } 
....................  
.................... // послед. чтение двух АЦП 
.................... /* 
.................... static void ADC_Seq_rd_and_print_ch(U8 chanel){ 
....................  
....................    switch (chanel){ 
.................... //---------------- АЦП 1 --------------------------------------//      
....................  case 1:  
....................   
....................  ADC_select(1); 
....................  ADC_setCh(1); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC_SYNC = 0; 
....................  delay_us(20); 
....................  ADC_SYNC = 1; 
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(1); 
....................  Printf("a%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................  
....................  break; 
....................  
.................... //---------------- 2 датчик --------------------------------------// 
....................  case 2: 
....................   
....................  ADC_select(1); 
....................  ADC_setCh(2); 
....................  ADC_select(0); 
....................   
....................  ADC_SYNC = 0; 
....................  delay_us(20); 
....................  ADC_SYNC = 1; 
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(1); 
....................  Printf("b%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................  
....................  break; 
....................   
.................... //---------------- 3 датчик --------------------------------------//   
....................  case 3:  
....................  
....................  ADC_select(1); 
....................  ADC_setCh(3); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC_SYNC = 0; 
....................  delay_us(20); 
....................  ADC_SYNC = 1; 
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(1); 
....................  Printf("c%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................  
....................  break; 
.................... //---------------- 4 датчик --------------------------------------//     
....................    case 4:  
....................     
....................  ADC_select(1); 
....................  ADC_setCh(4); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC_SYNC = 0; 
....................  delay_us(20); 
....................  ADC_SYNC = 1; 
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(1); 
....................  Printf("d%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................   
....................    break; 
.................... //----------------------------------------------------------------// 
....................  
.................... //------------------- АЦП 2 --------------------------------------//      
....................  case 5:  
....................   
....................  ADC_select(2); 
....................  ADC_setCh(1); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC2_SYNC = 0; 
....................  delay_us(20); 
....................  ADC2_SYNC = 1; 
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(2); 
....................  Printf("e%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................   
....................  break; 
....................   
.................... //---------------- 2 датчик --------------------------------------// 
....................  case 6:  
....................   
....................  ADC_select(2); 
....................  ADC_setCh(2); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC2_SYNC = 0; 
....................  delay_us(20); 
....................  ADC2_SYNC = 1; 
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(2); 
....................  Printf("f%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................    
....................  break; 
.................... //---------------- 3 датчик --------------------------------------//   
....................  case 7:  
....................  
....................  ADC_select(2); 
....................  ADC_setCh(3); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC2_SYNC = 0; 
....................  delay_us(20); 
....................  ADC2_SYNC = 1; 
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(2); 
....................  Printf("g%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................    
....................  break; 
.................... //---------------- 4 датчик --------------------------------------//     
....................    case 8:  
....................  
....................  ADC_select(2); 
....................  ADC_setCh(4); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC2_SYNC = 0; 
....................  delay_us(20); 
....................  ADC2_SYNC = 1; 
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(2); 
....................  Printf("h%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................    
....................   break; 
....................    } 
....................     
.................... } 
.................... */ 
.................... /**/ 
....................  
.................... // || чтение двух АЦП 
.................... static void ADC_Par_rd_and_print_ch(U8 channel) 
*
01158:  MOV     W5,[W15++]
0115A:  MOV     W6,[W15++]
.................... { 
....................   char rchr;             // принятый U2 символ 
....................    
....................    
....................    switch (channel){ 
0115C:  MOV.B   1884,W0L
0115E:  CLR.B   1
01160:  XOR     #1,W0
01162:  BRA     Z,1176
01164:  XOR     #3,W0
01166:  BRA     Z,1210
01168:  XOR     #1,W0
0116A:  BRA     Z,12AC
0116C:  XOR     #7,W0
0116E:  BRA     Z,1348
01170:  XOR     #1,W0
01172:  BRA     Z,13F6
01174:  BRA     1716
.................... //---------------- каналы 1 и 5 --------------------------------------//      
....................  case 1:  
....................   
....................  ADC_setCh(1,1); 
01176:  MOV.B   #1,W0L
01178:  MOV.B   W0L,188C
0117A:  MOV.B   #1,W0L
0117C:  MOV.B   W0L,188D
0117E:  CALL    6AC
....................  ADC_setCh(1,2); 
01182:  MOV.B   #1,W0L
01184:  MOV.B   W0L,188C
01186:  MOV.B   #2,W0L
01188:  MOV.B   W0L,188D
0118A:  CALL    6AC
....................  
....................  SYNC_ADC(1);  // синхр. измерений АЦП 1 
0118E:  MOV.B   #1,W0L
01190:  MOV.B   W0L,188C
01192:  CALL    710
....................  delay_ms(1);   
01196:  REPEAT  #1C3E
01198:  NOP     
0119A:  REPEAT  #3FFF
0119C:  NOP     
0119E:  REPEAT  #3FFF
011A0:  NOP     
....................  SYNC_ADC(2);  // синхр. измерений АЦП 2 
011A2:  MOV.B   #2,W0L
011A4:  MOV.B   W0L,188C
011A6:  CALL    710
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
011AA:  BTSS.B  2D4.1
011AC:  BRA     11B2
011AE:  GOTO    11AA
....................  Printf("a%09Ld\n",ADC_read_aver(1,0)); 
011B2:  MOV.B   #1,W0L
011B4:  MOV.B   W0L,188C
011B6:  CLR.B   188D
011B8:  CALL    E02
011BC:  MOV     W0,W5
011BE:  MOV     W1,W6
011C0:  BTSC.B  233.1
011C2:  BRA     11C0
011C4:  MOV     #61,W4
011C6:  MOV     W4,234
011C8:  MOV     W5,W0
011CA:  MOV     W6,W1
011CC:  MOV     #8009,W4
011CE:  CALL    EC6
011D2:  BTSC.B  233.1
011D4:  BRA     11D2
011D6:  MOV     #A,W4
011D8:  MOV     W4,234
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 2 
011DA:  BTSS.B  2D5.1
011DC:  BRA     11E2
011DE:  GOTO    11DA
....................  Printf("e%09Ld\n",ADC_read_aver(2,1)); 
011E2:  MOV.B   #2,W0L
011E4:  MOV.B   W0L,188C
011E6:  MOV.B   #1,W0L
011E8:  MOV.B   W0L,188D
011EA:  CALL    E02
011EE:  MOV     W0,W5
011F0:  MOV     W1,W6
011F2:  BTSC.B  233.1
011F4:  BRA     11F2
011F6:  MOV     #65,W4
011F8:  MOV     W4,234
011FA:  MOV     W5,W0
011FC:  MOV     W6,W1
011FE:  MOV     #8009,W4
01200:  CALL    EC6
01204:  BTSC.B  233.1
01206:  BRA     1204
01208:  MOV     #A,W4
0120A:  MOV     W4,234
....................  
....................  break; 
0120C:  GOTO    1716
....................  
.................... //---------------- каналы 2 и 6 --------------------------------------//   
....................  case 2:  
....................   
....................  ADC_setCh(2,1); 
01210:  MOV.B   #2,W0L
01212:  MOV.B   W0L,188C
01214:  MOV.B   #1,W0L
01216:  MOV.B   W0L,188D
01218:  CALL    6AC
....................  ADC_setCh(2,2); 
0121C:  MOV.B   #2,W0L
0121E:  MOV.B   W0L,188C
01220:  MOV.B   #2,W0L
01222:  MOV.B   W0L,188D
01224:  CALL    6AC
....................   
....................  SYNC_ADC(1);   // синхр. измерений АЦП 1 
01228:  MOV.B   #1,W0L
0122A:  MOV.B   W0L,188C
0122C:  CALL    710
....................  delay_ms(1);   
01230:  REPEAT  #1C3E
01232:  NOP     
01234:  REPEAT  #3FFF
01236:  NOP     
01238:  REPEAT  #3FFF
0123A:  NOP     
....................  SYNC_ADC(2);    // синхр. измерений АЦП 2 
0123C:  MOV.B   #2,W0L
0123E:  MOV.B   W0L,188C
01240:  CALL    710
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
01244:  BTSS.B  2D4.1
01246:  BRA     124C
01248:  GOTO    1244
....................  Printf("b%09Ld\n",ADC_read_aver(1,2)); 
0124C:  MOV.B   #1,W0L
0124E:  MOV.B   W0L,188C
01250:  MOV.B   #2,W0L
01252:  MOV.B   W0L,188D
01254:  CALL    E02
01258:  MOV     W0,W5
0125A:  MOV     W1,W6
0125C:  BTSC.B  233.1
0125E:  BRA     125C
01260:  MOV     #62,W4
01262:  MOV     W4,234
01264:  MOV     W5,W0
01266:  MOV     W6,W1
01268:  MOV     #8009,W4
0126A:  CALL    EC6
0126E:  BTSC.B  233.1
01270:  BRA     126E
01272:  MOV     #A,W4
01274:  MOV     W4,234
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 2 
01276:  BTSS.B  2D5.1
01278:  BRA     127E
0127A:  GOTO    1276
....................  Printf("f%09Ld\n",ADC_read_aver(2,3)); 
0127E:  MOV.B   #2,W0L
01280:  MOV.B   W0L,188C
01282:  MOV.B   #3,W0L
01284:  MOV.B   W0L,188D
01286:  CALL    E02
0128A:  MOV     W0,W5
0128C:  MOV     W1,W6
0128E:  BTSC.B  233.1
01290:  BRA     128E
01292:  MOV     #66,W4
01294:  MOV     W4,234
01296:  MOV     W5,W0
01298:  MOV     W6,W1
0129A:  MOV     #8009,W4
0129C:  CALL    EC6
012A0:  BTSC.B  233.1
012A2:  BRA     12A0
012A4:  MOV     #A,W4
012A6:  MOV     W4,234
....................   
....................  break; 
012A8:  GOTO    1716
....................   
.................... //---------------- каналы 3 и 7 --------------------------------------//    
....................  case 3:  
....................   
....................  ADC_setCh(3,1); 
012AC:  MOV.B   #3,W0L
012AE:  MOV.B   W0L,188C
012B0:  MOV.B   #1,W0L
012B2:  MOV.B   W0L,188D
012B4:  CALL    6AC
....................  ADC_setCh(3,2); 
012B8:  MOV.B   #3,W0L
012BA:  MOV.B   W0L,188C
012BC:  MOV.B   #2,W0L
012BE:  MOV.B   W0L,188D
012C0:  CALL    6AC
....................   
....................  SYNC_ADC(1);   // синхр. измерений АЦП 1 
012C4:  MOV.B   #1,W0L
012C6:  MOV.B   W0L,188C
012C8:  CALL    710
....................  delay_ms(1);   
012CC:  REPEAT  #1C3E
012CE:  NOP     
012D0:  REPEAT  #3FFF
012D2:  NOP     
012D4:  REPEAT  #3FFF
012D6:  NOP     
....................  SYNC_ADC(2);   // синхр. измерений АЦП 2 
012D8:  MOV.B   #2,W0L
012DA:  MOV.B   W0L,188C
012DC:  CALL    710
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
012E0:  BTSS.B  2D4.1
012E2:  BRA     12E8
012E4:  GOTO    12E0
....................  Printf("c%09Ld\n",ADC_read_aver(1,4)); 
012E8:  MOV.B   #1,W0L
012EA:  MOV.B   W0L,188C
012EC:  MOV.B   #4,W0L
012EE:  MOV.B   W0L,188D
012F0:  CALL    E02
012F4:  MOV     W0,W5
012F6:  MOV     W1,W6
012F8:  BTSC.B  233.1
012FA:  BRA     12F8
012FC:  MOV     #63,W4
012FE:  MOV     W4,234
01300:  MOV     W5,W0
01302:  MOV     W6,W1
01304:  MOV     #8009,W4
01306:  CALL    EC6
0130A:  BTSC.B  233.1
0130C:  BRA     130A
0130E:  MOV     #A,W4
01310:  MOV     W4,234
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 2 
01312:  BTSS.B  2D5.1
01314:  BRA     131A
01316:  GOTO    1312
....................  Printf("g%09Ld\n",ADC_read_aver(2,5)); 
0131A:  MOV.B   #2,W0L
0131C:  MOV.B   W0L,188C
0131E:  MOV.B   #5,W0L
01320:  MOV.B   W0L,188D
01322:  CALL    E02
01326:  MOV     W0,W5
01328:  MOV     W1,W6
0132A:  BTSC.B  233.1
0132C:  BRA     132A
0132E:  MOV     #67,W4
01330:  MOV     W4,234
01332:  MOV     W5,W0
01334:  MOV     W6,W1
01336:  MOV     #8009,W4
01338:  CALL    EC6
0133C:  BTSC.B  233.1
0133E:  BRA     133C
01340:  MOV     #A,W4
01342:  MOV     W4,234
....................   
....................  break; 
01344:  GOTO    1716
....................   
.................... //---------------- каналы 4 и 8 --------------------------------------//    
....................  case 4:  
....................   
....................  ADC_setCh(4,1); 
01348:  MOV.B   #4,W0L
0134A:  MOV.B   W0L,188C
0134C:  MOV.B   #1,W0L
0134E:  MOV.B   W0L,188D
01350:  CALL    6AC
....................  ADC_setCh(4,2); 
01354:  MOV.B   #4,W0L
01356:  MOV.B   W0L,188C
01358:  MOV.B   #2,W0L
0135A:  MOV.B   W0L,188D
0135C:  CALL    6AC
....................   
....................  SYNC_ADC(1);   // синхр. измерений АЦП 1 
01360:  MOV.B   #1,W0L
01362:  MOV.B   W0L,188C
01364:  CALL    710
....................  delay_ms(1);   
01368:  REPEAT  #1C3E
0136A:  NOP     
0136C:  REPEAT  #3FFF
0136E:  NOP     
01370:  REPEAT  #3FFF
01372:  NOP     
....................  SYNC_ADC(2);    // синхр. измерений АЦП 2 
01374:  MOV.B   #2,W0L
01376:  MOV.B   W0L,188C
01378:  CALL    710
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
0137C:  BTSS.B  2D4.1
0137E:  BRA     1384
01380:  GOTO    137C
....................  Printf("d%09Ld\n",ADC_read_aver(1,6)); 
01384:  MOV.B   #1,W0L
01386:  MOV.B   W0L,188C
01388:  MOV.B   #6,W0L
0138A:  MOV.B   W0L,188D
0138C:  CALL    E02
01390:  MOV     W0,W5
01392:  MOV     W1,W6
01394:  BTSC.B  233.1
01396:  BRA     1394
01398:  MOV     #64,W4
0139A:  MOV     W4,234
0139C:  MOV     W5,W0
0139E:  MOV     W6,W1
013A0:  MOV     #8009,W4
013A2:  CALL    EC6
013A6:  BTSC.B  233.1
013A8:  BRA     13A6
013AA:  MOV     #A,W4
013AC:  MOV     W4,234
....................  
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 2 
013AE:  BTSS.B  2D5.1
013B0:  BRA     13B6
013B2:  GOTO    13AE
....................  Printf("h%09Ld\n",ADC_read_aver(2,7)); 
013B6:  MOV.B   #2,W0L
013B8:  MOV.B   W0L,188C
013BA:  MOV.B   #7,W0L
013BC:  MOV.B   W0L,188D
013BE:  CALL    E02
013C2:  MOV     W0,W5
013C4:  MOV     W1,W6
013C6:  BTSC.B  233.1
013C8:  BRA     13C6
013CA:  MOV     #68,W4
013CC:  MOV     W4,234
013CE:  MOV     W5,W0
013D0:  MOV     W6,W1
013D2:  MOV     #8009,W4
013D4:  CALL    EC6
013D8:  BTSC.B  233.1
013DA:  BRA     13D8
013DC:  MOV     #A,W4
013DE:  MOV     W4,234
....................   
....................  Ma_buf_index++; // инкремент индекса 
013E0:  INC.B   182A
....................  if(Ma_buf_index > Ma_buf_size-1) Ma_buf_index = 0;   // сброс индекса буфера 
013E2:  MOV     182A,W4
013E4:  LSR     W4,#8,W4
013E6:  SUB     W4,#1,W0
013E8:  MOV     182A,W4
013EA:  CLR.B   9
013EC:  CP      W4,W0
013EE:  BRA     LEU,13F2
013F0:  CLR.B   182A
....................   
....................  break; 
013F2:  GOTO    1716
....................   
.................... //---------------- обработка команд с ПК ------------------------------//    
....................  case 5: 
....................   
....................  while(rdptr < wrptr){ 
013F6:  MOV.B   1870,W0L
013F8:  MOV     186C,W4
013FA:  LSR     W4,#8,W4
013FC:  CP.B    W4L,W0L
013FE:  BRA     LEU,1712
....................    U8 dg=0; 
....................    U16 buf1;  
01400:  CLR.B   1886
....................    //пока есть необработанные символы  
....................    rchr=getrxch(); 
01402:  CALL    FDA
01406:  MOV.B   W0L,1885
....................   
....................    switch(state){ 
01408:  MOV.B   186C,W0L
0140A:  CLR.B   1
0140C:  XOR     #0,W0
0140E:  BRA     Z,1426
01410:  XOR     #1,W0
01412:  BRA     Z,14B6
01414:  XOR     #3,W0
01416:  BRA     Z,1550
01418:  XOR     #1,W0
0141A:  BRA     Z,15EA
0141C:  XOR     #7,W0
0141E:  BRA     Z,162E
01420:  XOR     #1,W0
01422:  BRA     Z,1670
01424:  BRA     170C
....................           case 0: 
....................            switch (rchr){ //команды 
01426:  MOV.B   1885,W0L
01428:  CLR.B   1
0142A:  XOR     #73,W0
0142C:  BRA     Z,1440
0142E:  XOR     #3,W0
01430:  BRA     Z,1450
01432:  XOR     #17,W0
01434:  BRA     Z,1470
01436:  XOR     #11,W0
01438:  BRA     Z,147E
0143A:  XOR     #14,W0
0143C:  BRA     Z,148C
0143E:  BRA     149A
....................                case 's': stop_fl = 0; // старт измерений 
01440:  BCLR.B  81C.2
....................                          Clr_bufs(); 
01442:  CALL    412
....................                          ADC_init(); // инициализ .АЦП с новыми параметрами 
01446:  CALL    5C4
....................                          state=0; 
0144A:  CLR.B   186C
....................                break;  
0144C:  GOTO    14B2
....................                //---------- 
....................                case 'p': stop_fl = 1; // стоп измерений 
01450:  BSET.B  81C.2
....................                          printf("stopped\n\r");   
01452:  MOV     #0,W1
01454:  MOV     W1,W0
01456:  CLR.B   1
01458:  CALL    200
0145C:  INC     W1,W1
0145E:  BTSC.B  233.1
01460:  BRA     145E
01462:  MOV     W0,234
01464:  MOV     #8,W0
01466:  CPSGT   W1,W0
01468:  BRA     1454
....................                          state=0; 
0146A:  CLR.B   186C
....................                break;  
0146C:  GOTO    14B2
....................                //---------- 
....................                case 'g': state = 1; // pga_set 
01470:  MOV.B   #1,W0L
01472:  MOV.B   W0L,186C
....................                if(!stop_fl) state=0;  
01474:  BTSC.B  81C.2
01476:  BRA     147A
01478:  CLR.B   186C
....................                break; 
0147A:  GOTO    14B2
....................                //---------- 
....................                case 'v': state = 2; // sps_set 
0147E:  MOV.B   #2,W0L
01480:  MOV.B   W0L,186C
....................                if(!stop_fl) state=0;            
01482:  BTSC.B  81C.2
01484:  BRA     1488
01486:  CLR.B   186C
....................                break; 
01488:  GOTO    14B2
....................                //---------- 
....................                case 'b': state = 3; // aver_buf_size 
0148C:  MOV.B   #3,W0L
0148E:  MOV.B   W0L,186C
....................                if(!stop_fl) state=0;            
01490:  BTSC.B  81C.2
01492:  BRA     1496
01494:  CLR.B   186C
....................                break; 
01496:  GOTO    14B2
....................  
....................                default : printf("err \r\n");       
0149A:  MOV     #0,W1
0149C:  MOV     W1,W0
0149E:  CLR.B   1
014A0:  CALL    216
014A4:  INC     W1,W1
014A6:  BTSC.B  233.1
014A8:  BRA     14A6
014AA:  MOV     W0,234
014AC:  MOV     #5,W0
014AE:  CPSGT   W1,W0
014B0:  BRA     149C
....................          } // команды 
....................           break; 
014B2:  GOTO    170E
....................            
....................          case 1:  
....................          // уст. PGA 
....................             dg = ch_to_int(rchr); 
014B6:  MOV.B   1885,W0L
014B8:  MOV.B   W0L,188C
014BA:  CALL    101E
014BE:  MOV.B   W0L,1886
....................             if(dg == -1){  
014C0:  MOV     1886,W4
014C2:  XOR.B   #FF,W4L
014C4:  BRA     NZ,14E4
....................               state=0; 
014C6:  CLR.B   186C
....................               printf("PGA err \r\n");  
014C8:  MOV     #0,W1
014CA:  MOV     W1,W0
014CC:  CLR.B   1
014CE:  CALL    22A
014D2:  INC     W1,W1
014D4:  BTSC.B  233.1
014D6:  BRA     14D4
014D8:  MOV     W0,234
014DA:  MOV     #9,W0
014DC:  CPSGT   W1,W0
014DE:  BRA     14CA
....................               break; 
014E0:  GOTO    170E
....................                   } 
....................                    
....................               tmp = (U16)dg; 
014E4:  MOV.B   1886,W0L
014E6:  MOV.B   W0L,186E
014E8:  CLR.B   186F
....................                
....................             //if(stop_fl) {      
....................                if(tmp>=0 && tmp<=6){ 
014EA:  MOV     186E,W4
014EC:  CP      W4,#6
014EE:  BRA     GTU,1532
....................                   PGA_val=tmp; 
014F0:  MOV.B   186E,W0L
014F2:  MOV.B   W0L,812
....................                   printf("PGA=%u \r\n",PGA_val); 
014F4:  MOV     #0,W1
014F6:  MOV     W1,W0
014F8:  CLR.B   1
014FA:  CALL    242
014FE:  INC     W1,W1
01500:  BTSC.B  233.1
01502:  BRA     1500
01504:  MOV     W0,234
01506:  MOV     #3,W0
01508:  CPSGT   W1,W0
0150A:  BRA     14F6
0150C:  MOV.B   812,W0L
0150E:  CLR.B   1
01510:  MOV     #0,W4
01512:  CALL    10A6
01516:  BTSC.B  233.1
01518:  BRA     1516
0151A:  MOV     #20,W4
0151C:  MOV     W4,234
0151E:  BTSC.B  233.1
01520:  BRA     151E
01522:  MOV     #D,W4
01524:  MOV     W4,234
01526:  BTSC.B  233.1
01528:  BRA     1526
0152A:  MOV     #A,W4
0152C:  MOV     W4,234
....................                }  else printf("PGA out of range\r\n"); 
0152E:  GOTO    154A
01532:  MOV     #0,W1
01534:  MOV     W1,W0
01536:  CLR.B   1
01538:  CALL    258
0153C:  INC     W1,W1
0153E:  BTSC.B  233.1
01540:  BRA     153E
01542:  MOV     W0,234
01544:  MOV     #11,W0
01546:  CPSGT   W1,W0
01548:  BRA     1534
....................             //} 
....................                   state=0;      
0154A:  CLR.B   186C
....................          break; 
0154C:  GOTO    170E
....................           
....................          case 2:  
....................          // уст. SPS 
....................             dg = ch_to_int(rchr); 
01550:  MOV.B   1885,W0L
01552:  MOV.B   W0L,188C
01554:  CALL    101E
01558:  MOV.B   W0L,1886
....................             if(dg == -1){  
0155A:  MOV     1886,W4
0155C:  XOR.B   #FF,W4L
0155E:  BRA     NZ,157E
....................               state=0; 
01560:  CLR.B   186C
....................               printf("SPS err \r\n");  
01562:  MOV     #0,W1
01564:  MOV     W1,W0
01566:  CLR.B   1
01568:  CALL    278
0156C:  INC     W1,W1
0156E:  BTSC.B  233.1
01570:  BRA     156E
01572:  MOV     W0,234
01574:  MOV     #9,W0
01576:  CPSGT   W1,W0
01578:  BRA     1564
....................               break; 
0157A:  GOTO    170E
....................                   } 
....................                    
....................               tmp = (U16)dg; 
0157E:  MOV.B   1886,W0L
01580:  MOV.B   W0L,186E
01582:  CLR.B   186F
....................                    
....................             if(tmp>=0 && tmp<=7){ 
01584:  MOV     186E,W4
01586:  CP      W4,#7
01588:  BRA     GTU,15CC
....................                ADC_sps_var = tmp; 
0158A:  MOV.B   186E,W0L
0158C:  MOV.B   W0L,81E
....................                printf("SPS=%u \r\n",ADC_sps_var); 
0158E:  MOV     #0,W1
01590:  MOV     W1,W0
01592:  CLR.B   1
01594:  CALL    290
01598:  INC     W1,W1
0159A:  BTSC.B  233.1
0159C:  BRA     159A
0159E:  MOV     W0,234
015A0:  MOV     #3,W0
015A2:  CPSGT   W1,W0
015A4:  BRA     1590
015A6:  MOV.B   81E,W0L
015A8:  CLR.B   1
015AA:  MOV     #0,W4
015AC:  CALL    10A6
015B0:  BTSC.B  233.1
015B2:  BRA     15B0
015B4:  MOV     #20,W4
015B6:  MOV     W4,234
015B8:  BTSC.B  233.1
015BA:  BRA     15B8
015BC:  MOV     #D,W4
015BE:  MOV     W4,234
015C0:  BTSC.B  233.1
015C2:  BRA     15C0
015C4:  MOV     #A,W4
015C6:  MOV     W4,234
....................                } else printf("SPS out of range\r\n"); 
015C8:  GOTO    15E4
015CC:  MOV     #0,W1
015CE:  MOV     W1,W0
015D0:  CLR.B   1
015D2:  CALL    2A6
015D6:  INC     W1,W1
015D8:  BTSC.B  233.1
015DA:  BRA     15D8
015DC:  MOV     W0,234
015DE:  MOV     #11,W0
015E0:  CPSGT   W1,W0
015E2:  BRA     15CE
....................                   state=0;      
015E4:  CLR.B   186C
....................          break; 
015E6:  GOTO    170E
....................           
....................          case 3:  
....................          // уст. размера буфера усреднения 
....................             dg = ch_to_int(rchr); 
015EA:  MOV.B   1885,W0L
015EC:  MOV.B   W0L,188C
015EE:  CALL    101E
015F2:  MOV.B   W0L,1886
....................             if(dg == -1){  
015F4:  MOV     1886,W4
015F6:  XOR.B   #FF,W4L
015F8:  BRA     NZ,1618
....................               state=0; 
015FA:  CLR.B   186C
....................               printf("err p1 \r\n");  
015FC:  MOV     #0,W1
015FE:  MOV     W1,W0
01600:  CLR.B   1
01602:  CALL    2C6
01606:  INC     W1,W1
01608:  BTSC.B  233.1
0160A:  BRA     1608
0160C:  MOV     W0,234
0160E:  MOV     #8,W0
01610:  CPSGT   W1,W0
01612:  BRA     15FE
....................               break; 
01614:  GOTO    170E
....................                   } 
....................           // 1 цифра    
....................           tmp=0; 
01618:  CLR     186E
....................           tmp+=(U16)dg*100; 
0161A:  MOV.B   1886,W0L
0161C:  MOV.B   W0L,A
0161E:  CLR.B   B
01620:  MOV     #64,W4
01622:  MUL.UU  W5,W4,W0
01624:  ADD     186E
....................           state=4; 
01626:  MOV.B   #4,W0L
01628:  MOV.B   W0L,186C
....................            
....................          break; 
0162A:  GOTO    170E
....................           
....................          case 4:  
....................          // уст. размера буфера усреднения 
....................             dg = ch_to_int(rchr); 
0162E:  MOV.B   1885,W0L
01630:  MOV.B   W0L,188C
01632:  CALL    101E
01636:  MOV.B   W0L,1886
....................             if(dg == -1){  
01638:  MOV     1886,W4
0163A:  XOR.B   #FF,W4L
0163C:  BRA     NZ,165C
....................               state=0; 
0163E:  CLR.B   186C
....................               printf("err p2 \r\n");  
01640:  MOV     #0,W1
01642:  MOV     W1,W0
01644:  CLR.B   1
01646:  CALL    2DC
0164A:  INC     W1,W1
0164C:  BTSC.B  233.1
0164E:  BRA     164C
01650:  MOV     W0,234
01652:  MOV     #8,W0
01654:  CPSGT   W1,W0
01656:  BRA     1642
....................               break; 
01658:  GOTO    170E
....................                   } 
....................           // 2 цифра         
....................           tmp+=(U16)dg*10; 
0165C:  MOV.B   1886,W0L
0165E:  MOV.B   W0L,A
01660:  CLR.B   B
01662:  MOV     W5,W4
01664:  MUL.UU  W4,#A,W0
01666:  ADD     186E
....................           state=5; 
01668:  MOV.B   #5,W0L
0166A:  MOV.B   W0L,186C
....................            
....................          break; 
0166C:  GOTO    170E
....................           
....................          case 5:  
....................          // уст. размера буфера усреднения 
....................             dg = ch_to_int(rchr); 
01670:  MOV.B   1885,W0L
01672:  MOV.B   W0L,188C
01674:  CALL    101E
01678:  MOV.B   W0L,1886
....................             if(dg == -1){  
0167A:  MOV     1886,W4
0167C:  XOR.B   #FF,W4L
0167E:  BRA     NZ,169E
....................               state=0; 
01680:  CLR.B   186C
....................               printf("err p3 \r\n");  
01682:  MOV     #0,W1
01684:  MOV     W1,W0
01686:  CLR.B   1
01688:  CALL    2F2
0168C:  INC     W1,W1
0168E:  BTSC.B  233.1
01690:  BRA     168E
01692:  MOV     W0,234
01694:  MOV     #8,W0
01696:  CPSGT   W1,W0
01698:  BRA     1684
....................               break; 
0169A:  GOTO    170E
....................                   } 
....................           // 3 цифра  
....................           tmp+=(U16)dg; 
0169E:  MOV.B   1886,W0L
016A0:  CLR.B   1
016A2:  ADD     186E
....................           if(tmp>=0 && tmp<=128){ 
016A4:  MOV     186E,W4
016A6:  MOV     #80,W3
016A8:  CP      W3,W4
016AA:  BRA     NC,16EE
....................                        Ma_buf_size=(U8)tmp;// прочитаны все 3 цифры без ошибок 
016AC:  MOV.B   186E,W0L
016AE:  MOV.B   W0L,182B
....................                        printf("aver buf size=%u \r\n",Ma_buf_size); 
016B0:  MOV     #0,W1
016B2:  MOV     W1,W0
016B4:  CLR.B   1
016B6:  CALL    308
016BA:  INC     W1,W1
016BC:  BTSC.B  233.1
016BE:  BRA     16BC
016C0:  MOV     W0,234
016C2:  MOV     #D,W0
016C4:  CPSGT   W1,W0
016C6:  BRA     16B2
016C8:  MOV.B   182B,W0L
016CA:  CLR.B   1
016CC:  MOV     #0,W4
016CE:  CALL    10A6
016D2:  BTSC.B  233.1
016D4:  BRA     16D2
016D6:  MOV     #20,W4
016D8:  MOV     W4,234
016DA:  BTSC.B  233.1
016DC:  BRA     16DA
016DE:  MOV     #D,W4
016E0:  MOV     W4,234
016E2:  BTSC.B  233.1
016E4:  BRA     16E2
016E6:  MOV     #A,W4
016E8:  MOV     W4,234
....................           } else printf("aver buf out of range\r\n"); 
016EA:  GOTO    1706
016EE:  MOV     #0,W1
016F0:  MOV     W1,W0
016F2:  CLR.B   1
016F4:  CALL    328
016F8:  INC     W1,W1
016FA:  BTSC.B  233.1
016FC:  BRA     16FA
016FE:  MOV     W0,234
01700:  MOV     #16,W0
01702:  CPSGT   W1,W0
01704:  BRA     16F0
....................            
....................           state=0; 
01706:  CLR.B   186C
....................            
....................          break; 
01708:  GOTO    170E
....................           
....................         default : state=0;    
0170C:  CLR.B   186C
....................       } // state    
0170E:  GOTO    13F6
....................    } // while 
....................     
....................      break; 
01712:  GOTO    1716
....................    } // main case 
01716:  MOV     [--W15],W6
01718:  MOV     [--W15],W5
0171A:  RETURN  
.................... } 
....................  
.................... static void save_to_flash(){ 
....................        
....................    Sps_Wr = NumAver; 
....................    Aver_Wr = ADC_sps_var; // сохранение sps значения во флеш 
....................    CRC_Wr = CRC8(flash_wr_data,2); 
....................    Wr_Flash(); 
....................    }  
....................  
.................... #int_timer1 
.................... static void timer1_irq_handler(void) { 
*
0034C:  PUSH    42
0034E:  PUSH    36
00350:  PUSH    32
00352:  MOV     W0,[W15++]
00354:  MOV     #2,W0
00356:  REPEAT  #C
00358:  MOV     [W0++],[W15++]
.................... restart_wdt();     // сбос собачего таймера 
0035A:  CLRWDT  
.................... set_timer1(20000); //reset the timer. 
0035C:  MOV     #4E20,W4
0035E:  MOV     W4,100
.................... clear_interrupt(int_timer1); 
00360:  BCLR.B  84.3
.................... } 
....................  
00362:  BCLR.B  84.3
00364:  MOV     #1A,W0
00366:  REPEAT  #C
00368:  MOV     [--W15],[W0--]
0036A:  MOV     [--W15],W0
0036C:  POP     32
0036E:  POP     36
00370:  POP     42
00372:  RETFIE  
.................... #INT_RDA2 
.................... void UART2_RXd_isr(void){ 
00374:  PUSH    42
00376:  PUSH    36
00378:  PUSH    32
0037A:  MOV     W0,[W15++]
0037C:  MOV     #2,W0
0037E:  REPEAT  #C
00380:  MOV     [W0++],[W15++]
....................  
.................... //while(U2STA & 0x0001) 
.................... //{ //if(U2STA & 2) { U2STA = 0x0000; } 
....................    //printf("%X", 0x00FF & U2RXREG); 
.................... //  U2TXREG = 0x00FF & U2RXREG;  
.................... //} 
....................  
.................... while(U2STA & 0x0001) 
00382:  MOV     232,W0
00384:  AND     W0,#1,W0
00386:  CP0     W0
00388:  BRA     Z,39E
.................... { // Receive buffer has data, at least one more character can be read 
....................    wrptr++; 
0038A:  INC.B   186D
....................    RxData[wrptr & 0x0F] = (U8)(U2RXREG); 
0038C:  MOV.B   186D,W0L
0038E:  CLR.B   1
00390:  AND     W0,#F,W5
00392:  MOV     #1872,W4
00394:  ADD     W5,W4,W6
00396:  MOV     236,W0
00398:  MOV.B   W0L,[W6+#0]
0039A:  GOTO    382
....................    
.................... } 
0039E:  BCLR.B  87.6
003A0:  MOV     #1A,W0
003A2:  REPEAT  #C
003A4:  MOV     [--W15],[W0--]
003A6:  MOV     [--W15],W0
003A8:  POP     32
003AA:  POP     36
003AC:  POP     42
003AE:  RETFIE  
.................... } 
....................  
.................... /*############################################################################*/ 
....................  
.................... static void main() 
*
0171C:  MOV     #1F80,W15
0171E:  MOV     #1FFF,W0
01720:  MOV     W0,20
01722:  NOP     
01724:  MOV     #4444,W0
01726:  MOV     W0,A4
01728:  BSET.B  81.7
0172A:  BCLR.B  261.7
0172C:  BCLR.B  2E5.0
0172E:  BSET.B  2E4.7
01730:  BCLR.B  2E4.6
01732:  BCLR.B  260.6
01734:  MOV     #3B,W4
01736:  MOV     W4,262
01738:  BSET.B  261.7
0173A:  CLR     806
0173C:  MOV     #8000,W4
0173E:  MOV     W4,230
01740:  MOV     #400,W4
01742:  MOV     W4,232
01744:  BSET.B  230.3
01746:  MOV     #56,W4
01748:  MOV     W4,238
0174A:  MOV.B   #3,W0L
0174C:  MOV.B   W0L,812
0174E:  CLR.B   813
01750:  CLR.B   818
01752:  CLR.B   819
01754:  CLR.B   81A
01756:  CLR.B   81B
01758:  BCLR.B  81C.0
0175A:  BCLR.B  81C.1
0175C:  BCLR.B  81C.2
0175E:  MOV.B   #1,W0L
01760:  MOV.B   W0L,81D
01762:  MOV.B   #1,W0L
01764:  MOV.B   W0L,81E
01766:  MOV.B   #FF,W0L
01768:  MOV.B   W0L,81F
0176A:  SETM.B  820
0176C:  CLR.B   182A
0176E:  MOV.B   #10,W0L
01770:  MOV.B   W0L,182B
01772:  CLR     186E
01774:  CLR.B   186D
01776:  CLR.B   1870
01778:  SETM    32C
0177A:  SETM    32A
0177C:  CLR     800
0177E:  MOV     #7600,W4
01780:  MOV     W4,808
01782:  MOV     #3254,W4
01784:  MOV     W4,80A
01786:  MOV     #10,W4
01788:  MOV     W4,80C
0178A:  CLR     80E
0178C:  CLR.B   810
0178E:  CLR     814
01790:  CLR     816
01792:  CLR     1872
01794:  CLR     1874
01796:  CLR     1876
01798:  CLR     1878
0179A:  CLR     187A
0179C:  CLR     187C
0179E:  CLR     187E
017A0:  CLR     1880
017A2:  MOV.B   #1,W0L
017A4:  MOV.B   W0L,1882
.................... {  
....................   U8 ch = 1;             // начальная установка канала измерений АЦП 
....................  
....................   OscSetup(); 
017A6:  CALL    3B0
....................   MCU_init();  
017AA:  CALL    3DC
....................   //Rd_Flash();                        // чтение денных из флеш для расчета контр. суммы 
....................   //crc1 = CRC_buf;                    // сохраненная контр. сумма     
....................   //crc2 = CRC8(flash_rd_data,2);      // текущая контр. сумма 
....................    
....................   Clr_bufs(); 
017AE:  CALL    412
....................    
....................   ADC_sps_var = 0;   // сброс значений по умолчанию  
017B2:  CLR.B   81E
....................   NumAver = 1;       // тк произошел сбой контр. суммы 
017B4:  MOV.B   #1,W0L
017B6:  MOV.B   W0L,81D
....................       
....................   ADC_RESET = 1; ADC2_RESET = 1; 
017B8:  BSET.B  2D6.3
017BA:  BSET.B  2D6.0
....................   ADC_CS = 1;    ADC2_CS = 1; 
017BC:  BSET.B  2E9.1
017BE:  BSET.B  2D7.2
....................   ADC_SYNC = 1;  ADC2_SYNC = 1;  
017C0:  BSET.B  2D6.2
017C2:  BSET.B  2D7.3
....................       
....................   While(ADC_DRDY | ADC2_DRDY) { }   // ждем готовности обоих АЦП перед иниц.   
017C4:  CLR     W0
017C6:  BTSC.B  2D4.1
017C8:  INC     W0,W0
017CA:  MOV.B   W0L,W6L
017CC:  CLR     W0
017CE:  BTSC.B  2D5.1
017D0:  INC     W0,W0
017D2:  IOR.B    W6L,  W0L,W0L
017D4:  CP0.B   W0L
017D6:  BRA     Z,17DC
017D8:  GOTO    17C4
....................    
....................   ADC_init();        // Инициализация обоих АЦП  
017DC:  CALL    5C4
....................    
.................... /*############################################################################*/   
....................  
....................   while(true){ 
....................    
....................   ADC_Par_rd_and_print_ch(ch); // чтение 8 каналов двух АЦП 
017E0:  MOV.B   1882,W0L
017E2:  MOV.B   W0L,1884
017E4:  CALL    1158
....................    
....................   ch++;                    // инкремент номера канала 
017E8:  INC.B   1882
....................   if (ch > 5) ch = 1; // диапазон каналов 
017EA:  MOV     1882,W4
017EC:  CP.B    W4L,#5
017EE:  BRA     LEU,17F4
017F0:  MOV.B   #1,W0L
017F2:  MOV.B   W0L,1882
....................    
....................   if (stop_fl) ch = 5; // остановить измерения 
017F4:  BTSS.B  81C.2
017F6:  BRA     17FC
017F8:  MOV.B   #5,W0L
017FA:  MOV.B   W0L,1882
017FC:  GOTO    17E0
....................  
....................  
....................  } // while   
.................... }  // main 
.................... /*############################################################################*/ 
01800:  PWRSAV  #0
....................  

Configuration Fuses:
   Word  1L: 00CE   WRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0083   PR_PLL IESO
          H: FF00  
   Word  5L: 0006   HS NOOSCIO CKSFSM
          H: FF00  
   Word  6L: 00DD   WPOSTS14 WPRES128 WINDIS WDT
          H: FF00  
   Word  7L: 00E7   PUT128
          H: FF00  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: FF00  
