// изменена для версии PoE без дисплея
// 13.05.15

static U8 RdReg(U8 RegName)
{
   U8 RegValue = 0; 
   //1st Command Byte: 0001 rrrr where rrrr is the address of the first register to read.
   //2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to read – 1
   ADC_CS = 0;
   delay_us(1);
   Spi_write2(0x10+RegName); // 1st Command Byte,??????? ??????
   Spi_write2(0x00); // 1st Command Byte, ?????? ?????? ???? ????
   delay_us(8); // 50 CLK_IN PEDIODS
   RegValue = Spi_read2(0);
   delay_us(1);
   ADC_CS =1;
   delay_us(1);
   Return RegValue;  
}

static void WrReg(U8 RegName,CommandByte)
{
   ADC_CS = 0;
   //ADC2_CS = 0;
   delay_us(5);
   Spi_write2(0x50+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written.
   delay_us(10);
   Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1.
   delay_us(10);
   Spi_write2(CommandByte);
   delay_us(10);
   ADC_CS = 1;
   //ADC2_CS = 1;
   delay_us(2);
   
   //ADC_CS = 0;
   ADC2_CS = 0;
   delay_us(5);
   Spi_write2(0x50+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written.
   delay_us(10);
   Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1.
   delay_us(10);
   Spi_write2(CommandByte);
   delay_us(10);
   //ADC_CS = 1;
   ADC2_CS = 1;
   
   delay_us(20);
}

static void ADC_StopRd(){
   
  ADC_CS = 0;
  Spi_write2(0x0F);        // стоп
  delay_us(10);
  ADC_CS = 1;
}

static void ADC_sps_set(U8 SPS){

   ADC_StopRd();                                                              
   Sps_buf = SPS;
   WrReg(DRATE,SPS); 
                 
        
}

static void ADC_set_PGA(u8 PGA_val){
  
  PGA = PGA_val;

/* PGA
000 = 1 (default)
001 = 2
010 = 4
011 = 8
100 = 16
101 = 32
110 = 64
111 = 64*/
/**/

   switch (PGA_val){
      case 1:
       WrReg(ADCON,0);
      break;
      
      case 2:
       WrReg(ADCON,1);
      break;
      
      case 4:
       WrReg(ADCON,2);
      break;
      
      case 8:
       WrReg(ADCON,3);
      break;
      
      case 16:
       WrReg(ADCON,4);
      break;
      
      case 32:
       WrReg(ADCON,5);
      break;
      
      case 64:
       WrReg(ADCON,6);
      break; 
   }
}

static void ADC_wakeUp(void){
/*
   ADC_RESET = 1;
   ADC2_RESET = 1;
    
   delay_us(500);

   ADC_CS = 0;
   ADC2_CS = 0;
   
   delay_us(20);
   Spi_write2(0x0F);  
   delay_us(20);
   
   WrReg(STATUS,2);
   delay_us(20);
   
   ADC_set_PGA(8);
   delay_us(20);
   
   if(ADC_sps_var>7)  ADC_sps_var = 7;
   if(ADC_sps_var==0) ADC_sps_var = 1;
    switch (ADC_sps_var){                // передача величины скорости измерений АЦП 
      case 1: ADC_sps_set(0x23);  break; // 10   sps
      case 2: ADC_sps_set(0x43);  break; // 25   sps
      case 3: ADC_sps_set(0x63);  break; // 50   sps
      case 4: ADC_sps_set(0x82);  break; // 100  sps
      case 5: ADC_sps_set(0x91);  break; // 500  sps
      case 6: ADC_sps_set(0xA1);  break; // 1000 sps
      case 7: ADC_sps_set(0xC0);  break; // 3750 sps
      }
      
   delay_us(20);    
   ADC_CS = 1;
   ADC2_CS = 1;
   delay_us(200);
*/

   ADC_CS = 1;
   ADC2_CS = 1;
   
   ADC_RESET = 0; //When using the RESET pin, take it low to force a reset.
   ADC2_RESET = 0; //When using the RESET pin, take it low to force a reset.
   delay_us(200);
   
   ADC_RESET = 1;
   ADC2_RESET = 1;
   
   ADC_SYNC =0;
   ADC2_SYNC =0;   
   delay_us(200);
   
   ADC_SYNC = 1; //To use the SYNC/PDWN pin, take it low and then high
   ADC2_SYNC = 1; //To use the SYNC/PDWN pin, take it low and then high
   
   delay_ms(2);


}

static void ADC1_Sync_cmd(void){
   
   //ADC_SYNC =0;
   //delay_us(200);
   //ADC_SYNC =1;
   //delay_us(5);
   
   //ADC_CS = 0;
   //ADC2_CS = 0;
   //delay_us(1);
   Spi_write2(0xfc);
    //delay_us(1);
   //ADC_CS = 1;
   //ADC2_CS = 1;
   
}

static void ADC_WakeUp_cmd(void){
                     
   ADC_CS = 0;
   ADC2_CS = 0;
   delay_us(1);
   Spi_write2(0x00);
   delay_us(1);
   ADC_CS = 1;
   ADC2_CS = 1;
}

static S32 ADC_RData(){

     ADC_CS = 0;
     delay_us(1);
     Spi_write2(0x01);
     delay_us(1);
     ADC_CS = 1;
     delay_us(1);
     m1:
     if(!ADC_DRDY){
     ADC_CS = 0;
     delay_us(1);
     ADC_Rbyte1 = Spi_read2(0);
     ADC_Rbyte2 = Spi_read2(0);
     ADC_Rbyte3 = Spi_read2(0);
     delay_us(1);
     ADC_CS = 1;
     ADC_RByte_Sum = (ADC_Rbyte1<<16) + (ADC_Rbyte2<<8) + ADC_Rbyte3;
     return ADC_RByte_Sum;
     }
     else goto m1;
}

static void ADC_StartRdContin(){

     //ADC_CS = 0;
     //ADC2_CS = 0;
     //delay_us(1);                                         
     Spi_write2(0x03);             
     delay_us(10);
     //ADC_CS = 1;
     //ADC2_CS = 1;
}

static S32 ADC_RdataC(){                                              
                                                                  
     ADC_CS = 0;
     //ADC2_CS = 0;
     delay_us(1);                                        
     Spi_write2(0x03);// Rdata_contin
     delay_us(3);
     //ADC_CS = 1;
     //ADC2_CS = 1;
     
      While(ADC_DRDY) { }
      ADC_CS = 0;
      delay_us(3);
      ADC_Rbyte1 = Spi_read2(0);
      ADC_Rbyte2 = Spi_read2(0);
      ADC_Rbyte3 = Spi_read2(0);
      delay_us(3);
      //ADC_CS = 1;
     
      //While(ADC2_DRDY)
      //ADC2_CS = 0;
      //delay_us(1);
      //ADC2_Rbyte1 = Spi_read2(0);
      //ADC2_Rbyte2 = Spi_read2(0);
      //ADC2_Rbyte3 = Spi_read2(0);
      //delay_us(1);
      //ADC2_CS = 1;  
     
     ADC_RByte_Sum = (ADC_Rbyte1<<24) + (ADC_Rbyte2<<16) + (ADC_Rbyte3<<8);
     ADC2_RByte_Sum = (ADC2_Rbyte1<<24) + (ADC2_Rbyte2<<16) + (ADC2_Rbyte3<<8);
     ADC2_RByte_Sum = ADC2_RByte_Sum/256;
     return ADC_RByte_Sum/256;
     
     }

/**/
/**/

static void ADC_SelfCal(){
                     
   ADC_CS = 0;
   ADC2_CS = 0;
   delay_us(1);
   Spi_write2(0xF0);
    delay_us(1);
   ADC_CS = 1;
   ADC2_CS = 1;
   Switch (Sps_buf) {     
    
      case 0xF0:   
       delay_us(220);        
        break;                      
      
      case 0xE0:
       delay_us(255); 
        break;
        
      case 0xD0:
       delay_us(315); 
        break;
        
      case 0xC0:
       delay_us(445); 
        break;
        
      case 0xB0:
       delay_us(685); 
        break;
        
      case 0xA1:
       delay_ms(1);
       delay_us(185);               
        break;      
        
      case 0x92:
       delay_ms(5);
        break;
        
      case 0x82:
       delay_ms(10);
       delay_us(200);
        break;
                   
      case 0x63:
       delay_ms(21); 
        break;
        
      case 0x43:
       delay_ms(41); 
        break;
        
      case 0x23:
       delay_ms(101); 
        break;         
            
      case 0x13:
       delay_ms(201); 
        break;                          
     }
     
}

static void ADC_setCh(U8 Ch_Number){

  Spi_write2(0x50+MUX);    
  delay_us(10);
  Spi_write2(0);         
  delay_us(10);
  Spi_write2(Mx_ch_code[Ch_Number]);
    
}

static S32 Double_ADC_Rd_data(U8 channel){

    Switch (channel) {
    
    case 4: WrReg(MUX,0x10); break;
    case 3: WrReg(MUX,0x32); break;
    case 2: WrReg(MUX,0x54); break;
    case 1: WrReg(MUX,0x76); break;
    
           }
                                                                  
     While(ADC_DRDY) {}
     ADC_CS = 0;
     delay_us(2);
     Spi_write2(0x50+MUX); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written.
     delay_us(10);
     Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1.
     delay_us(10);
     Spi_write2(channel);
     delay_us(50);
     //ADC1_Sync_cmd();
     Spi_write2(0xfc);
     delay_us(10);
     //ADC_WakeUp_cmd();
     Spi_write2(0x00);
     delay_us(10);
     //ADC2_CS = 0;
     //delay_us(1);                                        
     //Spi_write2(0x03);// Rdata_contin
     Spi_write2(0x01);  // Rdata_single
     //delay_us(1);
     //ADC_CS = 1;
     //ADC2_CS = 1;
     
     delay_us(50);
     //ADC_CS = 0;
     ADC_Rbyte1 = Spi_read2(0);
     ADC_Rbyte2 = Spi_read2(0);
     ADC_Rbyte3 = Spi_read2(0);
     delay_us(10);
     ADC_CS = 1;
      //    }
     
     //else {
     /*
      While(ADC2_DRDY)
      delay_us(1);
      ADC2_CS = 0;
      delay_us(1);
      ADC2_Rbyte1 = Spi_read2(0);
      ADC2_Rbyte2 = Spi_read2(0);
      ADC2_Rbyte3 = Spi_read2(0);
      delay_us(1);
      ADC2_CS = 1;  
      */
      //    }
     
     ADC_RByte_Sum = (ADC_Rbyte1<<24) | (ADC_Rbyte2<<16) | (ADC_Rbyte3<<8);
     //ADC2_RByte_Sum = (ADC2_Rbyte1<<24) + (ADC2_Rbyte2<<16) + (ADC2_Rbyte3<<8);
     //ADC2_RByte_Sum = ADC2_RByte_Sum/256;
     return ADC_RByte_Sum/256;
     
     }

static S32 Read_ADC_vol_in(S32 k){

    S32 VinInt = 0;
    
    ADCresult = ADC_RDataC();
    ADCresult=ADCresult+ADCaddCoef; // Аддитивная ошибка, ошибка смещения
    
    Vin = ((ADCresult*5)/(8388608.0*PGA))*ADCmulCoef;
    //Vin2 = ((ADC2_RByte_Sum*5)/(8388608.0*PGA))*ADCmulCoef;
    
    //VinInt2 = Vin2*k;
    VinInt = Vin*k;
    
    return VinInt;
}

static S32 ADC_ch_v_read(U8 channel){

    S32 VinInt = 0;
    
    ADCresult = Double_ADC_Rd_data(channel);
    ADCresult=ADCresult+ADCaddCoef; // Аддитивная ошибка, ошибка смещения
    
    Vin = ((ADCresult*5)/(8388608.0*PGA));//*ADCmulCoef;
    //Vin2 = ((ADC2_RByte_Sum*5)/(8388608.0*PGA))*ADCmulCoef;
    
    //VinInt2 = Vin2*k;
    VinInt = Vin*1000000;
    
    return VinInt;
}
 
static S32 ADC_vol_average(U8 NumSamples){
   
   S32 A,Sum = 0;               
   U8 i;
   
   for (i=0;i<NumSamples;i++){
       
       A = Read_ADC_vol_in(uV);
       Sum = Sum + A;    
   }                                  
   return Sum/NumSamples;
}

static void ADC_init(){
   
  WrReg(STATUS,2);
  delay_us(20);
      //
   if(ADC_sps_var>7)  ADC_sps_var = 7;
    switch (ADC_sps_var){                // передача величины скорости измерений АЦП 
      case 0: ADC_sps_set(0x13);  break; // 5   sps
      case 1: ADC_sps_set(0x23);  break; // 10   sps
      case 2: ADC_sps_set(0x43);  break; // 25   sps
      case 3: ADC_sps_set(0x63);  break; // 50   sps
      case 4: ADC_sps_set(0x82);  break; // 100  sps
      case 5: ADC_sps_set(0x91);  break; // 500  sps
      case 6: ADC_sps_set(0xA1);  break; // 1000 sps
      case 7: ADC_sps_set(0xC0);  break; // 3750 sps
      }

}

static float power(float t, U8 k) // возведение t в степень k
{
  float res = 1.0;
  while (k) 
      {
        if (k & 1) 
           res *= t;
        t *= t;
        k >>= 1;
      }
  return res;
}

static ADC_read_ch (U8 channel)
  {
  
   if (channel > 4) ADC_select = 1;
   else ADC_select = 0;
   
   Switch (channel) 
   {
    // мультиплексирование каналов
    case 4: channel = 0x10; break;
    case 3: channel = 0x32; break;
    case 2: channel = 0x54; break;
    case 1: channel = 0x76; break;
    
    case 8: channel = 0x10; break;
    case 7: channel = 0x32; break;
    case 6: channel = 0x54; break;
    case 5: channel = 0x76; break;
    }
  
  if (ADC_select) {ADC_CS = 1; ADC2_CS = 0;}
  else            {ADC_CS = 0; ADC2_CS = 1;}
  
  Spi_write2(0x50+MUX);    // уст. канал 1 АЦП
  delay_us(10);
  Spi_write2(0);         
  delay_us(10);
  Spi_write2(channel);
  ADC_CS = 1;
  ADC2_CS = 1;
  //-------------------- 1 АЦП ----------------------------------//
  
  if (ADC_select) 
  {
      While(ADC2_DRDY) { } // ждем готовности АЦП 2
  }
  else            
  {
      While(ADC_DRDY) { } // ждем готовности АЦП 1
  }
  
  //While(ADC_DRDY) { }     // ждем готовности данных 1 АЦП
  
  if (ADC_select) {ADC_CS = 1; ADC2_CS = 0;}
  else            {ADC_CS = 0; ADC2_CS = 1;}
  
  Spi_write2(0x03);        // команда чтения
  delay_us(3);
  ADC_CS = 1;
  ADC2_CS = 1;
  
  delay_us(20);
  
  if (ADC_select) {ADC_CS = 1; ADC2_CS = 0;}
  else            {ADC_CS = 0; ADC2_CS = 1;}
  
  ADC_Rbyte1 = Spi_read2(0);   // чтение
  ADC_Rbyte2 = Spi_read2(0);
  ADC_Rbyte3 = Spi_read2(0);
  delay_us(3);
  ADC_CS = 1;
  ADC2_CS = 1;
   
 // While(ADC_DRDY) { }      // ждем готовности данных 1 АЦП
  
  //ADC_CS = 0;
  //delay_us(3);
  //Spi_write2(0x0F);        // стоп 1 АЦП  
  //ADC_CS = 1;
  //delay_us(10);
  
  //-------------------- Преобразование ----------------------------------//
  
  ADC_RByte_Sum = ((S32)ADC_Rbyte1<<24) | ((S32)ADC_Rbyte2<<16) | ((S32)ADC_Rbyte3<<8);
  ADC_RByte_Sum = ADC_RByte_Sum/256;
  
  //ADC2_RByte_Sum = ((S32)ADC2_Rbyte1<<24) | ((S32)ADC2_Rbyte2<<16) | ((S32)ADC2_Rbyte3<<8);
  //ADC2_RByte_Sum = ADC2_RByte_Sum/256;
  
  }
  
  static void ADC_stop(void)
  {
  
   if (ADC_select) 
  {
      While(ADC2_DRDY) { } // ждем готовности АЦП 2
  }
  else            
  {
      While(ADC_DRDY) { } // ждем готовности АЦП 1
  }
  
   if    (ADC_select) {ADC_CS = 1; ADC2_CS = 0;}
   else  {ADC_CS = 0; ADC2_CS = 1;}
   
   delay_us(3);
   Spi_write2(0x0F);        // стоп 1 АЦП  
   ADC_CS = 1;
   ADC2_CS = 1;
   delay_us(10);
  }
  
  static void ADC_select(U8 command)
  {
   switch(command)
   {
         case 0: ADC_CS = 1; ADC2_CS = 1; break;
         case 1: ADC_CS = 0; ADC2_CS = 1; break;
         case 2: ADC_CS = 1; ADC2_CS = 0; break;
   }
  }
  
  static S32 ADC_read()
  {
  
  S32 ADC_RByte_Sum;
  float Vin;
  
  Spi_write2(0x03);        // команда чтения
  delay_us(20);
  ADC_Rbyte1 = Spi_read2(0);   // чтение
  ADC_Rbyte2 = Spi_read2(0);
  ADC_Rbyte3 = Spi_read2(0);
  
  ADC_RByte_Sum = ((S32)ADC_Rbyte1<<24) | ((S32)ADC_Rbyte2<<16) | ((S32)ADC_Rbyte3<<8);
  ADC_RByte_Sum = ADC_RByte_Sum/256;
  
  Vin = ((ADC_RByte_Sum*5)/(8388608.0*PGA));
  
  return Vin*uV;
  
  }
