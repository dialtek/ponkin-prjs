#include <main.h>
#INCLUDE <stdlib.h>
#use rs232(UART2,xmit=PIN_F5,rcv=PIN_F4,baud=230400,BRGH1OK,ERRORS,parity=N,bits=8)
 
    // коды каналов мультиплексора..
    U8 Mx_ch_code[9] = {0, 0x76, 0x54, 0x32, 0x10};

    U8 PGA;
    U8 PGA_val = 3; // PGA = 8
    U8 Sps_buf=0;
    //S16 ADCaddCoef = 1;
    //float ADCmulCoef = 1;
   
   U8 flash_wr_data [] = {0,0,0,0}; // заготовка массива для записи во флэш
   U8 Aver_Wr = 0;
   U8 Sps_Wr = 0;
   U8 CRC_Wr = 0;
   U8 ADC_select = 0; // флаг выбора АЦП: 1ый или 2ой

   int1 meas_stop_fl = 0;
   int1 reset_fl = 0;    // флаг сброса системы
   int1 stop_fl = 0;
   
   U8 NumAver = 1;       // размер усреднения
   U8 ADC_sps_var = 1;   // переменная усреднения данных АЦП 
   U8 CRC1=0xFF,CRC2=0xFF, EE_CRC_buf;   // константы EEPROM CRC
   U8 flash_rd_data[4]; // заготовка массива для чтения из флэш

   //Ma - Moving Average
   S32 Ch_buf[8][128];  // буфер скользящего среднего для к1
   S32 Ch_buf_sum;     // сумма буфера скользящего среднего для к1

   U8 Ma_buf_index = 0; // индекс элемента скользящ. средн.
   U8 Ma_buf_size = 16;  // РАЗМЕР БУФЕРА!!!

   U8 state;
   U16 tmp=0;

   #include <ADS1256.h>
   
//================================ state-machine ===============================
#define detect_dev_id      10      // ??? 0 ????????? ???.????????
#define get_cmd_header     11      // ??? 1 ????????? ???.????????
#define get_modbus_word_msb   12   // ??? 2 ????????? ???.????????
#define get_modbus_word_lsb   13   // ??? 3 ????????? ???.????????
#define get_reg_cnt_msb    14      // ??? 4 ????????? ???.????????
#define get_reg_cnt_lsb    15      // ??? 5 ????????? ???.????????
#define calc_crc1          16      // ??? 6 ????????? ???.????????
#define calc_crc2          17      // ??? 7 ????????? ???.????????
#define get_modbus_word    18      // ??? 8 ????????? ???.????????

  U8 wr_ptr = 0, rd_ptr = 0;   // ???????? ?????? ? ?????? ? ?????? UART
  // ????? ??? ????. ????????? ??????
  U8 rx_buf[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
//==============================================================================

//============================== RS485 defines =================================
#define RS485_RX_EN     MDR_PORTB->RXTX &= ~(1<<10)  // ???.  ???????? RS485   \_ 
#define RS485_RX_DIS    MDR_PORTB->RXTX |=  (1<<10)  // ????. ???????? RS485   _/
#define RS485_TX_EN     MDR_PORTB->RXTX |=  (1<<9)   // ???.  ?????????? RS485 _/
#define RS485_TX_DIS    MDR_PORTB->RXTX &= ~(1<<9)  // ????. ?????????? RS485 \_

#define modbus_rhr_cmd  0x03    // read holding registers cmd id
#define modbus_wsr_cmd  0x06    // write single register cmd id

#define com_dev_id 0            // ? ????????????????? ?????? ???????????? ????? 0
#define dev_id 21               // modbus id ???????? ??????????                        <<<<<<<<<<=========================== ID
#define firmware_ver    11      // ?????? ???????? ???????? ??????????
#define device_family   3       // ??? ????????? ?????????: 1 - PBF modules, 2 - extraction modules, 3 - dc hv modules
#define max_regs_cnt    125     // ????. ???-?? ????????? ??? ?????? ?? 1 ???

#define volt_lvl_reg    1000    // ????? ???????? ??????????? ?????????? ? HV-????????

  U8 reg_addr_flag = 0;
  U8 reg_wr_flag = 0;
  U8 reg_qty_flag = 0;
  U8 get_crc_flag = 0;

  U8 rx_byte;       // ???? ???????? ? ??
 
  U8 answer = 0;    // ??? ?????? ?? ??????? ? ??
  U8 rd_state = detect_dev_id; // ?????? ????????? ?? ????????? ???? ????????? ?? id ????????? modbus
  U16 modbus_reg_addr = 0;     // ????? ???????? ??? R/W ?? ??????? ?? modbus ???????
  U16 temp_buf = 0;            // ????????? ?????
 
  U16 regs2read = 0;           // ????? ????????? ??? ?????? ?? ??????? modbus rhr
  U8  crc_buf[250];            // ????? ??? ???????? ?????? ??? ??????? CRC16
  U16 CRC16 = 0;               // ??? ???????? ??????????? ??????????? ?????
  U16 addr_buf_1, addr_buf_2;

  U16 reg_wr_data = 0;
  U16 holding_register[125];   // ????? ??? ???????? ?????????? ??????, ????. ????? ????????? - 124
//==============================================================================

void Rd_Flash(){

  read_program_memory(CK_USER_PAGE,flash_rd_data,4);
  delay_ms(5);
  NumAver = flash_rd_data[1]; 
  ADC_sps_var = flash_rd_data[0];
  EE_CRC_buf = flash_rd_data[2];

}

void Wr_Flash(){

  flash_wr_data[0] = Aver_Wr; 
  flash_wr_data[1] = Sps_Wr;
  flash_wr_data[2] = CRC_Wr;
  //flash_wr_data[4] = 0x00;
  write_program_memory(CK_USER_PAGE,flash_wr_data,4);
  delay_ms(2);

 //if(Rd_Flash(buf_index)==in_wr_data) return 1; else return 0;
}

char Crc8(unsigned char *pcBlock, unsigned int len)
{

  //Name  : CRC-8
  //Poly  : 0x31    x^8 + x^5 + x^4 + 1
  //Init  : 0xFF
  //Revert: false
  //XorOut: 0x00
  //Check : 0xF7 ("123456789")
  //MaxLen: 15 байт(127 бит) - обнаружение
  // одинарных, двойных, тройных и всех нечетных ошибок

    unsigned char crc = 0xFF;
    unsigned int i;
 
    while (len--)
    {
        crc ^= *pcBlock++;
 
        for (i = 0; i < 8; i++)
            crc = crc & 0x80 ? (crc << 1) ^ 0x31 : crc << 1;
    }
 
    return crc;
}

void UART2_init(){

   U2MODE = (1<<15 | // UARTx is enabled
             1<<13 | // Discontinue operation when device enters Idle mode 
             0<<12 | // IrDA encoder and decoder disabled
             1<<11 | // 1 - UxRTS in Simplex mode, 0 - flow control mode
             2<<9  | // UxTX, UxRX, UxCTS and UxRTS pins are enabled and used
             1<<7  | // 1 = Wake-up enabled
             0<<6  | // 0 = Loopback mode is disabled
             0<<5  | // Auto-Baud Enable bit, disabled
             0<<4  | // Receive Polarity Inversion bit, 0 = UxRX Idle state is '1'
             0<<3  | // BRGH: High Baud Rate Select bit , 0 = Low speed
             0<<2  | // 00 = 8-bit data, no parity
             0      // 0 = One Stop bit
   );

}

void uart_send_hex (U8 ch) {
  
   while(!U2_TRMT) { }          // if Transmit Shift Register is not Empty ?
   if(!U2_UTXBF) 
      U2TXREG = ch;             // if Transmit buffer is not full, at least one more data word can be written
  }

void OscSetup(){
  //Fcy=Fosc/2
  //Fin=10M
  //Fosc=Fin(M/(N1*N2)) = 40M
  // 
  //U2BRG = 259;// BAUD Rate Setting for 9600
  //U2MODE = 0b1010101010000000; // brgh = 0
  //U2BRG = 21;// BAUD Rate Setting for 115200
  U2BRG = 10;  // BAUD Rate Setting for 230400
  U2MODE = 0b1010101010000000; // brgh = 0
  
  PLLFBD = 30; // ???. ????. ??????? PLL M = 30
  
  PLLPRE4 = 0; // ???. ????. ??????? PLL N1 = 2
  PLLPRE3 = 0;
  PLLPRE2 = 0;
  PLLPRE1 = 0;
  PLLPRE0 = 0;
  
  PLLPOST0=0; // ???. ????. ??????? PLL N2 = 2
  PLLPOST1=0;
    
   }

void EnableInt (){

  //enable_interrupts(INT_RDA); // UART Int
  enable_interrupts(INT_RDA2); // UART2 Int
  
  enable_interrupts(INT_TIMER1);
  enable_interrupts(INT_TIMER2);
  
   //enable_interrupts(INT_EXT0);
  //EXT_INT_EDGE(L_TO_H);
  
  ENABLE_INTERRUPTS(INTR_GLOBAL);
}

void MCU_init(){

  setup_timer1(TMR_INTERNAL | TMR_DIV_BY_64);  // таймер 1 сбрасывает собачий таймер
  setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8);   // таймер 2 - modbus
  set_timer1(20000); // reset the timer 1
  set_timer2(2000);  // период Т2 - 2.5 us* 2000 = 5ms
  
   SETUP_SPI2(SPI_MASTER|SPI_SCK_IDLE_LOW|SPI_XMIT_H_TO_L|SPI_MODE_8B|SPI_SAMPLE_AT_END|SPI_SS_DISABLED|SPI_CLK_DIV_128);
   //f SCLK SPI = 312,5 kHz

 SCK2_TRIS=0; // SPI2 tris
 SDI2_TRIS=1;
 SDO2_TRIS=0;
 
 ADC_CS_TRIS=0;      ADC2_CS_TRIS=0;
 ADC_RESET_TRIS=0;   ADC2_RESET_TRIS=0;
 ADC_SYNC_TRIS=0;    ADC2_SYNC_TRIS=0;
 ADC_DRDY_TRIS=1;    ADC2_DRDY_TRIS=1;       // опрос готовнсти данных АЦП
 
 UART2_RX_TRIS=1;
 UART2_TX_TRIS=0;
 
 EnableInt();
}

void Full_dev_reset(){

  OscSetup();
  MCU_init();
  reset_fl = 0;
  //ADC_wakeUp();
  //ADC_wakeUp(); 
  ADC_init();
  ADC_set_PGA(8);
  ADC_sps_set(0x23); //0x023 - 10 sps, 0x43 - 25 sps, 0x63 - 50 sps
                     //0x82 - 100 sps, 0x91 - 500 sps
                     //0xA1 - 1000 sps, 0xC0 - 3750 sps
  ADC_SelfCal();
  meas_stop_fl = 0; // вкл. режим измерений
  NumAver = 10;      // сброс величины усреднения данных АЦП

}

void Clr_bufs(void)
{
  for (U8 i = 0; i < 8; i++)
  {
  // заполнение буферов скольз. ср. нулями
   for (U8 j = 0; j < Ma_buf_size; j++) 
      {
         Ch_buf[i][j] = 0;
      }
  }
}

U8 ch_to_int(U8 ch){
U8 dg=-1;
 switch (ch){
      case '0' : dg=0;
      break;
      case '1' : dg=1;
      break;
      case '2' : dg=2;
      break;
      case '3' : dg=3;
      break;
      case '4' : dg=4;
      break;
      case '5' : dg=5;
      break;
      case '6' : dg=6;
      break;
      case '7' : dg=7;
      break;
      case '8' : dg=8;
      break;
      case '9' : dg=9;
      break;
      default: dg=-1;
 }
return dg;
}

// послед. чтение двух АЦП
/*
static void ADC_Seq_rd_and_print_ch(U8 chanel){

   switch (chanel){
//---------------- АЦП 1 --------------------------------------//     
 case 1: 
 
 ADC_select(1);
 ADC_setCh(1);
 delay_us(20);
 ADC_select(0);
 
 ADC_SYNC = 0;
 delay_us(20);
 ADC_SYNC = 1;
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 ADC_select(1);
 Printf("a%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);

 break;

//---------------- 2 датчик --------------------------------------//
 case 2:
 
 ADC_select(1);
 ADC_setCh(2);
 ADC_select(0);
 
 ADC_SYNC = 0;
 delay_us(20);
 ADC_SYNC = 1;
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 ADC_select(1);
 Printf("b%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);

 break;
 
//---------------- 3 датчик --------------------------------------//  
 case 3: 

 ADC_select(1);
 ADC_setCh(3);
 delay_us(20);
 ADC_select(0);
 
 ADC_SYNC = 0;
 delay_us(20);
 ADC_SYNC = 1;
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 ADC_select(1);
 Printf("c%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);

 break;
//---------------- 4 датчик --------------------------------------//    
   case 4: 
   
 ADC_select(1);
 ADC_setCh(4);
 delay_us(20);
 ADC_select(0);
 
 ADC_SYNC = 0;
 delay_us(20);
 ADC_SYNC = 1;
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 ADC_select(1);
 Printf("d%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);
 
   break;
//----------------------------------------------------------------//

//------------------- АЦП 2 --------------------------------------//     
 case 5: 
 
 ADC_select(2);
 ADC_setCh(1);
 delay_us(20);
 ADC_select(0);
 
 ADC2_SYNC = 0;
 delay_us(20);
 ADC2_SYNC = 1;
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 1
 ADC_select(2);
 Printf("e%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);
 
 break;
 
//---------------- 2 датчик --------------------------------------//
 case 6: 
 
 ADC_select(2);
 ADC_setCh(2);
 delay_us(20);
 ADC_select(0);
 
 ADC2_SYNC = 0;
 delay_us(20);
 ADC2_SYNC = 1;
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 1
 ADC_select(2);
 Printf("f%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);
  
 break;
//---------------- 3 датчик --------------------------------------//  
 case 7: 

 ADC_select(2);
 ADC_setCh(3);
 delay_us(20);
 ADC_select(0);
 
 ADC2_SYNC = 0;
 delay_us(20);
 ADC2_SYNC = 1;
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 1
 ADC_select(2);
 Printf("g%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);
  
 break;
//---------------- 4 датчик --------------------------------------//    
   case 8: 

 ADC_select(2);
 ADC_setCh(4);
 delay_us(20);
 ADC_select(0);
 
 ADC2_SYNC = 0;
 delay_us(20);
 ADC2_SYNC = 1;
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 1
 ADC_select(2);
 Printf("h%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);
  
  break;
   }
   
}
*/
/*

// || чтение двух АЦП
static void ADC_Par_rd_and_print_ch(U8 channel)
{
  char rchr;             // принятый U2 символ
  
  
   switch (channel){
//---------------- каналы 1 и 5 --------------------------------------//     
 case 1: 
 
 ADC_setCh(1,1);
 ADC_setCh(1,2);

 SYNC_ADC(1);  // синхр. измерений АЦП 1
 delay_us(200);  
 SYNC_ADC(2);  // синхр. измерений АЦП 2
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 Printf("a%09Ld\n",ADC_read_aver(1,0));
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 2
 Printf("e%09Ld\n",ADC_read_aver(2,1));

 break;

//---------------- каналы 2 и 6 --------------------------------------//  
 case 2: 
 
 ADC_setCh(2,1);
 ADC_setCh(2,2);
 
 SYNC_ADC(1);   // синхр. измерений АЦП 1
 delay_us(200);  
 SYNC_ADC(2);    // синхр. измерений АЦП 2
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 Printf("b%09Ld\n",ADC_read_aver(1,2));
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 2
 Printf("f%09Ld\n",ADC_read_aver(2,3));
 
 break;
 
//---------------- каналы 3 и 7 --------------------------------------//   
 case 3: 
 
 ADC_setCh(3,1);
 ADC_setCh(3,2);
 
 SYNC_ADC(1);   // синхр. измерений АЦП 1
 delay_us(200);  
 SYNC_ADC(2);   // синхр. измерений АЦП 2
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 Printf("c%09Ld\n",ADC_read_aver(1,4));
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 2
 Printf("g%09Ld\n",ADC_read_aver(2,5));
 
 break;
 
//---------------- каналы 4 и 8 --------------------------------------//   
 case 4: 
 
 ADC_setCh(4,1);
 ADC_setCh(4,2);
 
 SYNC_ADC(1);   // синхр. измерений АЦП 1
 delay_us(200);  
 SYNC_ADC(2);    // синхр. измерений АЦП 2
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 Printf("d%09Ld\n",ADC_read_aver(1,6));

 While(ADC2_DRDY) { } // ждем готовности АЦП 2
 Printf("h%09Ld\n",ADC_read_aver(2,7));
 
 Ma_buf_index++; // инкремент индекса
 if(Ma_buf_index > Ma_buf_size-1) Ma_buf_index = 0;   // сброс индекса буфера
 
 break;
 
//---------------- обработка команд с ПК ------------------------------//   
 case 5:
 
 while(rdptr < wrptr){
   U8 dg=0;
   U16 buf1; 
   //пока есть необработанные символы 
   rchr=getrxch();
 
   switch(state){
          case 0:
           switch (rchr){ //команды
               case 's': stop_fl = 0; // старт измерений
                         Clr_bufs();
                         ADC_init(); // инициализ .АЦП с новыми параметрами
                         state=0;
               break; 
               //----------
               case 'p': stop_fl = 1; // стоп измерений
                         printf("stopped\n\r");  
                         state=0;
               break; 
               //----------
               case 'g': state = 1; // pga_set
               if(!stop_fl) state=0; 
               break;
               //----------
               case 'v': state = 2; // sps_set
               if(!stop_fl) state=0;           
               break;
               //----------
               case 'b': state = 5; // aver_buf_size
               if(!stop_fl) state=0;           
               break;

               default : printf("err \r\n");      
         } // команды
          break;
          
         case 1: 
         // уст. PGA
            dg = ch_to_int(rchr);
            if(dg == -1){ 
              state=0;
              printf("PGA err \r\n"); 
              break;
                  }
                  
              tmp = (U16)dg;
              
            //if(stop_fl) {     
               if(tmp>=0 && tmp<=6){
                  PGA_val=tmp;
                  printf("PGA=%u \r\n",PGA_val);
               }  else printf("PGA out of range\r\n");
            //}
                  state=0;     
         break;
         
         case 2: 
         // уст. SPS
            dg = ch_to_int(rchr);
            if(dg == -1){ 
              state=0;
              printf("err p1 \r\n"); 
              break;
                  }
          // 1 цифра   
          tmp=0;
          tmp+=(U16)dg*10;
          state=3;
          // ПОЧЕМУ НАДО СЛАТЬ 3 СИМВОЛА?
         break;
         
         case 3: 
         // уст. SPS
            dg = ch_to_int(rchr);
            if(dg == -1){ 
              state=0;
              printf("err p2 \r\n"); 
              break;
                  }
          // 2 цифра        
          tmp+=(U16)dg; 
          state=4;
         break;
         
         case 4: 
            if(tmp>=0 && tmp<=12){
               ADC_sps_var = tmp;
               printf("SPS=%u \r\n",ADC_sps_var);
               } else printf("SPS out of range\r\n");
                  state=0;     
         break;
         
         case 5: 
         // уст. размера буфера усреднения
            dg = ch_to_int(rchr);
            if(dg == -1){ 
              state=0;
              printf("err p1 \r\n"); 
              break;
                  }
          // 1 цифра   
          tmp=0;
          tmp+=(U16)dg*100;
          state=6;
          
         break;
         
         case 6: 
         // уст. размера буфера усреднения
            dg = ch_to_int(rchr);
            if(dg == -1){ 
              state=0;
              printf("err p2 \r\n"); 
              break;
                  }
          // 2 цифра        
          tmp+=(U16)dg*10;
          state=7;
          
         break;
         
         case 7: 
         // уст. размера буфера усреднения
            dg = ch_to_int(rchr);
            if(dg == -1){ 
              state=0;
              printf("err p3 \r\n"); 
              break;
                  }
          // 3 цифра 
          tmp+=(U16)dg;
          if(tmp>=0 && tmp<=128){
                       Ma_buf_size=(U8)tmp;// прочитаны все 3 цифры без ошибок
                       printf("aver buf size=%u \r\n",Ma_buf_size);
          } else printf("aver buf out of range\r\n");
          
          state=0;
          
         break;
         
        default : state=0;   
      } // state   
   } // while
   
     break;
   } // main case
}
*/

static void save_to_flash(){
      
   Sps_Wr = NumAver;
   Aver_Wr = ADC_sps_var; // сохранение sps значения во флеш
   CRC_Wr = CRC8(flash_wr_data,2);
   Wr_Flash();
   } 

/*========================================================================== */
// MODBUS

  void modbus_refresh(U8 cmd_type) {
  
   // обновление значений регистров надо делать ТУТ !!!     
   if(cmd_type == modbus_rhr_cmd)
   {
      holding_register[0] = NumAver;
      holding_register[2] = 1;   
   }
   //--------
   // обновление переменных из регистров
   if(cmd_type == modbus_wsr_cmd)
   {
      NumAver = holding_register[0];
   }
   
  }

  U8 get_rx_ch (void) {                                                     
// Get RX char
  U8 rch;

   if (rd_ptr < wr_ptr) // ????? ?? ????
   { 
      rd_ptr++;                    // ????????? ???????? ???????? ????
      rch = rx_buf[rd_ptr & 0x0f]; // ????. ???????? ?? ???????
   }
   else rch = 'x';   
   
   // ?????? ?????????? ?? UART ?? ????? ????????? ??????????  
   // ?? ????. ? ?????. ???????? ???????
   disable_interrupts(INT_RDA2); // UART Int
           
   if ((wr_ptr==rd_ptr) && (wr_ptr > 15)) // ???? ????? ????????                                            
   {  
      wr_ptr=0;                                                                   
      rd_ptr=0;                                                       
   } 

  enable_interrupts(INT_RDA2); // UART Int

return rch;
}

  U16 modbus_CRC16(U8 buf[], U8 len)  {//-------crc16
  U16 crc = 0xFFFF;
  //U8 crc_lsb, crc_msb;
  for (U8 pos = 0; pos < len; pos++)
  {
    crc ^= (U16)buf[pos];          // XOR byte into least sig. byte of crc
    for (U8 i = 8; i != 0; i--)
    {    // Loop over each bit
      if ((crc & 0x0001) != 0)
       {      // If the LSB is set
         crc >>= 1;                // Shift right and XOR 0xA001
         crc ^= 0xA001;
       }
       else                          // Else LSB is not set
         crc >>= 1;                  // Just shift right
     }
   }
  
   // Note, this number has low and high bytes swapped, 
   // so use it accordingly (or swap bytes)
   // swapping bytes
   crc = ((crc<<8)&0xff00)|((crc>>8)&0x00ff);
   
   return crc;
}

  void modbus_wsr_answer() { // ????? ?? ??????? ?????? ? ???????
    // ?????? CRC
    crc_buf[0] = dev_id;
    crc_buf[1] = modbus_wsr_cmd;
    crc_buf[2] = (U8)(modbus_reg_addr >> 8);
    crc_buf[3] = (U8)(modbus_reg_addr & 0x00ff);
    crc_buf[4] = (U8)(reg_wr_data >> 8);
    crc_buf[5] = (U8)(reg_wr_data & 0x00ff);
    CRC16 = modbus_CRC16(crc_buf, 6);

    //--------------------------------------------------------------------
    //RS485_TX_EN;
    // ???????? ?????? ???????
    uart_send_hex(dev_id);                // ID ??????????
    uart_send_hex(modbus_wsr_cmd);        // ??? ???????
    uart_send_hex((U8)(modbus_reg_addr >> 8));           // ??. ???? ?????? ????????
    uart_send_hex((U8)(modbus_reg_addr & 0x00ff));       // ??. ???? ?????? ????????
    uart_send_hex((U8)(reg_wr_data >> 8));
    uart_send_hex((U8)(reg_wr_data & 0x00ff));
     // ???????? CRC
    uart_send_hex((U8)(CRC16 >> 8));      // msb
    uart_send_hex((U8)(CRC16 & 0x00ff));  // lsb  
    //delay_ms(1);    
    //RS485_TX_DIS;
          //--------------------------------------------------------------------
  }

  void modbus_rhr_answer() {
    // ????? ?? ??????? ?????? ?????????
       addr_buf_2 = addr_buf_1;             // ????. ????? ??? ???????? ? ???? ??????????     
          // ?????? CRC
          crc_buf[0] = dev_id;
          crc_buf[1] = modbus_rhr_cmd;
          crc_buf[2] = regs2read*2;
          
          U8 cnt = 3;      // ???????? ???????? ?????? ??? ??????? CRC

          for(U8 i = 0; i < regs2read; i++)
          { // ?????????? ?????? CRC ??? ???????
            crc_buf[cnt++] = (U8)(holding_register[addr_buf_1] >> 8);
            crc_buf[cnt++] = (U8)(holding_register[addr_buf_1] & 0x00ff);
            ++addr_buf_1;
          }
            // ?????? CRC  
          CRC16 = modbus_CRC16(crc_buf,(regs2read*2)+3);
          //--------------------------------------------------------------------
          // ???????? ?????? ???????
          //RS485_TX_EN;
          uart_send_hex(dev_id);                // ID ??????????
          uart_send_hex(modbus_rhr_cmd);        // ??? ???????
          uart_send_hex(regs2read*2);           // ???-?? ???????????? ???? 
          //delay_ms(100);
          for(U8 j = 0; j < regs2read; j++)
          {   // ???????? ???? ?????? ? ??????????? ??????
            uart_send_hex((U8)(holding_register[addr_buf_2] >> 8));     // msb
            uart_send_hex((U8)(holding_register[addr_buf_2] & 0x00ff)); // lsb
            ++addr_buf_2;
          }
          // ???????? CRC
          uart_send_hex((U8)(CRC16 >> 8));      // msb
          uart_send_hex((U8)(CRC16 & 0x00ff));  // lsb    
         // delay_ms(1);
          //RS485_TX_DIS;
          //--------------------------------------------------------------------
  }

  void modbus_poll() {
    // update modbus regs and vars, send answer to master
  
    addr_buf_1 = modbus_reg_addr - 1000; // ??????????? ?? ???????? ? ??????
    
    /// on reading cmd
    if(answer == modbus_rhr_cmd) // ????? ??? ??????? ?????? ?????????
    {
         modbus_refresh(modbus_rhr_cmd);
         modbus_rhr_answer();    // ??????? ???????? ????????????? ?????????
    }
//--------------------------------------------------------------------
    /// on writing cmd
    if(answer == modbus_wsr_cmd) // ????? ??? ??????? ?????? ? ???????
    {
         holding_register[addr_buf_1] = reg_wr_data; // ?????? ?????????? ?????? ? ??????? ?? ??????
         modbus_refresh(modbus_wsr_cmd);
         modbus_wsr_answer();             // ??????? ?????? ?? ??????? ?????? ? ???????
    }  
     answer = 0;                      // ????? ????? ??????
  }

/*=========================================================================== */

#int_timer1
 void timer1_irq_handler(void) {
restart_wdt();     // сбос собачего таймера
set_timer1(8000); //reset the timer.
clear_interrupt(int_timer1);
}

#int_timer2
 void timer2_irq_handler(void) {
/// обработка команды modbus
  if(rd_ptr < wr_ptr) // ????? ?? ????, ??????? ???? 
    {              
       rx_byte = get_rx_ch();
       switch(rd_state)  // ???????? ??????? ????????? ?????? ??????
       {
       //====
         case detect_dev_id:              // ???? ????????? ? ??????????
           switch(rx_byte)
           {
             case dev_id:                 // ???????? ??????? ????????? ?? ???????? id ??????????      
               rd_state = get_cmd_header; // ??????? ? ????????? ???????? ????????? ???????
             break;
             //----  
             case com_dev_id:             // ???????? ??????? ?????????????????? ?????????
               rd_state = get_cmd_header; // ??????? ? ????????? ???????? ????????? ???????
             break;
             //----    
             default:                     // ???????? ??? ?????? ??????? 
               rd_state = detect_dev_id;  // ??????? ? ?????? id ??????? modbus
            }
          break;
       //=====                          
         case get_cmd_header:             // ?????? ??????? modbus
           switch (rx_byte)
           { 
             case modbus_rhr_cmd:                 // ?????? ?????????
                  reg_addr_flag = 1;              // ???. ????? ?????? ?????? ????????
                  regs2read = 0;
                  reg_wr_data = 0;
                  rd_state = get_modbus_word_msb; // ??????? ? ????. ????????? ???? ???? ? ??
             break;      
             //---- 
             case modbus_wsr_cmd:                 // ?????? ? ???????
                  reg_addr_flag = 1;              // ???. ????? ?????? ?????? ????????
                  reg_wr_flag   = 1;              // ???. ????? ?????? ? ??????? 
                  regs2read = 0;
                  reg_wr_data = 0;
                  rd_state = get_modbus_word_msb; // ??????? ? ????. ????????? ???? ???? ? ?? 
             break; 
             //---- 
             // ??????? ? ????. ?????? id ?????????? ? ?????? ??????  
             default: rd_state = detect_dev_id;
           }
         break;
        //=====
         case get_modbus_word_msb:              // ????????? ??. ?????
             temp_buf = (U16)rx_byte;           // ????. ??. ????
             temp_buf = temp_buf << 8;
             rd_state = get_modbus_word_lsb;    // ??????? ? ????. ?????? ??. ?????
         break;
         //=====
         case get_modbus_word_lsb:              // ????????? ??. ????? 
             temp_buf |= (U16)rx_byte;          // ????. ??. ????
             /// ?????? ?????? ??? ?????????? ????????
             if(reg_addr_flag)                 // ???? ???????? ???? ???????
             {
               modbus_reg_addr = temp_buf;     // ????. ?????? ?????????? ???????? ??? ??????
               reg_addr_flag = 0;              // ????? ????? ?????? ??????
               if(reg_wr_flag) reg_qty_flag = 0; // ????? ????? ?????? ????? ????????? ??? ?????? ???? ???? ??????? ??????             
               else reg_qty_flag = 1;            // ???. ????? ?????? ????? ????????? ??? ?????? ???? ??? ??????
               rd_state = get_modbus_word_msb;   // ??????? ? ????. ?????? 2 ???? ???-?? ????????? ??? ??????
               temp_buf = 0;                     // ????????? ?????????? ??????
               break;
             }
             
             if(reg_wr_flag)                   // ???? ?????? ? ????????
             { 
                reg_wr_data = temp_buf;        // ????. ???????? ??? ??????
                reg_wr_flag = 0;               // ????? ????? ?????? ? ???????
                get_crc_flag = modbus_wsr_cmd; // ???. ???? ??????? CRC ??? ??????? ??????
                rd_state = get_modbus_word_msb;// ??????? ? ????. ?????? 2 ???? CRC
                break;
             }
             
             if(reg_qty_flag)                  // ???? ?????? ??-?? ????????? ??? ???????
             { 
               if(temp_buf < max_regs_cnt)     // ???????? ?? ?????? ????? ????????? ??? ??????
               {  // ??
                regs2read = temp_buf;           // ?????????? ????? ????????? ??? ??????
                get_crc_flag = modbus_rhr_cmd;  // ???. ???? ??????? CRC ??? ??????? ??????
                rd_state = get_modbus_word_msb; // ??????? ? ????. ?????? 2 ???? CRC
               }
                 // ??????, ??????? ? ????. ?????? id ??????????
               else rd_state = detect_dev_id; 
               reg_qty_flag = 0;                // ????? ????? ?????? ???-?? ?????????       
               break;
             }
             
             if(get_crc_flag == modbus_rhr_cmd)// ?????? CRC16 ??? ??????? ?????? ?????????
             {
                crc_buf[0] = dev_id;
                crc_buf[1] = modbus_rhr_cmd;
                crc_buf[2] = (U8)(modbus_reg_addr >> 8);
                crc_buf[3] = (U8)(modbus_reg_addr & 0x00ff);
                crc_buf[4] = (U8)(regs2read >> 8);
                crc_buf[5] = (U8)(regs2read & 0x00ff);
                CRC16 = modbus_CRC16(crc_buf,6); 
                if(CRC16 == temp_buf) 
                { 
                  answer = modbus_rhr_cmd;
                  rd_state = detect_dev_id;
                }
                else rd_state = detect_dev_id; 
                get_crc_flag = 0;              // ????? ????? ??????? CRC16 
             }
               
             if(get_crc_flag == modbus_wsr_cmd)// ?????? ??? ??????? ?????? ? ???????
             { 
                crc_buf[0] = dev_id;
                crc_buf[1] = modbus_wsr_cmd;
                crc_buf[2] = (U8)(modbus_reg_addr >> 8);
                crc_buf[3] = (U8)(modbus_reg_addr & 0x00ff);
                crc_buf[4] = (U8)(reg_wr_data >> 8);
                crc_buf[5] = (U8)(reg_wr_data & 0x00ff);
             
                CRC16 = modbus_CRC16(crc_buf,6);
                if(CRC16 == temp_buf) 
                {
                  answer = modbus_wsr_cmd;
                  rd_state = detect_dev_id;
                }
                else rd_state = detect_dev_id; 
                get_crc_flag = 0;
               }
              
         break; 
         //=====
          default: rd_state = detect_dev_id;    
        } // switch
    }  // while
//--------------------------------------------- 
  


set_timer2(2000); // reset the timer.
clear_interrupt(int_timer2);

 
}

#INT_RDA2
void UART2_RXd_isr(void){

while(U2STA & 0x0001)
{ // Receive buffer has data, at least one more character can be read
   wr_ptr++;
   rx_buf[wr_ptr & 0x0F] = (U8)(U2RXREG);
}
}

/*########################################################################### */

static void main()
{ 
  U8 ch = 1;             // начальная установка канала измерений АЦП

  OscSetup();
  MCU_init(); 

  for(U8 i = 0; i < 125; i++) holding_register[i] = 0; // ??????? ?????? ?????????? ??????
  Clr_bufs();
  
  ADC_sps_var = 0;   // сброс значений по умолчанию 
  NumAver = 1;       // тк произошел сбой контр. суммы
     
  ADC_RESET = 1; ADC2_RESET = 1;
  ADC_CS = 1;    ADC2_CS = 1;
  ADC_SYNC = 1;  ADC2_SYNC = 1; 
    
  delay_ms(2);
  //While(ADC_DRDY | ADC2_DRDY) { }   // ждем готовности обоих АЦП перед иниц.  
  
  ADC_init();        // Инициализация обоих АЦП 
  
/*############################################################################*/  

  while(true){
  
   // ответ
   modbus_poll();

   delay_ms(10);
 } // while  
}  // main
/*############################################################################*/

