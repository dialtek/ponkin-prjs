#include <main.h>
#use rs232(UART2,xmit=PIN_F5,rcv=PIN_F4,baud=230400,BRGH1OK,ERRORS,parity=N,bits=8)
#include <ADS1256.h> // ADC

  // результаты измерений
  S32 pkt8_ch_1 = 0, pkt8_ch_2 = 0, pkt8_ch_3 = 0, pkt8_ch_4 = 0, 
      pkt8_ch_5 = 0, pkt8_ch_6 = 0, pkt8_ch_7 = 0, pkt8_ch_8 = 0;
  U16 meas_status; // статус бит обновления измерений
    
//****************************************************************************//
//                                  M O D B U S

//================================ state-machine =============================//
#define detect_dev_id      10      // ??? 0 ????????? ???.????????
#define get_cmd_header     11      // ??? 1 ????????? ???.????????
#define get_modbus_word_msb   12   // ??? 2 ????????? ???.????????
#define get_modbus_word_lsb   13   // ??? 3 ????????? ???.????????
#define get_reg_cnt_msb    14      // ??? 4 ????????? ???.????????
#define get_reg_cnt_lsb    15      // ??? 5 ????????? ???.????????
#define calc_crc1          16      // ??? 6 ????????? ???.????????
#define calc_crc2          17      // ??? 7 ????????? ???.????????
#define get_modbus_word    18      // ??? 8 ????????? ???.????????

  U8 wr_ptr = 0, rd_ptr = 0;   // ???????? ?????? ? ?????? ? ?????? UART
  // ????? ??? ????. ????????? ??????
  U8 rx_buf[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
//============================== RS-485 defines ==============================//
//// Это необходимо при использовании RS-485, при этом надо использовать UART1
//#define RS485_RX_EN     MDR_PORTB->RXTX &= ~(1<<10)  // ???.  ???????? RS485   \_ 
//#define RS485_RX_DIS    MDR_PORTB->RXTX |=  (1<<10)  // ????. ???????? RS485   _/
//#define RS485_TX_EN     MDR_PORTB->RXTX |=  (1<<9)   // ???.  ?????????? RS485 _/
//#define RS485_TX_DIS    MDR_PORTB->RXTX &= ~(1<<9)  // ????. ?????????? RS485 \_

#define modbus_rhr_cmd  0x03   // read holding registers cmd id
#define modbus_wsr_cmd  0x06   // write single register cmd id

#define com_dev_id 0           // ? ????????????????? ?????? ???????????? ????? 0
#define dev_id 102            // modbus id ???????? ??????????                  <<<<<<<<<<=========================== ID
#define firmware_ver    12     // ?????? ???????? ???????? ??????????
#define device_family   10     // ??? ????????? ?????????: 10 - PKT-8
#define max_regs_cnt    125    // ????. ???-?? ????????? ??? ?????? ?? 1 ???
#define meas_status_reg 16     // № статус регистра обновления измерений

  U8 reg_addr_flag = 0, reg_wr_flag = 0, reg_qty_flag = 0, get_crc_flag = 0;
  U8 rx_byte;                  // ???? ???????? ? ??
  U8 answer = 0;               // ??? ?????? ?? ??????? ? ??
  U8 rd_state = detect_dev_id; // ?????? ????????? ?? ????????? ???? ????????? ?? id ????????? modbus
  U16 modbus_reg_addr = 0;     // ????? ???????? ??? R/W ?? ??????? ?? modbus ???????
  U16 temp_buf = 0;            // ????????? ?????
 
  U16 regs2read = 0;           // ????? ????????? ??? ?????? ?? ??????? modbus rhr
  U8  crc_buf[250];            // ????? ??? ???????? ?????? ??? ??????? CRC16
  U16 CRC16 = 0;               // ??? ???????? ??????????? ??????????? ?????
  U16 addr_buf_1, addr_buf_2;

  U16 reg_wr_data = 0;
  U16 holding_register[125];   // ????? ??? ???????? ?????????? ??????, ????. ????? ????????? - 124
  
  void Clr_bufs(void)
{
  for (U8 i = 0; i < 8; i++)
  {
  // заполнение буферов скольз. ср. нулями
   for (U8 j = 0; j < Ma_buf_size; j++) 
      {
         Ch_buf[i][j] = 0;
      }
  }
}
   
//============================== MODBUS FUNCTIONS ============================//
  // прототип функции отправки байта по UART2
  void uart_send_hex (U8 ch);
  void Wr_Flash(void); 
  
  U8 is_reg (U16 reg_addr)
  {  
  /// проверка на чтение/запись определенного регистра
   U8 rd_status = 0;
      for(U8 t = addr_buf_1; t <= regs2read; t++)
      { // был ли прочитан этот рег. в составе группы
        if (t == reg_addr) rd_status = 1;  
      }
      // если был прочитан только этот регистр
      if ( reg_addr == (1000 + reg_addr) ) rd_status = 1;
      
      return rd_status;
  }
 
  ///////////////////////////////////
  void modbus_refresh(U8 cmd_type) {
  
   // обновление значений регистров надо делать ТУТ !     
  if(cmd_type == modbus_rhr_cmd)
   {
      //U8 read_complete = is_reading_reg(meas_status_reg);
      if(meas_status)  
      {  // цикл измерений завершен, обновление регистров
         holding_register[0] = (U16) (pkt8_ch_1 & 0x0000ffff);          // LSB канала 1
         holding_register[1] = (U16)((pkt8_ch_1 & 0xffff0000) >> 16);   // MSB канала 1
         
         holding_register[2] = (U16) (pkt8_ch_2 & 0x0000ffff);          // LSB канала 2
         holding_register[3] = (U16)((pkt8_ch_2 & 0xffff0000) >> 16);   // LSB канала 2
         
         holding_register[4] = (U16) (pkt8_ch_3 & 0x0000ffff);          // LSB канала 3
         holding_register[5] = (U16)((pkt8_ch_3 & 0xffff0000) >> 16);   // MSB канала 3
         
         holding_register[6] = (U16) (pkt8_ch_4 & 0x0000ffff);          // LSB канала 4
         holding_register[7] = (U16)((pkt8_ch_4 & 0xffff0000) >> 16);   // LSB канала 4
         
         holding_register[8] = (U16) (pkt8_ch_5 & 0x0000ffff);          // LSB канала 5
         holding_register[9] = (U16)((pkt8_ch_5 & 0xffff0000) >> 16);   // MSB канала 5
         
         holding_register[10] = (U16) (pkt8_ch_6 & 0x0000ffff);         // LSB канала 6
         holding_register[11] = (U16)((pkt8_ch_6 & 0xffff0000) >> 16);  // LSB канала 6
         
         holding_register[12] = (U16) (pkt8_ch_7 & 0x0000ffff);         // LSB канала 7
         holding_register[13] = (U16)((pkt8_ch_7 & 0xffff0000) >> 16);  // MSB канала 7
         
         holding_register[14] = (U16) (pkt8_ch_8 & 0x0000ffff);         // LSB канала 8
         holding_register[15] = (U16)((pkt8_ch_8 & 0xffff0000) >> 16);  // LSB канала 8
         
         // сброс статус флага новых измерений
         meas_status = 0;
      }
      
      holding_register[18] = PGA_val;
      holding_register[19] = ADC_sps_var;
      holding_register[20] = Ma_buf_size;
      holding_register[21] = dev_id;
      holding_register[22] = firmware_ver;
      holding_register[23] = device_family;
   }
   //-------------------------------------------------------------------------//
   /// обновление переменных из регистров
   if(cmd_type == modbus_wsr_cmd)
   {
         // range
         if(holding_register[18] >= 0 && holding_register[19] <= 6) 
             PGA_val = holding_register[18];
         // SPS
         if(holding_register[19] >= 0 && holding_register[19] <= 8) 
             ADC_sps_var = holding_register[19];
         // averfge buf size
         if(holding_register[20] >= 1 && holding_register[20] <= 128) 
         {
             Clr_bufs(); // очистка буфера скользящ. среднего
             Ma_buf_size = holding_register[20];
         }
   }
   
  } 

  U8 get_rx_ch (void) {                                                     
// Get RX char
  U8 rch;

   if (rd_ptr < wr_ptr) // ????? ?? ????
   { 
      rd_ptr++;                    // ????????? ???????? ???????? ????
      rch = rx_buf[rd_ptr & 0x0f]; // ????. ???????? ?? ???????
   }
   else rch = 'x';   
   
   // ?????? ?????????? ?? UART ?? ????? ????????? ??????????  
   // ?? ????. ? ?????. ???????? ???????
   disable_interrupts(INT_RDA2); // UART Int
           
   if ((wr_ptr==rd_ptr) && (wr_ptr > 15)) // ???? ????? ????????                                            
   {  
      wr_ptr=0;                                                                   
      rd_ptr=0;                                                       
   } 

  enable_interrupts(INT_RDA2); // UART Int

return rch;
}

  U16 modbus_CRC16(U8 buf[], U8 len)  {//-------crc16
  U16 crc = 0xFFFF;
  //U8 crc_lsb, crc_msb;
  for (U8 pos = 0; pos < len; pos++)
  {
    crc ^= (U16)buf[pos];          // XOR byte into least sig. byte of crc
    for (U8 i = 8; i != 0; i--)
    {    // Loop over each bit
      if ((crc & 0x0001) != 0)
       {      // If the LSB is set
         crc >>= 1;                // Shift right and XOR 0xA001
         crc ^= 0xA001;
       }
       else                          // Else LSB is not set
         crc >>= 1;                  // Just shift right
     }
   }
  
   // Note, this number has low and high bytes swapped, 
   // so use it accordingly (or swap bytes)
   // swapping bytes
   crc = ((crc<<8)&0xff00)|((crc>>8)&0x00ff);
   
   return crc;
}

  void modbus_wsr_answer() { // ????? ?? ??????? ?????? ? ???????
    // ?????? CRC
    crc_buf[0] = dev_id;
    crc_buf[1] = modbus_wsr_cmd;
    crc_buf[2] = (U8)(modbus_reg_addr >> 8);
    crc_buf[3] = (U8)(modbus_reg_addr & 0x00ff);
    crc_buf[4] = (U8)(reg_wr_data >> 8);
    crc_buf[5] = (U8)(reg_wr_data & 0x00ff);
    CRC16 = modbus_CRC16(crc_buf, 6);

    //--------------------------------------------------------------------
    //RS485_TX_EN;
    // ???????? ?????? ???????
    uart_send_hex(dev_id);                // ID ??????????
    uart_send_hex(modbus_wsr_cmd);        // ??? ???????
    uart_send_hex((U8)(modbus_reg_addr >> 8));           // ??. ???? ?????? ????????
    uart_send_hex((U8)(modbus_reg_addr & 0x00ff));       // ??. ???? ?????? ????????
    uart_send_hex((U8)(reg_wr_data >> 8));
    uart_send_hex((U8)(reg_wr_data & 0x00ff));
     // ???????? CRC
    uart_send_hex((U8)(CRC16 >> 8));      // msb
    uart_send_hex((U8)(CRC16 & 0x00ff));  // lsb  
    //delay_ms(1);    
    //RS485_TX_DIS;
          //--------------------------------------------------------------------
  }

  void modbus_rhr_answer() {
    // ????? ?? ??????? ?????? ?????????
       addr_buf_2 = addr_buf_1;             // ????. ????? ??? ???????? ? ???? ??????????     
          // ?????? CRC
          crc_buf[0] = dev_id;
          crc_buf[1] = modbus_rhr_cmd;
          crc_buf[2] = regs2read*2;
          
          U8 cnt = 3;      // ???????? ???????? ?????? ??? ??????? CRC

          for(U8 i = 0; i < regs2read; i++)
          { // ?????????? ?????? CRC ??? ???????
            crc_buf[cnt++] = (U8)(holding_register[addr_buf_1] >> 8);
            crc_buf[cnt++] = (U8)(holding_register[addr_buf_1] & 0x00ff);
            ++addr_buf_1;
          }
            // ?????? CRC  
          CRC16 = modbus_CRC16(crc_buf,(regs2read*2)+3);
          //--------------------------------------------------------------------
          // ???????? ?????? ???????
          //RS485_TX_EN;
          uart_send_hex(dev_id);                // ID ??????????
          uart_send_hex(modbus_rhr_cmd);        // ??? ???????
          uart_send_hex(regs2read*2);           // ???-?? ???????????? ???? 
          for(U8 j = 0; j < regs2read; j++)
          {   // ???????? ???? ?????? ? ??????????? ??????
            uart_send_hex((U8)(holding_register[addr_buf_2] >> 8));     // msb
            uart_send_hex((U8)(holding_register[addr_buf_2] & 0x00ff)); // lsb
            ++addr_buf_2;
          }
          // ???????? CRC
          uart_send_hex((U8)(CRC16 >> 8));      // msb
          uart_send_hex((U8)(CRC16 & 0x00ff));  // lsb    
         // delay_ms(1);
          //RS485_TX_DIS;
          //--------------------------------------------------------------------
  }

  void modbus_poll() {
    // update modbus regs and vars, send answer to master
  
    addr_buf_1 = modbus_reg_addr - 1000; // ??????????? ?? ???????? ? ??????
    
    /// on reading cmd
    if(answer == modbus_rhr_cmd) // ????? ??? ??????? ?????? ?????????
    {
         modbus_refresh(modbus_rhr_cmd);
         modbus_rhr_answer();    // ??????? ???????? ????????????? ?????????
    }
//--------------------------------------------------------------------
    /// on writing cmd
    if(answer == modbus_wsr_cmd) // ????? ??? ??????? ?????? ? ???????
    {
         holding_register[addr_buf_1] = reg_wr_data; // ?????? ?????????? ?????? ? ??????? ?? ??????
         modbus_refresh(modbus_wsr_cmd);
         modbus_wsr_answer();             // ??????? ?????? ?? ??????? ?????? ? ???????
        
         ADC_init();        // Инициализация обоих АЦП
         Wr_Flash();
    }  
     answer = 0;                      // ????? ????? ??????
  }

  /// MODBUS IRQ
  #int_timer2
  void timer2_irq_handler(void) {
/// обработка команды modbus
  if(rd_ptr < wr_ptr) // ????? ?? ????, ??????? ???? 
    {              
       rx_byte = get_rx_ch();
       switch(rd_state)  // ???????? ??????? ????????? ?????? ??????
       {
       //====
         case detect_dev_id:              // ???? ????????? ? ??????????
           switch(rx_byte)
           {
             case dev_id:                 // ???????? ??????? ????????? ?? ???????? id ??????????      
               rd_state = get_cmd_header; // ??????? ? ????????? ???????? ????????? ???????
             break;
             //----  
             case com_dev_id:             // ???????? ??????? ?????????????????? ?????????
               rd_state = get_cmd_header; // ??????? ? ????????? ???????? ????????? ???????
             break;
             //----    
             default:                     // ???????? ??? ?????? ??????? 
               rd_state = detect_dev_id;  // ??????? ? ?????? id ??????? modbus
            }
          break;
       //=====                          
         case get_cmd_header:             // ?????? ??????? modbus
           switch (rx_byte)
           { 
             case modbus_rhr_cmd:                 // ?????? ?????????
                  reg_addr_flag = 1;              // ???. ????? ?????? ?????? ????????
                  regs2read = 0;
                  reg_wr_data = 0;
                  rd_state = get_modbus_word_msb; // ??????? ? ????. ????????? ???? ???? ? ??
             break;      
             //---- 
             case modbus_wsr_cmd:                 // ?????? ? ???????
                  reg_addr_flag = 1;              // ???. ????? ?????? ?????? ????????
                  reg_wr_flag   = 1;              // ???. ????? ?????? ? ??????? 
                  regs2read = 0;
                  reg_wr_data = 0;
                  rd_state = get_modbus_word_msb; // ??????? ? ????. ????????? ???? ???? ? ?? 
             break; 
             //---- 
             // ??????? ? ????. ?????? id ?????????? ? ?????? ??????  
             default: rd_state = detect_dev_id;
           }
         break;
        //=====
         case get_modbus_word_msb:              // ????????? ??. ?????
             temp_buf = (U16)rx_byte;           // ????. ??. ????
             temp_buf = temp_buf << 8;
             rd_state = get_modbus_word_lsb;    // ??????? ? ????. ?????? ??. ?????
         break;
         //=====
         case get_modbus_word_lsb:              // ????????? ??. ????? 
             temp_buf |= (U16)rx_byte;          // ????. ??. ????
             /// ?????? ?????? ??? ?????????? ????????
             if(reg_addr_flag)                 // ???? ???????? ???? ???????
             {
               modbus_reg_addr = temp_buf;     // ????. ?????? ?????????? ???????? ??? ??????
               reg_addr_flag = 0;              // ????? ????? ?????? ??????
               if(reg_wr_flag) reg_qty_flag = 0; // ????? ????? ?????? ????? ????????? ??? ?????? ???? ???? ??????? ??????             
               else reg_qty_flag = 1;            // ???. ????? ?????? ????? ????????? ??? ?????? ???? ??? ??????
               rd_state = get_modbus_word_msb;   // ??????? ? ????. ?????? 2 ???? ???-?? ????????? ??? ??????
               temp_buf = 0;                     // ????????? ?????????? ??????
               break;
             }
             
             if(reg_wr_flag)                   // ???? ?????? ? ????????
             { 
                reg_wr_data = temp_buf;        // ????. ???????? ??? ??????
                reg_wr_flag = 0;               // ????? ????? ?????? ? ???????
                get_crc_flag = modbus_wsr_cmd; // ???. ???? ??????? CRC ??? ??????? ??????
                rd_state = get_modbus_word_msb;// ??????? ? ????. ?????? 2 ???? CRC
                break;
             }
             
             if(reg_qty_flag)                  // ???? ?????? ??-?? ????????? ??? ???????
             { 
               if(temp_buf < max_regs_cnt)     // ???????? ?? ?????? ????? ????????? ??? ??????
               {  // ??
                regs2read = temp_buf;           // ?????????? ????? ????????? ??? ??????
                get_crc_flag = modbus_rhr_cmd;  // ???. ???? ??????? CRC ??? ??????? ??????
                rd_state = get_modbus_word_msb; // ??????? ? ????. ?????? 2 ???? CRC
               }
                 // ??????, ??????? ? ????. ?????? id ??????????
               else rd_state = detect_dev_id; 
               reg_qty_flag = 0;                // ????? ????? ?????? ???-?? ?????????       
               break;
             }
             
             if(get_crc_flag == modbus_rhr_cmd)// ?????? CRC16 ??? ??????? ?????? ?????????
             {
                crc_buf[0] = dev_id;
                crc_buf[1] = modbus_rhr_cmd;
                crc_buf[2] = (U8)(modbus_reg_addr >> 8);
                crc_buf[3] = (U8)(modbus_reg_addr & 0x00ff);
                crc_buf[4] = (U8)(regs2read >> 8);
                crc_buf[5] = (U8)(regs2read & 0x00ff);
                CRC16 = modbus_CRC16(crc_buf,6); 
                if(CRC16 == temp_buf) 
                { 
                  answer = modbus_rhr_cmd;
                  rd_state = detect_dev_id;
                }
                else rd_state = detect_dev_id; 
                get_crc_flag = 0;              // ????? ????? ??????? CRC16 
             }
               
             if(get_crc_flag == modbus_wsr_cmd)// ?????? ??? ??????? ?????? ? ???????
             { 
                crc_buf[0] = dev_id;
                crc_buf[1] = modbus_wsr_cmd;
                crc_buf[2] = (U8)(modbus_reg_addr >> 8);
                crc_buf[3] = (U8)(modbus_reg_addr & 0x00ff);
                crc_buf[4] = (U8)(reg_wr_data >> 8);
                crc_buf[5] = (U8)(reg_wr_data & 0x00ff);
             
                CRC16 = modbus_CRC16(crc_buf,6);
                if(CRC16 == temp_buf) 
                {
                  answer = modbus_wsr_cmd;
                  rd_state = detect_dev_id;
                }
                else rd_state = detect_dev_id; 
                get_crc_flag = 0;
               }
              
         break; 
         //=====
          default: rd_state = detect_dev_id;    
        } // switch
    }  // if
//--------------------------------------------- 
  
set_timer2(2000); // reset the timer.
clear_interrupt(int_timer2);

}

//                                M O D B U S   E N D 
//****************************************************************************//
  void Rd_Flash(){

  read_program_memory(CK_USER_PAGE,flash_rd_data,4);
  delay_ms(5);
  Ma_buf_size = flash_rd_data[0];
  ADC_sps_var = flash_rd_data[1]; 
  PGA_val = flash_rd_data[2];
}

  void Wr_Flash(){

  flash_wr_data[0] = Ma_buf_size; 
  flash_wr_data[1] = ADC_sps_var;
  flash_wr_data[2] = PGA_val;
  write_program_memory(CK_USER_PAGE,flash_wr_data,4);
  delay_ms(2);

 //if(Rd_Flash(buf_index)==in_wr_data) return 1; else return 0;
}

  char Crc8(unsigned char *pcBlock, unsigned int len)
{

  //Name  : CRC-8
  //Poly  : 0x31    x^8 + x^5 + x^4 + 1
  //Init  : 0xFF
  //Revert: false
  //XorOut: 0x00
  //Check : 0xF7 ("123456789")
  //MaxLen: 15 байт(127 бит) - обнаружение
  // одинарных, двойных, тройных и всех нечетных ошибок

    unsigned char crc = 0xFF;
    unsigned int i;
 
    while (len--)
    {
        crc ^= *pcBlock++;
 
        for (i = 0; i < 8; i++)
            crc = crc & 0x80 ? (crc << 1) ^ 0x31 : crc << 1;
    }
 
    return crc;
}

  void UART2_init(){

   U2MODE = (1<<15 | // UARTx is enabled
             1<<13 | // Discontinue operation when device enters Idle mode 
             0<<12 | // IrDA encoder and decoder disabled
             1<<11 | // 1 - UxRTS in Simplex mode, 0 - flow control mode
             2<<9  | // UxTX, UxRX, UxCTS and UxRTS pins are enabled and used
             1<<7  | // 1 = Wake-up enabled
             0<<6  | // 0 = Loopback mode is disabled
             0<<5  | // Auto-Baud Enable bit, disabled
             0<<4  | // Receive Polarity Inversion bit, 0 = UxRX Idle state is '1'
             0<<3  | // BRGH: High Baud Rate Select bit , 0 = Low speed
             0<<2  | // 00 = 8-bit data, no parity
             0      // 0 = One Stop bit
   );

}

  void uart_send_hex (U8 ch) {
  
   while(!U2_TRMT) { }          // if Transmit Shift Register is not Empty ?
   if(!U2_UTXBF) 
      U2TXREG = ch;             // if Transmit buffer is not full, at least one more data word can be written
  }

  void OscSetup(){
  //Fcy=Fosc/2
  //Fin=10M
  //Fosc=Fin(M/(N1*N2)) = 40M
  // 
  //U2BRG = 259;// BAUD Rate Setting for 9600
  //U2MODE = 0b1010101010000000; // brgh = 0
  //U2BRG = 21;// BAUD Rate Setting for 115200
  U2BRG = 10;  // BAUD Rate Setting for 230400
  U2MODE = 0b1010101010000000; // brgh = 0
  
  PLLFBD = 30; // ???. ????. ??????? PLL M = 30
  
  PLLPRE4 = 0; // ???. ????. ??????? PLL N1 = 2
  PLLPRE3 = 0;
  PLLPRE2 = 0;
  PLLPRE1 = 0;
  PLLPRE0 = 0;
  
  PLLPOST0=0; // ???. ????. ??????? PLL N2 = 2
  PLLPOST1=0;
    
   }

  void EnableInt (){

  //enable_interrupts(INT_RDA); // UART Int
  enable_interrupts(INT_RDA2); // UART2 Int
  
  enable_interrupts(INT_TIMER1);
  enable_interrupts(INT_TIMER2);
  
   //enable_interrupts(INT_EXT0);
  //EXT_INT_EDGE(L_TO_H);
  
  ENABLE_INTERRUPTS(INTR_GLOBAL);
}

  void MCU_init(){

  setup_timer1(TMR_INTERNAL | TMR_DIV_BY_64);  // таймер 1 сбрасывает собачий таймер
  setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8);   // таймер 2 - modbus
  set_timer1(20000); // reset the timer 1
  set_timer2(2000);  // период Т2 - 2.5 us* 2000 = 5ms
  
   SETUP_SPI2(SPI_MASTER|SPI_SCK_IDLE_LOW|SPI_XMIT_H_TO_L|SPI_MODE_8B|SPI_SAMPLE_AT_END|SPI_SS_DISABLED|SPI_CLK_DIV_128);
   //f SCLK SPI = 312,5 kHz

 SCK2_TRIS=0; // SPI2 tris
 SDI2_TRIS=1;
 SDO2_TRIS=0;
 
 ADC_CS_TRIS=0;      ADC2_CS_TRIS=0;
 ADC_RESET_TRIS=0;   ADC2_RESET_TRIS=0;
 ADC_SYNC_TRIS=0;    ADC2_SYNC_TRIS=0;
 ADC_DRDY_TRIS=1;    ADC2_DRDY_TRIS=1;       // опрос готовнсти данных АЦП
 
 UART2_RX_TRIS=1;
 UART2_TX_TRIS=0;
 
 EnableInt();
}

  void Full_dev_reset(){

  OscSetup();
  MCU_init();
  reset_fl = 0;
  //ADC_wakeUp();
  //ADC_wakeUp(); 
  ADC_init();
  ADC_set_PGA(8);
  ADC_sps_set(0x23); //0x023 - 10 sps, 0x43 - 25 sps, 0x63 - 50 sps
                     //0x82 - 100 sps, 0x91 - 500 sps
                     //0xA1 - 1000 sps, 0xC0 - 3750 sps
  ADC_SelfCal();
  meas_stop_fl = 0; // вкл. режим измерений
  NumAver = 10;      // сброс величины усреднения данных АЦП

}

  U8 ch_to_int(U8 ch){
U8 dg=-1;
 switch (ch){
      case '0' : dg=0;
      break;
      case '1' : dg=1;
      break;
      case '2' : dg=2;
      break;
      case '3' : dg=3;
      break;
      case '4' : dg=4;
      break;
      case '5' : dg=5;
      break;
      case '6' : dg=6;
      break;
      case '7' : dg=7;
      break;
      case '8' : dg=8;
      break;
      case '9' : dg=9;
      break;
      default: dg=-1;
 }
return dg;
}

  // || чтение двух АЦП
  void ADC_par_rd_ch(U8 channel)
{

 switch (channel){
//---------------- каналы 1 и 5 --------------------------------------//     
 case 1: 
 
 ADC_setCh(1,1);
 ADC_setCh(1,2);

 SYNC_ADC(1);  // синхр. измерений АЦП 1
 delay_us(200);  
 SYNC_ADC(2);  // синхр. измерений АЦП 2
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 pkt8_ch_1 = ADC_read_aver(1,0);

 While(ADC2_DRDY) { } // ждем готовности АЦП 2
 pkt8_ch_5 = ADC_read_aver(2,1);

 break;

//---------------- каналы 2 и 6 --------------------------------------//  
 case 2: 
 
 ADC_setCh(2,1);
 ADC_setCh(2,2);
 
 SYNC_ADC(1);    // синхр. измерений АЦП 1
 delay_us(200);  
 SYNC_ADC(2);    // синхр. измерений АЦП 2
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 pkt8_ch_2 = ADC_read_aver(1,2);

 While(ADC2_DRDY) { } // ждем готовности АЦП 2
 pkt8_ch_6 = ADC_read_aver(2,3);
 
 break;
 
//---------------- каналы 3 и 7 --------------------------------------//   
 case 3: 
 
 ADC_setCh(3,1);
 ADC_setCh(3,2);
 
 SYNC_ADC(1);   // синхр. измерений АЦП 1
 delay_us(200);  
 SYNC_ADC(2);   // синхр. измерений АЦП 2
 
 While(ADC_DRDY) { }  // ждем готовности АЦП 1
 pkt8_ch_3 = ADC_read_aver(1,4);
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 2
 pkt8_ch_7 = ADC_read_aver(2,5);
 
 break;
 
//---------------- каналы 4 и 8 --------------------------------------//   
 case 4: 
 
 ADC_setCh(4,1);
 ADC_setCh(4,2);
 
 SYNC_ADC(1);   // синхр. измерений АЦП 1
 delay_us(200);  
 SYNC_ADC(2);    // синхр. измерений АЦП 2
 
 While(ADC_DRDY) { }  // ждем готовности АЦП 1
 pkt8_ch_4 = ADC_read_aver(1,6);

 While(ADC2_DRDY) { } // ждем готовности АЦП 2
 pkt8_ch_8 = ADC_read_aver(2,7);

 Ma_buf_index++; // инкремент индекса
 if(Ma_buf_index > Ma_buf_size-1) Ma_buf_index = 0;   // сброс индекса буфера
 
 break;

   } // main case
}

  void save_to_flash() {
      
   Sps_Wr = NumAver;
   Aver_Wr = Ma_buf_size; // сохранение sps значения во флеш
   PGA = PGA_val;
   CRC_Wr = CRC8(flash_wr_data,3);
   Wr_Flash();
   } 

  #int_timer1
  void timer1_irq_handler(void) {
restart_wdt();     // сбос собачего таймера
set_timer1(8000); //reset the timer.
clear_interrupt(int_timer1);
}

  #INT_RDA2
  void UART2_RXd_isr(void){

while(U2STA & 0x0001)
{ // Receive buffer has data, at least one more character can be read
   wr_ptr++;
   rx_buf[wr_ptr & 0x0F] = (U8)(U2RXREG);
}
}

/*########################################################################### */

  void main()
{ 
  OscSetup();
  MCU_init(); 

  for(U8 i = 0; i < 125; i++) holding_register[i] = 0; // ??????? ?????? ?????????? ??????
  Clr_bufs();
  
  //ADC_sps_var = 0;   // сброс значений по умолчанию 
  //NumAver = 1;       // тк произошел сбой контр. суммы
     
  ADC_RESET = 1; ADC2_RESET = 1;
  ADC_CS = 1;    ADC2_CS = 1;
  ADC_SYNC = 1;  ADC2_SYNC = 1; 

  While(ADC2_DRDY | ADC2_DRDY) { }   // ждем готовности обоих АЦП перед иниц.  
  Rd_Flash();
  ADC_init();        // Инициализация обоих АЦП 
  
/*############################################################################*/  

  while(true){

  ADC_par_rd_ch(1); // измрение к 1 и 5
  ADC_par_rd_ch(2); // измрение к 2 и 6
  ADC_par_rd_ch(3); // измрение к 3 и 7
  ADC_par_rd_ch(4); // измрение к 4 и 8 
  
  meas_status = 1;  // уст. флага обновления измерений
   
  modbus_poll();    // анализ запроса modbus и ответ при необходимости
  
 } // while  
}  // main
/*############################################################################*/


