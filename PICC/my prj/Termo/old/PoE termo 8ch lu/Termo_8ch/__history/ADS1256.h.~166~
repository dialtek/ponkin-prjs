// изменена для версии PoE без дисплея
// 28.05.15

static U8 RdReg(U8 RegName)
{
   U8 RegValue = 0; 
   //1st Command Byte: 0001 rrrr where rrrr is the address of the first register to read.
   //2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to read – 1
   ADC_CS = 0;
   delay_us(1);
   Spi_write2(0x10+RegName); // 1st Command Byte,??????? ??????
   Spi_write2(0x00); // 1st Command Byte, ?????? ?????? ???? ????
   delay_us(8); // 50 CLK_IN PEDIODS
   RegValue = Spi_read2(0);
   delay_us(1);
   ADC_CS =1;
   delay_us(1);
   Return RegValue;  
}

static void WrReg(U8 RegName,CommandByte)
{
   ADC_CS = 0;
   ADC2_CS = 0;
   delay_us(5);
   Spi_write2(0x50+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written.
   delay_us(10);
   Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1.
   delay_us(10);
   Spi_write2(CommandByte);
   delay_us(10);
   ADC_CS = 1;
   ADC2_CS = 1;
   delay_us(2);
   
   //ADC_CS = 0;
   //ADC2_CS = 0;
   //delay_us(5);
   //Spi_write2(0x50+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written.
   //delay_us(10);
   //Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1.
   //delay_us(10);
   //Spi_write2(CommandByte);
   //delay_us(10);
   //ADC_CS = 1;
   //ADC2_CS = 1;
   
   delay_us(20);
}

static void ADC_sps_set(U8 SPS){

   //ADC_StopRd();                                                              
   Sps_buf = SPS;
   WrReg(DRATE,SPS); 
   delay_us(20);
                 
        
}

static void ADC_set_PGA(u8 PGA_val){
  
  PGA = PGA_val;

/* PGA
000 = 1 (default)
001 = 2
010 = 4
011 = 8
100 = 16
101 = 32
110 = 64
111 = 64*/
/**/

   switch (PGA_val){
      case 1:
       WrReg(ADCON,0);
      break;
      
      case 2:
       WrReg(ADCON,1);
      break;
      
      case 4:
       WrReg(ADCON,2);
      break;
      
      case 8:
       WrReg(ADCON,3);
      break;
      
      case 16:
       WrReg(ADCON,4);
      break;
      
      case 32:
       WrReg(ADCON,5);
      break;
      
      case 64:
       WrReg(ADCON,6);
      break; 
   }
   delay_us(20);
}

static void ADC_wakeUp(void){

   ADC_CS = 1;
   ADC2_CS = 1;
   
   //ADC_RESET = 0; //When using the RESET pin, take it low to force a reset.
   //ADC2_RESET = 0; //When using the RESET pin, take it low to force a reset.
   //delay_us(200);
   
   ADC_RESET = 1;
   ADC2_RESET = 1;
   
   //ADC_SYNC =0;
   //ADC2_SYNC =0;   
   //delay_us(200);
   
   ADC_SYNC = 1; 
   ADC2_SYNC = 1; 
   
   delay_ms(2);
}

static void ADC_SelfCal(){
                     
   ADC_CS = 0;
   ADC2_CS = 0;
   delay_us(1);
   Spi_write2(0xF0);
    delay_us(1);
   ADC_CS = 1;
   ADC2_CS = 1;
   
   While(ADC_DRDY) { }  // ждем окончания калибровки
   While(ADC2_DRDY) { }
   
   
   /*
   Switch (Sps_buf) {     
    
      case 0xF0:   
       delay_us(220);        
        break;                      
      
      case 0xE0:
       delay_us(255); 
        break;
        
      case 0xD0:
       delay_us(315); 
        break;
        
      case 0xC0:
       delay_us(445); 
        break;
        
      case 0xB0:
       delay_us(685); 
        break;
        
      case 0xA1:
       delay_ms(1);
       delay_us(185);               
        break;      
        
      case 0x92:
       delay_ms(5);
        break;
        
      case 0x82:
       delay_ms(10);
       delay_us(200);
        break;
                   
      case 0x63:
       delay_ms(21); 
        break;
        
      case 0x43:
       delay_ms(41); 
        break;
        
      case 0x23:
       delay_ms(101); 
        break;         
            
      case 0x13:
       delay_ms(201); 
        break;                          
     }
     */
}

static void ADC_setCh(U8 Ch_Number){

  Spi_write2(0x50+MUX);    
  delay_us(10);
  Spi_write2(0);         
  delay_us(10);
  Spi_write2(Mx_ch_code[Ch_Number]);
    
}

static S32 ADC_vol_average(U8 NumSamples){
   
   S32 A,Sum = 0;               
   U8 i;
   
   for (i=0;i<NumSamples;i++){
       
       //A = Read_ADC_vol_in(uV);
       Sum = Sum + A;    
   }                                  
   return Sum/NumSamples;
}

static void ADC_init(){
   
  WrReg(STATUS,2);   // вкл. входной буфер
  delay_us(20);

   if(ADC_sps_var>7)  ADC_sps_var = 7;
   // установка sps
   switch (ADC_sps_var){                // передача величины скорости измерений АЦП 
    
      case 0: ADC_sps_set(0x13);  break; // 5   sps
      case 1: ADC_sps_set(0x23);  break; // 10   sps
      case 2: ADC_sps_set(0x43);  break; // 25   sps
      case 3: ADC_sps_set(0x63);  break; // 50   sps
      case 4: ADC_sps_set(0x82);  break; // 100  sps
      case 5: ADC_sps_set(0x91);  break; // 500  sps
      case 6: ADC_sps_set(0xA1);  break; // 1000 sps
      case 7: ADC_sps_set(0xC0);  break; // 3750 sps
      }
      
   ADC_set_PGA(8);    // Уст. PGA
   ADC_SelfCal();     // Автокалибровка обоих АЦП 
}

static float power(float t, U8 k) // возведение t в степень k
{
  float res = 1.0;
  while (k) 
      {
        if (k & 1) 
           res *= t;
        t *= t;
        k >>= 1;
      }
  return res;
}

static ADC_read_ch (U8 channel)
  {
  
   if (channel > 4) ADC_select = 1;
   else ADC_select = 0;
   
   Switch (channel) 
   {
    // мультиплексирование каналов
    case 4: channel = 0x10; break;
    case 3: channel = 0x32; break;
    case 2: channel = 0x54; break;
    case 1: channel = 0x76; break;
    
    case 8: channel = 0x10; break;
    case 7: channel = 0x32; break;
    case 6: channel = 0x54; break;
    case 5: channel = 0x76; break;
    }
  
  if (ADC_select) {ADC_CS = 1; ADC2_CS = 0;}
  else            {ADC_CS = 0; ADC2_CS = 1;}
  
  Spi_write2(0x50+MUX);    // уст. канал 1 АЦП
  delay_us(10);
  Spi_write2(0);         
  delay_us(10);
  Spi_write2(channel);
  ADC_CS = 1;
  ADC2_CS = 1;
  //-------------------- 1 АЦП ----------------------------------//
  
  if (ADC_select) 
  {
      While(ADC2_DRDY) { } // ждем готовности АЦП 2
  }
  else            
  {
      While(ADC_DRDY) { } // ждем готовности АЦП 1
  }
  
  //While(ADC_DRDY) { }     // ждем готовности данных 1 АЦП
  
  if (ADC_select) {ADC_CS = 1; ADC2_CS = 0;}
  else            {ADC_CS = 0; ADC2_CS = 1;}
  
  Spi_write2(0x03);        // команда чтения
  delay_us(3);
  ADC_CS = 1;
  ADC2_CS = 1;
  
  delay_us(20);
  
  if (ADC_select) {ADC_CS = 1; ADC2_CS = 0;}
  else            {ADC_CS = 0; ADC2_CS = 1;}
  
  ADC_Rbyte1 = Spi_read2(0);   // чтение
  ADC_Rbyte2 = Spi_read2(0);
  ADC_Rbyte3 = Spi_read2(0);
  delay_us(3);
  ADC_CS = 1;
  ADC2_CS = 1;
   
 // While(ADC_DRDY) { }      // ждем готовности данных 1 АЦП
  
  //ADC_CS = 0;
  //delay_us(3);
  //Spi_write2(0x0F);        // стоп 1 АЦП  
  //ADC_CS = 1;
  //delay_us(10);
  
  //-------------------- Преобразование ----------------------------------//
  
  ADC_RByte_Sum = ((S32)ADC_Rbyte1<<24) | ((S32)ADC_Rbyte2<<16) | ((S32)ADC_Rbyte3<<8);
  ADC_RByte_Sum = ADC_RByte_Sum/256;
  
  //ADC2_RByte_Sum = ((S32)ADC2_Rbyte1<<24) | ((S32)ADC2_Rbyte2<<16) | ((S32)ADC2_Rbyte3<<8);
  //ADC2_RByte_Sum = ADC2_RByte_Sum/256;
  
  }
   
static void ADC_select(U8 command)
  {
   switch(command)
   {
         case 0: ADC_CS = 1; ADC2_CS = 1; break;
         case 1: ADC_CS = 0; ADC2_CS = 1; break;
         case 2: ADC_CS = 1; ADC2_CS = 0; break;
   }
  }
  
static S32 ADC_read()
  {
  
  S32 ADC_RByte_Sum;
  float Vin;
  
  //Spi_write2(0x03);        // команда чтения RdataC
  Spi_write2(0x01);        // команда чтения Rdata
  delay_us(20);
  ADC_Rbyte1 = Spi_read2(0);   // чтение
  ADC_Rbyte2 = Spi_read2(0);
  ADC_Rbyte3 = Spi_read2(0);
  
  ADC_RByte_Sum = ((S32)ADC_Rbyte1<<24) | ((S32)ADC_Rbyte2<<16) | ((S32)ADC_Rbyte3<<8);
  ADC_RByte_Sum = ADC_RByte_Sum/256;
  
  Vin = ((ADC_RByte_Sum*5)/(8388608.0*PGA));
  
  return Vin*uV;
  
  }
