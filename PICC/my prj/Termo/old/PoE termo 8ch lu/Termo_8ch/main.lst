CCS PCD C Compiler, Version 5.015, 5967               30-мар-17 14:38

               Filename:   E:\work\Projects\ponkin\PICC\my prj\Termo\PoE termo 8ch lu\Termo_8ch\main.lst

               ROM used:   6102 bytes (7%)
                           Largest free fragment is 59434
               RAM used:   4390 (54%) at main() level
                           4486 (55%) worst case
               Stack size: 128

*
00000:  GOTO    1618
*
0001A:  DATA    34,03,00
*
00050:  DATA    5C,03,00
.................... #include <main.h> 
.................... #include <24HJ128GP506A.h> 
.................... //////////// Standard Header file for the PIC24HJ128GP506A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24HJ128GP506A 
*
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    73,74,00
0020E:  DATA    6F,70,00
00210:  DATA    70,65,00
00212:  DATA    64,0A,00
00214:  DATA    0D,00,00
00216:  CLR     32
00218:  MOV     #222,W3
0021A:  ADD     W3,W0,W0
0021C:  TBLRDL.B[W0],W0L
0021E:  CLR.B   1
00220:  RETURN  
00222:  DATA    65,72,00
00224:  DATA    72,20,00
00226:  DATA    0D,0A,00
00228:  DATA    00,00,00
0022A:  CLR     32
0022C:  MOV     #236,W3
0022E:  ADD     W3,W0,W0
00230:  TBLRDL.B[W0],W0L
00232:  CLR.B   1
00234:  RETURN  
00236:  DATA    50,47,00
00238:  DATA    41,20,00
0023A:  DATA    65,72,00
0023C:  DATA    72,20,00
0023E:  DATA    0D,0A,00
00240:  DATA    00,00,00
00242:  CLR     32
00244:  MOV     #24E,W3
00246:  ADD     W3,W0,W0
00248:  TBLRDL.B[W0],W0L
0024A:  CLR.B   1
0024C:  RETURN  
0024E:  DATA    50,47,00
00250:  DATA    41,3D,00
00252:  DATA    25,75,00
00254:  DATA    20,0D,00
00256:  DATA    0A,00,00
00258:  CLR     32
0025A:  MOV     #264,W3
0025C:  ADD     W3,W0,W0
0025E:  TBLRDL.B[W0],W0L
00260:  CLR.B   1
00262:  RETURN  
00264:  DATA    50,47,00
00266:  DATA    41,20,00
00268:  DATA    6F,75,00
0026A:  DATA    74,20,00
0026C:  DATA    6F,66,00
0026E:  DATA    20,72,00
00270:  DATA    61,6E,00
00272:  DATA    67,65,00
00274:  DATA    0D,0A,00
00276:  DATA    00,00,00
00278:  CLR     32
0027A:  MOV     #284,W3
0027C:  ADD     W3,W0,W0
0027E:  TBLRDL.B[W0],W0L
00280:  CLR.B   1
00282:  RETURN  
00284:  DATA    65,72,00
00286:  DATA    72,20,00
00288:  DATA    70,31,00
0028A:  DATA    20,0D,00
0028C:  DATA    0A,00,00
0028E:  CLR     32
00290:  MOV     #29A,W3
00292:  ADD     W3,W0,W0
00294:  TBLRDL.B[W0],W0L
00296:  CLR.B   1
00298:  RETURN  
0029A:  DATA    65,72,00
0029C:  DATA    72,20,00
0029E:  DATA    70,32,00
002A0:  DATA    20,0D,00
002A2:  DATA    0A,00,00
002A4:  CLR     32
002A6:  MOV     #2B0,W3
002A8:  ADD     W3,W0,W0
002AA:  TBLRDL.B[W0],W0L
002AC:  CLR.B   1
002AE:  RETURN  
002B0:  DATA    53,50,00
002B2:  DATA    53,3D,00
002B4:  DATA    25,75,00
002B6:  DATA    20,0D,00
002B8:  DATA    0A,00,00
002BA:  CLR     32
002BC:  MOV     #2C6,W3
002BE:  ADD     W3,W0,W0
002C0:  TBLRDL.B[W0],W0L
002C2:  CLR.B   1
002C4:  RETURN  
002C6:  DATA    53,50,00
002C8:  DATA    53,20,00
002CA:  DATA    6F,75,00
002CC:  DATA    74,20,00
002CE:  DATA    6F,66,00
002D0:  DATA    20,72,00
002D2:  DATA    61,6E,00
002D4:  DATA    67,65,00
002D6:  DATA    0D,0A,00
002D8:  DATA    00,00,00
002DA:  CLR     32
002DC:  MOV     #2E6,W3
002DE:  ADD     W3,W0,W0
002E0:  TBLRDL.B[W0],W0L
002E2:  CLR.B   1
002E4:  RETURN  
002E6:  DATA    65,72,00
002E8:  DATA    72,20,00
002EA:  DATA    70,33,00
002EC:  DATA    20,0D,00
002EE:  DATA    0A,00,00
002F0:  CLR     32
002F2:  MOV     #2FC,W3
002F4:  ADD     W3,W0,W0
002F6:  TBLRDL.B[W0],W0L
002F8:  CLR.B   1
002FA:  RETURN  
002FC:  DATA    61,76,00
002FE:  DATA    65,72,00
00300:  DATA    20,62,00
00302:  DATA    75,66,00
00304:  DATA    20,73,00
00306:  DATA    69,7A,00
00308:  DATA    65,3D,00
0030A:  DATA    25,75,00
0030C:  DATA    20,0D,00
0030E:  DATA    0A,00,00
00310:  CLR     32
00312:  MOV     #31C,W3
00314:  ADD     W3,W0,W0
00316:  TBLRDL.B[W0],W0L
00318:  CLR.B   1
0031A:  RETURN  
0031C:  DATA    61,76,00
0031E:  DATA    65,72,00
00320:  DATA    20,62,00
00322:  DATA    75,66,00
00324:  DATA    20,6F,00
00326:  DATA    75,74,00
00328:  DATA    20,6F,00
0032A:  DATA    66,20,00
0032C:  DATA    72,61,00
0032E:  DATA    6E,67,00
00330:  DATA    65,0D,00
00332:  DATA    0A,00,00
*
0075C:  MOV     W5,[W15++]
0075E:  MOV     #C,W5
00760:  REPEAT  #3
00762:  MOV     [W5++],[W15++]
00764:  MOV     #0,W9
00766:  BTSC.B  43.0
00768:  MOV     #1,W9
0076A:  MOV     W9,[W15++]
0076C:  XOR     W1,W3,W9
0076E:  BTSS    W1.F
00770:  BRA     778
00772:  COM     W1,W1
00774:  NEG     W0,W0
00776:  ADDC    W1,#0,W1
00778:  BTSS    W3.F
0077A:  BRA     782
0077C:  COM     W3,W3
0077E:  NEG     W2,W2
00780:  ADDC    W3,#0,W3
00782:  XOR     W2,W3,W4
00784:  BRA     Z,7B0
00786:  CLR     W4
00788:  CLR     W5
0078A:  CLR     W6
0078C:  CLR     W7
0078E:  MOV     #20,W8
00790:  BCLR.B  42.0
00792:  RLC     W0,W0
00794:  RLC     W1,W1
00796:  RLC     W4,W4
00798:  RLC     W5,W5
0079A:  CP      W5,W3
0079C:  BRA     NZ,7A0
0079E:  CPB     W4,W2
007A0:  BRA     NC,7A8
007A2:  SUB     W4,W2,W4
007A4:  SUBB    W5,W3,W5
007A6:  BSET.B  42.0
007A8:  RLC     W6,W6
007AA:  RLC     W7,W7
007AC:  DEC     W8,W8
007AE:  BRA     NZ,790
007B0:  BTSS    W9.F
007B2:  BRA     7C2
007B4:  NEG     W6,W0
007B6:  BRA     Z,7BA
007B8:  BRA     NZ,7BE
007BA:  NEG     W7,W1
007BC:  BRA     7C8
007BE:  COM     W7,W1
007C0:  BRA     7C8
007C2:  MOV     W7,W1
007C4:  MOV     W6,W0
007C6:  BRA     7C8
007C8:  MOV     [--W15],W9
007CA:  CP0     W9
007CC:  BRA     Z,7D0
007CE:  MOV.D   W4,W0
007D0:  MOV     #12,W5
007D2:  REPEAT  #3
007D4:  MOV     [--W15],[W5--]
007D6:  MOV     [--W15],W5
007D8:  RETURN  
007DA:  MOV     W5,[W15++]
007DC:  MOV     #C,W5
007DE:  REPEAT  #3
007E0:  MOV     [W5++],[W15++]
007E2:  MUL.UU  W0,W2,W4
007E4:  BTSS    W3.F
007E6:  BRA     7EC
007E8:  MUL.SS  W0,W3,W6
007EA:  BRA     7EE
007EC:  MUL.UU  W0,W3,W6
007EE:  BCLR.B  42.0
007F0:  ADD     W6,W5,W5
007F2:  ADDC    W7,#0,W8
007F4:  BTSS    W1.F
007F6:  BRA     7FC
007F8:  MUL.SS  W1,W2,W6
007FA:  BRA     7FE
007FC:  MUL.UU  W1,W2,W6
007FE:  ADDC    W6,W5,W5
00800:  ADDC    W7,W8,W8
00802:  ADDC    #0,W9
00804:  MUL.SS  W1,W3,W6
00806:  ADDC    W6,W8,W8
00808:  ADDC    W9,W7,W7
0080A:  MOV     W7,W3
0080C:  MOV     W8,W2
0080E:  MOV     W5,W1
00810:  MOV     W4,W0
00812:  MOV     #12,W5
00814:  REPEAT  #3
00816:  MOV     [--W15],[W5--]
00818:  MOV     [--W15],W5
0081A:  RETURN  
0081C:  MOV     W5,[W15++]
0081E:  MOV     #C,W5
00820:  REPEAT  #3
00822:  MOV     [W5++],[W15++]
00824:  MOV     W0,W4
00826:  MOV     W1,W5
00828:  MOV     W2,W6
0082A:  MOV     W3,W7
0082C:  CLR     W0
0082E:  CLR     W1
00830:  CLR     W2
00832:  CLR     W3
00834:  BCLR    W8.0
00836:  BTSS    W7.F
00838:  BRA     844
0083A:  BSET    W8.0
0083C:  NEG     W4,W4
0083E:  COM     W5,W5
00840:  COM     W6,W6
00842:  COM     W7,W7
00844:  IOR      W4,  W5,W9
00846:  BRA     NZ,84C
00848:  IOR      W6,  W7,W9
0084A:  BRA     Z,876
0084C:  MOV     #473,W9
0084E:  BTSC    W3.4
00850:  BRA     868
00852:  BCLR.B  42.0
00854:  RLC     W4,W4
00856:  RLC     W5,W5
00858:  RLC     W6,W6
0085A:  RLC     W7,W7
0085C:  RLC     W0,W0
0085E:  RLC     W1,W1
00860:  RLC     W2,W2
00862:  RLC     W3,W3
00864:  DEC     W9,W9
00866:  BRA     NZ,84E
00868:  SL      W9,#4,W9
0086A:  BCLR.B  42.0
0086C:  BCLR    W9.F
0086E:  BCLR    W3.4
00870:  XOR     W9,W3,W3
00872:  BTSC    W8.0
00874:  BSET    W3.F
00876:  MOV     #12,W5
00878:  REPEAT  #3
0087A:  MOV     [--W15],[W5--]
0087C:  MOV     [--W15],W5
0087E:  RETURN  
00880:  MOV     W8,[W15++]
00882:  MOV     #12,W8
00884:  REPEAT  #4
00886:  MOV     [W8++],[W15++]
00888:  CLR     W11
0088A:  MUL.UU  W12,#0,W12
0088C:  MOV     W3,W8
0088E:  MOV     W7,W9
00890:  MOV     #7FF,W10
00892:  BCLR.B  42.0
00894:  BCLR.B  42.1
00896:  ASR     W8,#4,W8
00898:  AND     W10,W8,W8
0089A:  CP0     W8
0089C:  BRA     Z,980
0089E:  BCLR.B  42.0
008A0:  BCLR.B  42.1
008A2:  ASR     W9,#4,W9
008A4:  AND     W10,W9,W9
008A6:  CP0     W9
008A8:  BRA     Z,980
008AA:  ADD     W9,W8,W8
008AC:  BTSC    W9.B
008AE:  BRA     8B8
008B0:  SUB     #3FF,W8
008B2:  BRA     Z,980
008B4:  BRA     NC,980
008B6:  BRA     8BE
008B8:  MOV     #401,W10
008BA:  ADD.B   W10L,W5L,W5L
008BC:  BRA     C,980
008BE:  XOR     W3,W7,W13
008C0:  BCLR.B  42.0
008C2:  BCLR.B  42.1
008C4:  AND     #F,W3
008C6:  BSET    W3.4
008C8:  AND     #F,W7
008CA:  BSET    W7.4
008CC:  MOV     W8,[W15++]
008CE:  MUL.UU  W4,W1,W8
008D0:  MUL.UU  W5,W0,W10
008D2:  ADD     W8,W10,W10
008D4:  ADDC    W9,W11,W11
008D6:  ADDC    #0,W12
008D8:  MUL.UU  W4,W2,W8
008DA:  ADD     W8,W11,W11
008DC:  ADDC    W9,W12,W12
008DE:  MUL.UU  W5,W1,W8
008E0:  CLR     W10
008E2:  ADD     W8,W11,W11
008E4:  ADDC    W9,W12,W12
008E6:  ADDC    #0,W10
008E8:  MUL.UU  W6,W0,W8
008EA:  ADD     W8,W11,W11
008EC:  ADDC    W9,W12,W12
008EE:  ADDC    #0,W10
008F0:  CLR     W11
008F2:  MUL.UU  W4,W3,W8
008F4:  ADD     W8,W12,W12
008F6:  ADDC    W9,W10,W10
008F8:  ADDC    #0,W11
008FA:  MUL.UU  W5,W2,W8
008FC:  ADD     W8,W12,W12
008FE:  ADDC    W9,W10,W10
00900:  ADDC    #0,W11
00902:  MUL.UU  W6,W1,W8
00904:  ADD     W8,W12,W12
00906:  ADDC    W9,W10,W10
00908:  ADDC    #0,W11
0090A:  MUL.UU  W7,W0,W8
0090C:  ADD     W8,W12,W12
0090E:  ADDC    W9,W10,W10
00910:  ADDC    #0,W11
00912:  MOV     W12,W0
00914:  CLR     W12
00916:  MUL.UU  W5,W3,W8
00918:  ADD     W8,W10,W10
0091A:  ADDC    W9,W11,W11
0091C:  ADDC    #0,W12
0091E:  MUL.UU  W6,W2,W8
00920:  ADD     W8,W10,W10
00922:  ADDC    W9,W11,W11
00924:  ADDC    #0,W12
00926:  MUL.UU  W6,W3,W8
00928:  ADD     W8,W11,W11
0092A:  ADDC    W9,W12,W12
0092C:  MUL.UU  W7,W1,W8
0092E:  ADD     W8,W10,W10
00930:  ADDC    W9,W11,W11
00932:  ADDC    #0,W12
00934:  MUL.UU  W7,W2,W8
00936:  ADD     W8,W11,W11
00938:  ADDC    W9,W12,W12
0093A:  MUL.UU  W7,W3,W8
0093C:  ADD     W8,W12,W12
0093E:  MOV     W10,W1
00940:  MOV     W11,W2
00942:  MOV     W12,W3
00944:  MOV     #5,W4
00946:  BCLR.B  42.0
00948:  RRC     W3,W3
0094A:  RRC     W2,W2
0094C:  RRC     W1,W1
0094E:  RRC     W0,W0
00950:  DEC     W4,W4
00952:  BRA     NZ,946
00954:  MOV     [--W15],W8
00956:  INC     W8,W8
00958:  IOR      W0,  W1,W6
0095A:  BRA     Z,95E
0095C:  BRA     962
0095E:  IOR      W2,  W3,W6
00960:  BRA     Z,972
00962:  BTSC    W3.4
00964:  BRA     972
00966:  BCLR.B  42.0
00968:  RLC     W0,W0
0096A:  RLC     W1,W1
0096C:  RLC     W2,W2
0096E:  RLC     W3,W3
00970:  DEC     W8,W8
00972:  SL      W8,#4,W8
00974:  BCLR    W3.F
00976:  BTSC    W13.F
00978:  BSET    W3.F
0097A:  BCLR    W3.4
0097C:  XOR     W8,W3,W3
0097E:  BRA     986
00980:  MUL.UU  W0,#0,W0
00982:  MUL.UU  W0,#0,W2
00984:  BRA     986
00986:  MOV     #1A,W8
00988:  REPEAT  #4
0098A:  MOV     [--W15],[W8--]
0098C:  MOV     [--W15],W8
0098E:  RETURN  
00990:  MOV     W5,[W15++]
00992:  MOV     #C,W5
00994:  REPEAT  #3
00996:  MOV     [W5++],[W15++]
00998:  MOV     W0,W4
0099A:  MOV     W1,W5
0099C:  MOV     W2,W6
0099E:  MOV     W3,W7
009A0:  CLR     W0
009A2:  CLR     W1
009A4:  CLR     W2
009A6:  CLR     W3
009A8:  BCLR    W8.0
009AA:  BTSS    W7.F
009AC:  BRA     9B8
009AE:  BSET    W8.0
009B0:  NEG     W4,W4
009B2:  COM     W5,W5
009B4:  COM     W6,W6
009B6:  COM     W7,W7
009B8:  IOR      W4,  W5,W9
009BA:  BRA     NZ,9C0
009BC:  IOR      W6,  W7,W9
009BE:  BRA     Z,9EA
009C0:  MOV     #473,W9
009C2:  BTSC    W3.4
009C4:  BRA     9DC
009C6:  BCLR.B  42.0
009C8:  RLC     W4,W4
009CA:  RLC     W5,W5
009CC:  RLC     W6,W6
009CE:  RLC     W7,W7
009D0:  RLC     W0,W0
009D2:  RLC     W1,W1
009D4:  RLC     W2,W2
009D6:  RLC     W3,W3
009D8:  DEC     W9,W9
009DA:  BRA     NZ,9C2
009DC:  SL      W9,#4,W9
009DE:  BCLR.B  42.0
009E0:  BCLR    W9.F
009E2:  BCLR    W3.4
009E4:  XOR     W9,W3,W3
009E6:  BTSC    W8.0
009E8:  BSET    W3.F
009EA:  MOV     #12,W5
009EC:  REPEAT  #3
009EE:  MOV     [--W15],[W5--]
009F0:  MOV     [--W15],W5
009F2:  RETURN  
009F4:  MOV     W8,[W15++]
009F6:  MOV     #12,W8
009F8:  REPEAT  #4
009FA:  MOV     [W8++],[W15++]
009FC:  XOR     W3,W7,W13
009FE:  MOV     W3,W8
00A00:  MOV     W7,W9
00A02:  MOV     #7FF,W10
00A04:  BCLR.B  42.0
00A06:  BCLR.B  42.1
00A08:  ASR     W8,#4,W8
00A0A:  AND     W10,W8,W8
00A0C:  CP0     W8
00A0E:  BRA     Z,AE8
00A10:  BCLR.B  42.0
00A12:  BCLR.B  42.1
00A14:  ASR     W9,#4,W9
00A16:  AND     W10,W9,W9
00A18:  CP0     W9
00A1A:  BRA     Z,AE8
00A1C:  CLR     W10
00A1E:  SUB     W8,W9,W12
00A20:  BRA     NC,A28
00A22:  ADD     #3FF,W12
00A24:  BRA     C,AE8
00A26:  BRA     A30
00A28:  MOV     #401,W11
00A2A:  SUB     W12,W11,W12
00A2C:  BRA     NC,AE8
00A2E:  BRA     Z,AE8
00A30:  CLR     W8
00A32:  CLR     W9
00A34:  CLR     W10
00A36:  CLR     W11
00A38:  AND     #1F,W3
00A3A:  BSET    W3.4
00A3C:  AND     #1F,W7
00A3E:  BSET    W7.4
00A40:  MOV     W12,[W15++]
00A42:  MOV     #36,W12
00A44:  SUB     W0,W4,W0
00A46:  SUBB    W1,W5,W1
00A48:  SUBB    W2,W6,W2
00A4A:  SUBB    W3,W7,W3
00A4C:  BRA     N,A52
00A4E:  BRA     C,A5C
00A50:  BRA     NZ,A5E
00A52:  ADD     W0,W4,W0
00A54:  ADDC    W1,W5,W1
00A56:  ADDC    W2,W6,W2
00A58:  ADDC    W3,W7,W3
00A5A:  BRA     A5E
00A5C:  BSET    W8.0
00A5E:  DEC     W12,W12
00A60:  BRA     Z,A78
00A62:  BCLR.B  42.0
00A64:  RLC     W0,W0
00A66:  RLC     W1,W1
00A68:  RLC     W2,W2
00A6A:  RLC     W3,W3
00A6C:  BCLR.B  42.0
00A6E:  RLC     W8,W8
00A70:  RLC     W9,W9
00A72:  RLC     W10,W10
00A74:  RLC     W11,W11
00A76:  BRA     A44
00A78:  MOV     [--W15],W12
00A7A:  BTSC    W11.5
00A7C:  BRA     A80
00A7E:  BRA     A8C
00A80:  BCLR.B  42.0
00A82:  RRC     W11,W11
00A84:  RRC     W10,W10
00A86:  RRC     W9,W9
00A88:  RRC     W8,W8
00A8A:  BRA     A92
00A8C:  DEC     W12,W12
00A8E:  BCLR.B  42.0
00A90:  BRA     Z,AE8
00A92:  BTSC.B  42.0
00A94:  BRA     AA8
00A96:  RLC     W0,W0
00A98:  RLC     W1,W1
00A9A:  RLC     W2,W2
00A9C:  RLC     W3,W3
00A9E:  SUB     W0,W4,W4
00AA0:  SUBB    W1,W5,W5
00AA2:  SUBB    W2,W6,W6
00AA4:  SUBB    W3,W7,W7
00AA6:  BRA     NC,AD2
00AA8:  INC     W8,W8
00AAA:  BRA     NZ,AD2
00AAC:  INC     W9,W9
00AAE:  BRA     NZ,AD2
00AB0:  INC     W10,W10
00AB2:  BRA     NZ,AD2
00AB4:  INC     W11,W11
00AB6:  BRA     NZ,AD2
00AB8:  INC     W12,W12
00ABA:  BRA     Z,AE8
00ABC:  BRA     AD2
00ABE:  DEC     W12,W12
00AC0:  BRA     Z,AE8
00AC2:  BTSC    W11.4
00AC4:  BRA     AD2
00AC6:  BCLR.B  42.0
00AC8:  RLC     W8,W8
00ACA:  RLC     W9,W9
00ACC:  RLC     W10,W10
00ACE:  RLC     W11,W11
00AD0:  BRA     AC2
00AD2:  SL      W12,#4,W12
00AD4:  BCLR.B  42.0
00AD6:  BCLR    W12.F
00AD8:  BTSC    W13.F
00ADA:  BSET    W12.F
00ADC:  BCLR    W11.4
00ADE:  XOR     W12,W11,W3
00AE0:  MOV     W10,W2
00AE2:  MOV     W9,W1
00AE4:  MOV     W8,W0
00AE6:  BRA     AF2
00AE8:  MOV     #0,W0
00AEA:  MOV     #0,W1
00AEC:  MOV     #0,W2
00AEE:  MOV     #0,W3
00AF0:  BRA     AF2
00AF2:  MOV     #1A,W8
00AF4:  REPEAT  #4
00AF6:  MOV     [--W15],[W8--]
00AF8:  MOV     [--W15],W8
00AFA:  RETURN  
00AFC:  MOV     W5,[W15++]
00AFE:  MOV     W6,[W15++]
00B00:  MOV     W3,W4
00B02:  MOV     W3,W6
00B04:  BCLR.B  42.0
00B06:  ASR     W4,#4,W4
00B08:  MOV     #7FF,W5
00B0A:  AND     W5,W4,W4
00B0C:  BRA     NZ,B14
00B0E:  MUL.UU  W0,#0,W0
00B10:  CLR     W2
00B12:  BRA     B3A
00B14:  SUB     #380,W4
00B16:  AND     #F,W3
00B18:  MOV     #3,W7
00B1A:  BCLR.B  42.0
00B1C:  RLC     W0,W0
00B1E:  RLC     W1,W1
00B20:  RLC     W2,W2
00B22:  RLC     W3,W3
00B24:  DEC     W7,W7
00B26:  BRA     NZ,B1A
00B28:  MOV     W1,W0
00B2A:  MOV     W2,W1
00B2C:  BCLR    W3.7
00B2E:  SWAP    W4
00B30:  BCLR.B  42.0
00B32:  RRC     W4,W4
00B34:  BTSC    W6.F
00B36:  BSET    W4.F
00B38:  XOR     W4,W3,W2
00B3A:  MOV     [--W15],W6
00B3C:  MOV     [--W15],W5
00B3E:  RETURN  
00B40:  MOV     W5,[W15++]
00B42:  MOV     #C,W5
00B44:  REPEAT  #4
00B46:  MOV     [W5++],[W15++]
00B48:  MOV     W0,W4
00B4A:  MOV     W1,W5
00B4C:  MOV     W3,W7
00B4E:  MOV     W2,W6
00B50:  BCLR.B  42.0
00B52:  BCLR.B  42.1
00B54:  RLC     W1,W1
00B56:  SWAP    W1
00B58:  AND     #FF,W1
00B5A:  CP0     W1
00B5C:  BRA     Z,BF4
00B5E:  BCLR.B  42.0
00B60:  BCLR.B  42.1
00B62:  RLC     W3,W3
00B64:  SWAP    W3
00B66:  AND     #FF,W3
00B68:  CP0     W3
00B6A:  BRA     Z,BF4
00B6C:  ZE      W0,W0
00B6E:  ADD.B   W3L,W1L,W0L
00B70:  BRA     C,B7A
00B72:  SUB     #7F,W0
00B74:  BRA     Z,BF4
00B76:  BRA     NC,BF4
00B78:  BRA     B7E
00B7A:  ADD.B   #81,W0L
00B7C:  BRA     C,BF4
00B7E:  XOR     W5,W7,W10
00B80:  BCLR.B  42.0
00B82:  BCLR.B  42.1
00B84:  AND     #FF,W5
00B86:  BSET    W5.7
00B88:  BCLR.B  42.0
00B8A:  AND     #FF,W7
00B8C:  BSET    W7.7
00B8E:  MUL.UU  W4,W6,W2
00B90:  MUL.UU  W5,W6,W8
00B92:  ADDC    W8,W3,W3
00B94:  MOV     W9,W1
00B96:  BTSC.B  42.0
00B98:  INC     W1,W1
00B9A:  BCLR.B  42.0
00B9C:  MUL.UU  W7,W4,W8
00B9E:  ADDC    W8,W3,W3
00BA0:  ADDC    W9,W1,W1
00BA2:  MUL.UU  W5,W7,W8
00BA4:  ADDC    W8,W1,W1
00BA6:  INC     W0,W0
00BA8:  CP0     W1
00BAA:  BTSC.B  42.1
00BAC:  BRA     BB0
00BAE:  BRA     BB6
00BB0:  CP0     W3
00BB2:  BTSC.B  42.1
00BB4:  BRA     BC0
00BB6:  BTSC    W1.F
00BB8:  BRA     BC0
00BBA:  RLC     W3,W3
00BBC:  RLC     W1,W1
00BBE:  DEC     W0,W0
00BC0:  MOV     W1,W2
00BC2:  BCLR.B  42.0
00BC4:  BTSS    W3.7
00BC6:  BRA     BDA
00BC8:  MOV     #FF00,W7
00BCA:  AND     W3,W7,W3
00BCC:  ADD     #100,W3
00BCE:  ADDC    W2,#0,W2
00BD0:  CP0     W2
00BD2:  BRA     NZ,BDA
00BD4:  CP0     W3
00BD6:  BRA     NZ,BDA
00BD8:  INC     W0,W0
00BDA:  SWAP    W0
00BDC:  BCLR.B  42.0
00BDE:  BCLR.B  42.1
00BE0:  RRC     W0,W1
00BE2:  BTSC    W10.F
00BE4:  BSET    W1.F
00BE6:  BCLR    W2.F
00BE8:  SWAP    W2
00BEA:  XOR.B   W2L,W1L,W1L
00BEC:  SWAP    W3
00BEE:  MOV.B   W3L,W2L
00BF0:  MOV     W2,W0
00BF2:  BRA     BFA
00BF4:  MOV     #0,W0
00BF6:  MOV     #0,W1
00BF8:  BRA     BFA
00BFA:  MOV     #14,W5
00BFC:  REPEAT  #4
00BFE:  MOV     [--W15],[W5--]
00C00:  MOV     [--W15],W5
00C02:  RETURN  
00C04:  MOV     W5,[W15++]
00C06:  MOV     W1,W5
00C08:  MOV     W0,W2
00C0A:  MOV     #B6,W4
00C0C:  RLC     W1,W1
00C0E:  SWAP    W1
00C10:  AND     #FF,W1
00C12:  SUB.B   W4L,W1L,W4L
00C14:  MOV.B   W5L,W3L
00C16:  BSET    W3.7
00C18:  AND     #FF,W3
00C1A:  CLR     W0
00C1C:  CLR     W1
00C1E:  CP      W4,#1F
00C20:  BRA     N,C40
00C22:  BCLR.B  42.0
00C24:  RRC     W3,W3
00C26:  RRC     W2,W2
00C28:  RRC     W1,W1
00C2A:  RRC     W0,W0
00C2C:  DEC     W4,W4
00C2E:  BRA     NZ,C22
00C30:  BTSS    W5.F
00C32:  BRA     C40
00C34:  NEG     W0,W0
00C36:  BRA     Z,C3C
00C38:  COM     W1,W1
00C3A:  BRA     C40
00C3C:  NEG     W1,W1
00C3E:  BRA     C40
00C40:  MOV     [--W15],W5
00C42:  RETURN  
*
00EDE:  MOV     W5,[W15++]
00EE0:  MOV     #C,W5
00EE2:  REPEAT  #3
00EE4:  MOV     [W5++],[W15++]
00EE6:  MOV     W0,W7
00EE8:  MOV     W4,W9
00EEA:  BCLR    W4.F
00EEC:  CP0     W4
00EEE:  BRA     NZ,EFC
00EF0:  BTSC    W9.F
00EF2:  BRA     EF8
00EF4:  MOV     #0,W5
00EF6:  BRA     F16
00EF8:  MOV     #0,W5
00EFA:  BRA     F16
00EFC:  SUB.B   W4L,#6,W5L
00EFE:  BRA     NC,F14
00F00:  MOV     #30,W0
00F02:  BTSS    W9.F
00F04:  MOV     #20,W0
00F06:  BTSC.B  233.1
00F08:  BRA     F06
00F0A:  MOV     W0,234
00F0C:  DEC     W5,W5
00F0E:  BRA     NN,F06
00F10:  MOV     #5,W5
00F12:  BRA     F16
00F14:  MOV     W4,W5
00F16:  MOV     #6,W4
00F18:  BSET    W5.E
00F1A:  BTSC    W9.F
00F1C:  BSET    W5.F
00F1E:  MOV     #2710,W8
00F20:  REPEAT  #11
00F22:  DIV.U   W7,W8
00F24:  CALL    F58
00F28:  MOV     W1,W7
00F2A:  MOV     #3E8,W8
00F2C:  REPEAT  #11
00F2E:  DIV.U   W7,W8
00F30:  CALL    F58
00F34:  MOV     W1,W7
00F36:  MOV     #64,W8
00F38:  REPEAT  #11
00F3A:  DIV.U   W7,W8
00F3C:  CALL    F58
00F40:  MOV     W1,W7
00F42:  MOV     #A,W8
00F44:  REPEAT  #11
00F46:  DIV.U   W7,W8
00F48:  CALL    F58
00F4C:  MOV     #30,W0
00F4E:  ADD.B   W1L,W0L,W0L
00F50:  BTSC.B  233.1
00F52:  BRA     F50
00F54:  MOV     W0,234
00F56:  BRA     F86
00F58:  MOV     #30,W6
00F5A:  CP0     W0
00F5C:  BRA     NZ,F7A
00F5E:  BTSS    W5.E
00F60:  BRA     F7C
00F62:  DEC     W4,W4
00F64:  CP.B    W4L,W5L
00F66:  BRA     Z,F6C
00F68:  BTSC.B  42.0
00F6A:  RETURN  
00F6C:  CP0     W0
00F6E:  BRA     NZ,F7A
00F70:  BTSS    W5.E
00F72:  BRA     F7C
00F74:  BTSS    W5.F
00F76:  MOV     #20,W6
00F78:  BRA     F7C
00F7A:  BCLR    W5.E
00F7C:  ADD.B   W6L,W0L,W0L
00F7E:  BTSC.B  233.1
00F80:  BRA     F7E
00F82:  MOV     W0,234
00F84:  RETURN  
00F86:  MOV     #12,W5
00F88:  REPEAT  #3
00F8A:  MOV     [--W15],[W5--]
00F8C:  MOV     [--W15],W5
00F8E:  RETURN  
*
014C0:  MOV     W6,[W15++]
014C2:  MOV     W7,[W15++]
014C4:  MOV     W8,[W15++]
014C6:  MOV     W9,[W15++]
014C8:  CLR     W4
014CA:  CLR     W5
014CC:  CLR     W6
014CE:  CLR     W7
014D0:  XOR     W2,W3,W8
014D2:  BRA     Z,14F6
014D4:  MOV     #20,W8
014D6:  BCLR.B  42.0
014D8:  RLC     W0,W0
014DA:  RLC     W1,W1
014DC:  RLC     W4,W4
014DE:  RLC     W5,W5
014E0:  CP      W5,W3
014E2:  BRA     NZ,14E6
014E4:  CPB     W4,W2
014E6:  BRA     NC,14EE
014E8:  SUB     W4,W2,W4
014EA:  SUBB    W5,W3,W5
014EC:  BSET.B  42.0
014EE:  RLC     W6,W6
014F0:  RLC     W7,W7
014F2:  DEC     W8,W8
014F4:  BRA     NZ,14D6
014F6:  MOV     W7,W1
014F8:  MOV     W6,W0
014FA:  MOV     [--W15],W9
014FC:  MOV     [--W15],W8
014FE:  MOV     [--W15],W7
01500:  MOV     [--W15],W6
01502:  RETURN  
01504:  MOV     W5,[W15++]
01506:  MOV     #C,W5
01508:  REPEAT  #7
0150A:  MOV     [W5++],[W15++]
0150C:  BTSS    W1.F
0150E:  BRA     151E
01510:  NEG     W0,W0
01512:  BRA     Z,1516
01514:  BRA     NZ,151A
01516:  NEG     W1,W1
01518:  BRA     151C
0151A:  COM     W1,W1
0151C:  BSET    W4.8
0151E:  CLR     W5
01520:  MOV     W0,W6
01522:  MOV     W1,W7
01524:  MOV     W4,W12
01526:  BCLR    W4.F
01528:  CP0.B   W4L
0152A:  BRA     NZ,152E
0152C:  BRA     155E
0152E:  SUB.B   W4L,#B,W5L
01530:  BRA     NC,155E
01532:  SUB.B   W4L,W5L,W4L
01534:  BTSS    W12.F
01536:  BRA     154E
01538:  BTSS    W4.8
0153A:  BRA     154A
0153C:  MOV     #2D,W0
0153E:  BTSC.B  233.1
01540:  BRA     153E
01542:  MOV     W0,234
01544:  BCLR    W4.8
01546:  DEC     W5,W5
01548:  BRA     N,155E
0154A:  MOV     #30,W0
0154C:  BRA     1550
0154E:  MOV     #20,W0
01550:  BTSC.B  233.1
01552:  BRA     1550
01554:  MOV     W0,234
01556:  DEC     W5,W5
01558:  BRA     NN,1550
0155A:  BTSC    W4.8
0155C:  DEC.B   W4L,W4L
0155E:  MOV     #E,W8
01560:  MOV     #0,W9
01562:  LNK     #10
01564:  MOV     W12,[W14+W8]
01566:  DEC2    W8,W8
01568:  BRA     NN,1564
0156A:  MOV     W4,W5
0156C:  MOV     #A,W4
0156E:  BTSC    W5.8
01570:  INC     W4,W4
01572:  BSET    W5.E
01574:  BTSC    W12.F
01576:  BSET    W5.F
01578:  CP0.B   W5L
0157A:  BRA     Z,157E
0157C:  DEC.B   W5L,W5L
0157E:  MOV     W4,[W14]
01580:  MOV     W5,[W14+#2]
01582:  MOV     W6,W0
01584:  MOV     W7,W1
01586:  MOV     #CA00,W2
01588:  MOV     #3B9A,W3
0158A:  MOV     #2710,W8
0158C:  BCLR    W13.F
0158E:  BCLR.B  43.0
01590:  CALL    14C0
01594:  BTG     W13.F
01596:  BTSC    W13.F
01598:  BRA     15A8
0159A:  MOV     W0,[W14+#8]
0159C:  MOV     W1,[W14+#A]
0159E:  MOV     W0,W2
015A0:  MOV     W1,W3
015A2:  MOV     [W14+#4],W0
015A4:  MOV     [W14+#6],W1
015A6:  BRA     158E
015A8:  MOV     W2,[W14+#8]
015AA:  MOV     W3,[W14+#A]
015AC:  MOV     W4,[W14+#4]
015AE:  MOV     W5,[W14+#6]
015B0:  MOV     [W14],W4
015B2:  MOV     [W14+#2],W5
015B4:  MOV     #30,W6
015B6:  CP0     W0
015B8:  BRA     NZ,15DC
015BA:  BTSS    W5.E
015BC:  BRA     15E0
015BE:  DEC     W4,W4
015C0:  MOV     W4,[W14]
015C2:  CP0     W4
015C4:  BRA     Z,15E0
015C6:  CP.B    W4L,W5L
015C8:  BRA     Z,15CE
015CA:  BTSC.B  42.0
015CC:  BRA     15FE
015CE:  BTSS    W5.F
015D0:  BRA     15D8
015D2:  BTSS    W5.8
015D4:  BRA     15F6
015D6:  BRA     15E6
015D8:  MOV     #20,W6
015DA:  BRA     15F6
015DC:  BCLR    W5.E
015DE:  MOV     W5,[W14+#2]
015E0:  MOV     [W14+#2],W5
015E2:  BTSS    W5.8
015E4:  BRA     15F6
015E6:  BCLR    W5.8
015E8:  MOV     W5,[W14+#2]
015EA:  MOV     W0,W10
015EC:  MOV     #2D,W0
015EE:  BTSC.B  233.1
015F0:  BRA     15EE
015F2:  MOV     W0,234
015F4:  MOV     W10,W0
015F6:  ADD.B   W6L,W0L,W0L
015F8:  BTSC.B  233.1
015FA:  BRA     15F8
015FC:  MOV     W0,234
015FE:  MOV     [W14+#8],W0
01600:  MOV     [W14+#A],W1
01602:  MOV     #A,W2
01604:  CLR     W3
01606:  CP      W0,#1
01608:  BRA     Z,160C
0160A:  BRA     158E
0160C:  ULNK    
0160E:  MOV     #1A,W5
01610:  REPEAT  #7
01612:  MOV     [--W15],[W5--]
01614:  MOV     [--W15],W5
01616:  RETURN  
....................  
.................... #list 
....................  
....................  
....................  
.................... //#FUSES PROTECT_HIGH            //General Segment Code Protect High Security 
.................... #FUSES WRTB                      //Boot block write protected 
.................... #FUSES CKSFSM                    //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES WDT                       //no Watch Dog Timer 
.................... #FUSES WPOSTS14                  //Watch Dog Timer PreScalar 1:8192 
.................... #FUSES PR_PLL                    //Primary Oscillator with PLL 
.................... #FUSES HS                        //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOWRT                     //Program memory not write protected 
.................... #use delay(clock=40M) 
....................  
.................... #WORD PLLFBD=0x0746 // osc PLL div reg 
....................  
.................... #WORD CLKDIV=0x0744  // osc con reg 
.................... #BIT PLLPOST1=CLKDIV.7 
.................... #BIT PLLPOST0=CLKDIV.6 
.................... #BIT PLLPRE4=CLKDIV.4 
.................... #BIT PLLPRE3=CLKDIV.3 
.................... #BIT PLLPRE2=CLKDIV.2 
.................... #BIT PLLPRE1=CLKDIV.1 
.................... #BIT PLLPRE0=CLKDIV.0 
....................  
.................... #WORD LATA=0x02C4  
.................... #WORD LATB=0x02CA 
.................... #WORD LATD=0x02D6 
.................... #WORD LATF=0x02E2 
.................... #WORD LATG=0x02E8   
.................... #WORD LATC=0x02D0 
....................  
.................... #use spi(spi2, FORCE_HW) 
.................... #use standard_io(B)//(B_outputs=PIN_B1, PIN_B2) 
....................  
.................... #define STATUS 0x00     // ADC1256 Register map 
.................... #define MUX 0x01  
.................... #define ADCON 0x02 
.................... #define DRATE 0x03 
.................... #define IO 0x04 
.................... #define OFCO 0x05 
.................... #define OFC1 0x06 
.................... #define OFC2 0x07 
.................... #define FSCO 0x08 
.................... #define FSC1 0x09 
.................... #define FSC2 0x0A 
....................  
.................... #define uV 10000000  // для калибровки  
.................... //#define uV 100000 // по умолчанию 
.................... #define mV 1000 
....................  
.................... #WORD PORTB=0x02C8 
.................... #WORD TRISB=0x02C6 
.................... #BIT  TRB0=TRISB.0 
.................... #BIT  TRB1=TRISB.1 
.................... #BIT  CN1_TRIS=TRISB.5 
.................... #BIT  CN2_TRIS=TRISB.4 
.................... #BIT  CN4_TRIS=TRISB.3 
.................... #BIT  CN3_TRIS=TRISB.2 
.................... #BIT  CN1=PORTB.5 
.................... #BIT  CN4=PORTB.3 
.................... #BIT  CN2=PORTB.4 
.................... #BIT  CN3=PORTB.2 
.................... #BIT  XPORT_RST_n=TRISB.15 
.................... #BIT  Status_LED_TRIS=TRISB.13 
.................... #BIT  TRB14=TRISB.14 
.................... #BIT  XPORT_RST_TRIS=TRISB.15 
.................... #BIT  RB1=LATB.1 
.................... #BIT  RB0=LATB.0 
.................... #BIT  Status_LED=LATB.13 
....................  
.................... #WORD PORTC=0x02CE 
.................... #WORD TRISC=0x02CC 
.................... //#BIT RC13=LATC.13 
.................... //#BIT RC14=LATC.14 
.................... #BIT RC13=PORTC.13 
.................... #BIT RC14=PORTC.14 
.................... #BIT  TRC13=TRISC.13 
.................... #BIT  TRC14=TRISC.14 
.................... #BIT  TRC1=TRISC.1 
.................... #BIT  TRC2=TRISC.2 
.................... #BIT  TRC4=TRISC.4 
.................... //_______________________________________ 
.................... #WORD PORTD=0x02D4 
.................... #WORD TRISD=0x02D2 
.................... #WORD ODCD=0x06D2 
....................  
.................... #BIT  TRD4=TRISD.4 
.................... #BIT  TRD5=TRISD.5 
.................... #BIT  TRD6=TRISD.6 
.................... #BIT  TRD7=TRISD.7 
.................... #BIT  TRD8=TRISD.8 
....................  
.................... #BIT  RD4=LATD.4 
.................... #BIT  RD5=LATD.5 
.................... #BIT  RD6=LATD.6 
.................... #BIT  RD7=LATD.7 
.................... #BIT  RD8=LATD.8 
.................... //_________________________________________________ 
.................... #WORD PORTF=0x02E0 
.................... #WORD TRISF=0x02DE 
.................... #BIT  UART2_RX_TRIS=TRISF.4 
.................... #BIT  UART2_TX_TRIS=TRISF.5 
....................  
.................... #WORD PORTG=0x02E6 
.................... #WORD TRISG=0x02E4 
.................... #BIT RG0=LATG.0 
.................... #BIT RG1=LATG.1 
.................... #BIT LCD_RW=LATG.12 
.................... #BIT LCD_RS=LATG.13 
.................... #BIT LCD_E=LATG.14 
.................... #BIT RG15=LATG.15 
.................... #BIT SCK2=LATG.6 // SPI2 pins 
.................... #BIT SDI2=LATG.7 
.................... #BIT SDO2=LATG.8 
.................... //#BIT SS2=LATG.9 
.................... #BIT SCK2_TRIS=TRISG.6 // SPI2 tris 
.................... #BIT SDI2_TRIS=TRISG.7 
.................... #BIT SDO2_TRIS=TRISG.8 
.................... #BIT TRG0=TRISG.0 
.................... #BIT TRG1=TRISG.1 
.................... #BIT LCD_RW_TRIS=TRISG.12 
.................... #BIT LCD_RS_TRIS=TRISG.13 
.................... #BIT LCD_E_TRIS=TRISG.14 
....................  
.................... //#BIT SS2_TRIS=TRISG.9 
....................  
.................... #define ADC_Dout SDI2 //???? Din ?? 
.................... #define ADC_Din SDO2  //???? Dout ?? 
....................  
.................... #BIT  ADC_RESET_TRIS=TRISD.3 
.................... #BIT  ADC2_RESET_TRIS=TRISD.0 
.................... #BIT  ADC_RESET=LATD.3 
.................... #BIT  ADC2_RESET=LATD.0 
....................  
.................... #BIT  ADC_SYNC_TRIS=TRISD.2 
.................... #BIT  ADC2_SYNC_TRIS=TRISD.11 
.................... #BIT  ADC_SYNC=LATD.2 
.................... #BIT  ADC2_SYNC=LATD.11 
....................  
.................... #BIT  ADC_CS_TRIS =TRISG.9 
.................... #BIT  ADC2_CS_TRIS=TRISD.10 
.................... #BIT  ADC_CS = LATG.9 
.................... #BIT  ADC2_CS= LATD.10 
....................  
.................... #BIT  ADC_DRDY_TRIS = TRISD.1 
.................... #BIT  ADC2_DRDY_TRIS= TRISD.9 
.................... #BIT  ADC_DRDY = PORTD.1 
.................... #BIT  ADC2_DRDY= PORTD.9 
....................  
.................... #byte U2TXREG = 0x0234  
.................... #byte U2RXREG = 0x0236 // регистр принимаемых Uart2 данных   
.................... #Word U2STA = 0x0232 
.................... #WORD U2BRG=0x0238 
.................... #WORD U2MODE=0x0230 
....................  
.................... #define FCY      40000000 
.................... #define BAUDRATE 9600                 
.................... #define BRGVAL   ((FCY/BAUDRATE)/16)-1 
....................  
.................... #define CK_FLASH_END       (getenv("PROGRAM_MEMORY")-1)       
.................... #define CK_FLASH_PAGE_SIZE (getenv("FLASH_ERASE_SIZE")/2)  
.................... #define CK_NUM_PAGES (CK_FLASH_END/CK_FLASH_PAGE_SIZE)  
....................  
.................... #define CK_USER_PAGE (CK_FLASH_PAGE_SIZE*(CK_NUM_PAGES-1))  
....................  
.................... #org CK_USER_PAGE,CK_FLASH_END {}  
....................  
....................    typedef unsigned int16 U16; 
....................    typedef unsigned int8 U8; 
....................    typedef unsigned int32 U32; 
....................    typedef signed int32 S32; 
....................    typedef signed int16 S16; 
....................    typedef signed int8 S8; 
....................  
....................  
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #use rs232(UART2,xmit=PIN_F5,rcv=PIN_F4,baud=230400,BRGH1OK,ERRORS,parity=N,bits=8) 
....................   
....................     // коды каналов мультиплексора.. 
....................     U8 Mx_ch_code[9] = {0, 0x76, 0x54, 0x32, 0x10}; 
....................     S32 adc_data[8]; 
....................     U8 PGA; 
....................     U8 PGA_val = 3; // PGA = 8 
....................     U8 Sps_buf=0; 
....................     //S16 ADCaddCoef = 1; 
....................     //float ADCmulCoef = 1; 
....................     
....................    U8 flash_wr_data [] = {0,0,0,0}; // заготовка массива для записи во флэш 
....................    U8 Aver_Wr = 0; 
....................    U8 Sps_Wr = 0; 
....................    U8 CRC_Wr = 0; 
....................    U8 ADC_select = 0; // флаг выбора АЦП: 1ый или 2ой 
....................  
....................    int1 meas_stop_fl = 0; 
....................    int1 reset_fl = 0;    // флаг сброса системы 
....................    int1 stop_fl = 0; 
....................    int1 send_t_fl = 0; 
....................     
....................    U8 NumAver = 1;       // размер усреднения 
....................    U8 ADC_sps_var = 1;   // переменная усреднения данных АЦП  
....................    U8 CRC1=0xFF,CRC2=0xFF, CRC_buf;   // константы EEPROM CRC 
....................    U8 flash_rd_data[4]; // заготовка массива для чтения из флэш 
....................  
....................    //Ma - Moving Average 
....................    S32 Ch_buf[8][128];  // буфер скользящего среднего для к1 
....................    S32 Ch_buf_sum;     // сумма буфера скользящего среднего для к1 
....................  
....................    U8 Ma_buf_index = 0; // индекс элемента скользящ. средн. 
....................    U8 Ma_buf_size = 16;  // РАЗМЕР БУФЕРА!!! 
....................     
....................    U8 RXd_buf[64]; // буфер для приема UART данных  
....................    U8 state; 
....................    U16 tmp=0; 
....................     
....................    static U8 wrptr=0,rdptr=0; 
....................    static U8 RxData[16];  
....................     
.................... #include <ADS1256.h> 
.................... // изменена для версии PoE без дисплея 
.................... // 28.05.15 
....................  
.................... //-------------------- работа с регистрами АЦП ------------------------------// 
....................  
.................... static U8 RdReg(U8 RegName) 
.................... { 
....................    U8 RegValue = 0;  
....................    //1st Command Byte: 0001 rrrr where rrrr is the address of the first register to read. 
....................    //2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to read – 1 
....................    ADC_CS = 0; 
....................    delay_us(1); 
....................    Spi_write2(0x10+RegName); // 1st Command Byte,??????? ?????? 
....................    Spi_write2(0x00); // 1st Command Byte, ?????? ?????? ???? ???? 
....................    delay_us(8); // 50 CLK_IN PEDIODS 
....................    RegValue = Spi_read2(0); 
....................    delay_us(1); 
....................    ADC_CS =1; 
....................    delay_us(1); 
....................    Return RegValue;   
.................... } 
....................  
.................... static void WrReg(U8 RegName,CommandByte) 
*
00440:  MOV     W5,[W15++]
.................... { 
....................    ADC_CS = 0; 
00442:  BCLR.B  2E9.1
....................    ADC2_CS = 0; 
00444:  BCLR.B  2D7.2
....................    delay_us(5); 
00446:  REPEAT  #62
00448:  NOP     
....................    Spi_write2(0x50+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written. 
0044A:  MOV     18AE,W4
0044C:  CLR.B   9
0044E:  MOV     #50,W3
00450:  ADD     W3,W4,W5
00452:  BCLR.B  260.6
00454:  BTSS.B  260.0
00456:  BRA     45C
00458:  MOV.B   268,W0L
0045A:  BRA     454
0045C:  PUSH    268
0045E:  MOV.B   W5L,[W15-#2]
00460:  POP     268
00462:  BTSS.B  260.0
00464:  BRA     462
....................    delay_us(10); 
00466:  REPEAT  #C6
00468:  NOP     
....................    Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1. 
0046A:  BCLR.B  260.6
0046C:  BTSS.B  260.0
0046E:  BRA     474
00470:  MOV.B   268,W0L
00472:  BRA     46C
00474:  CLR.B   268
00476:  BTSS.B  260.0
00478:  BRA     476
....................    delay_us(10); 
0047A:  REPEAT  #C6
0047C:  NOP     
....................    Spi_write2(CommandByte); 
0047E:  BCLR.B  260.6
00480:  BTSS.B  260.0
00482:  BRA     488
00484:  MOV.B   268,W0L
00486:  BRA     480
00488:  MOV.B   18AF,W0L
0048A:  MOV.B   W0L,268
0048C:  BTSS.B  260.0
0048E:  BRA     48C
....................    delay_us(10); 
00490:  REPEAT  #C6
00492:  NOP     
....................    ADC_CS = 1; 
00494:  BSET.B  2E9.1
....................    ADC2_CS = 1; 
00496:  BSET.B  2D7.2
....................   
....................    delay_us(20); 
00498:  REPEAT  #18E
0049A:  NOP     
0049C:  MOV     [--W15],W5
0049E:  RETURN  
.................... } 
.................... //---------------------------------------------------------------------------// 
....................  
.................... //==================== настройка и нинициализация АЦП =======================// 
....................  
.................... static void ADC_sps_set(U8 SPS){ 
....................                                                            
....................    Sps_buf = SPS; 
004A0:  MOV.B   18AC,W0L
004A2:  MOV.B   W0L,833
....................    WrReg(DRATE,SPS);  
004A4:  MOV.B   #3,W0L
004A6:  MOV.B   W0L,18AE
004A8:  MOV.B   18AC,W0L
004AA:  MOV.B   W0L,18AF
004AC:  CALL    440
....................    delay_us(20); 
004B0:  REPEAT  #18E
004B2:  NOP     
004B4:  RETURN  
....................                   
....................          
.................... } 
....................  
.................... static void ADC_set_PGA(u8 PGA_val){ 
....................    
.................... /* PGA 
.................... 000 = 1 (default) 
.................... 001 = 2 
.................... 010 = 4 
.................... 011 = 8 
.................... 100 = 16 
.................... 101 = 32 
.................... 110 = 64 
.................... 111 = 64*/ 
.................... /**/ 
....................  
.................... // PGA присваевается для расчета  
....................  
....................    switch (PGA_val){ 
004B6:  MOV.B   18AC,W0L
004B8:  CLR.B   1
004BA:  XOR     #0,W0
004BC:  BRA     Z,4D8
004BE:  XOR     #1,W0
004C0:  BRA     Z,4EA
004C2:  XOR     #3,W0
004C4:  BRA     Z,4FE
004C6:  XOR     #1,W0
004C8:  BRA     Z,512
004CA:  XOR     #7,W0
004CC:  BRA     Z,526
004CE:  XOR     #1,W0
004D0:  BRA     Z,53A
004D2:  XOR     #3,W0
004D4:  BRA     Z,54E
004D6:  BRA     562
....................       case 0: 
....................        WrReg(ADCON,0); 
004D8:  MOV.B   #2,W0L
004DA:  MOV.B   W0L,18AE
004DC:  CLR.B   18AF
004DE:  CALL    440
....................        PGA = 1; 
004E2:  MOV.B   #1,W0L
004E4:  MOV.B   W0L,811
....................       break; 
004E6:  GOTO    562
....................        
....................       case 1: 
....................        WrReg(ADCON,1); 
004EA:  MOV.B   #2,W0L
004EC:  MOV.B   W0L,18AE
004EE:  MOV.B   #1,W0L
004F0:  MOV.B   W0L,18AF
004F2:  CALL    440
....................        PGA = 2; 
004F6:  MOV.B   #2,W0L
004F8:  MOV.B   W0L,811
....................       break; 
004FA:  GOTO    562
....................        
....................       case 2: 
....................        WrReg(ADCON,2); 
004FE:  MOV.B   #2,W0L
00500:  MOV.B   W0L,18AE
00502:  MOV.B   #2,W0L
00504:  MOV.B   W0L,18AF
00506:  CALL    440
....................        PGA = 4; 
0050A:  MOV.B   #4,W0L
0050C:  MOV.B   W0L,811
....................       break; 
0050E:  GOTO    562
....................        
....................       case 3: 
....................        WrReg(ADCON,3); 
00512:  MOV.B   #2,W0L
00514:  MOV.B   W0L,18AE
00516:  MOV.B   #3,W0L
00518:  MOV.B   W0L,18AF
0051A:  CALL    440
....................        PGA = 8; 
0051E:  MOV.B   #8,W0L
00520:  MOV.B   W0L,811
....................       break; 
00522:  GOTO    562
....................        
....................       case 4: 
....................        WrReg(ADCON,4); 
00526:  MOV.B   #2,W0L
00528:  MOV.B   W0L,18AE
0052A:  MOV.B   #4,W0L
0052C:  MOV.B   W0L,18AF
0052E:  CALL    440
....................        PGA = 16; 
00532:  MOV.B   #10,W0L
00534:  MOV.B   W0L,811
....................       break; 
00536:  GOTO    562
....................        
....................       case 5: 
....................        WrReg(ADCON,5); 
0053A:  MOV.B   #2,W0L
0053C:  MOV.B   W0L,18AE
0053E:  MOV.B   #5,W0L
00540:  MOV.B   W0L,18AF
00542:  CALL    440
....................        PGA = 32; 
00546:  MOV.B   #20,W0L
00548:  MOV.B   W0L,811
....................       break; 
0054A:  GOTO    562
....................        
....................       case 6: 
....................        WrReg(ADCON,6); 
0054E:  MOV.B   #2,W0L
00550:  MOV.B   W0L,18AE
00552:  MOV.B   #6,W0L
00554:  MOV.B   W0L,18AF
00556:  CALL    440
....................        PGA = 64; 
0055A:  MOV.B   #40,W0L
0055C:  MOV.B   W0L,811
....................       break;  
0055E:  GOTO    562
....................    } 
....................    delay_us(20); 
00562:  REPEAT  #18E
00564:  NOP     
00566:  RETURN  
.................... } 
....................  
.................... static void ADC_SelfCal(){ 
00568:  MOV     W5,[W15++]
0056A:  MOV     W6,[W15++]
....................                       
....................    ADC_CS = 0; 
0056C:  BCLR.B  2E9.1
....................    ADC2_CS = 0; 
0056E:  BCLR.B  2D7.2
....................    delay_us(1); 
00570:  REPEAT  #12
00572:  NOP     
....................     
....................    Spi_write2(0xF0); 
00574:  BCLR.B  260.6
00576:  BTSS.B  260.0
00578:  BRA     57E
0057A:  MOV.B   268,W0L
0057C:  BRA     576
0057E:  MOV.B   #F0,W0L
00580:  MOV.B   W0L,268
00582:  BTSS.B  260.0
00584:  BRA     582
....................    delay_us(1); 
00586:  REPEAT  #12
00588:  NOP     
....................     
....................    ADC_CS = 1; 
0058A:  BSET.B  2E9.1
....................    ADC2_CS = 1; 
0058C:  BSET.B  2D7.2
....................     
....................    While(ADC_DRDY | ADC2_DRDY) { }   // ждем готовности обоих АЦП 
0058E:  CLR     W0
00590:  BTSC.B  2D4.1
00592:  INC     W0,W0
00594:  MOV.B   W0L,W6L
00596:  CLR     W0
00598:  BTSC.B  2D5.1
0059A:  INC     W0,W0
0059C:  IOR.B    W6L,  W0L,W0L
0059E:  CP0.B   W0L
005A0:  BRA     Z,5A6
005A2:  GOTO    58E
005A6:  MOV     [--W15],W6
005A8:  MOV     [--W15],W5
005AA:  RETURN  
....................      
....................    /* 
....................    Switch (Sps_buf) {      
....................      
....................       case 0xF0:    
....................        delay_us(220);         
....................         break;                       
....................        
....................       case 0xE0: 
....................        delay_us(255);  
....................         break; 
....................          
....................       case 0xD0: 
....................        delay_us(315);  
....................         break; 
....................          
....................       case 0xC0: 
....................        delay_us(445);  
....................         break; 
....................          
....................       case 0xB0: 
....................        delay_us(685);  
....................         break; 
....................          
....................       case 0xA1: 
....................        delay_ms(1); 
....................        delay_us(185);                
....................         break;       
....................          
....................       case 0x92: 
....................        delay_ms(5); 
....................         break; 
....................          
....................       case 0x82: 
....................        delay_ms(10); 
....................        delay_us(200); 
....................         break; 
....................                     
....................       case 0x63: 
....................        delay_ms(21);  
....................         break; 
....................          
....................       case 0x43: 
....................        delay_ms(41);  
....................         break; 
....................          
....................       case 0x23: 
....................        delay_ms(101);  
....................         break;          
....................              
....................       case 0x13: 
....................        delay_ms(201);  
....................         break;                           
....................      } 
....................      */ 
.................... } 
....................  
.................... static void ADC_init(){ 
....................     
....................   WrReg(STATUS,2);   // вкл. входной буфер 
005AC:  CLR.B   18AE
005AE:  MOV.B   #2,W0L
005B0:  MOV.B   W0L,18AF
005B2:  CALL    440
....................   delay_us(20); 
005B6:  REPEAT  #18E
005B8:  NOP     
....................  
....................    if(ADC_sps_var>8)  ADC_sps_var = 8; 
005BA:  MOV     83E,W4
005BC:  CP.B    W4L,#8
005BE:  BRA     LEU,5C4
005C0:  MOV.B   #8,W0L
005C2:  MOV.B   W0L,83E
....................    // установка sps 
....................    switch (ADC_sps_var){                // передача величины скорости измерений АЦП  
005C4:  MOV.B   83E,W0L
005C6:  CLR.B   1
005C8:  XOR     #0,W0
005CA:  BRA     Z,5FA
005CC:  XOR     #1,W0
005CE:  BRA     Z,606
005D0:  XOR     #3,W0
005D2:  BRA     Z,612
005D4:  XOR     #1,W0
005D6:  BRA     Z,61E
005D8:  XOR     #7,W0
005DA:  BRA     Z,62A
005DC:  XOR     #1,W0
005DE:  BRA     Z,636
005E0:  XOR     #3,W0
005E2:  BRA     Z,642
005E4:  XOR     #1,W0
005E6:  BRA     Z,64E
005E8:  XOR     #F,W0
005EA:  BRA     Z,65A
005EC:  XOR     #1,W0
005EE:  BRA     Z,666
005F0:  XOR     #3,W0
005F2:  BRA     Z,672
005F4:  XOR     #1,W0
005F6:  BRA     Z,67E
005F8:  BRA     68A
....................      
....................       case 0: ADC_sps_set(0x03);  break; // 2,5   sps 
005FA:  MOV.B   #3,W0L
005FC:  MOV.B   W0L,18AC
005FE:  CALL    4A0
00602:  GOTO    68A
....................       case 1: ADC_sps_set(0x13);  break; // 5   sps 
00606:  MOV.B   #13,W0L
00608:  MOV.B   W0L,18AC
0060A:  CALL    4A0
0060E:  GOTO    68A
....................       case 2: ADC_sps_set(0x23);  break; // 10   sps 
00612:  MOV.B   #23,W0L
00614:  MOV.B   W0L,18AC
00616:  CALL    4A0
0061A:  GOTO    68A
....................       case 3: ADC_sps_set(0x43);  break; // 25   sps 
0061E:  MOV.B   #43,W0L
00620:  MOV.B   W0L,18AC
00622:  CALL    4A0
00626:  GOTO    68A
....................       case 4: ADC_sps_set(0x63);  break; // 50   sps 
0062A:  MOV.B   #63,W0L
0062C:  MOV.B   W0L,18AC
0062E:  CALL    4A0
00632:  GOTO    68A
....................       case 5: ADC_sps_set(0x82);  break; // 100  sps 
00636:  MOV.B   #82,W0L
00638:  MOV.B   W0L,18AC
0063A:  CALL    4A0
0063E:  GOTO    68A
....................       case 6: ADC_sps_set(0x91);  break; // 500  sps 
00642:  MOV.B   #91,W0L
00644:  MOV.B   W0L,18AC
00646:  CALL    4A0
0064A:  GOTO    68A
....................       case 7: ADC_sps_set(0xA1);  break; // 1000 sps 
0064E:  MOV.B   #A1,W0L
00650:  MOV.B   W0L,18AC
00652:  CALL    4A0
00656:  GOTO    68A
....................       case 8: ADC_sps_set(0xC0);  break; // 3750 sps 
0065A:  MOV.B   #C0,W0L
0065C:  MOV.B   W0L,18AC
0065E:  CALL    4A0
00662:  GOTO    68A
....................       case 9: ADC_sps_set(0xd0);  break; // 7500  sps 
00666:  MOV.B   #D0,W0L
00668:  MOV.B   W0L,18AC
0066A:  CALL    4A0
0066E:  GOTO    68A
....................       case 10: ADC_sps_set(0xe0);  break; // 15000 sps 
00672:  MOV.B   #E0,W0L
00674:  MOV.B   W0L,18AC
00676:  CALL    4A0
0067A:  GOTO    68A
....................       case 11: ADC_sps_set(0xf0);  break; // 30000 sps 
0067E:  MOV.B   #F0,W0L
00680:  MOV.B   W0L,18AC
00682:  CALL    4A0
00686:  GOTO    68A
....................       } 
....................        
....................    ADC_set_PGA(PGA_val);    // Уст. PGA 
0068A:  MOV.B   832,W0L
0068C:  MOV.B   W0L,18AC
0068E:  CALL    4B6
....................    ADC_SelfCal();      // Автокалибровка обоих АЦП  
00692:  CALL    568
00696:  RETURN  
.................... } 
.................... //===========================================================================// 
....................  
....................  
.................... //---------------------- уст. каналов и чтение АЦП --------------------------// 
....................  
.................... static void SYNC_ADC(U8 command) 
....................   { /// синхронизация АЦП 
....................    
....................    //command 0 - не выбран ни один АЦП 
....................    //command 1 - выбран АЦП 1 
....................    //command 2 - выбран АЦП 2 
....................     
....................    switch(command) 
*
00728:  MOV.B   18AC,W0L
0072A:  CLR.B   1
0072C:  XOR     #0,W0
0072E:  BRA     Z,73A
00730:  XOR     #1,W0
00732:  BRA     Z,742
00734:  XOR     #3,W0
00736:  BRA     Z,74E
00738:  BRA     75A
....................    { 
....................          case 0:      
....................             ADC_SYNC = 1;  
0073A:  BSET.B  2D6.2
....................             ADC2_SYNC = 1; 
0073C:  BSET.B  2D7.3
....................          break; 
0073E:  GOTO    75A
....................           
....................          case 1:  
....................             ADC_SYNC = 0;  
00742:  BCLR.B  2D6.2
....................             delay_us(20); 
00744:  REPEAT  #18E
00746:  NOP     
....................             ADC_SYNC = 1; 
00748:  BSET.B  2D6.2
....................          break; 
0074A:  GOTO    75A
....................           
....................          case 2:  
....................             ADC2_SYNC = 0;  
0074E:  BCLR.B  2D7.3
....................             delay_us(20); 
00750:  REPEAT  #18E
00752:  NOP     
....................             ADC2_SYNC = 1;  
00754:  BSET.B  2D7.3
....................          break; 
00756:  GOTO    75A
....................    } 
0075A:  RETURN  
....................   } 
....................  
.................... static void ADC_select(U8 command) 
....................   { /// выбор АЦП 
....................    
....................    //command 0 - не выбран ни один АЦП 
....................    //command 1 - выбран АЦП 1 
....................    //command 2 - выбран АЦП 2 
....................     
....................    switch(command) 
*
00698:  MOV.B   18D6,W0L
0069A:  CLR.B   1
0069C:  XOR     #0,W0
0069E:  BRA     Z,6AA
006A0:  XOR     #1,W0
006A2:  BRA     Z,6B2
006A4:  XOR     #3,W0
006A6:  BRA     Z,6BA
006A8:  BRA     6C2
....................    { 
....................          case 0: ADC_CS = 1; ADC2_CS = 1; break; 
006AA:  BSET.B  2E9.1
006AC:  BSET.B  2D7.2
006AE:  GOTO    6C2
....................          case 1: ADC_CS = 0; ADC2_CS = 1; break; 
006B2:  BCLR.B  2E9.1
006B4:  BSET.B  2D7.2
006B6:  GOTO    6C2
....................          case 2: ADC_CS = 1; ADC2_CS = 0; break; 
006BA:  BSET.B  2E9.1
006BC:  BCLR.B  2D7.2
006BE:  GOTO    6C2
....................    } 
006C2:  RETURN  
....................   } 
....................  
.................... static void ADC_setCh(U8 Ch_Number, U8 ADC_number){ 
006C4:  MOV     W5,[W15++]
....................  
....................  // уст. каналоа АЦП 
....................  // 1 канал пользователя - 4 канал АЦП по факту (13(+) и 12(-) ножки) и тд. 
....................   
....................   ADC_select(ADC_number); // выбор АЦП 
006C6:  MOV.B   18AD,W0L
006C8:  MOV.B   W0L,18D6
006CA:  CALL    698
....................   delay_us(2); 
006CE:  REPEAT  #26
006D0:  NOP     
....................   
....................   Spi_write2(0x50+MUX);  // уст. канал АЦП    
006D2:  BCLR.B  260.6
006D4:  BTSS.B  260.0
006D6:  BRA     6DC
006D8:  MOV.B   268,W0L
006DA:  BRA     6D4
006DC:  MOV.B   #51,W0L
006DE:  MOV.B   W0L,268
006E0:  BTSS.B  260.0
006E2:  BRA     6E0
....................   delay_us(10); 
006E4:  REPEAT  #C6
006E6:  NOP     
....................   Spi_write2(0);          
006E8:  BCLR.B  260.6
006EA:  BTSS.B  260.0
006EC:  BRA     6F2
006EE:  MOV.B   268,W0L
006F0:  BRA     6EA
006F2:  CLR.B   268
006F4:  BTSS.B  260.0
006F6:  BRA     6F4
....................   delay_us(10); 
006F8:  REPEAT  #C6
006FA:  NOP     
....................   Spi_write2(Mx_ch_code[Ch_Number]); 
006FC:  MOV     18AC,W4
006FE:  CLR.B   9
00700:  MOV     #808,W3
00702:  ADD     W4,W3,W0
00704:  MOV.B   [W0],W5L
00706:  BCLR.B  260.6
00708:  BTSS.B  260.0
0070A:  BRA     710
0070C:  MOV.B   268,W0L
0070E:  BRA     708
00710:  PUSH    268
00712:  MOV.B   W5L,[W15-#2]
00714:  POP     268
00716:  BTSS.B  260.0
00718:  BRA     716
....................    
....................   ADC_select(0); 
0071A:  CLR.B   18D6
0071C:  CALL    698
....................   delay_us(20);   
00720:  REPEAT  #18E
00722:  NOP     
00724:  MOV     [--W15],W5
00726:  RETURN  
.................... } 
....................  
.................... static S32 ADC_read(U8 ADC_number) 
*
00C44:  MOV     W5,[W15++]
00C46:  MOV     #C,W5
00C48:  REPEAT  #4
00C4A:  MOV     [W5++],[W15++]
....................   { 
....................    
....................   ADC_select(ADC_number); // выбор АЦП 
00C4C:  MOV.B   18B8,W0L
00C4E:  MOV.B   W0L,18D6
00C50:  CALL    698
....................    
....................   S32 ADC_RByte1=0;  // ст. байт данных АЦП 
....................   S32 ADC_RByte2=0;  // ср. байт данных АЦП 
....................   S32 ADC_RByte3=0;  // мл. байт данных АЦП 
....................    
....................   S32 ADC_RByte_Sum; // суммарные отсчеты АЦП - 24 бита 
....................    
....................   float Vin;         // измеренное напряжение  
00C54:  CLR     18BA
00C56:  CLR     18BC
00C58:  CLR     18BE
00C5A:  CLR     18C0
00C5C:  CLR     18C2
00C5E:  CLR     18C4
....................  
....................   Spi_write2(0x01);        // команда чтения Rdata 
00C60:  BCLR.B  260.6
00C62:  BTSS.B  260.0
00C64:  BRA     C6A
00C66:  MOV.B   268,W0L
00C68:  BRA     C62
00C6A:  MOV.B   #1,W0L
00C6C:  MOV.B   W0L,268
00C6E:  BTSS.B  260.0
00C70:  BRA     C6E
....................   delay_us(20); 
00C72:  REPEAT  #18E
00C74:  NOP     
....................   ADC_Rbyte1 = Spi_read2(0);   // чтение 
00C76:  BCLR.B  260.6
00C78:  BTSS.B  260.0
00C7A:  BRA     C80
00C7C:  MOV.B   268,W0L
00C7E:  BRA     C78
00C80:  CLR.B   268
00C82:  BTSS.B  260.0
00C84:  BRA     C82
00C86:  MOV.B   268,W0L
00C88:  CLR.B   1
00C8A:  MOV     #0,W1
00C8C:  MOV     W0,18BA
00C8E:  MOV     W1,18BC
....................   ADC_Rbyte2 = Spi_read2(0); 
00C90:  BCLR.B  260.6
00C92:  BTSS.B  260.0
00C94:  BRA     C9A
00C96:  MOV.B   268,W0L
00C98:  BRA     C92
00C9A:  CLR.B   268
00C9C:  BTSS.B  260.0
00C9E:  BRA     C9C
00CA0:  MOV.B   268,W0L
00CA2:  CLR.B   1
00CA4:  MOV     #0,W1
00CA6:  MOV     W0,18BE
00CA8:  MOV     W1,18C0
....................   ADC_Rbyte3 = Spi_read2(0); 
00CAA:  BCLR.B  260.6
00CAC:  BTSS.B  260.0
00CAE:  BRA     CB4
00CB0:  MOV.B   268,W0L
00CB2:  BRA     CAC
00CB4:  CLR.B   268
00CB6:  BTSS.B  260.0
00CB8:  BRA     CB6
00CBA:  MOV.B   268,W0L
00CBC:  CLR.B   1
00CBE:  MOV     #0,W1
00CC0:  MOV     W0,18C2
00CC2:  MOV     W1,18C4
....................    
....................   ADC_select(0); // сброс выбора АЦП 
00CC4:  CLR.B   18D6
00CC6:  CALL    698
....................    
....................   // склеивание трех байт отсчетов АЦП 
....................   ADC_RByte_Sum = ((S32)ADC_Rbyte1<<24) | ((S32)ADC_Rbyte2<<16) | ((S32)ADC_Rbyte3<<8); 
00CCA:  MOV.B   18BA,W0L
00CCC:  MOV.B   W0L,D
00CCE:  CLR.B   W6
00CD0:  CLR.B   B
00CD2:  CLR.B   W5
00CD4:  MOV     18BE,W1
00CD6:  MOV     #0,W0
00CD8:  IOR      W5,  W0,W5
00CDA:  IOR      W6,  W1,W6
00CDC:  MOV.B   18C4,W0L
00CDE:  MOV.B   W0L,3
00CE0:  MOV.B   18C3,W0L
00CE2:  MOV.B   W0L,W1L
00CE4:  MOV.B   18C2,W0L
00CE6:  MOV.B   W0L,1
00CE8:  CLR.B   W0
00CEA:  IOR      W6,  W1,W1
00CEC:  IOR      W5,  W0,W0
00CEE:  MOV     W0,18C6
00CF0:  MOV     W1,18C8
....................   ADC_RByte_Sum = ADC_RByte_Sum/256; // приведение 24 бит к 32-битной переменной 
00CF2:  BCLR.B  43.0
00CF4:  MOV     18C6,W0
00CF6:  MOV     18C8,W1
00CF8:  MOV     #100,W2
00CFA:  MOV     #0,W3
00CFC:  CALL    75C
00D00:  MOV     W0,18C6
00D02:  MOV     W1,18C8
....................    
....................   Vin = ((ADC_RByte_Sum*5)/(8388608.0*PGA)); // расчет U 
00D04:  MOV     18C6,W0
00D06:  MOV     18C8,W1
00D08:  MOV     #5,W2
00D0A:  MOV     #0,W3
00D0C:  CALL    7DA
00D10:  MOV     W0,W5
00D12:  MOV     W1,W6
00D14:  MOV     #0,W1
00D16:  MOV     #0,W2
00D18:  MOV     #0,W3
00D1A:  MOV.B   811,W0L
00D1C:  CLR.B   1
00D1E:  CALL    81C
00D22:  MOV     W5,[W15++]
00D24:  MOV     W6,[W15++]
00D26:  MOV     W0,W4
00D28:  MOV     W1,W5
00D2A:  MOV     W2,W6
00D2C:  MOV     W3,W7
00D2E:  MOV     #0,W0
00D30:  MOV     #0,W1
00D32:  MOV     #0,W2
00D34:  MOV     #4160,W3
00D36:  CALL    880
00D3A:  MOV     [--W15],W6
00D3C:  MOV     [--W15],W5
00D3E:  MOV     W0,W7
00D40:  MOV     W1,W8
00D42:  MOV     W2,W9
00D44:  MOV     W3,W10
00D46:  MOV     W5,W0
00D48:  MOV     W6,W1
00D4A:  CLR     W3
00D4C:  BTSC    W1.F
00D4E:  SETM    W3
00D50:  MOV     W3,W2
00D52:  CALL    990
00D56:  MOV     W5,[W15++]
00D58:  MOV     W6,[W15++]
00D5A:  MOV     W7,[W15++]
00D5C:  MOV     W7,W4
00D5E:  MOV     W8,W5
00D60:  MOV     W9,W6
00D62:  MOV     W10,W7
00D64:  CALL    9F4
00D68:  MOV     [--W15],W7
00D6A:  MOV     [--W15],W6
00D6C:  MOV     [--W15],W5
00D6E:  CALL    AFC
00D72:  MOV     W1,18CA
00D74:  MOV     W2,18CC
....................    
....................   return Vin*uV; // возврат масштабированного U  
00D76:  MOV     18CA,W0
00D78:  MOV     18CC,W1
00D7A:  MOV     #9680,W2
00D7C:  MOV     #4B18,W3
00D7E:  CALL    B40
00D82:  CALL    C04
00D86:  MOV.D   W0,W0
00D88:  MOV     #14,W5
00D8A:  REPEAT  #4
00D8C:  MOV     [--W15],[W5--]
00D8E:  MOV     [--W15],W5
00D90:  RETURN  
....................    
....................   } 
....................  
.................... static S32 ADC_read_aver(U8 ADC_number,U8 ADC_ch) 
00D92:  MOV     W5,[W15++]
.................... { 
....................  S32 _Ch_buf_sum; // переменн. для хранения текущ. усредн. значения 
....................   
....................  Ch_buf[ADC_ch][Ma_buf_index] = ADC_read(ADC_number); // считываем текщее изм. в буфер 
00D94:  MOV.B   18AD,W0L
00D96:  CLR.B   1
00D98:  SL      W0,#9,W5
00D9A:  MOV.B   184A,W0L
00D9C:  CLR.B   1
00D9E:  SL      W0,#2,W0
00DA0:  ADD     W0,W5,W0
00DA2:  MOV     #846,W4
00DA4:  ADD     W0,W4,W5
00DA6:  MOV.B   18AC,W0L
00DA8:  MOV.B   W0L,18B8
00DAA:  CALL    C44
00DAE:  MOV     #0,W4
00DB0:  MOV     [W4++],[W5++]
00DB2:  MOV     [W4++],[W5++]
....................   
....................  for(U8 i = 0; i < Ma_buf_size; i++)                  // суммируем весь буфер 
00DB4:  CLR.B   18B2
00DB6:  MOV.B   18B2,W0L
00DB8:  MOV     184A,W4
00DBA:  LSR     W4,#8,W4
00DBC:  CP.B    W4L,W0L
00DBE:  BRA     LEU,DE8
....................  { 
....................    Ch_buf_sum += Ch_buf[ADC_ch][i];   // меняем элемент буфера на новый 
00DC0:  MOV.B   18AD,W0L
00DC2:  CLR.B   1
00DC4:  SL      W0,#9,W5
00DC6:  MOV.B   18B2,W0L
00DC8:  CLR.B   1
00DCA:  SL      W0,#2,W0
00DCC:  ADD     W0,W5,W0
00DCE:  MOV     #846,W4
00DD0:  ADD     W0,W4,W0
00DD2:  MOV     W0,W4
00DD4:  MOV     #0,W3
00DD6:  MOV     [W4++],[W3++]
00DD8:  MOV     [W4++],[W3++]
00DDA:  ADD     1846
00DDC:  MOV     W1,W0
00DDE:  ADDC    1848,W0
00DE0:  MOV     W0,1848
00DE2:  INC.B   18B2
00DE4:  GOTO    DB6
....................  }   
....................  Ch_buf_sum = Ch_buf_sum/Ma_buf_size; // вычисляем среднее 
00DE8:  BCLR.B  43.0
00DEA:  MOV.B   184B,W0L
00DEC:  MOV.B   W0L,W2L
00DEE:  CLR.B   5
00DF0:  MOV     #0,W3
00DF2:  MOV     1846,W0
00DF4:  MOV     1848,W1
00DF6:  CALL    75C
00DFA:  MOV     W0,1846
00DFC:  MOV     W1,1848
....................   
....................  _Ch_buf_sum = Ch_buf_sum; // пересохраняем для возврата 
00DFE:  PUSH    1846
00E00:  POP     18AE
00E02:  PUSH    1848
00E04:  POP     18B0
....................   
....................  Ch_buf_sum = 0;           // сброс глоб переменной 
00E06:  CLR     1846
00E08:  CLR     1848
....................   
....................  return _Ch_buf_sum; 
00E0A:  MOV     18AE,W0
00E0C:  MOV     18B0,W1
00E0E:  MOV     [--W15],W5
00E10:  RETURN  
....................  
.................... } 
....................  
.................... //---------------------------------------------------------------------------// 
....................  
....................  
.................... /*############################################################################*/ 
....................  
.................... static void Rd_Flash(){ 
....................  
....................   read_program_memory(CK_USER_PAGE,flash_rd_data,4); 
....................   delay_ms(5); 
....................   NumAver = flash_rd_data[1];  
....................   ADC_sps_var = flash_rd_data[0]; 
....................   CRC_buf = flash_rd_data[2]; 
....................  
.................... } 
....................  
.................... static void Wr_Flash(){ 
....................  
....................   flash_wr_data[0] = Aver_Wr;  
....................   flash_wr_data[1] = Sps_Wr; 
....................   flash_wr_data[2] = CRC_Wr; 
....................   //flash_wr_data[4] = 0x00; 
....................   write_program_memory(CK_USER_PAGE,flash_wr_data,4); 
....................   delay_ms(2); 
....................  
....................  //if(Rd_Flash(buf_index)==in_wr_data) return 1; else return 0; 
.................... } 
....................  
.................... unsigned char Crc8(unsigned char *pcBlock, unsigned int len) 
.................... { 
....................  
....................   //Name  : CRC-8 
....................   //Poly  : 0x31    x^8 + x^5 + x^4 + 1 
....................   //Init  : 0xFF 
....................   //Revert: false 
....................   //XorOut: 0x00 
....................   //Check : 0xF7 ("123456789") 
....................   //MaxLen: 15 байт(127 бит) - обнаружение 
....................   // одинарных, двойных, тройных и всех нечетных ошибок 
....................  
....................     unsigned char crc = 0xFF; 
....................     unsigned int i; 
....................   
....................     while (len--) 
....................     { 
....................         crc ^= *pcBlock++; 
....................   
....................         for (i = 0; i < 8; i++) 
....................             crc = crc & 0x80 ? (crc << 1) ^ 0x31 : crc << 1; 
....................     } 
....................   
....................     return crc; 
.................... } 
....................  
.................... static void UART2_init(){ 
....................  
....................    U2MODE = (1<<15 | // UARTx is enabled 
....................              1<<13 | // Discontinue operation when device enters Idle mode  
....................              0<<12 | // IrDA encoder and decoder disabled 
....................              1<<11 | // 1 - UxRTS in Simplex mode, 0 - flow control mode 
....................              2<<9  | // UxTX, UxRX, UxCTS and UxRTS pins are enabled and used 
....................              1<<7  | // 1 = Wake-up enabled 
....................              0<<6  | // 0 = Loopback mode is disabled 
....................              0<<5  | // Auto-Baud Enable bit, disabled 
....................              1<<4  | // Receive Polarity Inversion bit, 1 = UxRX Idle state is '0' 
....................              0<<3  | // BRGH: High Baud Rate Select bit , 0 = Low speed 
....................              0<<2  | // 00 = 8-bit data, no parity 
....................              0      // 0 = One Stop bit 
....................    ); 
....................  
.................... } 
....................  
.................... static void OscSetup(){ 
....................   //Fcy=Fosc/2 
....................   //Fin=10M 
....................   //Fosc=Fin(M/(N1*N2)) = 40M 
....................   //  
....................   //U2BRG = 259;// BAUD Rate Setting for 9600 
....................   //U2MODE = 0b1010101010000000; // brgh = 0 
....................   //U2BRG = 21;// BAUD Rate Setting for 115200 
....................   U2BRG = 10;  // BAUD Rate Setting for 230400 
*
00398:  MOV     #A,W4
0039A:  MOV     W4,238
....................   U2MODE = 0b1010101010000000; // brgh = 0 
0039C:  MOV     #AA80,W4
0039E:  MOV     W4,230
....................    
....................   PLLFBD = 30; // ???. ????. ??????? PLL M = 30 
003A0:  MOV     #1E,W4
003A2:  MOV     W4,746
....................    
....................   PLLPRE4 = 0; // ???. ????. ??????? PLL N1 = 2 
003A4:  BCLR.B  744.4
....................   PLLPRE3 = 0; 
003A6:  BCLR.B  744.3
....................   PLLPRE2 = 0; 
003A8:  BCLR.B  744.2
....................   PLLPRE1 = 0; 
003AA:  BCLR.B  744.1
....................   PLLPRE0 = 0; 
003AC:  BCLR.B  744.0
....................    
....................   PLLPOST0=0; // ???. ????. ??????? PLL N2 = 2 
003AE:  BCLR.B  744.6
....................   PLLPOST1=0; 
003B0:  BCLR.B  744.7
003B2:  RETURN  
....................      
....................    } 
....................  
.................... static void EnableInt (){ 
....................  
....................   enable_interrupts(INT_RDA); // UART Int 
003B4:  BSET.B  95.3
....................   enable_interrupts(INT_RDA2); // UART Int 
003B6:  BSET.B  97.6
....................    
....................   enable_interrupts(INT_TIMER1); 
003B8:  BSET.B  94.3
....................   EXT_INT_EDGE(L_TO_H); 
003BA:  BCLR.B  82.0
....................   ENABLE_INTERRUPTS(INTR_GLOBAL); 
003BC:  BCLR.B  81.7
003BE:  CLR     42
003C0:  BSET.B  81.7
003C2:  RETURN  
.................... } 
....................  
.................... static void MCU_init(){ 
....................  
....................   setup_timer1(TMR_INTERNAL | TMR_DIV_BY_64); // таймер 1 сбрасывает собачий таймер 
003C4:  CLR     104
003C6:  SETM    102
003C8:  MOV     #8020,W4
003CA:  MOV     W4,104
....................   set_timer1(20000); //reset the timer. 
003CC:  MOV     #4E20,W4
003CE:  MOV     W4,100
....................    
....................    SETUP_SPI2(SPI_MASTER|SPI_SCK_IDLE_LOW|SPI_XMIT_H_TO_L|SPI_MODE_8B|SPI_SAMPLE_AT_END|SPI_SS_DISABLED|SPI_CLK_DIV_128); 
003D0:  BCLR.B  261.7
003D2:  BCLR.B  260.6
003D4:  MOV     #221,W4
003D6:  MOV     W4,262
003D8:  BSET.B  261.7
....................    //f SCLK SPI = 312,5 kHz 
....................    //setup_timer1(TMR_DISABLED|TMR_DIV_BY_1); 
....................    //enable_interrupts(INT_EXT0); 
....................    //enable_interrupts(INT_TIMER1); 
....................    
....................  SCK2_TRIS=0; // SPI2 tris 
003DA:  BCLR.B  2E4.6
....................  SDI2_TRIS=1; 
003DC:  BSET.B  2E4.7
....................  SDO2_TRIS=0; 
003DE:  BCLR.B  2E5.0
....................   
....................  ADC_CS_TRIS=0;      ADC2_CS_TRIS=0; 
003E0:  BCLR.B  2E5.1
003E2:  BCLR.B  2D3.2
....................  ADC_RESET_TRIS=0;   ADC2_RESET_TRIS=0; 
003E4:  BCLR.B  2D2.3
003E6:  BCLR.B  2D2.0
....................  ADC_SYNC_TRIS=0;    ADC2_SYNC_TRIS=0; 
003E8:  BCLR.B  2D2.2
003EA:  BCLR.B  2D3.3
....................  ADC_DRDY_TRIS=1;    ADC2_DRDY_TRIS=1;       // опрос готовнсти данных АЦП 
003EC:  BSET.B  2D2.1
003EE:  BSET.B  2D3.1
....................   
....................  UART2_RX_TRIS=1; 
003F0:  BSET.B  2DE.4
....................  UART2_TX_TRIS=0; 
003F2:  BCLR.B  2DE.5
....................  //XPORT_RST_TRIS=0; 
....................   
....................  //XPORT_RST_n = 0; 
....................  //delay_us(500); 
....................  //XPORT_RST_n = 1; 
....................  EnableInt(); 
003F4:  CALL    3B4
003F8:  RETURN  
.................... } 
....................  
.................... static void Full_dev_reset(){ 
....................  
....................   OscSetup(); 
....................   MCU_init(); 
....................   reset_fl = 0; 
....................   //ADC_wakeUp(); 
....................   //ADC_wakeUp();  
....................   ADC_init(); 
....................   ADC_set_PGA(8); 
....................   ADC_sps_set(0x23); //0x023 - 10 sps, 0x43 - 25 sps, 0x63 - 50 sps 
....................                      //0x82 - 100 sps, 0x91 - 500 sps 
....................                      //0xA1 - 1000 sps, 0xC0 - 3750 sps 
....................   ADC_SelfCal(); 
....................   meas_stop_fl = 0; // вкл. режим измерений 
....................   NumAver = 10;      // сброс величины усреднения данных АЦП 
....................  
.................... } 
....................  
.................... static void Clr_bufs(void) 
003FA:  MOV     W5,[W15++]
.................... { 
....................   for (U8 i = 0; i < 8; i++) 
003FC:  CLR.B   18AC
003FE:  MOV     18AC,W4
00400:  CP.B    W4L,#8
00402:  BRA     C,43C
....................   { 
....................   // заполнение буферов скольз. ср. нулями 
....................    for (U8 j = 0; j < Ma_buf_size; j++)  
00404:  CLR.B   18AD
00406:  MOV.B   18AD,W0L
00408:  MOV     184A,W4
0040A:  LSR     W4,#8,W4
0040C:  CP.B    W4L,W0L
0040E:  BRA     LEU,436
....................       { 
....................          Ch_buf[i][j] = 0; 
00410:  MOV.B   18AC,W0L
00412:  CLR.B   1
00414:  SL      W0,#9,W5
00416:  MOV.B   18AD,W0L
00418:  CLR.B   1
0041A:  SL      W0,#2,W0
0041C:  ADD     W0,W5,W0
0041E:  MOV     #846,W4
00420:  ADD     W0,W4,W5
00422:  CLR.B   [W5]
00424:  MOV.B   #0,W0L
00426:  MOV.B   W0L,[W5+#1]
00428:  MOV.B   #0,W0L
0042A:  MOV.B   W0L,[W5+#2]
0042C:  MOV.B   #0,W0L
0042E:  MOV.B   W0L,[W5+#3]
00430:  INC.B   18AD
00432:  GOTO    406
....................       } 
00436:  INC.B   18AC
00438:  GOTO    3FE
....................   } 
0043C:  MOV     [--W15],W5
0043E:  RETURN  
.................... } 
....................  
.................... static U8 ch_to_int(char ch){ 
*
00E56:  MOV.B   #FF,W0L
00E58:  MOV.B   W0L,18AD
.................... U8 dg=-1; 
....................  switch (ch){ 
00E5A:  MOV.B   18AC,W0L
00E5C:  CLR.B   1
00E5E:  XOR     #30,W0
00E60:  BRA     Z,E88
00E62:  XOR     #1,W0
00E64:  BRA     Z,E8E
00E66:  XOR     #3,W0
00E68:  BRA     Z,E96
00E6A:  XOR     #1,W0
00E6C:  BRA     Z,E9E
00E6E:  XOR     #7,W0
00E70:  BRA     Z,EA6
00E72:  XOR     #1,W0
00E74:  BRA     Z,EAE
00E76:  XOR     #3,W0
00E78:  BRA     Z,EB6
00E7A:  XOR     #1,W0
00E7C:  BRA     Z,EBE
00E7E:  XOR     #F,W0
00E80:  BRA     Z,EC6
00E82:  XOR     #1,W0
00E84:  BRA     Z,ECE
00E86:  BRA     ED6
....................       case '0' : dg=0; 
00E88:  CLR.B   18AD
....................       break; 
00E8A:  GOTO    EDA
....................       case '1' : dg=1; 
00E8E:  MOV.B   #1,W0L
00E90:  MOV.B   W0L,18AD
....................       break; 
00E92:  GOTO    EDA
....................       case '2' : dg=2; 
00E96:  MOV.B   #2,W0L
00E98:  MOV.B   W0L,18AD
....................       break; 
00E9A:  GOTO    EDA
....................       case '3' : dg=3; 
00E9E:  MOV.B   #3,W0L
00EA0:  MOV.B   W0L,18AD
....................       break; 
00EA2:  GOTO    EDA
....................       case '4' : dg=4; 
00EA6:  MOV.B   #4,W0L
00EA8:  MOV.B   W0L,18AD
....................       break; 
00EAA:  GOTO    EDA
....................       case '5' : dg=5; 
00EAE:  MOV.B   #5,W0L
00EB0:  MOV.B   W0L,18AD
....................       break; 
00EB2:  GOTO    EDA
....................       case '6' : dg=6; 
00EB6:  MOV.B   #6,W0L
00EB8:  MOV.B   W0L,18AD
....................       break; 
00EBA:  GOTO    EDA
....................       case '7' : dg=7; 
00EBE:  MOV.B   #7,W0L
00EC0:  MOV.B   W0L,18AD
....................       break; 
00EC2:  GOTO    EDA
....................       case '8' : dg=8; 
00EC6:  MOV.B   #8,W0L
00EC8:  MOV.B   W0L,18AD
....................       break; 
00ECA:  GOTO    EDA
....................       case '9' : dg=9; 
00ECE:  MOV.B   #9,W0L
00ED0:  MOV.B   W0L,18AD
....................       break; 
00ED2:  GOTO    EDA
....................       default: dg=-1; 
00ED6:  MOV.B   #FF,W0L
00ED8:  MOV.B   W0L,18AD
....................  } 
.................... return dg; 
00EDA:  MOV.B   18AD,W0L
00EDC:  RETURN  
.................... } 
....................  
.................... static unsigned char getrxch (void){ 
*
00E12:  MOV     W5,[W15++]
....................  
.................... unsigned char rch; 
....................  
.................... if(rdptr < wrptr){ 
00E14:  MOV.B   1890,W0L
00E16:  MOV     188C,W4
00E18:  LSR     W4,#8,W4
00E1A:  CP.B    W4L,W0L
00E1C:  BRA     LEU,E34
....................  // есть символ, считываем 
....................    rdptr ++; 
00E1E:  INC.B   1890
....................    rch=RxData[rdptr& 0x0F];// прочитали символ 
00E20:  MOV.B   1890,W0L
00E22:  CLR.B   1
00E24:  AND     W0,#F,W5
00E26:  MOV     #1892,W4
00E28:  ADD     W5,W4,W0
00E2A:  MOV     18AC,W4
00E2C:  MOV.B   [W0+#0],W4L
00E2E:  MOV     W4,18AC
.................... } else rch = 'x';//символов нет 
00E30:  GOTO    E38
00E34:  MOV.B   #78,W0L
00E36:  MOV.B   W0L,18AC
....................    //обнуление указателей 
....................    disable_interrupts(INT_RDA2); 
00E38:  BCLR.B  97.6
....................   if((wrptr==rdptr) && (wrptr > 15))  
00E3A:  MOV.B   188D,W0L
00E3C:  CP.B    1890
00E3E:  BRA     NZ,E4C
00E40:  MOV     188C,W4
00E42:  LSR     W4,#8,W4
00E44:  CP.B    W4L,#F
00E46:  BRA     LEU,E4C
....................   { 
....................   wrptr=0; 
00E48:  CLR.B   188D
....................   rdptr=0; 
00E4A:  CLR.B   1890
....................   }  
....................   enable_interrupts(INT_RDA2); 
00E4C:  BSET.B  97.6
....................   return rch; 
00E4E:  MOV.B   18AC,W0L
00E50:  MOV.B   W0L,0
00E52:  MOV     [--W15],W5
00E54:  RETURN  
.................... } 
....................  
.................... // послед. чтение двух АЦП 
.................... /* 
.................... static void ADC_Seq_rd_and_print_ch(U8 chanel){ 
....................  
....................    switch (chanel){ 
.................... //---------------- АЦП 1 --------------------------------------//      
....................  case 1:  
....................   
....................  ADC_select(1); 
....................  ADC_setCh(1); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC_SYNC = 0; 
....................  delay_us(20); 
....................  ADC_SYNC = 1; 
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(1); 
....................  Printf("a%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................  
....................  break; 
....................  
.................... //---------------- 2 датчик --------------------------------------// 
....................  case 2: 
....................   
....................  ADC_select(1); 
....................  ADC_setCh(2); 
....................  ADC_select(0); 
....................   
....................  ADC_SYNC = 0; 
....................  delay_us(20); 
....................  ADC_SYNC = 1; 
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(1); 
....................  Printf("b%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................  
....................  break; 
....................   
.................... //---------------- 3 датчик --------------------------------------//   
....................  case 3:  
....................  
....................  ADC_select(1); 
....................  ADC_setCh(3); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC_SYNC = 0; 
....................  delay_us(20); 
....................  ADC_SYNC = 1; 
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(1); 
....................  Printf("c%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................  
....................  break; 
.................... //---------------- 4 датчик --------------------------------------//     
....................    case 4:  
....................     
....................  ADC_select(1); 
....................  ADC_setCh(4); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC_SYNC = 0; 
....................  delay_us(20); 
....................  ADC_SYNC = 1; 
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(1); 
....................  Printf("d%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................   
....................    break; 
.................... //----------------------------------------------------------------// 
....................  
.................... //------------------- АЦП 2 --------------------------------------//      
....................  case 5:  
....................   
....................  ADC_select(2); 
....................  ADC_setCh(1); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC2_SYNC = 0; 
....................  delay_us(20); 
....................  ADC2_SYNC = 1; 
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(2); 
....................  Printf("e%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................   
....................  break; 
....................   
.................... //---------------- 2 датчик --------------------------------------// 
....................  case 6:  
....................   
....................  ADC_select(2); 
....................  ADC_setCh(2); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC2_SYNC = 0; 
....................  delay_us(20); 
....................  ADC2_SYNC = 1; 
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(2); 
....................  Printf("f%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................    
....................  break; 
.................... //---------------- 3 датчик --------------------------------------//   
....................  case 7:  
....................  
....................  ADC_select(2); 
....................  ADC_setCh(3); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC2_SYNC = 0; 
....................  delay_us(20); 
....................  ADC2_SYNC = 1; 
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(2); 
....................  Printf("g%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................    
....................  break; 
.................... //---------------- 4 датчик --------------------------------------//     
....................    case 8:  
....................  
....................  ADC_select(2); 
....................  ADC_setCh(4); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC2_SYNC = 0; 
....................  delay_us(20); 
....................  ADC2_SYNC = 1; 
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(2); 
....................  Printf("h%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................    
....................   break; 
....................    } 
....................     
.................... } 
.................... */ 
.................... /**/ 
....................  
.................... // || чтение двух АЦП 
.................... static void ADC_Par_rd_and_print_ch(U8 channel) 
*
00F90:  MOV     W5,[W15++]
.................... { 
....................   char rchr;             // принятый U2 символ 
....................    
....................    
....................    switch (channel){ 
00F92:  MOV.B   18A4,W0L
00F94:  CLR.B   1
00F96:  XOR     #1,W0
00F98:  BRA     Z,FAC
00F9A:  XOR     #3,W0
00F9C:  BRA     Z,100A
00F9E:  XOR     #1,W0
00FA0:  BRA     Z,106A
00FA2:  XOR     #7,W0
00FA4:  BRA     Z,10CA
00FA6:  XOR     #1,W0
00FA8:  BRA     Z,113C
00FAA:  BRA     14BC
.................... //---------------- каналы 1 и 5 --------------------------------------//      
....................  case 1:  
....................   
....................  ADC_setCh(1,1); 
00FAC:  MOV.B   #1,W0L
00FAE:  MOV.B   W0L,18AC
00FB0:  MOV.B   #1,W0L
00FB2:  MOV.B   W0L,18AD
00FB4:  CALL    6C4
....................  ADC_setCh(1,2); 
00FB8:  MOV.B   #1,W0L
00FBA:  MOV.B   W0L,18AC
00FBC:  MOV.B   #2,W0L
00FBE:  MOV.B   W0L,18AD
00FC0:  CALL    6C4
....................  
....................  SYNC_ADC(1);  // синхр. измерений АЦП 1 
00FC4:  MOV.B   #1,W0L
00FC6:  MOV.B   W0L,18AC
00FC8:  CALL    728
....................  delay_us(200);   
00FCC:  REPEAT  #F9E
00FCE:  NOP     
....................  SYNC_ADC(2);  // синхр. измерений АЦП 2 
00FD0:  MOV.B   #2,W0L
00FD2:  MOV.B   W0L,18AC
00FD4:  CALL    728
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
00FD8:  BTSS.B  2D4.1
00FDA:  BRA     FE0
00FDC:  GOTO    FD8
....................  //Printf("a%09Ld\n",ADC_read_aver(1,0)); 
....................  adc_data[0] = ADC_read_aver(1,0); 
00FE0:  MOV.B   #1,W0L
00FE2:  MOV.B   W0L,18AC
00FE4:  CLR.B   18AD
00FE6:  CALL    D92
00FEA:  MOV     W0,812
00FEC:  MOV     W1,814
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 2 
00FEE:  BTSS.B  2D5.1
00FF0:  BRA     FF6
00FF2:  GOTO    FEE
....................  //Printf("e%09Ld\n",ADC_read_aver(2,1)); 
....................  adc_data[1] = ADC_read_aver(2,1); 
00FF6:  MOV.B   #2,W0L
00FF8:  MOV.B   W0L,18AC
00FFA:  MOV.B   #1,W0L
00FFC:  MOV.B   W0L,18AD
00FFE:  CALL    D92
01002:  MOV     W0,816
01004:  MOV     W1,818
....................  
....................  break; 
01006:  GOTO    14BC
....................  
.................... //---------------- каналы 2 и 6 --------------------------------------//   
....................  case 2:  
....................   
....................  ADC_setCh(2,1); 
0100A:  MOV.B   #2,W0L
0100C:  MOV.B   W0L,18AC
0100E:  MOV.B   #1,W0L
01010:  MOV.B   W0L,18AD
01012:  CALL    6C4
....................  ADC_setCh(2,2); 
01016:  MOV.B   #2,W0L
01018:  MOV.B   W0L,18AC
0101A:  MOV.B   #2,W0L
0101C:  MOV.B   W0L,18AD
0101E:  CALL    6C4
....................   
....................  SYNC_ADC(1);   // синхр. измерений АЦП 1 
01022:  MOV.B   #1,W0L
01024:  MOV.B   W0L,18AC
01026:  CALL    728
....................  delay_us(200);   
0102A:  REPEAT  #F9E
0102C:  NOP     
....................  SYNC_ADC(2);    // синхр. измерений АЦП 2 
0102E:  MOV.B   #2,W0L
01030:  MOV.B   W0L,18AC
01032:  CALL    728
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
01036:  BTSS.B  2D4.1
01038:  BRA     103E
0103A:  GOTO    1036
....................  //Printf("b%09Ld\n",ADC_read_aver(1,2)); 
....................  adc_data[2] = ADC_read_aver(1,2); 
0103E:  MOV.B   #1,W0L
01040:  MOV.B   W0L,18AC
01042:  MOV.B   #2,W0L
01044:  MOV.B   W0L,18AD
01046:  CALL    D92
0104A:  MOV     W0,81A
0104C:  MOV     W1,81C
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 2 
0104E:  BTSS.B  2D5.1
01050:  BRA     1056
01052:  GOTO    104E
....................  //Printf("f%09Ld\n",ADC_read_aver(2,3)); 
....................  adc_data[3] = ADC_read_aver(2,3); 
01056:  MOV.B   #2,W0L
01058:  MOV.B   W0L,18AC
0105A:  MOV.B   #3,W0L
0105C:  MOV.B   W0L,18AD
0105E:  CALL    D92
01062:  MOV     W0,81E
01064:  MOV     W1,820
....................   
....................  break; 
01066:  GOTO    14BC
....................   
.................... //---------------- каналы 3 и 7 --------------------------------------//    
....................  case 3:  
....................   
....................  ADC_setCh(3,1); 
0106A:  MOV.B   #3,W0L
0106C:  MOV.B   W0L,18AC
0106E:  MOV.B   #1,W0L
01070:  MOV.B   W0L,18AD
01072:  CALL    6C4
....................  ADC_setCh(3,2); 
01076:  MOV.B   #3,W0L
01078:  MOV.B   W0L,18AC
0107A:  MOV.B   #2,W0L
0107C:  MOV.B   W0L,18AD
0107E:  CALL    6C4
....................   
....................  SYNC_ADC(1);   // синхр. измерений АЦП 1 
01082:  MOV.B   #1,W0L
01084:  MOV.B   W0L,18AC
01086:  CALL    728
....................  delay_us(200);   
0108A:  REPEAT  #F9E
0108C:  NOP     
....................  SYNC_ADC(2);   // синхр. измерений АЦП 2 
0108E:  MOV.B   #2,W0L
01090:  MOV.B   W0L,18AC
01092:  CALL    728
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
01096:  BTSS.B  2D4.1
01098:  BRA     109E
0109A:  GOTO    1096
....................  //Printf("c%09Ld\n",ADC_read_aver(1,4)); 
....................   adc_data[4] = ADC_read_aver(1,4); 
0109E:  MOV.B   #1,W0L
010A0:  MOV.B   W0L,18AC
010A2:  MOV.B   #4,W0L
010A4:  MOV.B   W0L,18AD
010A6:  CALL    D92
010AA:  MOV     W0,822
010AC:  MOV     W1,824
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 2 
010AE:  BTSS.B  2D5.1
010B0:  BRA     10B6
010B2:  GOTO    10AE
....................  //Printf("g%09Ld\n",ADC_read_aver(2,5)); 
....................   adc_data[5] = ADC_read_aver(2,5); 
010B6:  MOV.B   #2,W0L
010B8:  MOV.B   W0L,18AC
010BA:  MOV.B   #5,W0L
010BC:  MOV.B   W0L,18AD
010BE:  CALL    D92
010C2:  MOV     W0,826
010C4:  MOV     W1,828
....................    
....................  break; 
010C6:  GOTO    14BC
....................   
.................... //---------------- каналы 4 и 8 --------------------------------------//    
....................  case 4:  
....................   
....................  ADC_setCh(4,1); 
010CA:  MOV.B   #4,W0L
010CC:  MOV.B   W0L,18AC
010CE:  MOV.B   #1,W0L
010D0:  MOV.B   W0L,18AD
010D2:  CALL    6C4
....................  ADC_setCh(4,2); 
010D6:  MOV.B   #4,W0L
010D8:  MOV.B   W0L,18AC
010DA:  MOV.B   #2,W0L
010DC:  MOV.B   W0L,18AD
010DE:  CALL    6C4
....................   
....................  SYNC_ADC(1);   // синхр. измерений АЦП 1 
010E2:  MOV.B   #1,W0L
010E4:  MOV.B   W0L,18AC
010E6:  CALL    728
....................  delay_us(200);   
010EA:  REPEAT  #F9E
010EC:  NOP     
....................  SYNC_ADC(2);    // синхр. измерений АЦП 2 
010EE:  MOV.B   #2,W0L
010F0:  MOV.B   W0L,18AC
010F2:  CALL    728
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
010F6:  BTSS.B  2D4.1
010F8:  BRA     10FE
010FA:  GOTO    10F6
....................  //Printf("d%09Ld\n",ADC_read_aver(1,6)); 
....................   adc_data[6] = ADC_read_aver(1,6); 
010FE:  MOV.B   #1,W0L
01100:  MOV.B   W0L,18AC
01102:  MOV.B   #6,W0L
01104:  MOV.B   W0L,18AD
01106:  CALL    D92
0110A:  MOV     W0,82A
0110C:  MOV     W1,82C
....................  
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 2 
0110E:  BTSS.B  2D5.1
01110:  BRA     1116
01112:  GOTO    110E
....................  //Printf("h%09Ld\n",ADC_read_aver(2,7)); 
....................  adc_data[7] = ADC_read_aver(2,7); 
01116:  MOV.B   #2,W0L
01118:  MOV.B   W0L,18AC
0111A:  MOV.B   #7,W0L
0111C:  MOV.B   W0L,18AD
0111E:  CALL    D92
01122:  MOV     W0,82E
01124:  MOV     W1,830
....................  Ma_buf_index++; // инкремент индекса 
01126:  INC.B   184A
....................  if(Ma_buf_index > Ma_buf_size-1) Ma_buf_index = 0;   // сброс индекса буфера 
01128:  MOV     184A,W4
0112A:  LSR     W4,#8,W4
0112C:  SUB     W4,#1,W0
0112E:  MOV     184A,W4
01130:  CLR.B   9
01132:  CP      W4,W0
01134:  BRA     LEU,1138
01136:  CLR.B   184A
....................   
....................  break; 
01138:  GOTO    14BC
....................   
.................... //---------------- обработка команд с ПК ------------------------------//    
....................  case 5: 
....................   
....................  while(rdptr < wrptr){ 
0113C:  MOV.B   1890,W0L
0113E:  MOV     188C,W4
01140:  LSR     W4,#8,W4
01142:  CP.B    W4L,W0L
01144:  BRA     LEU,14B8
....................    U8 dg=0; 
....................    U16 buf1;  
01146:  CLR.B   18A6
....................    //пока есть необработанные символы  
....................    rchr=getrxch(); 
01148:  CALL    E12
0114C:  MOV.B   W0L,18A5
....................   
....................    switch(state){ 
0114E:  MOV.B   188C,W0L
01150:  CLR.B   1
01152:  XOR     #0,W0
01154:  BRA     Z,1174
01156:  XOR     #1,W0
01158:  BRA     Z,1210
0115A:  XOR     #3,W0
0115C:  BRA     Z,12AA
0115E:  XOR     #1,W0
01160:  BRA     Z,12EE
01162:  XOR     #7,W0
01164:  BRA     Z,132A
01166:  XOR     #1,W0
01168:  BRA     Z,1390
0116A:  XOR     #3,W0
0116C:  BRA     Z,13D4
0116E:  XOR     #1,W0
01170:  BRA     Z,1416
01172:  BRA     14B2
....................           case 0: 
....................            switch (rchr){ //команды 
01174:  MOV.B   18A5,W0L
01176:  CLR.B   1
01178:  XOR     #73,W0
0117A:  BRA     Z,1192
0117C:  XOR     #3,W0
0117E:  BRA     Z,11A2
01180:  XOR     #17,W0
01182:  BRA     Z,11C2
01184:  XOR     #11,W0
01186:  BRA     Z,11D0
01188:  XOR     #14,W0
0118A:  BRA     Z,11DE
0118C:  XOR     #16,W0
0118E:  BRA     Z,11EC
01190:  BRA     11F4
....................                case 's': stop_fl = 0; // старт измерений 
01192:  BCLR.B  83C.2
....................                          Clr_bufs(); 
01194:  CALL    3FA
....................                          ADC_init(); // инициализ .АЦП с новыми параметрами 
01198:  CALL    5AC
....................                          state=0; 
0119C:  CLR.B   188C
....................                break;  
0119E:  GOTO    120C
....................                //---------- 
....................                case 'p': stop_fl = 1; // стоп измерений 
011A2:  BSET.B  83C.2
....................                          printf("stopped\n\r");   
011A4:  MOV     #0,W1
011A6:  MOV     W1,W0
011A8:  CLR.B   1
011AA:  CALL    200
011AE:  INC     W1,W1
011B0:  BTSC.B  233.1
011B2:  BRA     11B0
011B4:  MOV     W0,234
011B6:  MOV     #8,W0
011B8:  CPSGT   W1,W0
011BA:  BRA     11A6
....................                          state=0; 
011BC:  CLR.B   188C
....................                break;  
011BE:  GOTO    120C
....................                //---------- 
....................                case 'g': state = 1; // pga_set 
011C2:  MOV.B   #1,W0L
011C4:  MOV.B   W0L,188C
....................                if(!stop_fl) state=0;  
011C6:  BTSC.B  83C.2
011C8:  BRA     11CC
011CA:  CLR.B   188C
....................                break; 
011CC:  GOTO    120C
....................                //---------- 
....................                case 'v': state = 2; // sps_set 
011D0:  MOV.B   #2,W0L
011D2:  MOV.B   W0L,188C
....................                if(!stop_fl) state=0;            
011D4:  BTSC.B  83C.2
011D6:  BRA     11DA
011D8:  CLR.B   188C
....................                break; 
011DA:  GOTO    120C
....................                //---------- 
....................                case 'b': state = 5; // aver_buf_size 
011DE:  MOV.B   #5,W0L
011E0:  MOV.B   W0L,188C
....................                if(!stop_fl) state=0;            
011E2:  BTSC.B  83C.2
011E4:  BRA     11E8
011E6:  CLR.B   188C
....................                break; 
011E8:  GOTO    120C
....................                 
....................               //---------- 
....................                case 't': send_t_fl = 1; // взвод флага отпавки данных на комп. 
011EC:  BSET.B  83C.3
....................                          state=0;          
011EE:  CLR.B   188C
....................                break; 
011F0:  GOTO    120C
....................  
....................                default : printf("err \r\n");       
011F4:  MOV     #0,W1
011F6:  MOV     W1,W0
011F8:  CLR.B   1
011FA:  CALL    216
011FE:  INC     W1,W1
01200:  BTSC.B  233.1
01202:  BRA     1200
01204:  MOV     W0,234
01206:  MOV     #5,W0
01208:  CPSGT   W1,W0
0120A:  BRA     11F6
....................          } // команды 
....................           break; 
0120C:  GOTO    14B4
....................            
....................          case 1:  
....................          // уст. PGA 
....................             dg = ch_to_int(rchr); 
01210:  MOV.B   18A5,W0L
01212:  MOV.B   W0L,18AC
01214:  CALL    E56
01218:  MOV.B   W0L,18A6
....................             if(dg == -1){  
0121A:  MOV     18A6,W4
0121C:  XOR.B   #FF,W4L
0121E:  BRA     NZ,123E
....................               state=0; 
01220:  CLR.B   188C
....................               printf("PGA err \r\n");  
01222:  MOV     #0,W1
01224:  MOV     W1,W0
01226:  CLR.B   1
01228:  CALL    22A
0122C:  INC     W1,W1
0122E:  BTSC.B  233.1
01230:  BRA     122E
01232:  MOV     W0,234
01234:  MOV     #9,W0
01236:  CPSGT   W1,W0
01238:  BRA     1224
....................               break; 
0123A:  GOTO    14B4
....................                   } 
....................                    
....................               tmp = (U16)dg; 
0123E:  MOV.B   18A6,W0L
01240:  MOV.B   W0L,188E
01242:  CLR.B   188F
....................                
....................             //if(stop_fl) {      
....................                if(tmp>=0 && tmp<=6){ 
01244:  MOV     188E,W4
01246:  CP      W4,#6
01248:  BRA     GTU,128C
....................                   PGA_val=tmp; 
0124A:  MOV.B   188E,W0L
0124C:  MOV.B   W0L,832
....................                   printf("PGA=%u \r\n",PGA_val); 
0124E:  MOV     #0,W1
01250:  MOV     W1,W0
01252:  CLR.B   1
01254:  CALL    242
01258:  INC     W1,W1
0125A:  BTSC.B  233.1
0125C:  BRA     125A
0125E:  MOV     W0,234
01260:  MOV     #3,W0
01262:  CPSGT   W1,W0
01264:  BRA     1250
01266:  MOV.B   832,W0L
01268:  CLR.B   1
0126A:  MOV     #0,W4
0126C:  CALL    EDE
01270:  BTSC.B  233.1
01272:  BRA     1270
01274:  MOV     #20,W4
01276:  MOV     W4,234
01278:  BTSC.B  233.1
0127A:  BRA     1278
0127C:  MOV     #D,W4
0127E:  MOV     W4,234
01280:  BTSC.B  233.1
01282:  BRA     1280
01284:  MOV     #A,W4
01286:  MOV     W4,234
....................                }  else printf("PGA out of range\r\n"); 
01288:  GOTO    12A4
0128C:  MOV     #0,W1
0128E:  MOV     W1,W0
01290:  CLR.B   1
01292:  CALL    258
01296:  INC     W1,W1
01298:  BTSC.B  233.1
0129A:  BRA     1298
0129C:  MOV     W0,234
0129E:  MOV     #11,W0
012A0:  CPSGT   W1,W0
012A2:  BRA     128E
....................             //} 
....................                   state=0;      
012A4:  CLR.B   188C
....................          break; 
012A6:  GOTO    14B4
....................           
....................          case 2:  
....................          // уст. SPS 
....................             dg = ch_to_int(rchr); 
012AA:  MOV.B   18A5,W0L
012AC:  MOV.B   W0L,18AC
012AE:  CALL    E56
012B2:  MOV.B   W0L,18A6
....................             if(dg == -1){  
012B4:  MOV     18A6,W4
012B6:  XOR.B   #FF,W4L
012B8:  BRA     NZ,12D8
....................               state=0; 
012BA:  CLR.B   188C
....................               printf("err p1 \r\n");  
012BC:  MOV     #0,W1
012BE:  MOV     W1,W0
012C0:  CLR.B   1
012C2:  CALL    278
012C6:  INC     W1,W1
012C8:  BTSC.B  233.1
012CA:  BRA     12C8
012CC:  MOV     W0,234
012CE:  MOV     #8,W0
012D0:  CPSGT   W1,W0
012D2:  BRA     12BE
....................               break; 
012D4:  GOTO    14B4
....................                   } 
....................           // 1 цифра    
....................           tmp=0; 
012D8:  CLR     188E
....................           tmp+=(U16)dg*10; 
012DA:  MOV.B   18A6,W0L
012DC:  MOV.B   W0L,A
012DE:  CLR.B   B
012E0:  MOV     W5,W4
012E2:  MUL.UU  W4,#A,W0
012E4:  ADD     188E
....................           state=3; 
012E6:  MOV.B   #3,W0L
012E8:  MOV.B   W0L,188C
....................           // ПОЧЕМУ НАДО СЛАТЬ 3 СИМВОЛА? 
....................          break; 
012EA:  GOTO    14B4
....................           
....................          case 3:  
....................          // уст. SPS 
....................             dg = ch_to_int(rchr); 
012EE:  MOV.B   18A5,W0L
012F0:  MOV.B   W0L,18AC
012F2:  CALL    E56
012F6:  MOV.B   W0L,18A6
....................             if(dg == -1){  
012F8:  MOV     18A6,W4
012FA:  XOR.B   #FF,W4L
012FC:  BRA     NZ,131C
....................               state=0; 
012FE:  CLR.B   188C
....................               printf("err p2 \r\n");  
01300:  MOV     #0,W1
01302:  MOV     W1,W0
01304:  CLR.B   1
01306:  CALL    28E
0130A:  INC     W1,W1
0130C:  BTSC.B  233.1
0130E:  BRA     130C
01310:  MOV     W0,234
01312:  MOV     #8,W0
01314:  CPSGT   W1,W0
01316:  BRA     1302
....................               break; 
01318:  GOTO    14B4
....................                   } 
....................           // 2 цифра         
....................           tmp+=(U16)dg;  
0131C:  MOV.B   18A6,W0L
0131E:  CLR.B   1
01320:  ADD     188E
....................           state=4; 
01322:  MOV.B   #4,W0L
01324:  MOV.B   W0L,188C
....................          break; 
01326:  GOTO    14B4
....................           
....................          case 4:  
....................             if(tmp>=0 && tmp<=12){ 
0132A:  MOV     188E,W4
0132C:  CP      W4,#C
0132E:  BRA     GTU,1372
....................                ADC_sps_var = tmp; 
01330:  MOV.B   188E,W0L
01332:  MOV.B   W0L,83E
....................                printf("SPS=%u \r\n",ADC_sps_var); 
01334:  MOV     #0,W1
01336:  MOV     W1,W0
01338:  CLR.B   1
0133A:  CALL    2A4
0133E:  INC     W1,W1
01340:  BTSC.B  233.1
01342:  BRA     1340
01344:  MOV     W0,234
01346:  MOV     #3,W0
01348:  CPSGT   W1,W0
0134A:  BRA     1336
0134C:  MOV.B   83E,W0L
0134E:  CLR.B   1
01350:  MOV     #0,W4
01352:  CALL    EDE
01356:  BTSC.B  233.1
01358:  BRA     1356
0135A:  MOV     #20,W4
0135C:  MOV     W4,234
0135E:  BTSC.B  233.1
01360:  BRA     135E
01362:  MOV     #D,W4
01364:  MOV     W4,234
01366:  BTSC.B  233.1
01368:  BRA     1366
0136A:  MOV     #A,W4
0136C:  MOV     W4,234
....................                } else printf("SPS out of range\r\n"); 
0136E:  GOTO    138A
01372:  MOV     #0,W1
01374:  MOV     W1,W0
01376:  CLR.B   1
01378:  CALL    2BA
0137C:  INC     W1,W1
0137E:  BTSC.B  233.1
01380:  BRA     137E
01382:  MOV     W0,234
01384:  MOV     #11,W0
01386:  CPSGT   W1,W0
01388:  BRA     1374
....................                   state=0;      
0138A:  CLR.B   188C
....................          break; 
0138C:  GOTO    14B4
....................           
....................          case 5:  
....................          // уст. размера буфера усреднения 
....................             dg = ch_to_int(rchr); 
01390:  MOV.B   18A5,W0L
01392:  MOV.B   W0L,18AC
01394:  CALL    E56
01398:  MOV.B   W0L,18A6
....................             if(dg == -1){  
0139A:  MOV     18A6,W4
0139C:  XOR.B   #FF,W4L
0139E:  BRA     NZ,13BE
....................               state=0; 
013A0:  CLR.B   188C
....................               printf("err p1 \r\n");  
013A2:  MOV     #0,W1
013A4:  MOV     W1,W0
013A6:  CLR.B   1
013A8:  CALL    278
013AC:  INC     W1,W1
013AE:  BTSC.B  233.1
013B0:  BRA     13AE
013B2:  MOV     W0,234
013B4:  MOV     #8,W0
013B6:  CPSGT   W1,W0
013B8:  BRA     13A4
....................               break; 
013BA:  GOTO    14B4
....................                   } 
....................           // 1 цифра    
....................           tmp=0; 
013BE:  CLR     188E
....................           tmp+=(U16)dg*100; 
013C0:  MOV.B   18A6,W0L
013C2:  MOV.B   W0L,A
013C4:  CLR.B   B
013C6:  MOV     #64,W4
013C8:  MUL.UU  W5,W4,W0
013CA:  ADD     188E
....................           state=6; 
013CC:  MOV.B   #6,W0L
013CE:  MOV.B   W0L,188C
....................            
....................          break; 
013D0:  GOTO    14B4
....................           
....................          case 6:  
....................          // уст. размера буфера усреднения 
....................             dg = ch_to_int(rchr); 
013D4:  MOV.B   18A5,W0L
013D6:  MOV.B   W0L,18AC
013D8:  CALL    E56
013DC:  MOV.B   W0L,18A6
....................             if(dg == -1){  
013DE:  MOV     18A6,W4
013E0:  XOR.B   #FF,W4L
013E2:  BRA     NZ,1402
....................               state=0; 
013E4:  CLR.B   188C
....................               printf("err p2 \r\n");  
013E6:  MOV     #0,W1
013E8:  MOV     W1,W0
013EA:  CLR.B   1
013EC:  CALL    28E
013F0:  INC     W1,W1
013F2:  BTSC.B  233.1
013F4:  BRA     13F2
013F6:  MOV     W0,234
013F8:  MOV     #8,W0
013FA:  CPSGT   W1,W0
013FC:  BRA     13E8
....................               break; 
013FE:  GOTO    14B4
....................                   } 
....................           // 2 цифра         
....................           tmp+=(U16)dg*10; 
01402:  MOV.B   18A6,W0L
01404:  MOV.B   W0L,A
01406:  CLR.B   B
01408:  MOV     W5,W4
0140A:  MUL.UU  W4,#A,W0
0140C:  ADD     188E
....................           state=7; 
0140E:  MOV.B   #7,W0L
01410:  MOV.B   W0L,188C
....................            
....................          break; 
01412:  GOTO    14B4
....................           
....................          case 7:  
....................          // уст. размера буфера усреднения 
....................             dg = ch_to_int(rchr); 
01416:  MOV.B   18A5,W0L
01418:  MOV.B   W0L,18AC
0141A:  CALL    E56
0141E:  MOV.B   W0L,18A6
....................             if(dg == -1){  
01420:  MOV     18A6,W4
01422:  XOR.B   #FF,W4L
01424:  BRA     NZ,1444
....................               state=0; 
01426:  CLR.B   188C
....................               printf("err p3 \r\n");  
01428:  MOV     #0,W1
0142A:  MOV     W1,W0
0142C:  CLR.B   1
0142E:  CALL    2DA
01432:  INC     W1,W1
01434:  BTSC.B  233.1
01436:  BRA     1434
01438:  MOV     W0,234
0143A:  MOV     #8,W0
0143C:  CPSGT   W1,W0
0143E:  BRA     142A
....................               break; 
01440:  GOTO    14B4
....................                   } 
....................           // 3 цифра  
....................           tmp+=(U16)dg; 
01444:  MOV.B   18A6,W0L
01446:  CLR.B   1
01448:  ADD     188E
....................           if(tmp>=0 && tmp<=128){ 
0144A:  MOV     188E,W4
0144C:  MOV     #80,W3
0144E:  CP      W3,W4
01450:  BRA     NC,1494
....................                        Ma_buf_size=(U8)tmp;// прочитаны все 3 цифры без ошибок 
01452:  MOV.B   188E,W0L
01454:  MOV.B   W0L,184B
....................                        printf("aver buf size=%u \r\n",Ma_buf_size); 
01456:  MOV     #0,W1
01458:  MOV     W1,W0
0145A:  CLR.B   1
0145C:  CALL    2F0
01460:  INC     W1,W1
01462:  BTSC.B  233.1
01464:  BRA     1462
01466:  MOV     W0,234
01468:  MOV     #D,W0
0146A:  CPSGT   W1,W0
0146C:  BRA     1458
0146E:  MOV.B   184B,W0L
01470:  CLR.B   1
01472:  MOV     #0,W4
01474:  CALL    EDE
01478:  BTSC.B  233.1
0147A:  BRA     1478
0147C:  MOV     #20,W4
0147E:  MOV     W4,234
01480:  BTSC.B  233.1
01482:  BRA     1480
01484:  MOV     #D,W4
01486:  MOV     W4,234
01488:  BTSC.B  233.1
0148A:  BRA     1488
0148C:  MOV     #A,W4
0148E:  MOV     W4,234
....................           } else printf("aver buf out of range\r\n"); 
01490:  GOTO    14AC
01494:  MOV     #0,W1
01496:  MOV     W1,W0
01498:  CLR.B   1
0149A:  CALL    310
0149E:  INC     W1,W1
014A0:  BTSC.B  233.1
014A2:  BRA     14A0
014A4:  MOV     W0,234
014A6:  MOV     #16,W0
014A8:  CPSGT   W1,W0
014AA:  BRA     1496
....................            
....................           state=0; 
014AC:  CLR.B   188C
....................            
....................          break; 
014AE:  GOTO    14B4
....................           
....................         default : state=0;    
014B2:  CLR.B   188C
....................       } // state    
014B4:  GOTO    113C
....................    } // while 
....................     
....................      break; 
014B8:  GOTO    14BC
....................    } // main case 
014BC:  MOV     [--W15],W5
014BE:  RETURN  
.................... } 
....................  
.................... static void save_to_flash(){ 
....................        
....................    Sps_Wr = NumAver; 
....................    Aver_Wr = ADC_sps_var; // сохранение sps значения во флеш 
....................    CRC_Wr = CRC8(flash_wr_data,2); 
....................    Wr_Flash(); 
....................    }  
....................  
.................... #int_timer1 
.................... static void timer1_irq_handler(void) { 
*
00334:  PUSH    42
00336:  PUSH    36
00338:  PUSH    32
0033A:  MOV     W0,[W15++]
0033C:  MOV     #2,W0
0033E:  REPEAT  #C
00340:  MOV     [W0++],[W15++]
.................... restart_wdt();     // сбос собачего таймера 
00342:  CLRWDT  
.................... set_timer1(20000); //reset the timer. 
00344:  MOV     #4E20,W4
00346:  MOV     W4,100
.................... clear_interrupt(int_timer1); 
00348:  BCLR.B  84.3
.................... } 
....................  
0034A:  BCLR.B  84.3
0034C:  MOV     #1A,W0
0034E:  REPEAT  #C
00350:  MOV     [--W15],[W0--]
00352:  MOV     [--W15],W0
00354:  POP     32
00356:  POP     36
00358:  POP     42
0035A:  RETFIE  
.................... #INT_RDA2 
.................... void UART2_RXd_isr(void){ 
0035C:  PUSH    42
0035E:  PUSH    36
00360:  PUSH    32
00362:  MOV     W0,[W15++]
00364:  MOV     #2,W0
00366:  REPEAT  #C
00368:  MOV     [W0++],[W15++]
....................  
.................... while(U2STA & 0x0001) 
0036A:  MOV     232,W0
0036C:  AND     W0,#1,W0
0036E:  CP0     W0
00370:  BRA     Z,386
.................... { // Receive buffer has data, at least one more character can be read 
....................    wrptr++; 
00372:  INC.B   188D
....................    RxData[wrptr & 0x0F] = (U8)(U2RXREG); 
00374:  MOV.B   188D,W0L
00376:  CLR.B   1
00378:  AND     W0,#F,W5
0037A:  MOV     #1892,W4
0037C:  ADD     W5,W4,W6
0037E:  MOV     236,W0
00380:  MOV.B   W0L,[W6+#0]
00382:  GOTO    36A
.................... } 
00386:  BCLR.B  87.6
00388:  MOV     #1A,W0
0038A:  REPEAT  #C
0038C:  MOV     [--W15],[W0--]
0038E:  MOV     [--W15],W0
00390:  POP     32
00392:  POP     36
00394:  POP     42
00396:  RETFIE  
.................... } 
....................  
.................... /*############################################################################*/ 
....................  
.................... static void main() 
*
01618:  MOV     #1F80,W15
0161A:  MOV     #1FFF,W0
0161C:  MOV     W0,20
0161E:  NOP     
01620:  MOV     #4444,W0
01622:  MOV     W0,A4
01624:  BSET.B  81.7
01626:  BCLR.B  261.7
01628:  BCLR.B  2E5.0
0162A:  BSET.B  2E4.7
0162C:  BCLR.B  2E4.6
0162E:  BCLR.B  260.6
01630:  MOV     #3F,W4
01632:  MOV     W4,262
01634:  BSET.B  261.7
01636:  CLR     806
01638:  MOV     #8000,W4
0163A:  MOV     W4,230
0163C:  MOV     #400,W4
0163E:  MOV     W4,232
01640:  BSET.B  230.3
01642:  MOV     #15,W4
01644:  MOV     W4,238
01646:  MOV.B   #3,W0L
01648:  MOV.B   W0L,832
0164A:  CLR.B   833
0164C:  CLR.B   838
0164E:  CLR.B   839
01650:  CLR.B   83A
01652:  CLR.B   83B
01654:  BCLR.B  83C.0
01656:  BCLR.B  83C.1
01658:  BCLR.B  83C.2
0165A:  BCLR.B  83C.3
0165C:  MOV.B   #1,W0L
0165E:  MOV.B   W0L,83D
01660:  MOV.B   #1,W0L
01662:  MOV.B   W0L,83E
01664:  MOV.B   #FF,W0L
01666:  MOV.B   W0L,83F
01668:  SETM.B  840
0166A:  CLR.B   184A
0166C:  MOV.B   #10,W0L
0166E:  MOV.B   W0L,184B
01670:  CLR     188E
01672:  CLR.B   188D
01674:  CLR.B   1890
01676:  SETM    32C
01678:  SETM    32A
0167A:  CLR     800
0167C:  MOV     #7600,W4
0167E:  MOV     W4,808
01680:  MOV     #3254,W4
01682:  MOV     W4,80A
01684:  MOV     #10,W4
01686:  MOV     W4,80C
01688:  CLR     80E
0168A:  CLR.B   810
0168C:  CLR     834
0168E:  CLR     836
01690:  CLR     1892
01692:  CLR     1894
01694:  CLR     1896
01696:  CLR     1898
01698:  CLR     189A
0169A:  CLR     189C
0169C:  CLR     189E
0169E:  CLR     18A0
016A0:  MOV.B   #1,W0L
016A2:  MOV.B   W0L,18A2
.................... {  
....................   U8 ch = 1;             // начальная установка канала измерений АЦП 
....................  
....................   OscSetup(); 
016A4:  CALL    398
....................   MCU_init();  
016A8:  CALL    3C4
....................   //Rd_Flash();                        // чтение денных из флеш для расчета контр. суммы 
....................   //crc1 = CRC_buf;                    // сохраненная контр. сумма     
....................   //crc2 = CRC8(flash_rd_data,2);      // текущая контр. сумма 
....................    
....................   Clr_bufs(); 
016AC:  CALL    3FA
....................    
....................   ADC_sps_var = 0;   // сброс значений по умолчанию  
016B0:  CLR.B   83E
....................   NumAver = 1;       // тк произошел сбой контр. суммы 
016B2:  MOV.B   #1,W0L
016B4:  MOV.B   W0L,83D
....................       
....................   ADC_RESET = 1; ADC2_RESET = 1; 
016B6:  BSET.B  2D6.3
016B8:  BSET.B  2D6.0
....................   ADC_CS = 1;    ADC2_CS = 1; 
016BA:  BSET.B  2E9.1
016BC:  BSET.B  2D7.2
....................   ADC_SYNC = 1;  ADC2_SYNC = 1;  
016BE:  BSET.B  2D6.2
016C0:  BSET.B  2D7.3
....................       
....................   While(ADC_DRDY | ADC2_DRDY) { }   // ждем готовности обоих АЦП перед иниц.   
016C2:  CLR     W0
016C4:  BTSC.B  2D4.1
016C6:  INC     W0,W0
016C8:  MOV.B   W0L,W6L
016CA:  CLR     W0
016CC:  BTSC.B  2D5.1
016CE:  INC     W0,W0
016D0:  IOR.B    W6L,  W0L,W0L
016D2:  CP0.B   W0L
016D4:  BRA     Z,16DA
016D6:  GOTO    16C2
....................    
....................   ADC_init();        // Инициализация обоих АЦП  
016DA:  CALL    5AC
....................    
.................... /*############################################################################*/   
....................  
....................   while(true){ 
....................    
....................   ADC_Par_rd_and_print_ch(ch); // чтение 8 каналов двух АЦП 
016DE:  MOV.B   18A2,W0L
016E0:  MOV.B   W0L,18A4
016E2:  CALL    F90
....................    
....................   if(send_t_fl) 
016E6:  BTSS.B  83C.3
016E8:  BRA     17BC
....................   { 
....................       send_t_fl = 0; 
016EA:  BCLR.B  83C.3
....................       Printf("a%09Ld\n",adc_data[0]); 
016EC:  BTSC.B  233.1
016EE:  BRA     16EC
016F0:  MOV     #61,W4
016F2:  MOV     W4,234
016F4:  MOV     812,W0
016F6:  MOV     814,W1
016F8:  MOV     #8009,W4
016FA:  CALL    1504
016FE:  BTSC.B  233.1
01700:  BRA     16FE
01702:  MOV     #A,W4
01704:  MOV     W4,234
....................       Printf("e%09Ld\n",adc_data[1]); 
01706:  BTSC.B  233.1
01708:  BRA     1706
0170A:  MOV     #65,W4
0170C:  MOV     W4,234
0170E:  MOV     816,W0
01710:  MOV     818,W1
01712:  MOV     #8009,W4
01714:  CALL    1504
01718:  BTSC.B  233.1
0171A:  BRA     1718
0171C:  MOV     #A,W4
0171E:  MOV     W4,234
....................       Printf("b%09Ld\n",adc_data[2]); 
01720:  BTSC.B  233.1
01722:  BRA     1720
01724:  MOV     #62,W4
01726:  MOV     W4,234
01728:  MOV     81A,W0
0172A:  MOV     81C,W1
0172C:  MOV     #8009,W4
0172E:  CALL    1504
01732:  BTSC.B  233.1
01734:  BRA     1732
01736:  MOV     #A,W4
01738:  MOV     W4,234
....................       Printf("f%09Ld\n",adc_data[3]); 
0173A:  BTSC.B  233.1
0173C:  BRA     173A
0173E:  MOV     #66,W4
01740:  MOV     W4,234
01742:  MOV     81E,W0
01744:  MOV     820,W1
01746:  MOV     #8009,W4
01748:  CALL    1504
0174C:  BTSC.B  233.1
0174E:  BRA     174C
01750:  MOV     #A,W4
01752:  MOV     W4,234
....................       Printf("c%09Ld\n",adc_data[4]); 
01754:  BTSC.B  233.1
01756:  BRA     1754
01758:  MOV     #63,W4
0175A:  MOV     W4,234
0175C:  MOV     822,W0
0175E:  MOV     824,W1
01760:  MOV     #8009,W4
01762:  CALL    1504
01766:  BTSC.B  233.1
01768:  BRA     1766
0176A:  MOV     #A,W4
0176C:  MOV     W4,234
....................       Printf("g%09Ld\n",adc_data[5]); 
0176E:  BTSC.B  233.1
01770:  BRA     176E
01772:  MOV     #67,W4
01774:  MOV     W4,234
01776:  MOV     826,W0
01778:  MOV     828,W1
0177A:  MOV     #8009,W4
0177C:  CALL    1504
01780:  BTSC.B  233.1
01782:  BRA     1780
01784:  MOV     #A,W4
01786:  MOV     W4,234
....................       Printf("d%09Ld\n",adc_data[6]); 
01788:  BTSC.B  233.1
0178A:  BRA     1788
0178C:  MOV     #64,W4
0178E:  MOV     W4,234
01790:  MOV     82A,W0
01792:  MOV     82C,W1
01794:  MOV     #8009,W4
01796:  CALL    1504
0179A:  BTSC.B  233.1
0179C:  BRA     179A
0179E:  MOV     #A,W4
017A0:  MOV     W4,234
....................       Printf("h%09Ld\n",adc_data[7]); 
017A2:  BTSC.B  233.1
017A4:  BRA     17A2
017A6:  MOV     #68,W4
017A8:  MOV     W4,234
017AA:  MOV     82E,W0
017AC:  MOV     830,W1
017AE:  MOV     #8009,W4
017B0:  CALL    1504
017B4:  BTSC.B  233.1
017B6:  BRA     17B4
017B8:  MOV     #A,W4
017BA:  MOV     W4,234
....................  
....................   }// инкремент номера канала 
....................   ch++; 
017BC:  INC.B   18A2
....................   if (ch > 5) ch = 1; // диапазон каналов 
017BE:  MOV     18A2,W4
017C0:  CP.B    W4L,#5
017C2:  BRA     LEU,17C8
017C4:  MOV.B   #1,W0L
017C6:  MOV.B   W0L,18A2
....................   if (stop_fl) ch = 5; // остановить измерения 
017C8:  BTSS.B  83C.2
017CA:  BRA     17D0
017CC:  MOV.B   #5,W0L
017CE:  MOV.B   W0L,18A2
017D0:  GOTO    16DE
....................  } // while   
.................... }  // main 
.................... /*############################################################################*/ 
017D4:  PWRSAV  #0
....................  

Configuration Fuses:
   Word  1L: 00CE   WRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0083   PR_PLL IESO
          H: FF00  
   Word  5L: 0006   HS NOOSCIO CKSFSM
          H: FF00  
   Word  6L: 00DD   WPOSTS14 WPRES128 WINDIS WDT
          H: FF00  
   Word  7L: 00E7   PUT128
          H: FF00  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: FF00  
