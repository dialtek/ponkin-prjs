CCS PCD C Compiler, Version 5.049, 5967               31-май-18 13:09

               Filename:   F:\Mega\ponkin-prjs\PICC\my prj\Termo\old\PoE termo 8ch\main.lst

               ROM used:   6186 bytes (7%)
                           Largest free fragment is 59350
               RAM used:   4358 (53%) at main() level
                           4418 (54%) worst case
               Stack used: 78 locations (40 in main + 38 for interrupts)
               Stack size: 128

*
00000:  GOTO    1744
*
0001A:  DATA    34,03,00
*
00050:  DATA    5C,03,00
.................... #include <main.h> 
.................... #include <24HJ128GP506A.h> 
.................... //////////// Standard Header file for the PIC24HJ128GP506A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24HJ128GP506A 
*
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    73,74,00
0020E:  DATA    6F,70,00
00210:  DATA    70,65,00
00212:  DATA    64,0A,00
00214:  DATA    0D,00,00
00216:  CLR     32
00218:  MOV     #222,W3
0021A:  ADD     W3,W0,W0
0021C:  TBLRDL.B[W0],W0L
0021E:  CLR.B   1
00220:  RETURN  
00222:  DATA    65,72,00
00224:  DATA    72,20,00
00226:  DATA    0D,0A,00
00228:  DATA    00,00,00
0022A:  CLR     32
0022C:  MOV     #236,W3
0022E:  ADD     W3,W0,W0
00230:  TBLRDL.B[W0],W0L
00232:  CLR.B   1
00234:  RETURN  
00236:  DATA    50,47,00
00238:  DATA    41,20,00
0023A:  DATA    65,72,00
0023C:  DATA    72,20,00
0023E:  DATA    0D,0A,00
00240:  DATA    00,00,00
00242:  CLR     32
00244:  MOV     #24E,W3
00246:  ADD     W3,W0,W0
00248:  TBLRDL.B[W0],W0L
0024A:  CLR.B   1
0024C:  RETURN  
0024E:  DATA    50,47,00
00250:  DATA    41,3D,00
00252:  DATA    25,75,00
00254:  DATA    20,0D,00
00256:  DATA    0A,00,00
00258:  CLR     32
0025A:  MOV     #264,W3
0025C:  ADD     W3,W0,W0
0025E:  TBLRDL.B[W0],W0L
00260:  CLR.B   1
00262:  RETURN  
00264:  DATA    50,47,00
00266:  DATA    41,20,00
00268:  DATA    6F,75,00
0026A:  DATA    74,20,00
0026C:  DATA    6F,66,00
0026E:  DATA    20,72,00
00270:  DATA    61,6E,00
00272:  DATA    67,65,00
00274:  DATA    0D,0A,00
00276:  DATA    00,00,00
00278:  CLR     32
0027A:  MOV     #284,W3
0027C:  ADD     W3,W0,W0
0027E:  TBLRDL.B[W0],W0L
00280:  CLR.B   1
00282:  RETURN  
00284:  DATA    65,72,00
00286:  DATA    72,20,00
00288:  DATA    70,31,00
0028A:  DATA    20,0D,00
0028C:  DATA    0A,00,00
0028E:  CLR     32
00290:  MOV     #29A,W3
00292:  ADD     W3,W0,W0
00294:  TBLRDL.B[W0],W0L
00296:  CLR.B   1
00298:  RETURN  
0029A:  DATA    65,72,00
0029C:  DATA    72,20,00
0029E:  DATA    70,32,00
002A0:  DATA    20,0D,00
002A2:  DATA    0A,00,00
002A4:  CLR     32
002A6:  MOV     #2B0,W3
002A8:  ADD     W3,W0,W0
002AA:  TBLRDL.B[W0],W0L
002AC:  CLR.B   1
002AE:  RETURN  
002B0:  DATA    53,50,00
002B2:  DATA    53,3D,00
002B4:  DATA    25,75,00
002B6:  DATA    20,0D,00
002B8:  DATA    0A,00,00
002BA:  CLR     32
002BC:  MOV     #2C6,W3
002BE:  ADD     W3,W0,W0
002C0:  TBLRDL.B[W0],W0L
002C2:  CLR.B   1
002C4:  RETURN  
002C6:  DATA    53,50,00
002C8:  DATA    53,20,00
002CA:  DATA    6F,75,00
002CC:  DATA    74,20,00
002CE:  DATA    6F,66,00
002D0:  DATA    20,72,00
002D2:  DATA    61,6E,00
002D4:  DATA    67,65,00
002D6:  DATA    0D,0A,00
002D8:  DATA    00,00,00
002DA:  CLR     32
002DC:  MOV     #2E6,W3
002DE:  ADD     W3,W0,W0
002E0:  TBLRDL.B[W0],W0L
002E2:  CLR.B   1
002E4:  RETURN  
002E6:  DATA    65,72,00
002E8:  DATA    72,20,00
002EA:  DATA    70,33,00
002EC:  DATA    20,0D,00
002EE:  DATA    0A,00,00
002F0:  CLR     32
002F2:  MOV     #2FC,W3
002F4:  ADD     W3,W0,W0
002F6:  TBLRDL.B[W0],W0L
002F8:  CLR.B   1
002FA:  RETURN  
002FC:  DATA    61,76,00
002FE:  DATA    65,72,00
00300:  DATA    20,62,00
00302:  DATA    75,66,00
00304:  DATA    20,73,00
00306:  DATA    69,7A,00
00308:  DATA    65,3D,00
0030A:  DATA    25,75,00
0030C:  DATA    20,0D,00
0030E:  DATA    0A,00,00
00310:  CLR     32
00312:  MOV     #31C,W3
00314:  ADD     W3,W0,W0
00316:  TBLRDL.B[W0],W0L
00318:  CLR.B   1
0031A:  RETURN  
0031C:  DATA    61,76,00
0031E:  DATA    65,72,00
00320:  DATA    20,62,00
00322:  DATA    75,66,00
00324:  DATA    20,6F,00
00326:  DATA    75,74,00
00328:  DATA    20,6F,00
0032A:  DATA    66,20,00
0032C:  DATA    72,61,00
0032E:  DATA    6E,67,00
00330:  DATA    65,0D,00
00332:  DATA    0A,00,00
*
00722:  MOV     W5,[W15++]
00724:  MOV     #C,W5
00726:  REPEAT  #3
00728:  MOV     [W5++],[W15++]
0072A:  MOV     #0,W9
0072C:  BTSC.B  43.0
0072E:  MOV     #1,W9
00730:  MOV     W9,[W15++]
00732:  XOR     W1,W3,W9
00734:  BTSS    W1.F
00736:  BRA     73E
00738:  COM     W1,W1
0073A:  NEG     W0,W0
0073C:  ADDC    W1,#0,W1
0073E:  BTSS    W3.F
00740:  BRA     748
00742:  COM     W3,W3
00744:  NEG     W2,W2
00746:  ADDC    W3,#0,W3
00748:  XOR     W2,W3,W4
0074A:  BRA     Z,776
0074C:  CLR     W4
0074E:  CLR     W5
00750:  CLR     W6
00752:  CLR     W7
00754:  MOV     #20,W8
00756:  BCLR.B  42.0
00758:  RLC     W0,W0
0075A:  RLC     W1,W1
0075C:  RLC     W4,W4
0075E:  RLC     W5,W5
00760:  CP      W5,W3
00762:  BRA     NZ,766
00764:  CPB     W4,W2
00766:  BRA     NC,76E
00768:  SUB     W4,W2,W4
0076A:  SUBB    W5,W3,W5
0076C:  BSET.B  42.0
0076E:  RLC     W6,W6
00770:  RLC     W7,W7
00772:  DEC     W8,W8
00774:  BRA     NZ,756
00776:  BTSS    W9.F
00778:  BRA     788
0077A:  NEG     W6,W0
0077C:  BRA     Z,780
0077E:  BRA     NZ,784
00780:  NEG     W7,W1
00782:  BRA     78E
00784:  COM     W7,W1
00786:  BRA     78E
00788:  MOV     W7,W1
0078A:  MOV     W6,W0
0078C:  BRA     78E
0078E:  MOV     [--W15],W9
00790:  CP0     W9
00792:  BRA     Z,796
00794:  MOV.D   W4,W0
00796:  MOV     #12,W5
00798:  REPEAT  #3
0079A:  MOV     [--W15],[W5--]
0079C:  MOV     [--W15],W5
0079E:  RETURN  
007A0:  MOV     W5,[W15++]
007A2:  MOV     #C,W5
007A4:  REPEAT  #3
007A6:  MOV     [W5++],[W15++]
007A8:  MUL.UU  W0,W2,W4
007AA:  BTSS    W3.F
007AC:  BRA     7B2
007AE:  MUL.SS  W0,W3,W6
007B0:  BRA     7B4
007B2:  MUL.UU  W0,W3,W6
007B4:  BCLR.B  42.0
007B6:  ADD     W6,W5,W5
007B8:  ADDC    W7,#0,W8
007BA:  BTSS    W1.F
007BC:  BRA     7C2
007BE:  MUL.SS  W1,W2,W6
007C0:  BRA     7C4
007C2:  MUL.UU  W1,W2,W6
007C4:  ADDC    W6,W5,W5
007C6:  ADDC    W7,W8,W8
007C8:  ADDC    #0,W9
007CA:  MUL.SS  W1,W3,W6
007CC:  ADDC    W6,W8,W8
007CE:  ADDC    W9,W7,W7
007D0:  MOV     W7,W3
007D2:  MOV     W8,W2
007D4:  MOV     W5,W1
007D6:  MOV     W4,W0
007D8:  MOV     #12,W5
007DA:  REPEAT  #3
007DC:  MOV     [--W15],[W5--]
007DE:  MOV     [--W15],W5
007E0:  RETURN  
007E2:  MOV     W5,[W15++]
007E4:  MOV     #C,W5
007E6:  REPEAT  #3
007E8:  MOV     [W5++],[W15++]
007EA:  MOV     W0,W4
007EC:  MOV     W1,W5
007EE:  MOV     W2,W6
007F0:  MOV     W3,W7
007F2:  CLR     W0
007F4:  CLR     W1
007F6:  CLR     W2
007F8:  CLR     W3
007FA:  BCLR    W8.0
007FC:  BTSS    W7.F
007FE:  BRA     810
00800:  BSET    W8.0
00802:  COM     W7,W7
00804:  COM     W6,W6
00806:  COM     W5,W5
00808:  NEG     W4,W4
0080A:  ADDC    W5,#0,W5
0080C:  ADDC    W6,#0,W6
0080E:  ADDC    W7,#0,W7
00810:  IOR      W4,  W5,W9
00812:  BRA     NZ,818
00814:  IOR      W6,  W7,W9
00816:  BRA     Z,842
00818:  MOV     #473,W9
0081A:  BTSC    W3.4
0081C:  BRA     834
0081E:  BCLR.B  42.0
00820:  RLC     W4,W4
00822:  RLC     W5,W5
00824:  RLC     W6,W6
00826:  RLC     W7,W7
00828:  RLC     W0,W0
0082A:  RLC     W1,W1
0082C:  RLC     W2,W2
0082E:  RLC     W3,W3
00830:  DEC     W9,W9
00832:  BRA     NZ,81A
00834:  SL      W9,#4,W9
00836:  BCLR.B  42.0
00838:  BCLR    W9.F
0083A:  BCLR    W3.4
0083C:  XOR     W9,W3,W3
0083E:  BTSC    W8.0
00840:  BSET    W3.F
00842:  MOV     #12,W5
00844:  REPEAT  #3
00846:  MOV     [--W15],[W5--]
00848:  MOV     [--W15],W5
0084A:  RETURN  
0084C:  MOV     W8,[W15++]
0084E:  MOV     #12,W8
00850:  REPEAT  #4
00852:  MOV     [W8++],[W15++]
00854:  CLR     W11
00856:  MUL.UU  W12,#0,W12
00858:  MOV     W3,W8
0085A:  MOV     W7,W9
0085C:  MOV     #7FF,W10
0085E:  BCLR.B  42.0
00860:  BCLR.B  42.1
00862:  ASR     W8,#4,W8
00864:  AND     W10,W8,W8
00866:  CP0     W8
00868:  BRA     Z,94C
0086A:  BCLR.B  42.0
0086C:  BCLR.B  42.1
0086E:  ASR     W9,#4,W9
00870:  AND     W10,W9,W9
00872:  CP0     W9
00874:  BRA     Z,94C
00876:  ADD     W9,W8,W8
00878:  BTSC    W9.B
0087A:  BRA     884
0087C:  SUB     #3FF,W8
0087E:  BRA     Z,94C
00880:  BRA     NC,94C
00882:  BRA     88A
00884:  MOV     #401,W10
00886:  ADD.B   W10L,W5L,W5L
00888:  BRA     C,94C
0088A:  XOR     W3,W7,W13
0088C:  BCLR.B  42.0
0088E:  BCLR.B  42.1
00890:  AND     #F,W3
00892:  BSET    W3.4
00894:  AND     #F,W7
00896:  BSET    W7.4
00898:  MOV     W8,[W15++]
0089A:  MUL.UU  W4,W1,W8
0089C:  MUL.UU  W5,W0,W10
0089E:  ADD     W8,W10,W10
008A0:  ADDC    W9,W11,W11
008A2:  ADDC    #0,W12
008A4:  MUL.UU  W4,W2,W8
008A6:  ADD     W8,W11,W11
008A8:  ADDC    W9,W12,W12
008AA:  MUL.UU  W5,W1,W8
008AC:  CLR     W10
008AE:  ADD     W8,W11,W11
008B0:  ADDC    W9,W12,W12
008B2:  ADDC    #0,W10
008B4:  MUL.UU  W6,W0,W8
008B6:  ADD     W8,W11,W11
008B8:  ADDC    W9,W12,W12
008BA:  ADDC    #0,W10
008BC:  CLR     W11
008BE:  MUL.UU  W4,W3,W8
008C0:  ADD     W8,W12,W12
008C2:  ADDC    W9,W10,W10
008C4:  ADDC    #0,W11
008C6:  MUL.UU  W5,W2,W8
008C8:  ADD     W8,W12,W12
008CA:  ADDC    W9,W10,W10
008CC:  ADDC    #0,W11
008CE:  MUL.UU  W6,W1,W8
008D0:  ADD     W8,W12,W12
008D2:  ADDC    W9,W10,W10
008D4:  ADDC    #0,W11
008D6:  MUL.UU  W7,W0,W8
008D8:  ADD     W8,W12,W12
008DA:  ADDC    W9,W10,W10
008DC:  ADDC    #0,W11
008DE:  MOV     W12,W0
008E0:  CLR     W12
008E2:  MUL.UU  W5,W3,W8
008E4:  ADD     W8,W10,W10
008E6:  ADDC    W9,W11,W11
008E8:  ADDC    #0,W12
008EA:  MUL.UU  W6,W2,W8
008EC:  ADD     W8,W10,W10
008EE:  ADDC    W9,W11,W11
008F0:  ADDC    #0,W12
008F2:  MUL.UU  W6,W3,W8
008F4:  ADD     W8,W11,W11
008F6:  ADDC    W9,W12,W12
008F8:  MUL.UU  W7,W1,W8
008FA:  ADD     W8,W10,W10
008FC:  ADDC    W9,W11,W11
008FE:  ADDC    #0,W12
00900:  MUL.UU  W7,W2,W8
00902:  ADD     W8,W11,W11
00904:  ADDC    W9,W12,W12
00906:  MUL.UU  W7,W3,W8
00908:  ADD     W8,W12,W12
0090A:  MOV     W10,W1
0090C:  MOV     W11,W2
0090E:  MOV     W12,W3
00910:  MOV     #5,W4
00912:  BCLR.B  42.0
00914:  RRC     W3,W3
00916:  RRC     W2,W2
00918:  RRC     W1,W1
0091A:  RRC     W0,W0
0091C:  DEC     W4,W4
0091E:  BRA     NZ,912
00920:  MOV     [--W15],W8
00922:  INC     W8,W8
00924:  IOR      W0,  W1,W6
00926:  BRA     Z,92A
00928:  BRA     92E
0092A:  IOR      W2,  W3,W6
0092C:  BRA     Z,93E
0092E:  BTSC    W3.4
00930:  BRA     93E
00932:  BCLR.B  42.0
00934:  RLC     W0,W0
00936:  RLC     W1,W1
00938:  RLC     W2,W2
0093A:  RLC     W3,W3
0093C:  DEC     W8,W8
0093E:  SL      W8,#4,W8
00940:  BCLR    W3.F
00942:  BTSC    W13.F
00944:  BSET    W3.F
00946:  BCLR    W3.4
00948:  XOR     W8,W3,W3
0094A:  BRA     952
0094C:  MUL.UU  W0,#0,W0
0094E:  MUL.UU  W0,#0,W2
00950:  BRA     952
00952:  MOV     #1A,W8
00954:  REPEAT  #4
00956:  MOV     [--W15],[W8--]
00958:  MOV     [--W15],W8
0095A:  RETURN  
0095C:  MOV     W5,[W15++]
0095E:  MOV     #C,W5
00960:  REPEAT  #3
00962:  MOV     [W5++],[W15++]
00964:  MOV     W0,W4
00966:  MOV     W1,W5
00968:  MOV     W2,W6
0096A:  MOV     W3,W7
0096C:  CLR     W0
0096E:  CLR     W1
00970:  CLR     W2
00972:  CLR     W3
00974:  BCLR    W8.0
00976:  BTSS    W7.F
00978:  BRA     98A
0097A:  BSET    W8.0
0097C:  COM     W7,W7
0097E:  COM     W6,W6
00980:  COM     W5,W5
00982:  NEG     W4,W4
00984:  ADDC    W5,#0,W5
00986:  ADDC    W6,#0,W6
00988:  ADDC    W7,#0,W7
0098A:  IOR      W4,  W5,W9
0098C:  BRA     NZ,992
0098E:  IOR      W6,  W7,W9
00990:  BRA     Z,9BC
00992:  MOV     #473,W9
00994:  BTSC    W3.4
00996:  BRA     9AE
00998:  BCLR.B  42.0
0099A:  RLC     W4,W4
0099C:  RLC     W5,W5
0099E:  RLC     W6,W6
009A0:  RLC     W7,W7
009A2:  RLC     W0,W0
009A4:  RLC     W1,W1
009A6:  RLC     W2,W2
009A8:  RLC     W3,W3
009AA:  DEC     W9,W9
009AC:  BRA     NZ,994
009AE:  SL      W9,#4,W9
009B0:  BCLR.B  42.0
009B2:  BCLR    W9.F
009B4:  BCLR    W3.4
009B6:  XOR     W9,W3,W3
009B8:  BTSC    W8.0
009BA:  BSET    W3.F
009BC:  MOV     #12,W5
009BE:  REPEAT  #3
009C0:  MOV     [--W15],[W5--]
009C2:  MOV     [--W15],W5
009C4:  RETURN  
009C6:  MOV     W8,[W15++]
009C8:  MOV     #12,W8
009CA:  REPEAT  #4
009CC:  MOV     [W8++],[W15++]
009CE:  XOR     W3,W7,W13
009D0:  MOV     W3,W8
009D2:  MOV     W7,W9
009D4:  MOV     #7FF,W10
009D6:  BCLR.B  42.0
009D8:  BCLR.B  42.1
009DA:  ASR     W8,#4,W8
009DC:  AND     W10,W8,W8
009DE:  CP0     W8
009E0:  BRA     Z,ABA
009E2:  BCLR.B  42.0
009E4:  BCLR.B  42.1
009E6:  ASR     W9,#4,W9
009E8:  AND     W10,W9,W9
009EA:  CP0     W9
009EC:  BRA     Z,ABA
009EE:  CLR     W10
009F0:  SUB     W8,W9,W12
009F2:  BRA     NC,9FA
009F4:  ADD     #3FF,W12
009F6:  BRA     C,ABA
009F8:  BRA     A02
009FA:  MOV     #401,W11
009FC:  SUB     W12,W11,W12
009FE:  BRA     NC,ABA
00A00:  BRA     Z,ABA
00A02:  CLR     W8
00A04:  CLR     W9
00A06:  CLR     W10
00A08:  CLR     W11
00A0A:  AND     #1F,W3
00A0C:  BSET    W3.4
00A0E:  AND     #1F,W7
00A10:  BSET    W7.4
00A12:  MOV     W12,[W15++]
00A14:  MOV     #36,W12
00A16:  SUB     W0,W4,W0
00A18:  SUBB    W1,W5,W1
00A1A:  SUBB    W2,W6,W2
00A1C:  SUBB    W3,W7,W3
00A1E:  BRA     N,A24
00A20:  BRA     C,A2E
00A22:  BRA     NZ,A30
00A24:  ADD     W0,W4,W0
00A26:  ADDC    W1,W5,W1
00A28:  ADDC    W2,W6,W2
00A2A:  ADDC    W3,W7,W3
00A2C:  BRA     A30
00A2E:  BSET    W8.0
00A30:  DEC     W12,W12
00A32:  BRA     Z,A4A
00A34:  BCLR.B  42.0
00A36:  RLC     W0,W0
00A38:  RLC     W1,W1
00A3A:  RLC     W2,W2
00A3C:  RLC     W3,W3
00A3E:  BCLR.B  42.0
00A40:  RLC     W8,W8
00A42:  RLC     W9,W9
00A44:  RLC     W10,W10
00A46:  RLC     W11,W11
00A48:  BRA     A16
00A4A:  MOV     [--W15],W12
00A4C:  BTSC    W11.5
00A4E:  BRA     A52
00A50:  BRA     A5E
00A52:  BCLR.B  42.0
00A54:  RRC     W11,W11
00A56:  RRC     W10,W10
00A58:  RRC     W9,W9
00A5A:  RRC     W8,W8
00A5C:  BRA     A64
00A5E:  DEC     W12,W12
00A60:  BCLR.B  42.0
00A62:  BRA     Z,ABA
00A64:  BTSC.B  42.0
00A66:  BRA     A7A
00A68:  RLC     W0,W0
00A6A:  RLC     W1,W1
00A6C:  RLC     W2,W2
00A6E:  RLC     W3,W3
00A70:  SUB     W0,W4,W4
00A72:  SUBB    W1,W5,W5
00A74:  SUBB    W2,W6,W6
00A76:  SUBB    W3,W7,W7
00A78:  BRA     NC,AA4
00A7A:  INC     W8,W8
00A7C:  BRA     NZ,AA4
00A7E:  INC     W9,W9
00A80:  BRA     NZ,AA4
00A82:  INC     W10,W10
00A84:  BRA     NZ,AA4
00A86:  INC     W11,W11
00A88:  BRA     NZ,AA4
00A8A:  INC     W12,W12
00A8C:  BRA     Z,ABA
00A8E:  BRA     AA4
00A90:  DEC     W12,W12
00A92:  BRA     Z,ABA
00A94:  BTSC    W11.4
00A96:  BRA     AA4
00A98:  BCLR.B  42.0
00A9A:  RLC     W8,W8
00A9C:  RLC     W9,W9
00A9E:  RLC     W10,W10
00AA0:  RLC     W11,W11
00AA2:  BRA     A94
00AA4:  SL      W12,#4,W12
00AA6:  BCLR.B  42.0
00AA8:  BCLR    W12.F
00AAA:  BTSC    W13.F
00AAC:  BSET    W12.F
00AAE:  BCLR    W11.4
00AB0:  XOR     W12,W11,W3
00AB2:  MOV     W10,W2
00AB4:  MOV     W9,W1
00AB6:  MOV     W8,W0
00AB8:  BRA     AC4
00ABA:  MOV     #0,W0
00ABC:  MOV     #0,W1
00ABE:  MOV     #0,W2
00AC0:  MOV     #0,W3
00AC2:  BRA     AC4
00AC4:  MOV     #1A,W8
00AC6:  REPEAT  #4
00AC8:  MOV     [--W15],[W8--]
00ACA:  MOV     [--W15],W8
00ACC:  RETURN  
00ACE:  MOV     W5,[W15++]
00AD0:  MOV     W6,[W15++]
00AD2:  MOV     W3,W4
00AD4:  MOV     W3,W6
00AD6:  BCLR.B  42.0
00AD8:  ASR     W4,#4,W4
00ADA:  MOV     #7FF,W5
00ADC:  AND     W5,W4,W4
00ADE:  BRA     NZ,AE6
00AE0:  MUL.UU  W0,#0,W0
00AE2:  CLR     W2
00AE4:  BRA     B0C
00AE6:  SUB     #380,W4
00AE8:  AND     #F,W3
00AEA:  MOV     #3,W7
00AEC:  BCLR.B  42.0
00AEE:  RLC     W0,W0
00AF0:  RLC     W1,W1
00AF2:  RLC     W2,W2
00AF4:  RLC     W3,W3
00AF6:  DEC     W7,W7
00AF8:  BRA     NZ,AEC
00AFA:  MOV     W1,W0
00AFC:  MOV     W2,W1
00AFE:  BCLR    W3.7
00B00:  SWAP    W4
00B02:  BCLR.B  42.0
00B04:  RRC     W4,W4
00B06:  BTSC    W6.F
00B08:  BSET    W4.F
00B0A:  XOR     W4,W3,W2
00B0C:  MOV     [--W15],W6
00B0E:  MOV     [--W15],W5
00B10:  RETURN  
00B12:  MOV     W5,[W15++]
00B14:  MOV     #C,W5
00B16:  REPEAT  #4
00B18:  MOV     [W5++],[W15++]
00B1A:  MOV     W0,W4
00B1C:  MOV     W1,W5
00B1E:  MOV     W3,W7
00B20:  MOV     W2,W6
00B22:  BCLR.B  42.0
00B24:  BCLR.B  42.1
00B26:  RLC     W1,W1
00B28:  SWAP    W1
00B2A:  AND     #FF,W1
00B2C:  CP0     W1
00B2E:  BRA     Z,BC6
00B30:  BCLR.B  42.0
00B32:  BCLR.B  42.1
00B34:  RLC     W3,W3
00B36:  SWAP    W3
00B38:  AND     #FF,W3
00B3A:  CP0     W3
00B3C:  BRA     Z,BC6
00B3E:  ZE      W0,W0
00B40:  ADD.B   W3L,W1L,W0L
00B42:  BRA     C,B4C
00B44:  SUB     #7F,W0
00B46:  BRA     Z,BC6
00B48:  BRA     NC,BC6
00B4A:  BRA     B50
00B4C:  ADD.B   #81,W0L
00B4E:  BRA     C,BC6
00B50:  XOR     W5,W7,W10
00B52:  BCLR.B  42.0
00B54:  BCLR.B  42.1
00B56:  AND     #FF,W5
00B58:  BSET    W5.7
00B5A:  BCLR.B  42.0
00B5C:  AND     #FF,W7
00B5E:  BSET    W7.7
00B60:  MUL.UU  W4,W6,W2
00B62:  MUL.UU  W5,W6,W8
00B64:  ADDC    W8,W3,W3
00B66:  MOV     W9,W1
00B68:  BTSC.B  42.0
00B6A:  INC     W1,W1
00B6C:  BCLR.B  42.0
00B6E:  MUL.UU  W7,W4,W8
00B70:  ADDC    W8,W3,W3
00B72:  ADDC    W9,W1,W1
00B74:  MUL.UU  W5,W7,W8
00B76:  ADDC    W8,W1,W1
00B78:  INC     W0,W0
00B7A:  CP0     W1
00B7C:  BTSC.B  42.1
00B7E:  BRA     B82
00B80:  BRA     B88
00B82:  CP0     W3
00B84:  BTSC.B  42.1
00B86:  BRA     B92
00B88:  BTSC    W1.F
00B8A:  BRA     B92
00B8C:  RLC     W3,W3
00B8E:  RLC     W1,W1
00B90:  DEC     W0,W0
00B92:  MOV     W1,W2
00B94:  BCLR.B  42.0
00B96:  BTSS    W3.7
00B98:  BRA     BAC
00B9A:  MOV     #FF00,W7
00B9C:  AND     W3,W7,W3
00B9E:  ADD     #100,W3
00BA0:  ADDC    W2,#0,W2
00BA2:  CP0     W2
00BA4:  BRA     NZ,BAC
00BA6:  CP0     W3
00BA8:  BRA     NZ,BAC
00BAA:  INC     W0,W0
00BAC:  SWAP    W0
00BAE:  BCLR.B  42.0
00BB0:  BCLR.B  42.1
00BB2:  RRC     W0,W1
00BB4:  BTSC    W10.F
00BB6:  BSET    W1.F
00BB8:  BCLR    W2.F
00BBA:  SWAP    W2
00BBC:  XOR.B   W2L,W1L,W1L
00BBE:  SWAP    W3
00BC0:  MOV.B   W3L,W2L
00BC2:  MOV     W2,W0
00BC4:  BRA     BCC
00BC6:  MOV     #0,W0
00BC8:  MOV     #0,W1
00BCA:  BRA     BCC
00BCC:  MOV     #14,W5
00BCE:  REPEAT  #4
00BD0:  MOV     [--W15],[W5--]
00BD2:  MOV     [--W15],W5
00BD4:  RETURN  
00BD6:  MOV     W5,[W15++]
00BD8:  MOV     W1,W5
00BDA:  MOV     W0,W2
00BDC:  MOV     #B6,W4
00BDE:  RLC     W1,W1
00BE0:  SWAP    W1
00BE2:  AND     #FF,W1
00BE4:  SUB.B   W4L,W1L,W4L
00BE6:  MOV.B   W5L,W3L
00BE8:  BSET    W3.7
00BEA:  AND     #FF,W3
00BEC:  CLR     W0
00BEE:  CLR     W1
00BF0:  CP      W4,#18
00BF2:  BRA     N,C12
00BF4:  BCLR.B  42.0
00BF6:  RRC     W3,W3
00BF8:  RRC     W2,W2
00BFA:  RRC     W1,W1
00BFC:  RRC     W0,W0
00BFE:  DEC     W4,W4
00C00:  BRA     NZ,BF4
00C02:  BTSS    W5.F
00C04:  BRA     C12
00C06:  NEG     W0,W0
00C08:  BRA     Z,C0E
00C0A:  COM     W1,W1
00C0C:  BRA     C12
00C0E:  NEG     W1,W1
00C10:  BRA     C12
00C12:  MOV     [--W15],W5
00C14:  RETURN  
*
00E6E:  MOV     W6,[W15++]
00E70:  MOV     W7,[W15++]
00E72:  MOV     W8,[W15++]
00E74:  MOV     W9,[W15++]
00E76:  CLR     W4
00E78:  CLR     W5
00E7A:  CLR     W6
00E7C:  CLR     W7
00E7E:  XOR     W2,W3,W8
00E80:  BRA     Z,EA4
00E82:  MOV     #20,W8
00E84:  BCLR.B  42.0
00E86:  RLC     W0,W0
00E88:  RLC     W1,W1
00E8A:  RLC     W4,W4
00E8C:  RLC     W5,W5
00E8E:  CP      W5,W3
00E90:  BRA     NZ,E94
00E92:  CPB     W4,W2
00E94:  BRA     NC,E9C
00E96:  SUB     W4,W2,W4
00E98:  SUBB    W5,W3,W5
00E9A:  BSET.B  42.0
00E9C:  RLC     W6,W6
00E9E:  RLC     W7,W7
00EA0:  DEC     W8,W8
00EA2:  BRA     NZ,E84
00EA4:  MOV     W7,W1
00EA6:  MOV     W6,W0
00EA8:  MOV     [--W15],W9
00EAA:  MOV     [--W15],W8
00EAC:  MOV     [--W15],W7
00EAE:  MOV     [--W15],W6
00EB0:  RETURN  
00EB2:  MOV     W5,[W15++]
00EB4:  MOV     #C,W5
00EB6:  REPEAT  #7
00EB8:  MOV     [W5++],[W15++]
00EBA:  BTSS    W1.F
00EBC:  BRA     ECC
00EBE:  NEG     W0,W0
00EC0:  BRA     Z,EC4
00EC2:  BRA     NZ,EC8
00EC4:  NEG     W1,W1
00EC6:  BRA     ECA
00EC8:  COM     W1,W1
00ECA:  BSET    W4.8
00ECC:  CLR     W5
00ECE:  MOV     W0,W6
00ED0:  MOV     W1,W7
00ED2:  MOV     W4,W12
00ED4:  BCLR    W4.F
00ED6:  CP0.B   W4L
00ED8:  BRA     NZ,EDC
00EDA:  BRA     F10
00EDC:  SUB.B   W4L,#B,W5L
00EDE:  BRA     NC,F10
00EE0:  SUB.B   W4L,W5L,W4L
00EE2:  BTSS    W12.F
00EE4:  BRA     EFC
00EE6:  BTSS    W4.8
00EE8:  BRA     EF8
00EEA:  MOV     #2D,W0
00EEC:  BTSC.B  233.1
00EEE:  BRA     EEC
00EF0:  MOV     W0,234
00EF2:  BCLR    W4.8
00EF4:  DEC     W5,W5
00EF6:  BRA     N,F10
00EF8:  MOV     #30,W0
00EFA:  BRA     EFE
00EFC:  MOV     #20,W0
00EFE:  MOV     W0,[W15++]
00F00:  BTSC.B  233.1
00F02:  BRA     F00
00F04:  MOV     W0,234
00F06:  MOV     [--W15],W0
00F08:  DEC     W5,W5
00F0A:  BRA     NN,EFE
00F0C:  BTSC    W4.8
00F0E:  DEC.B   W4L,W4L
00F10:  MOV     #E,W8
00F12:  MOV     #0,W9
00F14:  LNK     #10
00F16:  MOV     W12,[W14+W8]
00F18:  DEC2    W8,W8
00F1A:  BRA     NN,F16
00F1C:  MOV     W4,W5
00F1E:  MOV     #A,W4
00F20:  BTSC    W5.8
00F22:  INC     W4,W4
00F24:  BSET    W5.E
00F26:  BTSC    W12.F
00F28:  BSET    W5.F
00F2A:  CP0.B   W5L
00F2C:  BRA     Z,F30
00F2E:  DEC.B   W5L,W5L
00F30:  MOV     W4,[W14]
00F32:  MOV     W5,[W14+#2]
00F34:  MOV     W6,W0
00F36:  MOV     W7,W1
00F38:  MOV     #CA00,W2
00F3A:  MOV     #3B9A,W3
00F3C:  MOV     #2710,W8
00F3E:  BCLR    W13.F
00F40:  BCLR.B  43.0
00F42:  CALL    E6E
00F46:  BTG     W13.F
00F48:  BTSC    W13.F
00F4A:  BRA     F5A
00F4C:  MOV     W0,[W14+#8]
00F4E:  MOV     W1,[W14+#A]
00F50:  MOV     W0,W2
00F52:  MOV     W1,W3
00F54:  MOV     [W14+#4],W0
00F56:  MOV     [W14+#6],W1
00F58:  BRA     F40
00F5A:  MOV     W2,[W14+#8]
00F5C:  MOV     W3,[W14+#A]
00F5E:  MOV     W4,[W14+#4]
00F60:  MOV     W5,[W14+#6]
00F62:  MOV     [W14],W4
00F64:  MOV     [W14+#2],W5
00F66:  MOV     #30,W6
00F68:  CP0     W0
00F6A:  BRA     NZ,F8E
00F6C:  BTSS    W5.E
00F6E:  BRA     F92
00F70:  DEC     W4,W4
00F72:  MOV     W4,[W14]
00F74:  CP0     W4
00F76:  BRA     Z,F92
00F78:  CP.B    W4L,W5L
00F7A:  BRA     Z,F80
00F7C:  BTSC.B  42.0
00F7E:  BRA     FB0
00F80:  BTSS    W5.F
00F82:  BRA     F8A
00F84:  BTSS    W5.8
00F86:  BRA     FA8
00F88:  BRA     F98
00F8A:  MOV     #20,W6
00F8C:  BRA     FA8
00F8E:  BCLR    W5.E
00F90:  MOV     W5,[W14+#2]
00F92:  MOV     [W14+#2],W5
00F94:  BTSS    W5.8
00F96:  BRA     FA8
00F98:  BCLR    W5.8
00F9A:  MOV     W5,[W14+#2]
00F9C:  MOV     W0,W10
00F9E:  MOV     #2D,W0
00FA0:  BTSC.B  233.1
00FA2:  BRA     FA0
00FA4:  MOV     W0,234
00FA6:  MOV     W10,W0
00FA8:  ADD.B   W6L,W0L,W0L
00FAA:  BTSC.B  233.1
00FAC:  BRA     FAA
00FAE:  MOV     W0,234
00FB0:  MOV     [W14+#8],W0
00FB2:  MOV     [W14+#A],W1
00FB4:  MOV     #A,W2
00FB6:  CLR     W3
00FB8:  CP      W0,#1
00FBA:  BRA     Z,FBE
00FBC:  BRA     F40
00FBE:  ULNK    
00FC0:  MOV     #1A,W5
00FC2:  REPEAT  #7
00FC4:  MOV     [--W15],[W5--]
00FC6:  MOV     [--W15],W5
00FC8:  RETURN  
*
01096:  MOV     W5,[W15++]
01098:  MOV     #C,W5
0109A:  REPEAT  #3
0109C:  MOV     [W5++],[W15++]
0109E:  MOV     W0,W7
010A0:  MOV     W4,W9
010A2:  BCLR    W4.F
010A4:  CP0     W4
010A6:  BRA     NZ,10B4
010A8:  BTSC    W9.F
010AA:  BRA     10B0
010AC:  MOV     #0,W5
010AE:  BRA     10D2
010B0:  MOV     #0,W5
010B2:  BRA     10D2
010B4:  SUB.B   W4L,#6,W5L
010B6:  BRA     NC,10D0
010B8:  MOV     #30,W0
010BA:  BTSS    W9.F
010BC:  MOV     #20,W0
010BE:  MOV     W0,[W15++]
010C0:  BTSC.B  233.1
010C2:  BRA     10C0
010C4:  MOV     W0,234
010C6:  MOV     [--W15],W0
010C8:  DEC     W5,W5
010CA:  BRA     NN,10BE
010CC:  MOV     #5,W5
010CE:  BRA     10D2
010D0:  MOV     W4,W5
010D2:  MOV     #6,W4
010D4:  BSET    W5.E
010D6:  BTSC    W9.F
010D8:  BSET    W5.F
010DA:  MOV     #2710,W8
010DC:  REPEAT  #11
010DE:  DIV.U   W7,W8
010E0:  CALL    1114
010E4:  MOV     W1,W7
010E6:  MOV     #3E8,W8
010E8:  REPEAT  #11
010EA:  DIV.U   W7,W8
010EC:  CALL    1114
010F0:  MOV     W1,W7
010F2:  MOV     #64,W8
010F4:  REPEAT  #11
010F6:  DIV.U   W7,W8
010F8:  CALL    1114
010FC:  MOV     W1,W7
010FE:  MOV     #A,W8
01100:  REPEAT  #11
01102:  DIV.U   W7,W8
01104:  CALL    1114
01108:  MOV     #30,W0
0110A:  ADD.B   W1L,W0L,W0L
0110C:  BTSC.B  233.1
0110E:  BRA     110C
01110:  MOV     W0,234
01112:  BRA     1142
01114:  MOV     #30,W6
01116:  CP0     W0
01118:  BRA     NZ,1136
0111A:  BTSS    W5.E
0111C:  BRA     1138
0111E:  DEC     W4,W4
01120:  CP.B    W4L,W5L
01122:  BRA     Z,1128
01124:  BTSC.B  42.0
01126:  RETURN  
01128:  CP0     W0
0112A:  BRA     NZ,1136
0112C:  BTSS    W5.E
0112E:  BRA     1138
01130:  BTSS    W5.F
01132:  MOV     #20,W6
01134:  BRA     1138
01136:  BCLR    W5.E
01138:  ADD.B   W6L,W0L,W0L
0113A:  BTSC.B  233.1
0113C:  BRA     113A
0113E:  MOV     W0,234
01140:  RETURN  
01142:  MOV     #12,W5
01144:  REPEAT  #3
01146:  MOV     [--W15],[W5--]
01148:  MOV     [--W15],W5
0114A:  RETURN  
....................  
.................... #list 
....................  
....................  
....................  
.................... //#FUSES PROTECT_HIGH            //General Segment Code Protect High Security 
.................... #FUSES WRTB                      //Boot block write protected 
.................... #FUSES CKSFSM                    //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES WDT                       //no Watch Dog Timer 
.................... #FUSES WPOSTS14                  //Watch Dog Timer PreScalar 1:8192 
.................... #FUSES PR_PLL                    //Primary Oscillator with PLL 
.................... #FUSES HS                        //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOWRT                     //Program memory not write protected 
.................... #use delay(clock=40M) 
....................  
.................... #WORD PLLFBD=0x0746 // osc PLL div reg 
....................  
.................... #WORD CLKDIV=0x0744  // osc con reg 
.................... #BIT PLLPOST1=CLKDIV.7 
.................... #BIT PLLPOST0=CLKDIV.6 
.................... #BIT PLLPRE4=CLKDIV.4 
.................... #BIT PLLPRE3=CLKDIV.3 
.................... #BIT PLLPRE2=CLKDIV.2 
.................... #BIT PLLPRE1=CLKDIV.1 
.................... #BIT PLLPRE0=CLKDIV.0 
....................  
.................... #WORD LATA=0x02C4  
.................... #WORD LATB=0x02CA 
.................... #WORD LATD=0x02D6 
.................... #WORD LATF=0x02E2 
.................... #WORD LATG=0x02E8   
.................... #WORD LATC=0x02D0 
....................  
.................... #use spi(spi2, FORCE_HW) 
.................... #use standard_io(B)//(B_outputs=PIN_B1, PIN_B2) 
....................  
.................... #define STATUS 0x00     // ADC1256 Register map 
.................... #define MUX 0x01  
.................... #define ADCON 0x02 
.................... #define DRATE 0x03 
.................... #define IO 0x04 
.................... #define OFCO 0x05 
.................... #define OFC1 0x06 
.................... #define OFC2 0x07 
.................... #define FSCO 0x08 
.................... #define FSC1 0x09 
.................... #define FSC2 0x0A 
.................... #define uV 10000000  // для калибровки  
.................... //#define uV 100000 // по умолчанию 
.................... #define mV 1000 
....................  
.................... #WORD PORTB=0x02C8 
.................... #WORD TRISB=0x02C6 
.................... #BIT  TRB0=TRISB.0 
.................... #BIT  TRB1=TRISB.1 
.................... #BIT  CN1_TRIS=TRISB.5 
.................... #BIT  CN2_TRIS=TRISB.4 
.................... #BIT  CN4_TRIS=TRISB.3 
.................... #BIT  CN3_TRIS=TRISB.2 
.................... #BIT  CN1=PORTB.5 
.................... #BIT  CN4=PORTB.3 
.................... #BIT  CN2=PORTB.4 
.................... #BIT  CN3=PORTB.2 
.................... #BIT  XPORT_RST_n=TRISB.15 
.................... #BIT  Status_LED_TRIS=TRISB.13 
.................... #BIT  TRB14=TRISB.14 
.................... #BIT  XPORT_RST_TRIS=TRISB.15 
.................... #BIT  RB1=LATB.1 
.................... #BIT  RB0=LATB.0 
.................... #BIT  Status_LED=LATB.13 
....................  
.................... #WORD PORTC=0x02CE 
.................... #WORD TRISC=0x02CC 
.................... //#BIT RC13=LATC.13 
.................... //#BIT RC14=LATC.14 
.................... #BIT RC13=PORTC.13 
.................... #BIT RC14=PORTC.14 
.................... #BIT  TRC13=TRISC.13 
.................... #BIT  TRC14=TRISC.14 
.................... #BIT  TRC1=TRISC.1 
.................... #BIT  TRC2=TRISC.2 
.................... #BIT  TRC4=TRISC.4 
.................... //_______________________________________ 
.................... #WORD PORTD=0x02D4 
.................... #WORD TRISD=0x02D2 
.................... #WORD ODCD=0x06D2 
....................  
.................... #BIT  TRD4=TRISD.4 
.................... #BIT  TRD5=TRISD.5 
.................... #BIT  TRD6=TRISD.6 
.................... #BIT  TRD7=TRISD.7 
.................... #BIT  TRD8=TRISD.8 
....................  
.................... #BIT  RD4=LATD.4 
.................... #BIT  RD5=LATD.5 
.................... #BIT  RD6=LATD.6 
.................... #BIT  RD7=LATD.7 
.................... #BIT  RD8=LATD.8 
.................... //_________________________________________________ 
.................... #WORD PORTF=0x02E0 
.................... #WORD TRISF=0x02DE 
.................... #BIT  UART2_RX_TRIS=TRISF.4 
.................... #BIT  UART2_TX_TRIS=TRISF.5 
....................  
.................... #WORD PORTG=0x02E6 
.................... #WORD TRISG=0x02E4 
.................... #BIT RG0=LATG.0 
.................... #BIT RG1=LATG.1 
.................... #BIT LCD_RW=LATG.12 
.................... #BIT LCD_RS=LATG.13 
.................... #BIT LCD_E=LATG.14 
.................... #BIT RG15=LATG.15 
.................... #BIT SCK2=LATG.6 // SPI2 pins 
.................... #BIT SDI2=LATG.7 
.................... #BIT SDO2=LATG.8 
.................... //#BIT SS2=LATG.9 
.................... #BIT SCK2_TRIS=TRISG.6 // SPI2 tris 
.................... #BIT SDI2_TRIS=TRISG.7 
.................... #BIT SDO2_TRIS=TRISG.8 
.................... #BIT TRG0=TRISG.0 
.................... #BIT TRG1=TRISG.1 
.................... #BIT LCD_RW_TRIS=TRISG.12 
.................... #BIT LCD_RS_TRIS=TRISG.13 
.................... #BIT LCD_E_TRIS=TRISG.14 
....................  
.................... //#BIT SS2_TRIS=TRISG.9 
....................  
.................... #define ADC_Dout SDI2 //???? Din ?? 
.................... #define ADC_Din SDO2  //???? Dout ?? 
....................  
.................... #BIT  ADC_RESET_TRIS=TRISD.3 
.................... #BIT  ADC2_RESET_TRIS=TRISD.0 
.................... #BIT  ADC_RESET=LATD.3 
.................... #BIT  ADC2_RESET=LATD.0 
....................  
.................... #BIT  ADC_SYNC_TRIS=TRISD.2 
.................... #BIT  ADC2_SYNC_TRIS=TRISD.11 
.................... #BIT  ADC_SYNC=LATD.2 
.................... #BIT  ADC2_SYNC=LATD.11 
....................  
.................... #BIT  ADC_CS_TRIS =TRISG.9 
.................... #BIT  ADC2_CS_TRIS=TRISD.10 
.................... #BIT  ADC_CS = LATG.9 
.................... #BIT  ADC2_CS= LATD.10 
....................  
.................... #BIT  ADC_DRDY_TRIS = TRISD.1 
.................... #BIT  ADC2_DRDY_TRIS= TRISD.9 
.................... #BIT  ADC_DRDY = PORTD.1 
.................... #BIT  ADC2_DRDY= PORTD.9 
....................  
.................... #WORD U2TXREG = 0x0234  
.................... #WORD U2RXREG = 0x0236 // регистр принимаемых Uart2 данных   
.................... #Word U2STA = 0x0232 
.................... #WORD U2BRG=0x0238 
.................... #WORD U2MODE=0x0230 
.................... #WORD U2STA=0x0232 
.................... #BIT  U2_TRMT  = U2STA.8   // Transmit Shift Register is Empty bit (read-only) 
.................... #BIT  U2_UTXBF = U2STA.9   // Transmit Buffer Full Status bit (read-only) 
.................... #BIT  U2_UTXEN = U2STA.10  // Transmit Enable bit 
....................  
.................... #define FCY      40000000 
.................... #define BAUDRATE 230400                 
.................... #define BRGVAL   ((FCY/BAUDRATE)/16)-1 
....................  
.................... #define CK_FLASH_END       (getenv("PROGRAM_MEMORY")-1)       
.................... #define CK_FLASH_PAGE_SIZE (getenv("FLASH_ERASE_SIZE")/2)  
.................... #define CK_NUM_PAGES (CK_FLASH_END/CK_FLASH_PAGE_SIZE)  
....................  
.................... #define CK_USER_PAGE (CK_FLASH_PAGE_SIZE*(CK_NUM_PAGES-1))  
....................  
.................... #org CK_USER_PAGE,CK_FLASH_END {}  
....................  
....................    typedef unsigned int16 U16; 
....................    typedef unsigned int8 U8; 
....................    typedef unsigned int32 U32; 
....................    typedef signed int32 S32; 
....................    typedef signed int16 S16; 
....................    typedef signed int8 S8; 
....................  
....................  
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #use rs232(UART2,xmit=PIN_F5,rcv=PIN_F4,baud=230400,BRGH1OK,ERRORS,parity=N,bits=8) 
....................   
....................     // коды каналов мультиплексора.. 
....................     U8 Mx_ch_code[9] = {0, 0x76, 0x54, 0x32, 0x10}; 
....................  
....................     U8 PGA; 
....................     U8 PGA_val = 3; // PGA = 8 
....................     U8 Sps_buf=0; 
....................     //S16 ADCaddCoef = 1; 
....................     //float ADCmulCoef = 1; 
....................     
....................    U8 flash_wr_data [] = {0,0,0,0}; // заготовка массива для записи во флэш 
....................    U8 Aver_Wr = 0; 
....................    U8 Sps_Wr = 0; 
....................    U8 CRC_Wr = 0; 
....................    U8 ADC_select = 0; // флаг выбора АЦП: 1ый или 2ой 
....................  
....................    int1 meas_stop_fl = 0; 
....................    int1 reset_fl = 0;    // флаг сброса системы 
....................    int1 stop_fl = 0; 
....................     
....................    U8 NumAver = 1;       // размер усреднения 
....................    U8 ADC_sps_var = 1;   // переменная усреднения данных АЦП  
....................    U8 CRC1=0xFF,CRC2=0xFF, CRC_buf;   // константы EEPROM CRC 
....................    U8 flash_rd_data[4]; // заготовка массива для чтения из флэш 
....................  
....................    //Ma - Moving Average 
....................    S32 Ch_buf[8][128];  // буфер скользящего среднего для к1 
....................    S32 Ch_buf_sum;     // сумма буфера скользящего среднего для к1 
....................  
....................    U8 Ma_buf_index = 0; // индекс элемента скользящ. средн. 
....................    U8 Ma_buf_size = 16;  // РАЗМЕР БУФЕРА!!! 
....................     
....................    U8 RXd_buf[64]; // буфер для приема UART данных  
....................    U8 state; 
....................    U16 tmp=0; 
....................     
....................    static U8 wrptr=0,rdptr=0; 
....................    static U8 RxData[16];  
....................     
.................... #include <ADS1256.h> 
.................... // изменена для версии PoE без дисплея 
.................... // 28.05.15 
....................  
.................... //-------------------- работа с регистрами АЦП ------------------------------// 
....................  
.................... static U8 RdReg(U8 RegName) 
.................... { 
....................    U8 RegValue = 0;  
....................    //1st Command Byte: 0001 rrrr where rrrr is the address of the first register to read. 
....................    //2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to read – 1 
....................    ADC_CS = 0; 
....................    delay_us(1); 
....................    Spi_write2(0x10+RegName); // 1st Command Byte,??????? ?????? 
....................    Spi_write2(0x00); // 1st Command Byte, ?????? ?????? ???? ???? 
....................    delay_us(8); // 50 CLK_IN PEDIODS 
....................    RegValue = Spi_read2(0); 
....................    delay_us(1); 
....................    ADC_CS =1; 
....................    delay_us(1); 
....................    Return RegValue;   
.................... } 
....................  
.................... static void WrReg(U8 RegName,CommandByte) 
*
00434:  MOV     W5,[W15++]
.................... { 
....................    ADC_CS = 0; 
00436:  BCLR.B  2E9.1
....................    ADC2_CS = 0; 
00438:  BCLR.B  2D7.2
....................    delay_us(5); 
0043A:  REPEAT  #62
0043C:  NOP     
....................    Spi_write2(0x50+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written. 
0043E:  MOV     188C,W4
00440:  CLR.B   9
00442:  MOV     #50,W3
00444:  ADD     W3,W4,W5
00446:  BCLR.B  260.6
00448:  BTSS.B  260.0
0044A:  BRA     450
0044C:  MOV.B   268,W0L
0044E:  BRA     448
00450:  PUSH    268
00452:  MOV.B   W5L,[W15-#2]
00454:  POP     268
00456:  BTSS.B  260.0
00458:  BRA     456
....................    delay_us(10); 
0045A:  REPEAT  #C6
0045C:  NOP     
....................    Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1. 
0045E:  BCLR.B  260.6
00460:  BTSS.B  260.0
00462:  BRA     468
00464:  MOV.B   268,W0L
00466:  BRA     460
00468:  CLR.B   268
0046A:  BTSS.B  260.0
0046C:  BRA     46A
....................    delay_us(10); 
0046E:  REPEAT  #C6
00470:  NOP     
....................    Spi_write2(CommandByte); 
00472:  BCLR.B  260.6
00474:  BTSS.B  260.0
00476:  BRA     47C
00478:  MOV.B   268,W0L
0047A:  BRA     474
0047C:  MOV.B   188E,W0L
0047E:  MOV.B   W0L,268
00480:  BTSS.B  260.0
00482:  BRA     480
....................    delay_us(10); 
00484:  REPEAT  #C6
00486:  NOP     
....................    ADC_CS = 1; 
00488:  BSET.B  2E9.1
....................    ADC2_CS = 1; 
0048A:  BSET.B  2D7.2
....................   
....................    delay_us(20); 
0048C:  REPEAT  #18E
0048E:  NOP     
00490:  MOV     [--W15],W5
00492:  RETURN  
.................... } 
.................... //---------------------------------------------------------------------------// 
....................  
.................... //==================== настройка и нинициализация АЦП =======================// 
....................  
.................... static void ADC_sps_set(U8 SPS){ 
....................                                                            
....................    Sps_buf = SPS; 
00494:  MOV.B   188A,W0L
00496:  MOV.B   W0L,813
....................    WrReg(DRATE,SPS);  
00498:  MOV.B   #3,W0L
0049A:  MOV.B   W0L,188C
0049C:  MOV.B   188A,W0L
0049E:  MOV.B   W0L,188E
004A0:  CLR.B   188F
004A2:  CALL    434
....................    delay_us(20); 
004A6:  REPEAT  #18E
004A8:  NOP     
004AA:  RETURN  
....................                   
....................          
.................... } 
....................  
.................... static void ADC_set_PGA(u8 PGA_val){ 
....................    
.................... /* PGA 
.................... 000 = 1 (default) 
.................... 001 = 2 
.................... 010 = 4 
.................... 011 = 8 
.................... 100 = 16 
.................... 101 = 32 
.................... 110 = 64 
.................... 111 = 64*/ 
.................... /**/ 
....................  
.................... // PGA присваевается для расчета  
....................  
....................    switch (PGA_val){ 
004AC:  MOV.B   188A,W0L
004AE:  CLR.B   1
004B0:  XOR     #0,W0
004B2:  BRA     Z,4CE
004B4:  XOR     #1,W0
004B6:  BRA     Z,4E0
004B8:  XOR     #3,W0
004BA:  BRA     Z,4F4
004BC:  XOR     #1,W0
004BE:  BRA     Z,508
004C0:  XOR     #7,W0
004C2:  BRA     Z,51C
004C4:  XOR     #1,W0
004C6:  BRA     Z,530
004C8:  XOR     #3,W0
004CA:  BRA     Z,544
004CC:  BRA     558
....................       case 0: 
....................        WrReg(ADCON,0); 
004CE:  MOV.B   #2,W0L
004D0:  MOV.B   W0L,188C
004D2:  CLR     188E
004D4:  CALL    434
....................        PGA = 1; 
004D8:  MOV.B   #1,W0L
004DA:  MOV.B   W0L,811
....................       break; 
004DC:  GOTO    558
....................        
....................       case 1: 
....................        WrReg(ADCON,1); 
004E0:  MOV.B   #2,W0L
004E2:  MOV.B   W0L,188C
004E4:  MOV     #1,W4
004E6:  MOV     W4,188E
004E8:  CALL    434
....................        PGA = 2; 
004EC:  MOV.B   #2,W0L
004EE:  MOV.B   W0L,811
....................       break; 
004F0:  GOTO    558
....................        
....................       case 2: 
....................        WrReg(ADCON,2); 
004F4:  MOV.B   #2,W0L
004F6:  MOV.B   W0L,188C
004F8:  MOV     #2,W4
004FA:  MOV     W4,188E
004FC:  CALL    434
....................        PGA = 4; 
00500:  MOV.B   #4,W0L
00502:  MOV.B   W0L,811
....................       break; 
00504:  GOTO    558
....................        
....................       case 3: 
....................        WrReg(ADCON,3); 
00508:  MOV.B   #2,W0L
0050A:  MOV.B   W0L,188C
0050C:  MOV     #3,W4
0050E:  MOV     W4,188E
00510:  CALL    434
....................        PGA = 8; 
00514:  MOV.B   #8,W0L
00516:  MOV.B   W0L,811
....................       break; 
00518:  GOTO    558
....................        
....................       case 4: 
....................        WrReg(ADCON,4); 
0051C:  MOV.B   #2,W0L
0051E:  MOV.B   W0L,188C
00520:  MOV     #4,W4
00522:  MOV     W4,188E
00524:  CALL    434
....................        PGA = 16; 
00528:  MOV.B   #10,W0L
0052A:  MOV.B   W0L,811
....................       break; 
0052C:  GOTO    558
....................        
....................       case 5: 
....................        WrReg(ADCON,5); 
00530:  MOV.B   #2,W0L
00532:  MOV.B   W0L,188C
00534:  MOV     #5,W4
00536:  MOV     W4,188E
00538:  CALL    434
....................        PGA = 32; 
0053C:  MOV.B   #20,W0L
0053E:  MOV.B   W0L,811
....................       break; 
00540:  GOTO    558
....................        
....................       case 6: 
....................        WrReg(ADCON,6); 
00544:  MOV.B   #2,W0L
00546:  MOV.B   W0L,188C
00548:  MOV     #6,W4
0054A:  MOV     W4,188E
0054C:  CALL    434
....................        PGA = 64; 
00550:  MOV.B   #40,W0L
00552:  MOV.B   W0L,811
....................       break;  
00554:  GOTO    558
....................    } 
....................    delay_us(20); 
00558:  REPEAT  #18E
0055A:  NOP     
0055C:  RETURN  
.................... } 
....................  
.................... static void ADC_SelfCal(){ 
0055E:  MOV     W5,[W15++]
00560:  MOV     W6,[W15++]
....................                       
....................    ADC_CS = 0; 
00562:  BCLR.B  2E9.1
....................    ADC2_CS = 0; 
00564:  BCLR.B  2D7.2
....................    delay_us(1); 
00566:  REPEAT  #12
00568:  NOP     
....................     
....................    Spi_write2(0xF0); 
0056A:  BCLR.B  260.6
0056C:  BTSS.B  260.0
0056E:  BRA     574
00570:  MOV.B   268,W0L
00572:  BRA     56C
00574:  MOV.B   #F0,W0L
00576:  MOV.B   W0L,268
00578:  BTSS.B  260.0
0057A:  BRA     578
....................    delay_us(1); 
0057C:  REPEAT  #12
0057E:  NOP     
....................     
....................    ADC_CS = 1; 
00580:  BSET.B  2E9.1
....................    ADC2_CS = 1; 
00582:  BSET.B  2D7.2
....................     
....................    While(ADC_DRDY | ADC2_DRDY) { }   // ждем готовности обоих АЦП 
00584:  CLR     W0
00586:  BTSC.B  2D4.1
00588:  INC     W0,W0
0058A:  MOV.B   W0L,W6L
0058C:  CLR     W0
0058E:  BTSC.B  2D5.1
00590:  INC     W0,W0
00592:  IOR.B    W6L,  W0L,W0L
00594:  CP0.B   W0L
00596:  BRA     Z,59C
00598:  GOTO    584
0059C:  MOV     [--W15],W6
0059E:  MOV     [--W15],W5
005A0:  RETURN  
....................      
....................    /* 
....................    Switch (Sps_buf) {      
....................      
....................       case 0xF0:    
....................        delay_us(220);         
....................         break;                       
....................        
....................       case 0xE0: 
....................        delay_us(255);  
....................         break; 
....................          
....................       case 0xD0: 
....................        delay_us(315);  
....................         break; 
....................          
....................       case 0xC0: 
....................        delay_us(445);  
....................         break; 
....................          
....................       case 0xB0: 
....................        delay_us(685);  
....................         break; 
....................          
....................       case 0xA1: 
....................        delay_ms(1); 
....................        delay_us(185);                
....................         break;       
....................          
....................       case 0x92: 
....................        delay_ms(5); 
....................         break; 
....................          
....................       case 0x82: 
....................        delay_ms(10); 
....................        delay_us(200); 
....................         break; 
....................                     
....................       case 0x63: 
....................        delay_ms(21);  
....................         break; 
....................          
....................       case 0x43: 
....................        delay_ms(41);  
....................         break; 
....................          
....................       case 0x23: 
....................        delay_ms(101);  
....................         break;          
....................              
....................       case 0x13: 
....................        delay_ms(201);  
....................         break;                           
....................      } 
....................      */ 
.................... } 
....................  
.................... static void ADC_init(){ 
....................     
....................   WrReg(STATUS,2);   // вкл. входной буфер 
005A2:  CLR.B   188C
005A4:  MOV     #2,W4
005A6:  MOV     W4,188E
005A8:  CALL    434
....................   delay_us(20); 
005AC:  REPEAT  #18E
005AE:  NOP     
....................  
....................    if(ADC_sps_var>8)  ADC_sps_var = 8; 
005B0:  MOV     81E,W4
005B2:  CP.B    W4L,#8
005B4:  BRA     LEU,5BA
005B6:  MOV.B   #8,W0L
005B8:  MOV.B   W0L,81E
....................    // установка sps 
....................    switch (ADC_sps_var){                // передача величины скорости измерений АЦП  
005BA:  MOV.B   81E,W0L
005BC:  CLR.B   1
005BE:  XOR     #0,W0
005C0:  BRA     Z,5E4
005C2:  XOR     #1,W0
005C4:  BRA     Z,5F0
005C6:  XOR     #3,W0
005C8:  BRA     Z,5FC
005CA:  XOR     #1,W0
005CC:  BRA     Z,608
005CE:  XOR     #7,W0
005D0:  BRA     Z,614
005D2:  XOR     #1,W0
005D4:  BRA     Z,620
005D6:  XOR     #3,W0
005D8:  BRA     Z,62C
005DA:  XOR     #1,W0
005DC:  BRA     Z,638
005DE:  XOR     #F,W0
005E0:  BRA     Z,644
005E2:  BRA     650
....................      
....................       case 0: ADC_sps_set(0x03);  break; // 2,5   sps 
005E4:  MOV.B   #3,W0L
005E6:  MOV.B   W0L,188A
005E8:  CALL    494
005EC:  GOTO    650
....................       case 1: ADC_sps_set(0x13);  break; // 5   sps 
005F0:  MOV.B   #13,W0L
005F2:  MOV.B   W0L,188A
005F4:  CALL    494
005F8:  GOTO    650
....................       case 2: ADC_sps_set(0x23);  break; // 10   sps 
005FC:  MOV.B   #23,W0L
005FE:  MOV.B   W0L,188A
00600:  CALL    494
00604:  GOTO    650
....................       case 3: ADC_sps_set(0x43);  break; // 25   sps 
00608:  MOV.B   #43,W0L
0060A:  MOV.B   W0L,188A
0060C:  CALL    494
00610:  GOTO    650
....................       case 4: ADC_sps_set(0x63);  break; // 50   sps 
00614:  MOV.B   #63,W0L
00616:  MOV.B   W0L,188A
00618:  CALL    494
0061C:  GOTO    650
....................       case 5: ADC_sps_set(0x82);  break; // 100  sps 
00620:  MOV.B   #82,W0L
00622:  MOV.B   W0L,188A
00624:  CALL    494
00628:  GOTO    650
....................       case 6: ADC_sps_set(0x91);  break; // 500  sps 
0062C:  MOV.B   #91,W0L
0062E:  MOV.B   W0L,188A
00630:  CALL    494
00634:  GOTO    650
....................       case 7: ADC_sps_set(0xA1);  break; // 1000 sps 
00638:  MOV.B   #A1,W0L
0063A:  MOV.B   W0L,188A
0063C:  CALL    494
00640:  GOTO    650
....................       case 8: ADC_sps_set(0xC0);  break; // 3750 sps 
00644:  MOV.B   #C0,W0L
00646:  MOV.B   W0L,188A
00648:  CALL    494
0064C:  GOTO    650
....................       } 
....................        
....................    ADC_set_PGA(PGA_val);    // Уст. PGA 
00650:  MOV.B   812,W0L
00652:  MOV.B   W0L,188A
00654:  CALL    4AC
....................    ADC_SelfCal();      // Автокалибровка обоих АЦП  
00658:  CALL    55E
0065C:  RETURN  
.................... } 
.................... //===========================================================================// 
....................  
....................  
.................... //---------------------- уст. каналов и чтение АЦП --------------------------// 
....................  
.................... static void SYNC_ADC(U8 command) 
....................   { /// синхронизация АЦП 
....................    
....................    //command 0 - не выбран ни один АЦП 
....................    //command 1 - выбран АЦП 1 
....................    //command 2 - выбран АЦП 2 
....................     
....................    switch(command) 
*
006EE:  MOV.B   188A,W0L
006F0:  CLR.B   1
006F2:  XOR     #0,W0
006F4:  BRA     Z,700
006F6:  XOR     #1,W0
006F8:  BRA     Z,708
006FA:  XOR     #3,W0
006FC:  BRA     Z,714
006FE:  BRA     720
....................    { 
....................          case 0:      
....................             ADC_SYNC = 1;  
00700:  BSET.B  2D6.2
....................             ADC2_SYNC = 1; 
00702:  BSET.B  2D7.3
....................          break; 
00704:  GOTO    720
....................           
....................          case 1:  
....................             ADC_SYNC = 0;  
00708:  BCLR.B  2D6.2
....................             delay_us(20); 
0070A:  REPEAT  #18E
0070C:  NOP     
....................             ADC_SYNC = 1; 
0070E:  BSET.B  2D6.2
....................          break; 
00710:  GOTO    720
....................           
....................          case 2:  
....................             ADC2_SYNC = 0;  
00714:  BCLR.B  2D7.3
....................             delay_us(20); 
00716:  REPEAT  #18E
00718:  NOP     
....................             ADC2_SYNC = 1;  
0071A:  BSET.B  2D7.3
....................          break; 
0071C:  GOTO    720
....................    } 
00720:  RETURN  
....................   } 
....................  
.................... static void ADC_select(U8 command) 
....................   { /// выбор АЦП 
....................    
....................    //command 0 - не выбран ни один АЦП 
....................    //command 1 - выбран АЦП 1 
....................    //command 2 - выбран АЦП 2 
....................     
....................    switch(command) 
*
0065E:  MOV.B   18AE,W0L
00660:  CLR.B   1
00662:  XOR     #0,W0
00664:  BRA     Z,670
00666:  XOR     #1,W0
00668:  BRA     Z,678
0066A:  XOR     #3,W0
0066C:  BRA     Z,680
0066E:  BRA     688
....................    { 
....................          case 0: ADC_CS = 1; ADC2_CS = 1; break; 
00670:  BSET.B  2E9.1
00672:  BSET.B  2D7.2
00674:  GOTO    688
....................          case 1: ADC_CS = 0; ADC2_CS = 1; break; 
00678:  BCLR.B  2E9.1
0067A:  BSET.B  2D7.2
0067C:  GOTO    688
....................          case 2: ADC_CS = 1; ADC2_CS = 0; break; 
00680:  BSET.B  2E9.1
00682:  BCLR.B  2D7.2
00684:  GOTO    688
....................    } 
00688:  RETURN  
....................   } 
....................  
.................... static void ADC_setCh(U8 Ch_Number, U8 ADC_number){ 
0068A:  MOV     W5,[W15++]
....................  
....................  // уст. каналоа АЦП 
....................  // 1 канал пользователя - 4 канал АЦП по факту (13(+) и 12(-) ножки) и тд. 
....................   
....................   ADC_select(ADC_number); // выбор АЦП 
0068C:  MOV.B   188B,W0L
0068E:  MOV.B   W0L,18AE
00690:  CALL    65E
....................   delay_us(2); 
00694:  REPEAT  #26
00696:  NOP     
....................   
....................   Spi_write2(0x50+MUX);  // уст. канал АЦП    
00698:  BCLR.B  260.6
0069A:  BTSS.B  260.0
0069C:  BRA     6A2
0069E:  MOV.B   268,W0L
006A0:  BRA     69A
006A2:  MOV.B   #51,W0L
006A4:  MOV.B   W0L,268
006A6:  BTSS.B  260.0
006A8:  BRA     6A6
....................   delay_us(10); 
006AA:  REPEAT  #C6
006AC:  NOP     
....................   Spi_write2(0);          
006AE:  BCLR.B  260.6
006B0:  BTSS.B  260.0
006B2:  BRA     6B8
006B4:  MOV.B   268,W0L
006B6:  BRA     6B0
006B8:  CLR.B   268
006BA:  BTSS.B  260.0
006BC:  BRA     6BA
....................   delay_us(10); 
006BE:  REPEAT  #C6
006C0:  NOP     
....................   Spi_write2(Mx_ch_code[Ch_Number]); 
006C2:  MOV     188A,W4
006C4:  CLR.B   9
006C6:  MOV     #808,W3
006C8:  ADD     W4,W3,W0
006CA:  MOV.B   [W0],W5L
006CC:  BCLR.B  260.6
006CE:  BTSS.B  260.0
006D0:  BRA     6D6
006D2:  MOV.B   268,W0L
006D4:  BRA     6CE
006D6:  PUSH    268
006D8:  MOV.B   W5L,[W15-#2]
006DA:  POP     268
006DC:  BTSS.B  260.0
006DE:  BRA     6DC
....................    
....................   ADC_select(0); 
006E0:  CLR.B   18AE
006E2:  CALL    65E
....................   delay_us(20);   
006E6:  REPEAT  #18E
006E8:  NOP     
006EA:  MOV     [--W15],W5
006EC:  RETURN  
.................... } 
....................  
.................... static S32 ADC_read(U8 ADC_number) 
*
00C16:  MOV     W5,[W15++]
00C18:  MOV     #C,W5
00C1A:  REPEAT  #4
00C1C:  MOV     [W5++],[W15++]
....................   { 
....................    
....................   ADC_select(ADC_number); // выбор АЦП 
00C1E:  MOV.B   1896,W0L
00C20:  MOV.B   W0L,18AE
00C22:  CALL    65E
....................    
....................   S32 ADC_RByte1=0;  // ст. байт данных АЦП 
....................   S32 ADC_RByte2=0;  // ср. байт данных АЦП 
....................   S32 ADC_RByte3=0;  // мл. байт данных АЦП 
....................    
....................   S32 ADC_RByte_Sum; // суммарные отсчеты АЦП - 24 бита 
....................    
....................   float Vin;         // измеренное напряжение  
00C26:  CLR     1898
00C28:  CLR     189A
00C2A:  CLR     189C
00C2C:  CLR     189E
00C2E:  CLR     18A0
00C30:  CLR     18A2
....................  
....................   Spi_write2(0x01);        // команда чтения Rdata 
00C32:  BCLR.B  260.6
00C34:  BTSS.B  260.0
00C36:  BRA     C3C
00C38:  MOV.B   268,W0L
00C3A:  BRA     C34
00C3C:  MOV.B   #1,W0L
00C3E:  MOV.B   W0L,268
00C40:  BTSS.B  260.0
00C42:  BRA     C40
....................   delay_us(20); 
00C44:  REPEAT  #18E
00C46:  NOP     
....................   ADC_Rbyte1 = Spi_read2(0);   // чтение 
00C48:  BCLR.B  260.6
00C4A:  BTSS.B  260.0
00C4C:  BRA     C52
00C4E:  MOV.B   268,W0L
00C50:  BRA     C4A
00C52:  CLR.B   268
00C54:  BTSS.B  260.0
00C56:  BRA     C54
00C58:  MOV.B   268,W0L
00C5A:  CLR.B   1
00C5C:  MOV     #0,W1
00C5E:  MOV     W0,1898
00C60:  MOV     W1,189A
....................   ADC_Rbyte2 = Spi_read2(0); 
00C62:  BCLR.B  260.6
00C64:  BTSS.B  260.0
00C66:  BRA     C6C
00C68:  MOV.B   268,W0L
00C6A:  BRA     C64
00C6C:  CLR.B   268
00C6E:  BTSS.B  260.0
00C70:  BRA     C6E
00C72:  MOV.B   268,W0L
00C74:  CLR.B   1
00C76:  MOV     #0,W1
00C78:  MOV     W0,189C
00C7A:  MOV     W1,189E
....................   ADC_Rbyte3 = Spi_read2(0); 
00C7C:  BCLR.B  260.6
00C7E:  BTSS.B  260.0
00C80:  BRA     C86
00C82:  MOV.B   268,W0L
00C84:  BRA     C7E
00C86:  CLR.B   268
00C88:  BTSS.B  260.0
00C8A:  BRA     C88
00C8C:  MOV.B   268,W0L
00C8E:  CLR.B   1
00C90:  MOV     #0,W1
00C92:  MOV     W0,18A0
00C94:  MOV     W1,18A2
....................    
....................   ADC_select(0); // сброс выбора АЦП 
00C96:  CLR.B   18AE
00C98:  CALL    65E
....................    
....................   // склеивание трех байт отсчетов АЦП 
....................   ADC_RByte_Sum = ((S32)ADC_Rbyte1<<24) | ((S32)ADC_Rbyte2<<16) | ((S32)ADC_Rbyte3<<8); 
00C9C:  MOV.B   1898,W0L
00C9E:  MOV.B   W0L,D
00CA0:  CLR.B   W6
00CA2:  CLR.B   B
00CA4:  CLR.B   W5
00CA6:  MOV     189E,W2
00CA8:  MOV     189C,W1
00CAA:  MOV     #0,W0
00CAC:  IOR      W5,  W0,W5
00CAE:  IOR      W6,  W1,W6
00CB0:  MOV.B   18A2,W0L
00CB2:  MOV.B   W0L,3
00CB4:  MOV.B   18A1,W0L
00CB6:  MOV.B   W0L,W1L
00CB8:  MOV.B   18A0,W0L
00CBA:  MOV.B   W0L,1
00CBC:  CLR.B   W0
00CBE:  IOR      W6,  W1,W1
00CC0:  IOR      W5,  W0,W0
00CC2:  MOV     W0,18A4
00CC4:  MOV     W1,18A6
....................   ADC_RByte_Sum = ADC_RByte_Sum/256; // приведение 24 бит к 32-битной переменной 
00CC6:  BCLR.B  43.0
00CC8:  MOV     18A4,W0
00CCA:  MOV     18A6,W1
00CCC:  MOV     #100,W2
00CCE:  MOV     #0,W3
00CD0:  CALL    722
00CD4:  MOV     W0,18A4
00CD6:  MOV     W1,18A6
....................   if(ADC_RByte_Sum > 0x7FFFFF) 
00CD8:  MOV     18A6,W4
00CDA:  MOV     #7F,W3
00CDC:  CP      W3,W4
00CDE:  BRA     GT,D60
00CE0:  BRA     LT,CEA
00CE2:  MOV     18A4,W4
00CE4:  MOV     #FFFF,W3
00CE6:  CP      W3,W4
00CE8:  BRA     C,D60
....................   { 
....................   Vin = ((ADC_RByte_Sum*-5)/(8388608.0*PGA)); // расчет -U 
00CEA:  MOV     18A4,W0
00CEC:  MOV     18A6,W1
00CEE:  MOV     #FFFB,W2
00CF0:  MOV     #FFFF,W3
00CF2:  CALL    7A0
00CF6:  MOV     W0,W5
00CF8:  MOV     W1,W6
00CFA:  MOV     #0,W1
00CFC:  MOV     #0,W2
00CFE:  MOV     #0,W3
00D00:  MOV.B   811,W0L
00D02:  CLR.B   1
00D04:  CALL    7E2
00D08:  MOV     W5,[W15++]
00D0A:  MOV     W6,[W15++]
00D0C:  MOV     W0,W4
00D0E:  MOV     W1,W5
00D10:  MOV     W2,W6
00D12:  MOV     W3,W7
00D14:  MOV     #0,W0
00D16:  MOV     #0,W1
00D18:  MOV     #0,W2
00D1A:  MOV     #4160,W3
00D1C:  CALL    84C
00D20:  MOV     [--W15],W6
00D22:  MOV     [--W15],W5
00D24:  MOV     W0,W7
00D26:  MOV     W1,W8
00D28:  MOV     W2,W9
00D2A:  MOV     W3,W10
00D2C:  MOV     W5,W0
00D2E:  MOV     W6,W1
00D30:  CLR     W3
00D32:  BTSC    W1.F
00D34:  SETM    W3
00D36:  MOV     W3,W2
00D38:  CALL    95C
00D3C:  MOV     W5,[W15++]
00D3E:  MOV     W6,[W15++]
00D40:  MOV     W7,[W15++]
00D42:  MOV     W7,W4
00D44:  MOV     W8,W5
00D46:  MOV     W9,W6
00D48:  MOV     W10,W7
00D4A:  CALL    9C6
00D4E:  MOV     [--W15],W7
00D50:  MOV     [--W15],W6
00D52:  MOV     [--W15],W5
00D54:  CALL    ACE
00D58:  MOV     W1,18A8
00D5A:  MOV     W2,18AA
....................   } 
00D5C:  GOTO    DD2
....................   else Vin = ((ADC_RByte_Sum*5)/(8388608.0*PGA)); // расчет U 
00D60:  MOV     18A4,W0
00D62:  MOV     18A6,W1
00D64:  MOV     #5,W2
00D66:  MOV     #0,W3
00D68:  CALL    7A0
00D6C:  MOV     W0,W5
00D6E:  MOV     W1,W6
00D70:  MOV     #0,W1
00D72:  MOV     #0,W2
00D74:  MOV     #0,W3
00D76:  MOV.B   811,W0L
00D78:  CLR.B   1
00D7A:  CALL    7E2
00D7E:  MOV     W5,[W15++]
00D80:  MOV     W6,[W15++]
00D82:  MOV     W0,W4
00D84:  MOV     W1,W5
00D86:  MOV     W2,W6
00D88:  MOV     W3,W7
00D8A:  MOV     #0,W0
00D8C:  MOV     #0,W1
00D8E:  MOV     #0,W2
00D90:  MOV     #4160,W3
00D92:  CALL    84C
00D96:  MOV     [--W15],W6
00D98:  MOV     [--W15],W5
00D9A:  MOV     W0,W7
00D9C:  MOV     W1,W8
00D9E:  MOV     W2,W9
00DA0:  MOV     W3,W10
00DA2:  MOV     W5,W0
00DA4:  MOV     W6,W1
00DA6:  CLR     W3
00DA8:  BTSC    W1.F
00DAA:  SETM    W3
00DAC:  MOV     W3,W2
00DAE:  CALL    95C
00DB2:  MOV     W5,[W15++]
00DB4:  MOV     W6,[W15++]
00DB6:  MOV     W7,[W15++]
00DB8:  MOV     W7,W4
00DBA:  MOV     W8,W5
00DBC:  MOV     W9,W6
00DBE:  MOV     W10,W7
00DC0:  CALL    9C6
00DC4:  MOV     [--W15],W7
00DC6:  MOV     [--W15],W6
00DC8:  MOV     [--W15],W5
00DCA:  CALL    ACE
00DCE:  MOV     W1,18A8
00DD0:  MOV     W2,18AA
....................    
....................   return Vin*uV; // возврат масштабированного U  
00DD2:  MOV     18A8,W0
00DD4:  MOV     18AA,W1
00DD6:  MOV     #9680,W2
00DD8:  MOV     #4B18,W3
00DDA:  CALL    B12
00DDE:  CALL    BD6
00DE2:  MOV.D   W0,W0
00DE4:  MOV     #14,W5
00DE6:  REPEAT  #4
00DE8:  MOV     [--W15],[W5--]
00DEA:  MOV     [--W15],W5
00DEC:  RETURN  
....................    
....................   } 
....................  
.................... static S32 ADC_read_aver(U8 ADC_number,U8 ADC_ch) 
00DEE:  MOV     W5,[W15++]
.................... { 
....................  S32 _Ch_buf_sum; // переменн. для хранения текущ. усредн. значения 
....................   
....................  Ch_buf[ADC_ch][Ma_buf_index] = ADC_read(ADC_number); // считываем текщее изм. в буфер 
00DF0:  MOV.B   188B,W0L
00DF2:  CLR.B   1
00DF4:  SL      W0,#9,W5
00DF6:  MOV.B   182A,W0L
00DF8:  CLR.B   1
00DFA:  SL      W0,#2,W0
00DFC:  ADD     W0,W5,W0
00DFE:  MOV     #826,W4
00E00:  ADD     W0,W4,W5
00E02:  MOV.B   188A,W0L
00E04:  MOV.B   W0L,1896
00E06:  CALL    C16
00E0A:  MOV     #0,W4
00E0C:  MOV     [W4++],[W5++]
00E0E:  MOV     [W4++],[W5++]
....................   
....................  for(U8 i = 0; i < Ma_buf_size; i++)                  // суммируем весь буфер 
00E10:  CLR.B   1890
00E12:  MOV.B   1890,W0L
00E14:  MOV     182A,W4
00E16:  LSR     W4,#8,W4
00E18:  CP.B    W4L,W0L
00E1A:  BRA     LEU,E44
....................  { 
....................    Ch_buf_sum += Ch_buf[ADC_ch][i];   // меняем элемент буфера на новый 
00E1C:  MOV.B   188B,W0L
00E1E:  CLR.B   1
00E20:  SL      W0,#9,W5
00E22:  MOV.B   1890,W0L
00E24:  CLR.B   1
00E26:  SL      W0,#2,W0
00E28:  ADD     W0,W5,W0
00E2A:  MOV     #826,W4
00E2C:  ADD     W0,W4,W0
00E2E:  MOV     W0,W4
00E30:  MOV     #0,W3
00E32:  MOV     [W4++],[W3++]
00E34:  MOV     [W4++],[W3++]
00E36:  ADD     1826
00E38:  MOV     1828,W4
00E3A:  ADDC    W1,W4,W0
00E3C:  MOV     W0,1828
00E3E:  INC.B   1890
00E40:  GOTO    E12
....................  }   
....................  Ch_buf_sum = Ch_buf_sum/Ma_buf_size; // вычисляем среднее 
00E44:  BCLR.B  43.0
00E46:  MOV.B   182B,W0L
00E48:  MOV.B   W0L,W2L
00E4A:  CLR.B   5
00E4C:  MOV     #0,W3
00E4E:  MOV     1826,W0
00E50:  MOV     1828,W1
00E52:  CALL    722
00E56:  MOV     W0,1826
00E58:  MOV     W1,1828
....................   
....................  _Ch_buf_sum = Ch_buf_sum; // пересохраняем для возврата 
00E5A:  PUSH    1826
00E5C:  POP     188C
00E5E:  PUSH    1828
00E60:  POP     188E
....................   
....................  Ch_buf_sum = 0;           // сброс глоб переменной 
00E62:  CLR     1826
00E64:  CLR     1828
....................   
....................  return _Ch_buf_sum; 
00E66:  MOV     188C,W0
00E68:  MOV     188E,W1
00E6A:  MOV     [--W15],W5
00E6C:  RETURN  
....................  
.................... } 
....................  
.................... //---------------------------------------------------------------------------// 
....................  
....................  
.................... /*############################################################################*/ 
....................  
.................... static void Rd_Flash(){ 
....................  
....................   read_program_memory(CK_USER_PAGE,flash_rd_data,4); 
....................   delay_ms(5); 
....................   NumAver = flash_rd_data[1];  
....................   ADC_sps_var = flash_rd_data[0]; 
....................   CRC_buf = flash_rd_data[2]; 
....................  
.................... } 
....................  
.................... static void Wr_Flash(){ 
....................  
....................   flash_wr_data[0] = Aver_Wr;  
....................   flash_wr_data[1] = Sps_Wr; 
....................   flash_wr_data[2] = CRC_Wr; 
....................   //flash_wr_data[4] = 0x00; 
....................   write_program_memory(CK_USER_PAGE,flash_wr_data,4); 
....................   delay_ms(2); 
....................  
....................  //if(Rd_Flash(buf_index)==in_wr_data) return 1; else return 0; 
.................... } 
....................  
.................... unsigned char Crc8(unsigned char *pcBlock, unsigned int len) 
.................... { 
....................  
....................   //Name  : CRC-8 
....................   //Poly  : 0x31    x^8 + x^5 + x^4 + 1 
....................   //Init  : 0xFF 
....................   //Revert: false 
....................   //XorOut: 0x00 
....................   //Check : 0xF7 ("123456789") 
....................   //MaxLen: 15 байт(127 бит) - обнаружение 
....................   // одинарных, двойных, тройных и всех нечетных ошибок 
....................  
....................     unsigned char crc = 0xFF; 
....................     unsigned int i; 
....................   
....................     while (len--) 
....................     { 
....................         crc ^= *pcBlock++; 
....................   
....................         for (i = 0; i < 8; i++) 
....................             crc = crc & 0x80 ? (crc << 1) ^ 0x31 : crc << 1; 
....................     } 
....................   
....................     return crc; 
.................... } 
....................  
.................... static void UART2_init(){ 
....................  
....................    U2MODE = (1<<15 | // UARTx is enabled 
....................              1<<13 | // Discontinue operation when device enters Idle mode  
....................              0<<12 | // IrDA encoder and decoder disabled 
....................              1<<11 | // 1 - UxRTS in Simplex mode, 0 - flow control mode 
....................              2<<9  | // UxTX, UxRX, UxCTS and UxRTS pins are enabled and used 
....................              1<<7  | // 1 = Wake-up enabled 
....................              0<<6  | // 0 = Loopback mode is disabled 
....................              0<<5  | // Auto-Baud Enable bit, disabled 
....................              1<<4  | // Receive Polarity Inversion bit, 1 = UxRX Idle state is '0' 
....................              0<<3  | // BRGH: High Baud Rate Select bit , 0 = Low speed 
....................              0<<2  | // 00 = 8-bit data, no parity 
....................              0      // 0 = One Stop bit 
....................    ); 
....................  
.................... } 
....................  
.................... static void OscSetup(){ 
....................   //Fcy=Fosc/2 
....................   //Fin=10M 
....................   //Fosc=Fin(M/(N1*N2)) = 40M 
....................   //  
....................   //U2BRG = 259;// BAUD Rate Setting for 9600 
....................   //U2MODE = 0b1010101010000000; // brgh = 0 
....................   //U2BRG = 21;// BAUD Rate Setting for 115200 
....................   U2BRG = 10;  // BAUD Rate Setting for 230400 
*
0038C:  MOV     #A,W4
0038E:  MOV     W4,238
....................   U2MODE = 0b1010101010000000; // brgh = 0 
00390:  MOV     #AA80,W4
00392:  MOV     W4,230
....................    
....................   PLLFBD = 30; // ???. ????. ??????? PLL M = 30 
00394:  MOV     #1E,W4
00396:  MOV     W4,746
....................    
....................   PLLPRE4 = 0; // ???. ????. ??????? PLL N1 = 2 
00398:  BCLR.B  744.4
....................   PLLPRE3 = 0; 
0039A:  BCLR.B  744.3
....................   PLLPRE2 = 0; 
0039C:  BCLR.B  744.2
....................   PLLPRE1 = 0; 
0039E:  BCLR.B  744.1
....................   PLLPRE0 = 0; 
003A0:  BCLR.B  744.0
....................    
....................   PLLPOST0=0; // ???. ????. ??????? PLL N2 = 2 
003A2:  BCLR.B  744.6
....................   PLLPOST1=0; 
003A4:  BCLR.B  744.7
003A6:  RETURN  
....................      
....................    } 
....................  
.................... static void EnableInt (){ 
....................  
....................   enable_interrupts(INT_RDA); // UART Int 
003A8:  BSET.B  95.3
....................   enable_interrupts(INT_RDA2); // UART Int 
003AA:  BSET.B  97.6
....................    
....................   enable_interrupts(INT_TIMER1); 
003AC:  BSET.B  94.3
....................   EXT_INT_EDGE(L_TO_H); 
003AE:  BCLR.B  82.0
....................   ENABLE_INTERRUPTS(INTR_GLOBAL); 
003B0:  BCLR.B  81.7
003B2:  CLR     42
003B4:  BSET.B  81.7
003B6:  RETURN  
.................... } 
....................  
.................... static void MCU_init(){ 
....................  
....................   setup_timer1(TMR_INTERNAL | TMR_DIV_BY_64); // таймер 1 сбрасывает собачий таймер 
003B8:  CLR     104
003BA:  SETM    102
003BC:  MOV     #8020,W4
003BE:  MOV     W4,104
....................   set_timer1(20000); //reset the timer. 
003C0:  MOV     #4E20,W4
003C2:  MOV     W4,100
....................    
....................    SETUP_SPI2(SPI_MASTER|SPI_SCK_IDLE_LOW|SPI_XMIT_H_TO_L|SPI_MODE_8B|SPI_SAMPLE_AT_END|SPI_SS_DISABLED|SPI_CLK_DIV_128); 
003C4:  BCLR.B  261.7
003C6:  BCLR.B  260.6
003C8:  MOV     #221,W4
003CA:  MOV     W4,262
003CC:  BSET.B  261.7
....................    //f SCLK SPI = 312,5 kHz 
....................    //setup_timer1(TMR_DISABLED|TMR_DIV_BY_1); 
....................    //enable_interrupts(INT_EXT0); 
....................    //enable_interrupts(INT_TIMER1); 
....................    
....................  SCK2_TRIS=0; // SPI2 tris 
003CE:  BCLR.B  2E4.6
....................  SDI2_TRIS=1; 
003D0:  BSET.B  2E4.7
....................  SDO2_TRIS=0; 
003D2:  BCLR.B  2E5.0
....................   
....................  ADC_CS_TRIS=0;      ADC2_CS_TRIS=0; 
003D4:  BCLR.B  2E5.1
003D6:  BCLR.B  2D3.2
....................  ADC_RESET_TRIS=0;   ADC2_RESET_TRIS=0; 
003D8:  BCLR.B  2D2.3
003DA:  BCLR.B  2D2.0
....................  ADC_SYNC_TRIS=0;    ADC2_SYNC_TRIS=0; 
003DC:  BCLR.B  2D2.2
003DE:  BCLR.B  2D3.3
....................  ADC_DRDY_TRIS=1;    ADC2_DRDY_TRIS=1;       // опрос готовнсти данных АЦП 
003E0:  BSET.B  2D2.1
003E2:  BSET.B  2D3.1
....................   
....................  UART2_RX_TRIS=1; 
003E4:  BSET.B  2DE.4
....................  UART2_TX_TRIS=0; 
003E6:  BCLR.B  2DE.5
....................  //XPORT_RST_TRIS=0; 
....................   
....................  //XPORT_RST_n = 0; 
....................  //delay_us(500); 
....................  //XPORT_RST_n = 1; 
....................  EnableInt(); 
003E8:  CALL    3A8
003EC:  RETURN  
.................... } 
....................  
.................... static void Full_dev_reset(){ 
....................  
....................   OscSetup(); 
....................   MCU_init(); 
....................   reset_fl = 0; 
....................   //ADC_wakeUp(); 
....................   //ADC_wakeUp();  
....................   ADC_init(); 
....................   ADC_set_PGA(8); 
....................   ADC_sps_set(0x23); //0x023 - 10 sps, 0x43 - 25 sps, 0x63 - 50 sps 
....................                      //0x82 - 100 sps, 0x91 - 500 sps 
....................                      //0xA1 - 1000 sps, 0xC0 - 3750 sps 
....................   ADC_SelfCal(); 
....................   meas_stop_fl = 0; // вкл. режим измерений 
....................   NumAver = 10;      // сброс величины усреднения данных АЦП 
....................  
.................... } 
....................  
.................... static void Clr_bufs(void) 
003EE:  MOV     W5,[W15++]
.................... { 
....................   for (U8 i = 0; i < 8; i++) 
003F0:  CLR.B   188A
003F2:  MOV     188A,W4
003F4:  CP.B    W4L,#8
003F6:  BRA     C,430
....................   { 
....................   // заполнение буферов скольз. ср. нулями 
....................    for (U8 j = 0; j < Ma_buf_size; j++)  
003F8:  CLR.B   188B
003FA:  MOV.B   188B,W0L
003FC:  MOV     182A,W4
003FE:  LSR     W4,#8,W4
00400:  CP.B    W4L,W0L
00402:  BRA     LEU,42A
....................       { 
....................          Ch_buf[i][j] = 0; 
00404:  MOV.B   188A,W0L
00406:  CLR.B   1
00408:  SL      W0,#9,W5
0040A:  MOV.B   188B,W0L
0040C:  CLR.B   1
0040E:  SL      W0,#2,W0
00410:  ADD     W0,W5,W0
00412:  MOV     #826,W4
00414:  ADD     W0,W4,W5
00416:  CLR.B   [W5]
00418:  MOV.B   #0,W0L
0041A:  MOV.B   W0L,[W5+#1]
0041C:  MOV.B   #0,W0L
0041E:  MOV.B   W0L,[W5+#2]
00420:  MOV.B   #0,W0L
00422:  MOV.B   W0L,[W5+#3]
00424:  INC.B   188B
00426:  GOTO    3FA
....................       } 
0042A:  INC.B   188A
0042C:  GOTO    3F2
....................   } 
00430:  MOV     [--W15],W5
00432:  RETURN  
.................... } 
....................  
.................... static U8 ch_to_int(char ch){ 
*
0100E:  MOV.B   #FF,W0L
01010:  MOV.B   W0L,188B
.................... U8 dg=-1; 
....................  switch (ch){ 
01012:  MOV.B   188A,W0L
01014:  SE      W0,W0
01016:  XOR     #30,W0
01018:  BRA     Z,1040
0101A:  XOR     #1,W0
0101C:  BRA     Z,1046
0101E:  XOR     #3,W0
01020:  BRA     Z,104E
01022:  XOR     #1,W0
01024:  BRA     Z,1056
01026:  XOR     #7,W0
01028:  BRA     Z,105E
0102A:  XOR     #1,W0
0102C:  BRA     Z,1066
0102E:  XOR     #3,W0
01030:  BRA     Z,106E
01032:  XOR     #1,W0
01034:  BRA     Z,1076
01036:  XOR     #F,W0
01038:  BRA     Z,107E
0103A:  XOR     #1,W0
0103C:  BRA     Z,1086
0103E:  BRA     108E
....................       case '0' : dg=0; 
01040:  CLR.B   188B
....................       break; 
01042:  GOTO    1092
....................       case '1' : dg=1; 
01046:  MOV.B   #1,W0L
01048:  MOV.B   W0L,188B
....................       break; 
0104A:  GOTO    1092
....................       case '2' : dg=2; 
0104E:  MOV.B   #2,W0L
01050:  MOV.B   W0L,188B
....................       break; 
01052:  GOTO    1092
....................       case '3' : dg=3; 
01056:  MOV.B   #3,W0L
01058:  MOV.B   W0L,188B
....................       break; 
0105A:  GOTO    1092
....................       case '4' : dg=4; 
0105E:  MOV.B   #4,W0L
01060:  MOV.B   W0L,188B
....................       break; 
01062:  GOTO    1092
....................       case '5' : dg=5; 
01066:  MOV.B   #5,W0L
01068:  MOV.B   W0L,188B
....................       break; 
0106A:  GOTO    1092
....................       case '6' : dg=6; 
0106E:  MOV.B   #6,W0L
01070:  MOV.B   W0L,188B
....................       break; 
01072:  GOTO    1092
....................       case '7' : dg=7; 
01076:  MOV.B   #7,W0L
01078:  MOV.B   W0L,188B
....................       break; 
0107A:  GOTO    1092
....................       case '8' : dg=8; 
0107E:  MOV.B   #8,W0L
01080:  MOV.B   W0L,188B
....................       break; 
01082:  GOTO    1092
....................       case '9' : dg=9; 
01086:  MOV.B   #9,W0L
01088:  MOV.B   W0L,188B
....................       break; 
0108A:  GOTO    1092
....................       default: dg=-1; 
0108E:  MOV.B   #FF,W0L
01090:  MOV.B   W0L,188B
....................  } 
.................... return dg; 
01092:  MOV.B   188B,W0L
01094:  RETURN  
.................... } 
....................  
.................... static unsigned char getrxch (void){ 
*
00FCA:  MOV     W5,[W15++]
....................  
.................... unsigned char rch; 
....................  
.................... if(rdptr < wrptr){ 
00FCC:  MOV.B   1870,W0L
00FCE:  MOV     186C,W4
00FD0:  LSR     W4,#8,W4
00FD2:  CP.B    W4L,W0L
00FD4:  BRA     LEU,FEC
....................  // есть символ, считываем 
....................    rdptr ++; 
00FD6:  INC.B   1870
....................    rch=RxData[rdptr& 0x0F];// прочитали символ 
00FD8:  MOV.B   1870,W0L
00FDA:  CLR.B   1
00FDC:  AND     W0,#F,W5
00FDE:  MOV     #1872,W4
00FE0:  ADD     W5,W4,W0
00FE2:  MOV     188A,W4
00FE4:  MOV.B   [W0+#0],W4L
00FE6:  MOV     W4,188A
.................... } else rch = 'x';//символов нет 
00FE8:  GOTO    FF0
00FEC:  MOV.B   #78,W0L
00FEE:  MOV.B   W0L,188A
....................    //обнуление указателей 
....................    disable_interrupts(INT_RDA2); 
00FF0:  BCLR.B  97.6
....................   if((wrptr==rdptr) && (wrptr > 15))  
00FF2:  MOV.B   186D,W0L
00FF4:  CP.B    1870
00FF6:  BRA     NZ,1004
00FF8:  MOV     186C,W4
00FFA:  LSR     W4,#8,W4
00FFC:  CP.B    W4L,#F
00FFE:  BRA     LEU,1004
....................   { 
....................   wrptr=0; 
01000:  CLR.B   186D
....................   rdptr=0; 
01002:  CLR.B   1870
....................   }  
....................   enable_interrupts(INT_RDA2); 
01004:  BSET.B  97.6
....................   return rch; 
01006:  MOV.B   188A,W0L
01008:  MOV.B   W0L,0
0100A:  MOV     [--W15],W5
0100C:  RETURN  
.................... } 
....................  
.................... // послед. чтение двух АЦП 
.................... /* 
.................... static void ADC_Seq_rd_and_print_ch(U8 chanel){ 
....................  
....................    switch (chanel){ 
.................... //---------------- АЦП 1 --------------------------------------//      
....................  case 1:  
....................   
....................  ADC_select(1); 
....................  ADC_setCh(1); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC_SYNC = 0; 
....................  delay_us(20); 
....................  ADC_SYNC = 1; 
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(1); 
....................  Printf("a%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................  
....................  break; 
....................  
.................... //---------------- 2 датчик --------------------------------------// 
....................  case 2: 
....................   
....................  ADC_select(1); 
....................  ADC_setCh(2); 
....................  ADC_select(0); 
....................   
....................  ADC_SYNC = 0; 
....................  delay_us(20); 
....................  ADC_SYNC = 1; 
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(1); 
....................  Printf("b%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................  
....................  break; 
....................   
.................... //---------------- 3 датчик --------------------------------------//   
....................  case 3:  
....................  
....................  ADC_select(1); 
....................  ADC_setCh(3); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC_SYNC = 0; 
....................  delay_us(20); 
....................  ADC_SYNC = 1; 
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(1); 
....................  Printf("c%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................  
....................  break; 
.................... //---------------- 4 датчик --------------------------------------//     
....................    case 4:  
....................     
....................  ADC_select(1); 
....................  ADC_setCh(4); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC_SYNC = 0; 
....................  delay_us(20); 
....................  ADC_SYNC = 1; 
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(1); 
....................  Printf("d%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................   
....................    break; 
.................... //----------------------------------------------------------------// 
....................  
.................... //------------------- АЦП 2 --------------------------------------//      
....................  case 5:  
....................   
....................  ADC_select(2); 
....................  ADC_setCh(1); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC2_SYNC = 0; 
....................  delay_us(20); 
....................  ADC2_SYNC = 1; 
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(2); 
....................  Printf("e%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................   
....................  break; 
....................   
.................... //---------------- 2 датчик --------------------------------------// 
....................  case 6:  
....................   
....................  ADC_select(2); 
....................  ADC_setCh(2); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC2_SYNC = 0; 
....................  delay_us(20); 
....................  ADC2_SYNC = 1; 
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(2); 
....................  Printf("f%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................    
....................  break; 
.................... //---------------- 3 датчик --------------------------------------//   
....................  case 7:  
....................  
....................  ADC_select(2); 
....................  ADC_setCh(3); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC2_SYNC = 0; 
....................  delay_us(20); 
....................  ADC2_SYNC = 1; 
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(2); 
....................  Printf("g%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................    
....................  break; 
.................... //---------------- 4 датчик --------------------------------------//     
....................    case 8:  
....................  
....................  ADC_select(2); 
....................  ADC_setCh(4); 
....................  delay_us(20); 
....................  ADC_select(0); 
....................   
....................  ADC2_SYNC = 0; 
....................  delay_us(20); 
....................  ADC2_SYNC = 1; 
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 1 
....................  ADC_select(2); 
....................  Printf("h%08Lu\n",ADC_read()); 
....................  ADC_select(0); 
....................  delay_us(20); 
....................    
....................   break; 
....................    } 
....................     
.................... } 
.................... */ 
.................... /**/ 
....................  
.................... // || чтение двух АЦП 
.................... static void ADC_Par_rd_and_print_ch(U8 channel) 
*
0114C:  MOV     W5,[W15++]
0114E:  MOV     W6,[W15++]
.................... { 
....................   char rchr;             // принятый U2 символ 
....................    
....................    
....................    switch (channel){ 
01150:  MOV.B   1884,W0L
01152:  CLR.B   1
01154:  XOR     #1,W0
01156:  BRA     Z,116A
01158:  XOR     #3,W0
0115A:  BRA     Z,11FC
0115C:  XOR     #1,W0
0115E:  BRA     Z,1290
01160:  XOR     #7,W0
01162:  BRA     Z,1324
01164:  XOR     #1,W0
01166:  BRA     Z,13CA
01168:  BRA     173E
.................... //---------------- каналы 1 и 5 --------------------------------------//      
....................  case 1:  
....................   
....................  ADC_setCh(1,1); 
0116A:  MOV.B   #1,W0L
0116C:  MOV.B   W0L,188A
0116E:  MOV.B   #1,W0L
01170:  MOV.B   W0L,188B
01172:  CALL    68A
....................  ADC_setCh(1,2); 
01176:  MOV.B   #1,W0L
01178:  MOV.B   W0L,188A
0117A:  MOV.B   #2,W0L
0117C:  MOV.B   W0L,188B
0117E:  CALL    68A
....................  
....................  SYNC_ADC(1);  // синхр. измерений АЦП 1 
01182:  MOV.B   #1,W0L
01184:  MOV.B   W0L,188A
01186:  CALL    6EE
....................  delay_us(200);   
0118A:  REPEAT  #F9E
0118C:  NOP     
....................  SYNC_ADC(2);  // синхр. измерений АЦП 2 
0118E:  MOV.B   #2,W0L
01190:  MOV.B   W0L,188A
01192:  CALL    6EE
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
01196:  BTSS.B  2D4.1
01198:  BRA     119E
0119A:  GOTO    1196
....................  Printf("a%09Ld\n",ADC_read_aver(1,0)); 
0119E:  MOV.B   #1,W0L
011A0:  MOV.B   W0L,188A
011A2:  CLR.B   188B
011A4:  CALL    DEE
011A8:  MOV     W0,W5
011AA:  MOV     W1,W6
011AC:  BTSC.B  233.1
011AE:  BRA     11AC
011B0:  MOV     #61,W4
011B2:  MOV     W4,234
011B4:  MOV     W5,W0
011B6:  MOV     W6,W1
011B8:  MOV     #8009,W4
011BA:  CALL    EB2
011BE:  BTSC.B  233.1
011C0:  BRA     11BE
011C2:  MOV     #A,W4
011C4:  MOV     W4,234
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 2 
011C6:  BTSS.B  2D5.1
011C8:  BRA     11CE
011CA:  GOTO    11C6
....................  Printf("e%09Ld\n",ADC_read_aver(2,1)); 
011CE:  MOV.B   #2,W0L
011D0:  MOV.B   W0L,188A
011D2:  MOV.B   #1,W0L
011D4:  MOV.B   W0L,188B
011D6:  CALL    DEE
011DA:  MOV     W0,W5
011DC:  MOV     W1,W6
011DE:  BTSC.B  233.1
011E0:  BRA     11DE
011E2:  MOV     #65,W4
011E4:  MOV     W4,234
011E6:  MOV     W5,W0
011E8:  MOV     W6,W1
011EA:  MOV     #8009,W4
011EC:  CALL    EB2
011F0:  BTSC.B  233.1
011F2:  BRA     11F0
011F4:  MOV     #A,W4
011F6:  MOV     W4,234
....................  
....................  break; 
011F8:  GOTO    173E
....................  
.................... //---------------- каналы 2 и 6 --------------------------------------//   
....................  case 2:  
....................   
....................  ADC_setCh(2,1); 
011FC:  MOV.B   #2,W0L
011FE:  MOV.B   W0L,188A
01200:  MOV.B   #1,W0L
01202:  MOV.B   W0L,188B
01204:  CALL    68A
....................  ADC_setCh(2,2); 
01208:  MOV.B   #2,W0L
0120A:  MOV.B   W0L,188A
0120C:  MOV.B   #2,W0L
0120E:  MOV.B   W0L,188B
01210:  CALL    68A
....................   
....................  SYNC_ADC(1);   // синхр. измерений АЦП 1 
01214:  MOV.B   #1,W0L
01216:  MOV.B   W0L,188A
01218:  CALL    6EE
....................  delay_us(200);   
0121C:  REPEAT  #F9E
0121E:  NOP     
....................  SYNC_ADC(2);    // синхр. измерений АЦП 2 
01220:  MOV.B   #2,W0L
01222:  MOV.B   W0L,188A
01224:  CALL    6EE
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
01228:  BTSS.B  2D4.1
0122A:  BRA     1230
0122C:  GOTO    1228
....................  Printf("b%09Ld\n",ADC_read_aver(1,2)); 
01230:  MOV.B   #1,W0L
01232:  MOV.B   W0L,188A
01234:  MOV.B   #2,W0L
01236:  MOV.B   W0L,188B
01238:  CALL    DEE
0123C:  MOV     W0,W5
0123E:  MOV     W1,W6
01240:  BTSC.B  233.1
01242:  BRA     1240
01244:  MOV     #62,W4
01246:  MOV     W4,234
01248:  MOV     W5,W0
0124A:  MOV     W6,W1
0124C:  MOV     #8009,W4
0124E:  CALL    EB2
01252:  BTSC.B  233.1
01254:  BRA     1252
01256:  MOV     #A,W4
01258:  MOV     W4,234
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 2 
0125A:  BTSS.B  2D5.1
0125C:  BRA     1262
0125E:  GOTO    125A
....................  Printf("f%09Ld\n",ADC_read_aver(2,3)); 
01262:  MOV.B   #2,W0L
01264:  MOV.B   W0L,188A
01266:  MOV.B   #3,W0L
01268:  MOV.B   W0L,188B
0126A:  CALL    DEE
0126E:  MOV     W0,W5
01270:  MOV     W1,W6
01272:  BTSC.B  233.1
01274:  BRA     1272
01276:  MOV     #66,W4
01278:  MOV     W4,234
0127A:  MOV     W5,W0
0127C:  MOV     W6,W1
0127E:  MOV     #8009,W4
01280:  CALL    EB2
01284:  BTSC.B  233.1
01286:  BRA     1284
01288:  MOV     #A,W4
0128A:  MOV     W4,234
....................   
....................  break; 
0128C:  GOTO    173E
....................   
.................... //---------------- каналы 3 и 7 --------------------------------------//    
....................  case 3:  
....................   
....................  ADC_setCh(3,1); 
01290:  MOV.B   #3,W0L
01292:  MOV.B   W0L,188A
01294:  MOV.B   #1,W0L
01296:  MOV.B   W0L,188B
01298:  CALL    68A
....................  ADC_setCh(3,2); 
0129C:  MOV.B   #3,W0L
0129E:  MOV.B   W0L,188A
012A0:  MOV.B   #2,W0L
012A2:  MOV.B   W0L,188B
012A4:  CALL    68A
....................   
....................  SYNC_ADC(1);   // синхр. измерений АЦП 1 
012A8:  MOV.B   #1,W0L
012AA:  MOV.B   W0L,188A
012AC:  CALL    6EE
....................  delay_us(200);   
012B0:  REPEAT  #F9E
012B2:  NOP     
....................  SYNC_ADC(2);   // синхр. измерений АЦП 2 
012B4:  MOV.B   #2,W0L
012B6:  MOV.B   W0L,188A
012B8:  CALL    6EE
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
012BC:  BTSS.B  2D4.1
012BE:  BRA     12C4
012C0:  GOTO    12BC
....................  Printf("c%09Ld\n",ADC_read_aver(1,4)); 
012C4:  MOV.B   #1,W0L
012C6:  MOV.B   W0L,188A
012C8:  MOV.B   #4,W0L
012CA:  MOV.B   W0L,188B
012CC:  CALL    DEE
012D0:  MOV     W0,W5
012D2:  MOV     W1,W6
012D4:  BTSC.B  233.1
012D6:  BRA     12D4
012D8:  MOV     #63,W4
012DA:  MOV     W4,234
012DC:  MOV     W5,W0
012DE:  MOV     W6,W1
012E0:  MOV     #8009,W4
012E2:  CALL    EB2
012E6:  BTSC.B  233.1
012E8:  BRA     12E6
012EA:  MOV     #A,W4
012EC:  MOV     W4,234
....................   
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 2 
012EE:  BTSS.B  2D5.1
012F0:  BRA     12F6
012F2:  GOTO    12EE
....................  Printf("g%09Ld\n",ADC_read_aver(2,5)); 
012F6:  MOV.B   #2,W0L
012F8:  MOV.B   W0L,188A
012FA:  MOV.B   #5,W0L
012FC:  MOV.B   W0L,188B
012FE:  CALL    DEE
01302:  MOV     W0,W5
01304:  MOV     W1,W6
01306:  BTSC.B  233.1
01308:  BRA     1306
0130A:  MOV     #67,W4
0130C:  MOV     W4,234
0130E:  MOV     W5,W0
01310:  MOV     W6,W1
01312:  MOV     #8009,W4
01314:  CALL    EB2
01318:  BTSC.B  233.1
0131A:  BRA     1318
0131C:  MOV     #A,W4
0131E:  MOV     W4,234
....................   
....................  break; 
01320:  GOTO    173E
....................   
.................... //---------------- каналы 4 и 8 --------------------------------------//    
....................  case 4:  
....................   
....................  ADC_setCh(4,1); 
01324:  MOV.B   #4,W0L
01326:  MOV.B   W0L,188A
01328:  MOV.B   #1,W0L
0132A:  MOV.B   W0L,188B
0132C:  CALL    68A
....................  ADC_setCh(4,2); 
01330:  MOV.B   #4,W0L
01332:  MOV.B   W0L,188A
01334:  MOV.B   #2,W0L
01336:  MOV.B   W0L,188B
01338:  CALL    68A
....................   
....................  SYNC_ADC(1);   // синхр. измерений АЦП 1 
0133C:  MOV.B   #1,W0L
0133E:  MOV.B   W0L,188A
01340:  CALL    6EE
....................  delay_us(200);   
01344:  REPEAT  #F9E
01346:  NOP     
....................  SYNC_ADC(2);    // синхр. измерений АЦП 2 
01348:  MOV.B   #2,W0L
0134A:  MOV.B   W0L,188A
0134C:  CALL    6EE
....................   
....................  While(ADC_DRDY) { } // ждем готовности АЦП 1 
01350:  BTSS.B  2D4.1
01352:  BRA     1358
01354:  GOTO    1350
....................  Printf("d%09Ld\n",ADC_read_aver(1,6)); 
01358:  MOV.B   #1,W0L
0135A:  MOV.B   W0L,188A
0135C:  MOV.B   #6,W0L
0135E:  MOV.B   W0L,188B
01360:  CALL    DEE
01364:  MOV     W0,W5
01366:  MOV     W1,W6
01368:  BTSC.B  233.1
0136A:  BRA     1368
0136C:  MOV     #64,W4
0136E:  MOV     W4,234
01370:  MOV     W5,W0
01372:  MOV     W6,W1
01374:  MOV     #8009,W4
01376:  CALL    EB2
0137A:  BTSC.B  233.1
0137C:  BRA     137A
0137E:  MOV     #A,W4
01380:  MOV     W4,234
....................  
....................  While(ADC2_DRDY) { } // ждем готовности АЦП 2 
01382:  BTSS.B  2D5.1
01384:  BRA     138A
01386:  GOTO    1382
....................  Printf("h%09Ld\n",ADC_read_aver(2,7)); 
0138A:  MOV.B   #2,W0L
0138C:  MOV.B   W0L,188A
0138E:  MOV.B   #7,W0L
01390:  MOV.B   W0L,188B
01392:  CALL    DEE
01396:  MOV     W0,W5
01398:  MOV     W1,W6
0139A:  BTSC.B  233.1
0139C:  BRA     139A
0139E:  MOV     #68,W4
013A0:  MOV     W4,234
013A2:  MOV     W5,W0
013A4:  MOV     W6,W1
013A6:  MOV     #8009,W4
013A8:  CALL    EB2
013AC:  BTSC.B  233.1
013AE:  BRA     13AC
013B0:  MOV     #A,W4
013B2:  MOV     W4,234
....................   
....................  Ma_buf_index++; // инкремент индекса 
013B4:  INC.B   182A
....................  if(Ma_buf_index > Ma_buf_size-1) Ma_buf_index = 0;   // сброс индекса буфера 
013B6:  MOV     182A,W4
013B8:  LSR     W4,#8,W4
013BA:  SUB     W4,#1,W0
013BC:  MOV     182A,W4
013BE:  CLR.B   9
013C0:  CP      W4,W0
013C2:  BRA     LEU,13C6
013C4:  CLR.B   182A
....................   
....................  break; 
013C6:  GOTO    173E
....................   
.................... //---------------- обработка команд с ПК ------------------------------//    
....................  case 5: 
....................   
....................  while(rdptr < wrptr){ 
013CA:  MOV.B   1870,W0L
013CC:  MOV     186C,W4
013CE:  LSR     W4,#8,W4
013D0:  CP.B    W4L,W0L
013D2:  BRA     LEU,173A
....................    U8 dg=0; 
....................    U16 buf1;  
013D4:  CLR.B   1886
....................    //пока есть необработанные символы  
....................    rchr=getrxch(); 
013D6:  CALL    FCA
013DA:  MOV.B   W0L,1885
....................   
....................    switch(state){ 
013DC:  MOV.B   186C,W0L
013DE:  CLR.B   1
013E0:  XOR     #0,W0
013E2:  BRA     Z,1402
013E4:  XOR     #1,W0
013E6:  BRA     Z,1492
013E8:  XOR     #3,W0
013EA:  BRA     Z,152C
013EC:  XOR     #1,W0
013EE:  BRA     Z,1570
013F0:  XOR     #7,W0
013F2:  BRA     Z,15AC
013F4:  XOR     #1,W0
013F6:  BRA     Z,1612
013F8:  XOR     #3,W0
013FA:  BRA     Z,1656
013FC:  XOR     #1,W0
013FE:  BRA     Z,1698
01400:  BRA     1734
....................           case 0: 
....................            switch (rchr){ //команды 
01402:  MOV.B   1885,W0L
01404:  SE      W0,W0
01406:  XOR     #73,W0
01408:  BRA     Z,141C
0140A:  XOR     #3,W0
0140C:  BRA     Z,142C
0140E:  XOR     #17,W0
01410:  BRA     Z,144C
01412:  XOR     #11,W0
01414:  BRA     Z,145A
01416:  XOR     #14,W0
01418:  BRA     Z,1468
0141A:  BRA     1476
....................                case 's': stop_fl = 0; // старт измерений 
0141C:  BCLR.B  81C.2
....................                          Clr_bufs(); 
0141E:  CALL    3EE
....................                          ADC_init(); // инициализ .АЦП с новыми параметрами 
01422:  CALL    5A2
....................                          state=0; 
01426:  CLR.B   186C
....................                break;  
01428:  GOTO    148E
....................                //---------- 
....................                case 'p': stop_fl = 1; // стоп измерений 
0142C:  BSET.B  81C.2
....................                          printf("stopped\n\r");   
0142E:  MOV     #0,W1
01430:  MOV     W1,W0
01432:  CLR.B   1
01434:  CALL    200
01438:  INC     W1,W1
0143A:  BTSC.B  233.1
0143C:  BRA     143A
0143E:  MOV     W0,234
01440:  MOV     #8,W0
01442:  CPSGT   W1,W0
01444:  BRA     1430
....................                          state=0; 
01446:  CLR.B   186C
....................                break;  
01448:  GOTO    148E
....................                //---------- 
....................                case 'g': state = 1; // pga_set 
0144C:  MOV.B   #1,W0L
0144E:  MOV.B   W0L,186C
....................                if(!stop_fl) state=0;  
01450:  BTSC.B  81C.2
01452:  BRA     1456
01454:  CLR.B   186C
....................                break; 
01456:  GOTO    148E
....................                //---------- 
....................                case 'v': state = 2; // sps_set 
0145A:  MOV.B   #2,W0L
0145C:  MOV.B   W0L,186C
....................                if(!stop_fl) state=0;            
0145E:  BTSC.B  81C.2
01460:  BRA     1464
01462:  CLR.B   186C
....................                break; 
01464:  GOTO    148E
....................                //---------- 
....................                case 'b': state = 5; // aver_buf_size 
01468:  MOV.B   #5,W0L
0146A:  MOV.B   W0L,186C
....................                if(!stop_fl) state=0;            
0146C:  BTSC.B  81C.2
0146E:  BRA     1472
01470:  CLR.B   186C
....................                break; 
01472:  GOTO    148E
....................  
....................                default : printf("err \r\n");       
01476:  MOV     #0,W1
01478:  MOV     W1,W0
0147A:  CLR.B   1
0147C:  CALL    216
01480:  INC     W1,W1
01482:  BTSC.B  233.1
01484:  BRA     1482
01486:  MOV     W0,234
01488:  MOV     #5,W0
0148A:  CPSGT   W1,W0
0148C:  BRA     1478
....................          } // команды 
....................           break; 
0148E:  GOTO    1736
....................            
....................          case 1:  
....................          // уст. PGA 
....................             dg = ch_to_int(rchr); 
01492:  MOV.B   1885,W0L
01494:  MOV.B   W0L,188A
01496:  CALL    100E
0149A:  MOV.B   W0L,1886
....................             if(dg == -1){  
0149C:  MOV     1886,W4
0149E:  XOR.B   #FF,W4L
014A0:  BRA     NZ,14C0
....................               state=0; 
014A2:  CLR.B   186C
....................               printf("PGA err \r\n");  
014A4:  MOV     #0,W1
014A6:  MOV     W1,W0
014A8:  CLR.B   1
014AA:  CALL    22A
014AE:  INC     W1,W1
014B0:  BTSC.B  233.1
014B2:  BRA     14B0
014B4:  MOV     W0,234
014B6:  MOV     #9,W0
014B8:  CPSGT   W1,W0
014BA:  BRA     14A6
....................               break; 
014BC:  GOTO    1736
....................                   } 
....................                    
....................               tmp = (U16)dg; 
014C0:  MOV.B   1886,W0L
014C2:  MOV.B   W0L,186E
014C4:  CLR.B   186F
....................                
....................             //if(stop_fl) {      
....................                if(tmp>=0 && tmp<=6){ 
014C6:  MOV     186E,W4
014C8:  CP      W4,#6
014CA:  BRA     GTU,150E
....................                   PGA_val=tmp; 
014CC:  MOV.B   186E,W0L
014CE:  MOV.B   W0L,812
....................                   printf("PGA=%u \r\n",PGA_val); 
014D0:  MOV     #0,W1
014D2:  MOV     W1,W0
014D4:  CLR.B   1
014D6:  CALL    242
014DA:  INC     W1,W1
014DC:  BTSC.B  233.1
014DE:  BRA     14DC
014E0:  MOV     W0,234
014E2:  MOV     #3,W0
014E4:  CPSGT   W1,W0
014E6:  BRA     14D2
014E8:  MOV.B   812,W0L
014EA:  CLR.B   1
014EC:  MOV     #0,W4
014EE:  CALL    1096
014F2:  BTSC.B  233.1
014F4:  BRA     14F2
014F6:  MOV     #20,W4
014F8:  MOV     W4,234
014FA:  BTSC.B  233.1
014FC:  BRA     14FA
014FE:  MOV     #D,W4
01500:  MOV     W4,234
01502:  BTSC.B  233.1
01504:  BRA     1502
01506:  MOV     #A,W4
01508:  MOV     W4,234
....................                }  else printf("PGA out of range\r\n"); 
0150A:  GOTO    1526
0150E:  MOV     #0,W1
01510:  MOV     W1,W0
01512:  CLR.B   1
01514:  CALL    258
01518:  INC     W1,W1
0151A:  BTSC.B  233.1
0151C:  BRA     151A
0151E:  MOV     W0,234
01520:  MOV     #11,W0
01522:  CPSGT   W1,W0
01524:  BRA     1510
....................             //} 
....................                   state=0;      
01526:  CLR.B   186C
....................          break; 
01528:  GOTO    1736
....................           
....................          case 2:  
....................          // уст. SPS 
....................             dg = ch_to_int(rchr); 
0152C:  MOV.B   1885,W0L
0152E:  MOV.B   W0L,188A
01530:  CALL    100E
01534:  MOV.B   W0L,1886
....................             if(dg == -1){  
01536:  MOV     1886,W4
01538:  XOR.B   #FF,W4L
0153A:  BRA     NZ,155A
....................               state=0; 
0153C:  CLR.B   186C
....................               printf("err p1 \r\n");  
0153E:  MOV     #0,W1
01540:  MOV     W1,W0
01542:  CLR.B   1
01544:  CALL    278
01548:  INC     W1,W1
0154A:  BTSC.B  233.1
0154C:  BRA     154A
0154E:  MOV     W0,234
01550:  MOV     #8,W0
01552:  CPSGT   W1,W0
01554:  BRA     1540
....................               break; 
01556:  GOTO    1736
....................                   } 
....................           // 1 цифра    
....................           tmp=0; 
0155A:  CLR     186E
....................           tmp+=(U16)dg*10; 
0155C:  MOV.B   1886,W0L
0155E:  MOV.B   W0L,A
01560:  CLR.B   B
01562:  MOV     W5,W4
01564:  MUL.UU  W4,#A,W0
01566:  ADD     186E
....................           state=3; 
01568:  MOV.B   #3,W0L
0156A:  MOV.B   W0L,186C
....................           // ПОЧЕМУ НАДО СЛАТЬ 3 СИМВОЛА? 
....................          break; 
0156C:  GOTO    1736
....................           
....................          case 3:  
....................          // уст. SPS 
....................             dg = ch_to_int(rchr); 
01570:  MOV.B   1885,W0L
01572:  MOV.B   W0L,188A
01574:  CALL    100E
01578:  MOV.B   W0L,1886
....................             if(dg == -1){  
0157A:  MOV     1886,W4
0157C:  XOR.B   #FF,W4L
0157E:  BRA     NZ,159E
....................               state=0; 
01580:  CLR.B   186C
....................               printf("err p2 \r\n");  
01582:  MOV     #0,W1
01584:  MOV     W1,W0
01586:  CLR.B   1
01588:  CALL    28E
0158C:  INC     W1,W1
0158E:  BTSC.B  233.1
01590:  BRA     158E
01592:  MOV     W0,234
01594:  MOV     #8,W0
01596:  CPSGT   W1,W0
01598:  BRA     1584
....................               break; 
0159A:  GOTO    1736
....................                   } 
....................           // 2 цифра         
....................           tmp+=(U16)dg;  
0159E:  MOV.B   1886,W0L
015A0:  CLR.B   1
015A2:  ADD     186E
....................           state=4; 
015A4:  MOV.B   #4,W0L
015A6:  MOV.B   W0L,186C
....................          break; 
015A8:  GOTO    1736
....................           
....................          case 4:  
....................             if(tmp>=0 && tmp<=12){ 
015AC:  MOV     186E,W4
015AE:  CP      W4,#C
015B0:  BRA     GTU,15F4
....................                ADC_sps_var = tmp; 
015B2:  MOV.B   186E,W0L
015B4:  MOV.B   W0L,81E
....................                printf("SPS=%u \r\n",ADC_sps_var); 
015B6:  MOV     #0,W1
015B8:  MOV     W1,W0
015BA:  CLR.B   1
015BC:  CALL    2A4
015C0:  INC     W1,W1
015C2:  BTSC.B  233.1
015C4:  BRA     15C2
015C6:  MOV     W0,234
015C8:  MOV     #3,W0
015CA:  CPSGT   W1,W0
015CC:  BRA     15B8
015CE:  MOV.B   81E,W0L
015D0:  CLR.B   1
015D2:  MOV     #0,W4
015D4:  CALL    1096
015D8:  BTSC.B  233.1
015DA:  BRA     15D8
015DC:  MOV     #20,W4
015DE:  MOV     W4,234
015E0:  BTSC.B  233.1
015E2:  BRA     15E0
015E4:  MOV     #D,W4
015E6:  MOV     W4,234
015E8:  BTSC.B  233.1
015EA:  BRA     15E8
015EC:  MOV     #A,W4
015EE:  MOV     W4,234
....................                } else printf("SPS out of range\r\n"); 
015F0:  GOTO    160C
015F4:  MOV     #0,W1
015F6:  MOV     W1,W0
015F8:  CLR.B   1
015FA:  CALL    2BA
015FE:  INC     W1,W1
01600:  BTSC.B  233.1
01602:  BRA     1600
01604:  MOV     W0,234
01606:  MOV     #11,W0
01608:  CPSGT   W1,W0
0160A:  BRA     15F6
....................                   state=0;      
0160C:  CLR.B   186C
....................          break; 
0160E:  GOTO    1736
....................           
....................          case 5:  
....................          // уст. размера буфера усреднения 
....................             dg = ch_to_int(rchr); 
01612:  MOV.B   1885,W0L
01614:  MOV.B   W0L,188A
01616:  CALL    100E
0161A:  MOV.B   W0L,1886
....................             if(dg == -1){  
0161C:  MOV     1886,W4
0161E:  XOR.B   #FF,W4L
01620:  BRA     NZ,1640
....................               state=0; 
01622:  CLR.B   186C
....................               printf("err p1 \r\n");  
01624:  MOV     #0,W1
01626:  MOV     W1,W0
01628:  CLR.B   1
0162A:  CALL    278
0162E:  INC     W1,W1
01630:  BTSC.B  233.1
01632:  BRA     1630
01634:  MOV     W0,234
01636:  MOV     #8,W0
01638:  CPSGT   W1,W0
0163A:  BRA     1626
....................               break; 
0163C:  GOTO    1736
....................                   } 
....................           // 1 цифра    
....................           tmp=0; 
01640:  CLR     186E
....................           tmp+=(U16)dg*100; 
01642:  MOV.B   1886,W0L
01644:  MOV.B   W0L,A
01646:  CLR.B   B
01648:  MOV     #64,W4
0164A:  MUL.UU  W5,W4,W0
0164C:  ADD     186E
....................           state=6; 
0164E:  MOV.B   #6,W0L
01650:  MOV.B   W0L,186C
....................            
....................          break; 
01652:  GOTO    1736
....................           
....................          case 6:  
....................          // уст. размера буфера усреднения 
....................             dg = ch_to_int(rchr); 
01656:  MOV.B   1885,W0L
01658:  MOV.B   W0L,188A
0165A:  CALL    100E
0165E:  MOV.B   W0L,1886
....................             if(dg == -1){  
01660:  MOV     1886,W4
01662:  XOR.B   #FF,W4L
01664:  BRA     NZ,1684
....................               state=0; 
01666:  CLR.B   186C
....................               printf("err p2 \r\n");  
01668:  MOV     #0,W1
0166A:  MOV     W1,W0
0166C:  CLR.B   1
0166E:  CALL    28E
01672:  INC     W1,W1
01674:  BTSC.B  233.1
01676:  BRA     1674
01678:  MOV     W0,234
0167A:  MOV     #8,W0
0167C:  CPSGT   W1,W0
0167E:  BRA     166A
....................               break; 
01680:  GOTO    1736
....................                   } 
....................           // 2 цифра         
....................           tmp+=(U16)dg*10; 
01684:  MOV.B   1886,W0L
01686:  MOV.B   W0L,A
01688:  CLR.B   B
0168A:  MOV     W5,W4
0168C:  MUL.UU  W4,#A,W0
0168E:  ADD     186E
....................           state=7; 
01690:  MOV.B   #7,W0L
01692:  MOV.B   W0L,186C
....................            
....................          break; 
01694:  GOTO    1736
....................           
....................          case 7:  
....................          // уст. размера буфера усреднения 
....................             dg = ch_to_int(rchr); 
01698:  MOV.B   1885,W0L
0169A:  MOV.B   W0L,188A
0169C:  CALL    100E
016A0:  MOV.B   W0L,1886
....................             if(dg == -1){  
016A2:  MOV     1886,W4
016A4:  XOR.B   #FF,W4L
016A6:  BRA     NZ,16C6
....................               state=0; 
016A8:  CLR.B   186C
....................               printf("err p3 \r\n");  
016AA:  MOV     #0,W1
016AC:  MOV     W1,W0
016AE:  CLR.B   1
016B0:  CALL    2DA
016B4:  INC     W1,W1
016B6:  BTSC.B  233.1
016B8:  BRA     16B6
016BA:  MOV     W0,234
016BC:  MOV     #8,W0
016BE:  CPSGT   W1,W0
016C0:  BRA     16AC
....................               break; 
016C2:  GOTO    1736
....................                   } 
....................           // 3 цифра  
....................           tmp+=(U16)dg; 
016C6:  MOV.B   1886,W0L
016C8:  CLR.B   1
016CA:  ADD     186E
....................           if(tmp>=0 && tmp<=128){ 
016CC:  MOV     186E,W4
016CE:  MOV     #80,W3
016D0:  CP      W3,W4
016D2:  BRA     NC,1716
....................                        Ma_buf_size=(U8)tmp;// прочитаны все 3 цифры без ошибок 
016D4:  MOV.B   186E,W0L
016D6:  MOV.B   W0L,182B
....................                        printf("aver buf size=%u \r\n",Ma_buf_size); 
016D8:  MOV     #0,W1
016DA:  MOV     W1,W0
016DC:  CLR.B   1
016DE:  CALL    2F0
016E2:  INC     W1,W1
016E4:  BTSC.B  233.1
016E6:  BRA     16E4
016E8:  MOV     W0,234
016EA:  MOV     #D,W0
016EC:  CPSGT   W1,W0
016EE:  BRA     16DA
016F0:  MOV.B   182B,W0L
016F2:  CLR.B   1
016F4:  MOV     #0,W4
016F6:  CALL    1096
016FA:  BTSC.B  233.1
016FC:  BRA     16FA
016FE:  MOV     #20,W4
01700:  MOV     W4,234
01702:  BTSC.B  233.1
01704:  BRA     1702
01706:  MOV     #D,W4
01708:  MOV     W4,234
0170A:  BTSC.B  233.1
0170C:  BRA     170A
0170E:  MOV     #A,W4
01710:  MOV     W4,234
....................           } else printf("aver buf out of range\r\n"); 
01712:  GOTO    172E
01716:  MOV     #0,W1
01718:  MOV     W1,W0
0171A:  CLR.B   1
0171C:  CALL    310
01720:  INC     W1,W1
01722:  BTSC.B  233.1
01724:  BRA     1722
01726:  MOV     W0,234
01728:  MOV     #16,W0
0172A:  CPSGT   W1,W0
0172C:  BRA     1718
....................            
....................           state=0; 
0172E:  CLR.B   186C
....................            
....................          break; 
01730:  GOTO    1736
....................           
....................         default : state=0;    
01734:  CLR.B   186C
....................       } // state    
01736:  GOTO    13CA
....................    } // while 
....................     
....................      break; 
0173A:  GOTO    173E
....................    } // main case 
0173E:  MOV     [--W15],W6
01740:  MOV     [--W15],W5
01742:  RETURN  
.................... } 
....................  
.................... static void save_to_flash(){ 
....................        
....................    Sps_Wr = NumAver; 
....................    Aver_Wr = ADC_sps_var; // сохранение sps значения во флеш 
....................    CRC_Wr = CRC8(flash_wr_data,2); 
....................    Wr_Flash(); 
....................    }  
....................  
.................... #int_timer1 
.................... static void timer1_irq_handler(void) { 
*
00334:  PUSH    42
00336:  PUSH    36
00338:  PUSH    32
0033A:  MOV     W0,[W15++]
0033C:  MOV     #2,W0
0033E:  REPEAT  #C
00340:  MOV     [W0++],[W15++]
.................... restart_wdt();     // сбос собачего таймера 
00342:  CLRWDT  
.................... set_timer1(20000); //reset the timer. 
00344:  MOV     #4E20,W4
00346:  MOV     W4,100
.................... clear_interrupt(int_timer1); 
00348:  BCLR.B  84.3
.................... } 
....................  
0034A:  BCLR.B  84.3
0034C:  MOV     #1A,W0
0034E:  REPEAT  #C
00350:  MOV     [--W15],[W0--]
00352:  MOV     [--W15],W0
00354:  POP     32
00356:  POP     36
00358:  POP     42
0035A:  RETFIE  
.................... #INT_RDA2 
.................... void UART2_RXd_isr(void){ 
0035C:  PUSH    42
0035E:  PUSH    36
00360:  PUSH    32
00362:  MOV     W0,[W15++]
00364:  MOV     #2,W0
00366:  REPEAT  #C
00368:  MOV     [W0++],[W15++]
....................  
....................    wrptr++; 
0036A:  INC.B   186D
....................    RxData[wrptr & 0x0F] = (U8)(U2RXREG); 
0036C:  MOV.B   186D,W0L
0036E:  CLR.B   1
00370:  AND     W0,#F,W5
00372:  MOV     #1872,W4
00374:  ADD     W5,W4,W6
00376:  MOV     236,W0
00378:  MOV.B   W0L,[W6+#0]
....................  
0037A:  BCLR.B  87.6
0037C:  MOV     #1A,W0
0037E:  REPEAT  #C
00380:  MOV     [--W15],[W0--]
00382:  MOV     [--W15],W0
00384:  POP     32
00386:  POP     36
00388:  POP     42
0038A:  RETFIE  
.................... } 
....................  
.................... /*############################################################################*/ 
....................  
.................... static void main() 
*
01744:  MOV     #2780,W15
01746:  MOV     #27FF,W0
01748:  MOV     W0,20
0174A:  NOP     
0174C:  MOV     #4444,W0
0174E:  MOV     W0,A4
01750:  BSET.B  81.7
01752:  BCLR.B  261.7
01754:  BCLR.B  2E5.0
01756:  BSET.B  2E4.7
01758:  BCLR.B  2E4.6
0175A:  BCLR.B  260.6
0175C:  MOV     #3F,W4
0175E:  MOV     W4,262
01760:  BSET.B  261.7
01762:  CLR     806
01764:  MOV     #8000,W4
01766:  MOV     W4,230
01768:  MOV     #400,W4
0176A:  MOV     W4,232
0176C:  BSET.B  230.3
0176E:  MOV     #15,W4
01770:  MOV     W4,238
01772:  MOV.B   #3,W0L
01774:  MOV.B   W0L,812
01776:  CLR.B   813
01778:  CLR.B   818
0177A:  CLR.B   819
0177C:  CLR.B   81A
0177E:  CLR.B   81B
01780:  BCLR.B  81C.0
01782:  BCLR.B  81C.1
01784:  BCLR.B  81C.2
01786:  MOV.B   #1,W0L
01788:  MOV.B   W0L,81D
0178A:  MOV.B   #1,W0L
0178C:  MOV.B   W0L,81E
0178E:  MOV.B   #FF,W0L
01790:  MOV.B   W0L,81F
01792:  SETM.B  820
01794:  CLR.B   182A
01796:  MOV.B   #10,W0L
01798:  MOV.B   W0L,182B
0179A:  CLR     186E
0179C:  CLR.B   186D
0179E:  CLR.B   1870
017A0:  SETM    32C
017A2:  SETM    32A
017A4:  CLR     800
017A6:  MOV     #7600,W4
017A8:  MOV     W4,808
017AA:  MOV     #3254,W4
017AC:  MOV     W4,80A
017AE:  MOV     #10,W4
017B0:  MOV     W4,80C
017B2:  CLR     80E
017B4:  CLR.B   810
017B6:  CLR     814
017B8:  CLR     816
017BA:  CLR     1872
017BC:  CLR     1874
017BE:  CLR     1876
017C0:  CLR     1878
017C2:  CLR     187A
017C4:  CLR     187C
017C6:  CLR     187E
017C8:  CLR     1880
017CA:  MOV.B   #1,W0L
017CC:  MOV.B   W0L,1882
.................... {  
....................   U8 ch = 1;             // начальная установка канала измерений АЦП 
....................  
....................   OscSetup(); 
017CE:  CALL    38C
....................   MCU_init();  
017D2:  CALL    3B8
....................   //Rd_Flash();                        // чтение денных из флеш для расчета контр. суммы 
....................   //crc1 = CRC_buf;                    // сохраненная контр. сумма     
....................   //crc2 = CRC8(flash_rd_data,2);      // текущая контр. сумма 
....................    
....................   Clr_bufs(); 
017D6:  CALL    3EE
....................    
....................   ADC_sps_var = 0;   // сброс значений по умолчанию  
017DA:  CLR.B   81E
....................   NumAver = 1;       // тк произошел сбой контр. суммы 
017DC:  MOV.B   #1,W0L
017DE:  MOV.B   W0L,81D
....................       
....................   ADC_RESET = 1; ADC2_RESET = 1; 
017E0:  BSET.B  2D6.3
017E2:  BSET.B  2D6.0
....................   ADC_CS = 1;    ADC2_CS = 1; 
017E4:  BSET.B  2E9.1
017E6:  BSET.B  2D7.2
....................   ADC_SYNC = 1;  ADC2_SYNC = 1;  
017E8:  BSET.B  2D6.2
017EA:  BSET.B  2D7.3
....................       
....................   While(ADC_DRDY | ADC2_DRDY) { }   // ждем готовности обоих АЦП перед иниц.   
017EC:  CLR     W0
017EE:  BTSC.B  2D4.1
017F0:  INC     W0,W0
017F2:  MOV.B   W0L,W6L
017F4:  CLR     W0
017F6:  BTSC.B  2D5.1
017F8:  INC     W0,W0
017FA:  IOR.B    W6L,  W0L,W0L
017FC:  CP0.B   W0L
017FE:  BRA     Z,1804
01800:  GOTO    17EC
....................    
....................   ADC_init();        // Инициализация обоих АЦП  
01804:  CALL    5A2
....................    
.................... /*############################################################################*/   
....................  
....................   while(true){ 
....................    
....................   ADC_Par_rd_and_print_ch(ch); // чтение 8 каналов двух АЦП 
01808:  MOV.B   1882,W0L
0180A:  MOV.B   W0L,1884
0180C:  CALL    114C
....................    
....................   ch++;                    // инкремент номера канала 
01810:  INC.B   1882
....................   if (ch > 5) ch = 1; // диапазон каналов 
01812:  MOV     1882,W4
01814:  CP.B    W4L,#5
01816:  BRA     LEU,181C
01818:  MOV.B   #1,W0L
0181A:  MOV.B   W0L,1882
....................    
....................   if (stop_fl) ch = 5; // остановить измерения 
0181C:  BTSS.B  81C.2
0181E:  BRA     1824
01820:  MOV.B   #5,W0L
01822:  MOV.B   W0L,1882
01824:  GOTO    1808
....................  
....................  
....................  } // while   
.................... }  // main 
.................... /*############################################################################*/ 
01828:  PWRSAV  #0
....................  

Configuration Fuses:
   Word  1L: 00CE   WRTB NOBSS NORBS
          H: 0000  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: 0000  
   Word  3L: 0007   NOWRT NOPROTECT
          H: 0000  
   Word  4L: 0083   PR_PLL IESO
          H: 0000  
   Word  5L: 0006   HS NOOSCIO CKSFSM
          H: 0000  
   Word  6L: 00DD   WPOSTS14 WPRES128 WINDIS WDT
          H: 0000  
   Word  7L: 00E7   PUT128
          H: 0000  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: 0000  
