CCS PCD C Compiler, Version 5.019, 5967               10-май-15 11:58

               Filename:   D:\work\Projects\PICC\my prj\Termo3_2.0\Termo_8ch\main.lst

               ROM used:   9490 bytes (11%)
                           Largest free fragment is 56046
               RAM used:   205 (3%) at main() level
                           302 (4%) worst case
               Stack used: 82 locations (42 in main + 40 for interrupts)
               Stack size: 128

*
00000:  GOTO    2034
*
0001A:  DATA    72,04,00
*
0003A:  DATA    16,04,00
.................... #include <main.h> 
.................... //#include <24HJ128GP506.h> 
.................... #include <24HJ128GP506A.h> 
.................... //////////// Standard Header file for the PIC24HJ128GP506A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24HJ128GP506A 
*
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    20,20,00
0020E:  DATA    20,38,00
00210:  DATA    20,43,00
00212:  DATA    68,61,00
00214:  DATA    6E,6E,00
00216:  DATA    65,6C,00
00218:  DATA    00,00,00
0021A:  CLR     32
0021C:  MOV     #226,W3
0021E:  ADD     W3,W0,W0
00220:  TBLRDL.B[W0],W0L
00222:  CLR.B   1
00224:  RETURN  
00226:  DATA    20,20,00
00228:  DATA    54,68,00
0022A:  DATA    65,72,00
0022C:  DATA    6D,6F,00
0022E:  DATA    6D,65,00
00230:  DATA    74,72,00
00232:  DATA    79,00,00
00234:  CLR     32
00236:  MOV     #240,W3
00238:  ADD     W3,W0,W0
0023A:  TBLRDL.B[W0],W0L
0023C:  CLR.B   1
0023E:  RETURN  
00240:  DATA    20,5F,00
00242:  DATA    5F,5F,00
00244:  DATA    4C,48,00
00246:  DATA    45,50,00
00248:  DATA    5F,4A,00
0024A:  DATA    49,4E,00
0024C:  DATA    52,5F,00
0024E:  DATA    5F,5F,00
00250:  DATA    00,00,00
00252:  CLR     32
00254:  MOV     #25E,W3
00256:  ADD     W3,W0,W0
00258:  TBLRDL.B[W0],W0L
0025A:  CLR.B   1
0025C:  RETURN  
0025E:  DATA    41,44,00
00260:  DATA    43,20,00
00262:  DATA    73,70,00
00264:  DATA    73,20,00
00266:  DATA    73,65,00
00268:  DATA    74,20,00
0026A:  DATA    20,00,00
0026C:  CLR     32
0026E:  MOV     #278,W3
00270:  ADD     W3,W0,W0
00272:  TBLRDL.B[W0],W0L
00274:  CLR.B   1
00276:  RETURN  
00278:  DATA    41,76,00
0027A:  DATA    65,72,00
0027C:  DATA    61,67,00
0027E:  DATA    65,20,00
00280:  DATA    73,65,00
00282:  DATA    74,20,00
00284:  DATA    20,00,00
00286:  CLR     32
00288:  MOV     #292,W3
0028A:  ADD     W3,W0,W0
0028C:  TBLRDL.B[W0],W0L
0028E:  CLR.B   1
00290:  RETURN  
00292:  DATA    52,65,00
00294:  DATA    73,65,00
00296:  DATA    74,20,00
00298:  DATA    64,65,00
0029A:  DATA    76,69,00
0029C:  DATA    63,65,00
0029E:  DATA    20,00,00
002A0:  CLR     32
002A2:  MOV     #2AC,W3
002A4:  ADD     W3,W0,W0
002A6:  TBLRDL.B[W0],W0L
002A8:  CLR.B   1
002AA:  RETURN  
002AC:  DATA    52,65,00
002AE:  DATA    74,75,00
002B0:  DATA    72,6E,00
002B2:  DATA    20,62,00
002B4:  DATA    61,63,00
002B6:  DATA    6B,20,00
002B8:  DATA    20,00,00
002BA:  CLR     32
002BC:  MOV     #2C6,W3
002BE:  ADD     W3,W0,W0
002C0:  TBLRDL.B[W0],W0L
002C2:  CLR.B   1
002C4:  RETURN  
002C6:  DATA    3C,2D,00
002C8:  DATA    2D,00,00
002CA:  CLR     32
002CC:  MOV     #2D6,W3
002CE:  ADD     W3,W0,W0
002D0:  TBLRDL.B[W0],W0L
002D2:  CLR.B   1
002D4:  RETURN  
002D6:  DATA    20,20,00
002D8:  DATA    20,00,00
002DA:  CLR     32
002DC:  MOV     #2E6,W3
002DE:  ADD     W3,W0,W0
002E0:  TBLRDL.B[W0],W0L
002E2:  CLR.B   1
002E4:  RETURN  
002E6:  DATA    20,20,00
002E8:  DATA    20,52,00
002EA:  DATA    65,73,00
002EC:  DATA    65,74,00
002EE:  DATA    20,64,00
002F0:  DATA    6F,6E,00
002F2:  DATA    65,00,00
002F4:  CLR     32
002F6:  MOV     #300,W3
002F8:  ADD     W3,W0,W0
002FA:  TBLRDL.B[W0],W0L
002FC:  CLR.B   1
002FE:  RETURN  
00300:  DATA    53,74,00
00302:  DATA    61,72,00
00304:  DATA    74,69,00
00306:  DATA    6E,67,00
00308:  DATA    20,64,00
0030A:  DATA    65,76,00
0030C:  DATA    69,63,00
0030E:  DATA    65,21,00
00310:  DATA    00,00,00
00312:  CLR     32
00314:  MOV     #31E,W3
00316:  ADD     W3,W0,W0
00318:  TBLRDL.B[W0],W0L
0031A:  CLR.B   1
0031C:  RETURN  
0031E:  DATA    20,20,00
00320:  DATA    52,65,00
00322:  DATA    61,64,00
00324:  DATA    69,6E,00
00326:  DATA    67,20,00
00328:  DATA    64,61,00
0032A:  DATA    74,61,00
0032C:  DATA    00,00,00
0032E:  CLR     32
00330:  MOV     #33A,W3
00332:  ADD     W3,W0,W0
00334:  TBLRDL.B[W0],W0L
00336:  CLR.B   1
00338:  RETURN  
0033A:  DATA    20,20,00
0033C:  DATA    20,66,00
0033E:  DATA    72,6F,00
00340:  DATA    6D,20,00
00342:  DATA    52,4F,00
00344:  DATA    4D,2E,00
00346:  DATA    2E,2E,00
00348:  DATA    00,00,00
0034A:  CLR     32
0034C:  MOV     #356,W3
0034E:  ADD     W3,W0,W0
00350:  TBLRDL.B[W0],W0L
00352:  CLR.B   1
00354:  RETURN  
00356:  DATA    20,20,00
00358:  DATA    20,20,00
0035A:  DATA    20,20,00
0035C:  DATA    20,4F,00
0035E:  DATA    4B,21,00
00360:  DATA    00,00,00
00362:  CLR     32
00364:  MOV     #36E,W3
00366:  ADD     W3,W0,W0
00368:  TBLRDL.B[W0],W0L
0036A:  CLR.B   1
0036C:  RETURN  
0036E:  DATA    20,20,00
00370:  DATA    20,43,00
00372:  DATA    52,43,00
00374:  DATA    20,65,00
00376:  DATA    72,72,00
00378:  DATA    6F,72,00
0037A:  DATA    21,00,00
0037C:  CLR     32
0037E:  MOV     #388,W3
00380:  ADD     W3,W0,W0
00382:  TBLRDL.B[W0],W0L
00384:  CLR.B   1
00386:  RETURN  
00388:  DATA    53,61,00
0038A:  DATA    6D,70,00
0038C:  DATA    6C,65,00
0038E:  DATA    73,20,00
00390:  DATA    70,65,00
00392:  DATA    72,20,00
00394:  DATA    73,65,00
00396:  DATA    63,2E,00
00398:  DATA    00,00,00
0039A:  CLR     32
0039C:  MOV     #3A6,W3
0039E:  ADD     W3,W0,W0
003A0:  TBLRDL.B[W0],W0L
003A2:  CLR.B   1
003A4:  RETURN  
003A6:  DATA    20,20,00
003A8:  DATA    20,20,00
003AA:  DATA    41,76,00
003AC:  DATA    65,72,00
003AE:  DATA    61,67,00
003B0:  DATA    65,00,00
003B2:  CLR     32
003B4:  MOV     #3BE,W3
003B6:  ADD     W3,W0,W0
003B8:  TBLRDL.B[W0],W0L
003BA:  CLR.B   1
003BC:  RETURN  
003BE:  DATA    20,52,00
003C0:  DATA    65,73,00
003C2:  DATA    65,74,00
003C4:  DATA    20,64,00
003C6:  DATA    65,76,00
003C8:  DATA    69,63,00
003CA:  DATA    65,3F,00
003CC:  DATA    00,00,00
003CE:  CLR     32
003D0:  MOV     #3DA,W3
003D2:  ADD     W3,W0,W0
003D4:  TBLRDL.B[W0],W0L
003D6:  CLR.B   1
003D8:  RETURN  
003DA:  DATA    20,20,00
003DC:  DATA    20,20,00
003DE:  DATA    59,65,00
003E0:  DATA    73,20,00
003E2:  DATA    2D,3E,00
003E4:  DATA    20,2B,00
003E6:  DATA    00,00,00
003E8:  CLR     32
003EA:  MOV     #3F4,W3
003EC:  ADD     W3,W0,W0
003EE:  TBLRDL.B[W0],W0L
003F0:  CLR.B   1
003F2:  RETURN  
003F4:  DATA    20,20,00
003F6:  DATA    20,20,00
003F8:  DATA    4E,6F,00
003FA:  DATA    20,20,00
003FC:  DATA    2D,3E,00
003FE:  DATA    20,2D,00
00400:  DATA    00,00,00
*
00726:  MOV     W1,32
00728:  CP0     W3
0072A:  BRA     Z,752
0072C:  BTSC.B  0.0
0072E:  BRA     73C
00730:  TBLRDL.B[W0++],[W2++]
00732:  DEC     W3,W3
00734:  BRA     Z,752
00736:  TBLRDL.B[W0],[W2++]
00738:  DEC     W3,W3
0073A:  BRA     Z,752
0073C:  DEC     W0,W0
0073E:  TBLRDH.B[W0++],[W2++]
00740:  DEC     W3,W3
00742:  BRA     Z,752
00744:  CLR.B   [W2++]
00746:  DEC     W3,W3
00748:  INC     W0,W0
0074A:  CP0     W0
0074C:  BTSC.B  42.1
0074E:  INC     0032
00750:  BRA     728
00752:  RETURN  
*
00B58:  MOV     W5,[W15++]
00B5A:  MOV     #C,W5
00B5C:  REPEAT  #3
00B5E:  MOV     [W5++],[W15++]
00B60:  MOV     #0,W9
00B62:  BTSC.B  43.0
00B64:  MOV     #1,W9
00B66:  MOV     W9,[W15++]
00B68:  XOR     W1,W3,W9
00B6A:  BTSS    W1.F
00B6C:  BRA     B74
00B6E:  COM     W1,W1
00B70:  NEG     W0,W0
00B72:  ADDC    W1,#0,W1
00B74:  BTSS    W3.F
00B76:  BRA     B7E
00B78:  COM     W3,W3
00B7A:  NEG     W2,W2
00B7C:  ADDC    W3,#0,W3
00B7E:  XOR     W2,W3,W4
00B80:  BRA     Z,BAC
00B82:  CLR     W4
00B84:  CLR     W5
00B86:  CLR     W6
00B88:  CLR     W7
00B8A:  MOV     #20,W8
00B8C:  BCLR.B  42.0
00B8E:  RLC     W0,W0
00B90:  RLC     W1,W1
00B92:  RLC     W4,W4
00B94:  RLC     W5,W5
00B96:  CP      W5,W3
00B98:  BRA     NZ,B9C
00B9A:  CPB     W4,W2
00B9C:  BRA     NC,BA4
00B9E:  SUB     W4,W2,W4
00BA0:  SUBB    W5,W3,W5
00BA2:  BSET.B  42.0
00BA4:  RLC     W6,W6
00BA6:  RLC     W7,W7
00BA8:  DEC     W8,W8
00BAA:  BRA     NZ,B8C
00BAC:  BTSS    W9.F
00BAE:  BRA     BBE
00BB0:  NEG     W6,W0
00BB2:  BRA     Z,BB6
00BB4:  BRA     NZ,BBA
00BB6:  NEG     W7,W1
00BB8:  BRA     BC4
00BBA:  COM     W7,W1
00BBC:  BRA     BC4
00BBE:  MOV     W7,W1
00BC0:  MOV     W6,W0
00BC2:  BRA     BC4
00BC4:  MOV     [--W15],W9
00BC6:  CP0     W9
00BC8:  BRA     Z,BCC
00BCA:  MOV.D   W4,W0
00BCC:  MOV     #12,W5
00BCE:  REPEAT  #3
00BD0:  MOV     [--W15],[W5--]
00BD2:  MOV     [--W15],W5
00BD4:  RETURN  
*
00DF2:  MOV     W5,[W15++]
00DF4:  MOV     #C,W5
00DF6:  REPEAT  #3
00DF8:  MOV     [W5++],[W15++]
00DFA:  MUL.UU  W0,W2,W4
00DFC:  BTSS    W3.F
00DFE:  BRA     E04
00E00:  MUL.SS  W0,W3,W6
00E02:  BRA     E06
00E04:  MUL.UU  W0,W3,W6
00E06:  BCLR.B  42.0
00E08:  ADD     W6,W5,W5
00E0A:  ADDC    W7,#0,W8
00E0C:  BTSS    W1.F
00E0E:  BRA     E14
00E10:  MUL.SS  W1,W2,W6
00E12:  BRA     E16
00E14:  MUL.UU  W1,W2,W6
00E16:  ADDC    W6,W5,W5
00E18:  ADDC    W7,W8,W8
00E1A:  ADDC    #0,W9
00E1C:  MUL.SS  W1,W3,W6
00E1E:  ADDC    W6,W8,W8
00E20:  ADDC    W9,W7,W7
00E22:  MOV     W7,W3
00E24:  MOV     W8,W2
00E26:  MOV     W5,W1
00E28:  MOV     W4,W0
00E2A:  MOV     #12,W5
00E2C:  REPEAT  #3
00E2E:  MOV     [--W15],[W5--]
00E30:  MOV     [--W15],W5
00E32:  RETURN  
00E34:  MOV     W5,[W15++]
00E36:  MOV     #C,W5
00E38:  REPEAT  #3
00E3A:  MOV     [W5++],[W15++]
00E3C:  MOV     W0,W4
00E3E:  MOV     W1,W5
00E40:  MOV     W2,W6
00E42:  MOV     W3,W7
00E44:  CLR     W0
00E46:  CLR     W1
00E48:  CLR     W2
00E4A:  CLR     W3
00E4C:  BCLR    W8.0
00E4E:  BTSS    W7.F
00E50:  BRA     E5C
00E52:  BSET    W8.0
00E54:  NEG     W4,W4
00E56:  COM     W5,W5
00E58:  COM     W6,W6
00E5A:  COM     W7,W7
00E5C:  IOR      W4,  W5,W9
00E5E:  BRA     NZ,E64
00E60:  IOR      W6,  W7,W9
00E62:  BRA     Z,E8E
00E64:  MOV     #473,W9
00E66:  BTSC    W3.4
00E68:  BRA     E80
00E6A:  BCLR.B  42.0
00E6C:  RLC     W4,W4
00E6E:  RLC     W5,W5
00E70:  RLC     W6,W6
00E72:  RLC     W7,W7
00E74:  RLC     W0,W0
00E76:  RLC     W1,W1
00E78:  RLC     W2,W2
00E7A:  RLC     W3,W3
00E7C:  DEC     W9,W9
00E7E:  BRA     NZ,E66
00E80:  SL      W9,#4,W9
00E82:  BCLR.B  42.0
00E84:  BCLR    W9.F
00E86:  BCLR    W3.4
00E88:  XOR     W9,W3,W3
00E8A:  BTSC    W8.0
00E8C:  BSET    W3.F
00E8E:  MOV     #12,W5
00E90:  REPEAT  #3
00E92:  MOV     [--W15],[W5--]
00E94:  MOV     [--W15],W5
00E96:  RETURN  
00E98:  MOV     W8,[W15++]
00E9A:  MOV     #12,W8
00E9C:  REPEAT  #4
00E9E:  MOV     [W8++],[W15++]
00EA0:  CLR     W11
00EA2:  MUL.UU  W12,#0,W12
00EA4:  MOV     W3,W8
00EA6:  MOV     W7,W9
00EA8:  MOV     #7FF,W10
00EAA:  BCLR.B  42.0
00EAC:  BCLR.B  42.1
00EAE:  ASR     W8,#4,W8
00EB0:  AND     W10,W8,W8
00EB2:  CP0     W8
00EB4:  BRA     Z,F98
00EB6:  BCLR.B  42.0
00EB8:  BCLR.B  42.1
00EBA:  ASR     W9,#4,W9
00EBC:  AND     W10,W9,W9
00EBE:  CP0     W9
00EC0:  BRA     Z,F98
00EC2:  ADD     W9,W8,W8
00EC4:  BTSC    W9.B
00EC6:  BRA     ED0
00EC8:  SUB     #3FF,W8
00ECA:  BRA     Z,F98
00ECC:  BRA     NC,F98
00ECE:  BRA     ED6
00ED0:  MOV     #401,W10
00ED2:  ADD.B   W10L,W5L,W5L
00ED4:  BRA     C,F98
00ED6:  XOR     W3,W7,W13
00ED8:  BCLR.B  42.0
00EDA:  BCLR.B  42.1
00EDC:  AND     #F,W3
00EDE:  BSET    W3.4
00EE0:  AND     #F,W7
00EE2:  BSET    W7.4
00EE4:  MOV     W8,[W15++]
00EE6:  MUL.UU  W4,W1,W8
00EE8:  MUL.UU  W5,W0,W10
00EEA:  ADD     W8,W10,W10
00EEC:  ADDC    W9,W11,W11
00EEE:  ADDC    #0,W12
00EF0:  MUL.UU  W4,W2,W8
00EF2:  ADD     W8,W11,W11
00EF4:  ADDC    W9,W12,W12
00EF6:  MUL.UU  W5,W1,W8
00EF8:  CLR     W10
00EFA:  ADD     W8,W11,W11
00EFC:  ADDC    W9,W12,W12
00EFE:  ADDC    #0,W10
00F00:  MUL.UU  W6,W0,W8
00F02:  ADD     W8,W11,W11
00F04:  ADDC    W9,W12,W12
00F06:  ADDC    #0,W10
00F08:  CLR     W11
00F0A:  MUL.UU  W4,W3,W8
00F0C:  ADD     W8,W12,W12
00F0E:  ADDC    W9,W10,W10
00F10:  ADDC    #0,W11
00F12:  MUL.UU  W5,W2,W8
00F14:  ADD     W8,W12,W12
00F16:  ADDC    W9,W10,W10
00F18:  ADDC    #0,W11
00F1A:  MUL.UU  W6,W1,W8
00F1C:  ADD     W8,W12,W12
00F1E:  ADDC    W9,W10,W10
00F20:  ADDC    #0,W11
00F22:  MUL.UU  W7,W0,W8
00F24:  ADD     W8,W12,W12
00F26:  ADDC    W9,W10,W10
00F28:  ADDC    #0,W11
00F2A:  MOV     W12,W0
00F2C:  CLR     W12
00F2E:  MUL.UU  W5,W3,W8
00F30:  ADD     W8,W10,W10
00F32:  ADDC    W9,W11,W11
00F34:  ADDC    #0,W12
00F36:  MUL.UU  W6,W2,W8
00F38:  ADD     W8,W10,W10
00F3A:  ADDC    W9,W11,W11
00F3C:  ADDC    #0,W12
00F3E:  MUL.UU  W6,W3,W8
00F40:  ADD     W8,W11,W11
00F42:  ADDC    W9,W12,W12
00F44:  MUL.UU  W7,W1,W8
00F46:  ADD     W8,W10,W10
00F48:  ADDC    W9,W11,W11
00F4A:  ADDC    #0,W12
00F4C:  MUL.UU  W7,W2,W8
00F4E:  ADD     W8,W11,W11
00F50:  ADDC    W9,W12,W12
00F52:  MUL.UU  W7,W3,W8
00F54:  ADD     W8,W12,W12
00F56:  MOV     W10,W1
00F58:  MOV     W11,W2
00F5A:  MOV     W12,W3
00F5C:  MOV     #5,W4
00F5E:  BCLR.B  42.0
00F60:  RRC     W3,W3
00F62:  RRC     W2,W2
00F64:  RRC     W1,W1
00F66:  RRC     W0,W0
00F68:  DEC     W4,W4
00F6A:  BRA     NZ,F5E
00F6C:  MOV     [--W15],W8
00F6E:  INC     W8,W8
00F70:  IOR      W0,  W1,W6
00F72:  BRA     Z,F76
00F74:  BRA     F7A
00F76:  IOR      W2,  W3,W6
00F78:  BRA     Z,F8A
00F7A:  BTSC    W3.4
00F7C:  BRA     F8A
00F7E:  BCLR.B  42.0
00F80:  RLC     W0,W0
00F82:  RLC     W1,W1
00F84:  RLC     W2,W2
00F86:  RLC     W3,W3
00F88:  DEC     W8,W8
00F8A:  SL      W8,#4,W8
00F8C:  BCLR    W3.F
00F8E:  BTSC    W13.F
00F90:  BSET    W3.F
00F92:  BCLR    W3.4
00F94:  XOR     W8,W3,W3
00F96:  BRA     F9E
00F98:  MUL.UU  W0,#0,W0
00F9A:  MUL.UU  W0,#0,W2
00F9C:  BRA     F9E
00F9E:  MOV     #1A,W8
00FA0:  REPEAT  #4
00FA2:  MOV     [--W15],[W8--]
00FA4:  MOV     [--W15],W8
00FA6:  RETURN  
00FA8:  MOV     W5,[W15++]
00FAA:  MOV     #C,W5
00FAC:  REPEAT  #3
00FAE:  MOV     [W5++],[W15++]
00FB0:  MOV     W0,W4
00FB2:  MOV     W1,W5
00FB4:  MOV     W2,W6
00FB6:  MOV     W3,W7
00FB8:  CLR     W0
00FBA:  CLR     W1
00FBC:  CLR     W2
00FBE:  CLR     W3
00FC0:  BCLR    W8.0
00FC2:  BTSS    W7.F
00FC4:  BRA     FD0
00FC6:  BSET    W8.0
00FC8:  NEG     W4,W4
00FCA:  COM     W5,W5
00FCC:  COM     W6,W6
00FCE:  COM     W7,W7
00FD0:  IOR      W4,  W5,W9
00FD2:  BRA     NZ,FD8
00FD4:  IOR      W6,  W7,W9
00FD6:  BRA     Z,1002
00FD8:  MOV     #473,W9
00FDA:  BTSC    W3.4
00FDC:  BRA     FF4
00FDE:  BCLR.B  42.0
00FE0:  RLC     W4,W4
00FE2:  RLC     W5,W5
00FE4:  RLC     W6,W6
00FE6:  RLC     W7,W7
00FE8:  RLC     W0,W0
00FEA:  RLC     W1,W1
00FEC:  RLC     W2,W2
00FEE:  RLC     W3,W3
00FF0:  DEC     W9,W9
00FF2:  BRA     NZ,FDA
00FF4:  SL      W9,#4,W9
00FF6:  BCLR.B  42.0
00FF8:  BCLR    W9.F
00FFA:  BCLR    W3.4
00FFC:  XOR     W9,W3,W3
00FFE:  BTSC    W8.0
01000:  BSET    W3.F
01002:  MOV     #12,W5
01004:  REPEAT  #3
01006:  MOV     [--W15],[W5--]
01008:  MOV     [--W15],W5
0100A:  RETURN  
0100C:  MOV     W8,[W15++]
0100E:  MOV     #12,W8
01010:  REPEAT  #4
01012:  MOV     [W8++],[W15++]
01014:  XOR     W3,W7,W13
01016:  MOV     W3,W8
01018:  MOV     W7,W9
0101A:  MOV     #7FF,W10
0101C:  BCLR.B  42.0
0101E:  BCLR.B  42.1
01020:  ASR     W8,#4,W8
01022:  AND     W10,W8,W8
01024:  CP0     W8
01026:  BRA     Z,1100
01028:  BCLR.B  42.0
0102A:  BCLR.B  42.1
0102C:  ASR     W9,#4,W9
0102E:  AND     W10,W9,W9
01030:  CP0     W9
01032:  BRA     Z,1100
01034:  CLR     W10
01036:  SUB     W8,W9,W12
01038:  BRA     NC,1040
0103A:  ADD     #3FF,W12
0103C:  BRA     C,1100
0103E:  BRA     1048
01040:  MOV     #401,W11
01042:  SUB     W12,W11,W12
01044:  BRA     NC,1100
01046:  BRA     Z,1100
01048:  CLR     W8
0104A:  CLR     W9
0104C:  CLR     W10
0104E:  CLR     W11
01050:  AND     #1F,W3
01052:  BSET    W3.4
01054:  AND     #1F,W7
01056:  BSET    W7.4
01058:  MOV     W12,[W15++]
0105A:  MOV     #36,W12
0105C:  SUB     W0,W4,W0
0105E:  SUBB    W1,W5,W1
01060:  SUBB    W2,W6,W2
01062:  SUBB    W3,W7,W3
01064:  BRA     N,106A
01066:  BRA     C,1074
01068:  BRA     NZ,1076
0106A:  ADD     W0,W4,W0
0106C:  ADDC    W1,W5,W1
0106E:  ADDC    W2,W6,W2
01070:  ADDC    W3,W7,W3
01072:  BRA     1076
01074:  BSET    W8.0
01076:  DEC     W12,W12
01078:  BRA     Z,1090
0107A:  BCLR.B  42.0
0107C:  RLC     W0,W0
0107E:  RLC     W1,W1
01080:  RLC     W2,W2
01082:  RLC     W3,W3
01084:  BCLR.B  42.0
01086:  RLC     W8,W8
01088:  RLC     W9,W9
0108A:  RLC     W10,W10
0108C:  RLC     W11,W11
0108E:  BRA     105C
01090:  MOV     [--W15],W12
01092:  BTSC    W11.5
01094:  BRA     1098
01096:  BRA     10A4
01098:  BCLR.B  42.0
0109A:  RRC     W11,W11
0109C:  RRC     W10,W10
0109E:  RRC     W9,W9
010A0:  RRC     W8,W8
010A2:  BRA     10AA
010A4:  DEC     W12,W12
010A6:  BCLR.B  42.0
010A8:  BRA     Z,1100
010AA:  BTSC.B  42.0
010AC:  BRA     10C0
010AE:  RLC     W0,W0
010B0:  RLC     W1,W1
010B2:  RLC     W2,W2
010B4:  RLC     W3,W3
010B6:  SUB     W0,W4,W4
010B8:  SUBB    W1,W5,W5
010BA:  SUBB    W2,W6,W6
010BC:  SUBB    W3,W7,W7
010BE:  BRA     NC,10EA
010C0:  INC     W8,W8
010C2:  BRA     NZ,10EA
010C4:  INC     W9,W9
010C6:  BRA     NZ,10EA
010C8:  INC     W10,W10
010CA:  BRA     NZ,10EA
010CC:  INC     W11,W11
010CE:  BRA     NZ,10EA
010D0:  INC     W12,W12
010D2:  BRA     Z,1100
010D4:  BRA     10EA
010D6:  DEC     W12,W12
010D8:  BRA     Z,1100
010DA:  BTSC    W11.4
010DC:  BRA     10EA
010DE:  BCLR.B  42.0
010E0:  RLC     W8,W8
010E2:  RLC     W9,W9
010E4:  RLC     W10,W10
010E6:  RLC     W11,W11
010E8:  BRA     10DA
010EA:  SL      W12,#4,W12
010EC:  BCLR.B  42.0
010EE:  BCLR    W12.F
010F0:  BTSC    W13.F
010F2:  BSET    W12.F
010F4:  BCLR    W11.4
010F6:  XOR     W12,W11,W3
010F8:  MOV     W10,W2
010FA:  MOV     W9,W1
010FC:  MOV     W8,W0
010FE:  BRA     110A
01100:  MOV     #0,W0
01102:  MOV     #0,W1
01104:  MOV     #0,W2
01106:  MOV     #0,W3
01108:  BRA     110A
0110A:  MOV     #1A,W8
0110C:  REPEAT  #4
0110E:  MOV     [--W15],[W8--]
01110:  MOV     [--W15],W8
01112:  RETURN  
01114:  MOV     W5,[W15++]
01116:  MOV     W2,W3
01118:  MOV     W2,W5
0111A:  BCLR.B  42.0
0111C:  RLC     W3,W3
0111E:  SWAP    W3
01120:  AND     #FF,W3
01122:  BRA     NZ,112A
01124:  MUL.UU  W0,#0,W0
01126:  MUL.UU  W2,#0,W2
01128:  BRA     1156
0112A:  ADD     #380,W3
0112C:  AND     #7F,W2
0112E:  MOV     #3,W6
01130:  CLR     W4
01132:  BCLR.B  42.0
01134:  RRC     W2,W2
01136:  RRC     W1,W1
01138:  RRC     W0,W0
0113A:  BTSC.B  42.0
0113C:  INC     W4,W4
0113E:  DEC     W6,W6
01140:  BRA     NZ,1132
01142:  BCLR    W2.7
01144:  SL      W3,#4,W3
01146:  BCLR    W3.F
01148:  BTSC    W5.F
0114A:  BSET    W3.F
0114C:  XOR     W2,W3,W3
0114E:  MOV     W1,W2
01150:  MOV     W0,W1
01152:  ADD     W4,W1,W1
01154:  CLR     W0
01156:  MOV     [--W15],W5
01158:  RETURN  
0115A:  MOV     W5,[W15++]
0115C:  MOV     W6,[W15++]
0115E:  MOV     W3,W4
01160:  MOV     W3,W6
01162:  BCLR.B  42.0
01164:  ASR     W4,#4,W4
01166:  MOV     #7FF,W5
01168:  AND     W5,W4,W4
0116A:  BRA     NZ,1172
0116C:  MUL.UU  W0,#0,W0
0116E:  CLR     W2
01170:  BRA     1198
01172:  SUB     #380,W4
01174:  AND     #F,W3
01176:  MOV     #3,W7
01178:  BCLR.B  42.0
0117A:  RLC     W0,W0
0117C:  RLC     W1,W1
0117E:  RLC     W2,W2
01180:  RLC     W3,W3
01182:  DEC     W7,W7
01184:  BRA     NZ,1178
01186:  MOV     W1,W0
01188:  MOV     W2,W1
0118A:  BCLR    W3.7
0118C:  SWAP    W4
0118E:  BCLR.B  42.0
01190:  RRC     W4,W4
01192:  BTSC    W6.F
01194:  BSET    W4.F
01196:  XOR     W4,W3,W2
01198:  MOV     [--W15],W6
0119A:  MOV     [--W15],W5
0119C:  RETURN  
0119E:  MOV     W5,[W15++]
011A0:  MOV     W6,[W15++]
011A2:  MOV     W0,W4
011A4:  MOV     W1,W5
011A6:  CLR     W0
011A8:  CLR     W1
011AA:  BCLR    W6.0
011AC:  BTSS    W5.F
011AE:  BRA     11BC
011B0:  BSET    W6.0
011B2:  NEG     W4,W4
011B4:  BRA     Z,11BA
011B6:  COM     W5,W5
011B8:  BRA     11BC
011BA:  NEG     W5,W5
011BC:  IOR      W4,  W5,W3
011BE:  BRA     Z,11E6
011C0:  CLR     W2
011C2:  MOV     #B6,W1
011C4:  BTSC    W2.7
011C6:  BRA     11D6
011C8:  BCLR.B  42.0
011CA:  RLC     W4,W4
011CC:  RLC     W5,W5
011CE:  RLC     W0,W0
011D0:  RLC     W2,W2
011D2:  DEC     W1,W1
011D4:  BRA     NZ,11C4
011D6:  SWAP    W1
011D8:  BCLR.B  42.0
011DA:  RRC     W1,W1
011DC:  BCLR    W1.F
011DE:  BCLR    W2.7
011E0:  XOR.B   W2L,W1L,W1L
011E2:  BTSC    W6.0
011E4:  BSET    W1.F
011E6:  MOV     [--W15],W6
011E8:  MOV     [--W15],W5
011EA:  RETURN  
011EC:  MOV     W5,[W15++]
011EE:  MOV     #C,W5
011F0:  REPEAT  #4
011F2:  MOV     [W5++],[W15++]
011F4:  MOV     W0,W4
011F6:  MOV     W1,W5
011F8:  MOV     W3,W7
011FA:  MOV     W2,W6
011FC:  BCLR.B  42.0
011FE:  BCLR.B  42.1
01200:  RLC     W1,W1
01202:  SWAP    W1
01204:  AND     #FF,W1
01206:  CP0     W1
01208:  BRA     Z,12A0
0120A:  BCLR.B  42.0
0120C:  BCLR.B  42.1
0120E:  RLC     W3,W3
01210:  SWAP    W3
01212:  AND     #FF,W3
01214:  CP0     W3
01216:  BRA     Z,12A0
01218:  ZE      W0,W0
0121A:  ADD.B   W3L,W1L,W0L
0121C:  BRA     C,1226
0121E:  SUB     #7F,W0
01220:  BRA     Z,12A0
01222:  BRA     NC,12A0
01224:  BRA     122A
01226:  ADD.B   #81,W0L
01228:  BRA     C,12A0
0122A:  XOR     W5,W7,W10
0122C:  BCLR.B  42.0
0122E:  BCLR.B  42.1
01230:  AND     #FF,W5
01232:  BSET    W5.7
01234:  BCLR.B  42.0
01236:  AND     #FF,W7
01238:  BSET    W7.7
0123A:  MUL.UU  W4,W6,W2
0123C:  MUL.UU  W5,W6,W8
0123E:  ADDC    W8,W3,W3
01240:  MOV     W9,W1
01242:  BTSC.B  42.0
01244:  INC     W1,W1
01246:  BCLR.B  42.0
01248:  MUL.UU  W7,W4,W8
0124A:  ADDC    W8,W3,W3
0124C:  ADDC    W9,W1,W1
0124E:  MUL.UU  W5,W7,W8
01250:  ADDC    W8,W1,W1
01252:  INC     W0,W0
01254:  CP0     W1
01256:  BTSC.B  42.1
01258:  BRA     125C
0125A:  BRA     1262
0125C:  CP0     W3
0125E:  BTSC.B  42.1
01260:  BRA     126C
01262:  BTSC    W1.F
01264:  BRA     126C
01266:  RLC     W3,W3
01268:  RLC     W1,W1
0126A:  DEC     W0,W0
0126C:  MOV     W1,W2
0126E:  BCLR.B  42.0
01270:  BTSS    W3.7
01272:  BRA     1286
01274:  MOV     #FF00,W7
01276:  AND     W3,W7,W3
01278:  ADD     #100,W3
0127A:  ADDC    W2,#0,W2
0127C:  CP0     W2
0127E:  BRA     NZ,1286
01280:  CP0     W3
01282:  BRA     NZ,1286
01284:  INC     W0,W0
01286:  SWAP    W0
01288:  BCLR.B  42.0
0128A:  BCLR.B  42.1
0128C:  RRC     W0,W1
0128E:  BTSC    W10.F
01290:  BSET    W1.F
01292:  BCLR    W2.F
01294:  SWAP    W2
01296:  XOR.B   W2L,W1L,W1L
01298:  SWAP    W3
0129A:  MOV.B   W3L,W2L
0129C:  MOV     W2,W0
0129E:  BRA     12A6
012A0:  MOV     #0,W0
012A2:  MOV     #0,W1
012A4:  BRA     12A6
012A6:  MOV     #14,W5
012A8:  REPEAT  #4
012AA:  MOV     [--W15],[W5--]
012AC:  MOV     [--W15],W5
012AE:  RETURN  
012B0:  MOV     W5,[W15++]
012B2:  MOV     W1,W5
012B4:  MOV     W0,W2
012B6:  MOV     #B6,W4
012B8:  RLC     W1,W1
012BA:  SWAP    W1
012BC:  AND     #FF,W1
012BE:  SUB.B   W4L,W1L,W4L
012C0:  MOV.B   W5L,W3L
012C2:  BSET    W3.7
012C4:  AND     #FF,W3
012C6:  CLR     W0
012C8:  CLR     W1
012CA:  CP      W4,#18
012CC:  BRA     N,12EC
012CE:  BCLR.B  42.0
012D0:  RRC     W3,W3
012D2:  RRC     W2,W2
012D4:  RRC     W1,W1
012D6:  RRC     W0,W0
012D8:  DEC     W4,W4
012DA:  BRA     NZ,12CE
012DC:  BTSS    W5.F
012DE:  BRA     12EC
012E0:  NEG     W0,W0
012E2:  BRA     Z,12E8
012E4:  COM     W1,W1
012E6:  BRA     12EC
012E8:  NEG     W1,W1
012EA:  BRA     12EC
012EC:  MOV     [--W15],W5
012EE:  RETURN  
*
0142A:  MOV     W5,[W15++]
0142C:  MOV     #C,W5
0142E:  REPEAT  #3
01430:  MOV     [W5++],[W15++]
01432:  MOV     #0,W9
01434:  BTSC.B  43.0
01436:  MOV     #1,W9
01438:  MOV     W9,[W15++]
0143A:  CLR     W4
0143C:  CLR     W5
0143E:  CLR     W6
01440:  CLR     W7
01442:  XOR     W2,W3,W8
01444:  BRA     Z,1468
01446:  MOV     #20,W8
01448:  BCLR.B  42.0
0144A:  RLC     W0,W0
0144C:  RLC     W1,W1
0144E:  RLC     W4,W4
01450:  RLC     W5,W5
01452:  CP      W5,W3
01454:  BRA     NZ,1458
01456:  CPB     W4,W2
01458:  BRA     NC,1460
0145A:  SUB     W4,W2,W4
0145C:  SUBB    W5,W3,W5
0145E:  BSET.B  42.0
01460:  RLC     W6,W6
01462:  RLC     W7,W7
01464:  DEC     W8,W8
01466:  BRA     NZ,1448
01468:  MOV     W7,W1
0146A:  MOV     W6,W0
0146C:  MOV     [--W15],W9
0146E:  CP0     W9
01470:  BRA     Z,1474
01472:  MOV.D   W4,W0
01474:  MOV     #12,W5
01476:  REPEAT  #3
01478:  MOV     [--W15],[W5--]
0147A:  MOV     [--W15],W5
0147C:  RETURN  
0147E:  MOV     W5,[W15++]
01480:  MOV     #C,W5
01482:  REPEAT  #3
01484:  MOV     [W5++],[W15++]
01486:  MUL.UU  W0,W2,W4
01488:  MUL.UU  W0,W3,W6
0148A:  BCLR.B  42.0
0148C:  ADD     W6,W5,W5
0148E:  ADDC    W7,#0,W8
01490:  MUL.UU  W1,W2,W6
01492:  ADDC    W6,W5,W5
01494:  ADDC    W7,W8,W8
01496:  MUL.UU  W1,W3,W6
01498:  ADD     W6,W8,W8
0149A:  ADDC    #0,W7
0149C:  MOV     W7,W3
0149E:  MOV     W8,W2
014A0:  MOV     W5,W1
014A2:  MOV     W4,W0
014A4:  MOV     #12,W5
014A6:  REPEAT  #3
014A8:  MOV     [--W15],[W5--]
014AA:  MOV     [--W15],W5
014AC:  RETURN  
*
016C2:  MOV     W6,[W15++]
016C4:  MOV     W7,[W15++]
016C6:  MOV     W8,[W15++]
016C8:  MOV     W9,[W15++]
016CA:  CLR     W4
016CC:  CLR     W5
016CE:  CLR     W6
016D0:  CLR     W7
016D2:  XOR     W2,W3,W8
016D4:  BRA     Z,16F8
016D6:  MOV     #20,W8
016D8:  BCLR.B  42.0
016DA:  RLC     W0,W0
016DC:  RLC     W1,W1
016DE:  RLC     W4,W4
016E0:  RLC     W5,W5
016E2:  CP      W5,W3
016E4:  BRA     NZ,16E8
016E6:  CPB     W4,W2
016E8:  BRA     NC,16F0
016EA:  SUB     W4,W2,W4
016EC:  SUBB    W5,W3,W5
016EE:  BSET.B  42.0
016F0:  RLC     W6,W6
016F2:  RLC     W7,W7
016F4:  DEC     W8,W8
016F6:  BRA     NZ,16D8
016F8:  MOV     W7,W1
016FA:  MOV     W6,W0
016FC:  MOV     [--W15],W9
016FE:  MOV     [--W15],W8
01700:  MOV     [--W15],W7
01702:  MOV     [--W15],W6
01704:  RETURN  
01706:  MOV     W5,[W15++]
01708:  MOV     #C,W5
0170A:  REPEAT  #7
0170C:  MOV     [W5++],[W15++]
0170E:  MOV     W0,W6
01710:  MOV     W1,W7
01712:  MOV     W4,W12
01714:  BCLR    W4.F
01716:  CP0     W4
01718:  BRA     NZ,171E
0171A:  MOV     #0,W5
0171C:  BRA     1738
0171E:  SUB.B   W4L,#B,W5L
01720:  BRA     NC,1736
01722:  MOV     #30,W0
01724:  BTSS    W12.F
01726:  MOV     #20,W0
01728:  BTSC.B  233.1
0172A:  BRA     1728
0172C:  MOV     W0,234
0172E:  DEC     W5,W5
01730:  BRA     NN,1728
01732:  MOV     #A,W5
01734:  BRA     1738
01736:  MOV     W4,W5
01738:  MOV     #10,W8
0173A:  MOV     #0,W9
0173C:  LNK     #10
0173E:  MOV     W12,[W14+W8]
01740:  DEC2    W8,W8
01742:  BRA     NN,173E
01744:  MOV     #A,W4
01746:  BSET    W5.E
01748:  BTSC    W12.F
0174A:  BSET    W5.F
0174C:  MOV     W4,[W14]
0174E:  MOV     W5,[W14+#2]
01750:  MOV     W6,W0
01752:  MOV     W7,W1
01754:  MOV     #CA00,W2
01756:  MOV     #3B9A,W3
01758:  MOV     #2710,W8
0175A:  BCLR    W13.F
0175C:  BTG     W13.F
0175E:  CALL    16C2
01762:  BTSC    W13.F
01764:  BRA     1774
01766:  MOV     W0,[W14+#8]
01768:  MOV     W1,[W14+#A]
0176A:  MOV     W0,W2
0176C:  MOV     W1,W3
0176E:  MOV     [W14+#4],W0
01770:  MOV     [W14+#6],W1
01772:  BRA     175C
01774:  MOV     W2,[W14+#8]
01776:  MOV     W3,[W14+#A]
01778:  MOV     W4,[W14+#4]
0177A:  MOV     W5,[W14+#6]
0177C:  MOV     [W14],W4
0177E:  MOV     [W14+#2],W5
01780:  MOV     #30,W6
01782:  CP0     W0
01784:  BRA     NZ,17A8
01786:  BTSS    W5.E
01788:  BRA     17AC
0178A:  DEC     W4,W4
0178C:  MOV     W4,[W14]
0178E:  CP0     W4
01790:  BRA     Z,17AC
01792:  CP.B    W4L,W5L
01794:  BTSC.B  42.0
01796:  BRA     17B4
01798:  MOV     #30,W6
0179A:  CP0     W0
0179C:  BRA     NZ,17A8
0179E:  BTSS    W5.E
017A0:  BRA     17AC
017A2:  BTSS    W5.F
017A4:  MOV     #20,W6
017A6:  BRA     17AC
017A8:  BCLR    W5.E
017AA:  MOV     W5,[W14+#2]
017AC:  ADD.B   W6L,W0L,W0L
017AE:  BTSC.B  233.1
017B0:  BRA     17AE
017B2:  MOV     W0,234
017B4:  MOV     [W14+#8],W0
017B6:  MOV     [W14+#A],W1
017B8:  MOV     #A,W2
017BA:  CLR     W3
017BC:  CP      W0,#1
017BE:  BRA     Z,17C2
017C0:  BRA     175C
017C2:  ULNK    
017C4:  MOV     #1A,W5
017C6:  REPEAT  #7
017C8:  MOV     [--W15],[W5--]
017CA:  MOV     [--W15],W5
017CC:  RETURN  
*
01F4E:  PUSH    42
01F50:  MOV     W0,[W15++]
01F52:  BCLR.B  81.7
01F54:  MOV     42,W4
01F56:  IOR     #E0,W4
01F58:  MOV     W4,42
01F5A:  BSET.B  81.7
01F5C:  MOV     W1,760
01F5E:  MOV     #55,W4
01F60:  MOV     W4,766
01F62:  MOV     #AA,W4
01F64:  MOV     W4,766
01F66:  BSET.B  761.7
01F68:  NOP     
01F6A:  NOP     
01F6C:  MOV     [--W15],W0
01F6E:  BCLR.B  81.7
01F70:  POP     42
01F72:  BSET.B  81.7
01F74:  RETURN  
01F76:  MOV     W5,[W15++]
01F78:  MOV     #C,W5
01F7A:  REPEAT  #3
01F7C:  MOV     [W5++],[W15++]
01F7E:  BCLR    W3.0
01F80:  BCLR    W3.1
01F82:  CP0     W3
01F84:  BRA     Z,1FEE
01F86:  BCLR    W0.0
01F88:  BCLR    W2.0
01F8A:  MOV     W1,32
01F8C:  MOV     W0,W1
01F8E:  MOV     #FFFF,W4
01F90:  MOV     #7F,W0
01F92:  AND     W0,W1,W0
01F94:  BRA     Z,1FA6
01F96:  MOV     W1,[W15++]
01F98:  LSR     W1,#7,W1
01F9A:  SL      W1,#7,W1
01F9C:  TBLWTL  W4,[W1]
01F9E:  TBLWTH  W4,[W1++]
01FA0:  SUB     W0,#2,W0
01FA2:  BRA     NZ,1F9C
01FA4:  MOV     [--W15],W1
01FA6:  MOV     #3FF,W0
01FA8:  AND     W0,W1,W0
01FAA:  BRA     NZ,1FB8
01FAC:  TBLWTL  W0,[W1]
01FAE:  MOV     W1,[W15++]
01FB0:  MOV     #4042,W1
01FB2:  CALL    1F4E
01FB6:  MOV     [--W15],W1
01FB8:  TBLWTL  [W2++],[W1]
01FBA:  TBLWTH  [W2++],[W1++]
01FBC:  CP0     W1
01FBE:  BTSC.B  42.1
01FC0:  INC     0032
01FC2:  MOV     #7F,W0
01FC4:  AND     W1,W0,W0
01FC6:  BRA     NZ,1FD2
01FC8:  MOV     W1,[W15++]
01FCA:  MOV     #4001,W1
01FCC:  CALL    1F4E
01FD0:  MOV     [--W15],W1
01FD2:  SUB     W3,#4,W3
01FD4:  BRA     NZ,1FA6
01FD6:  MOV     #7F,W0
01FD8:  AND     W1,W0,W0
01FDA:  BRA     Z,1FEE
01FDC:  MOV     #FFFF,W4
01FDE:  TBLWTL  W4,[W1]
01FE0:  TBLWTH  W4,[W1++]
01FE2:  MOV     #7F,W0
01FE4:  AND     W1,W0,W0
01FE6:  BRA     NZ,1FDE
01FE8:  MOV     #4001,W1
01FEA:  CALL    1F4E
01FEE:  MOV     #12,W5
01FF0:  REPEAT  #3
01FF2:  MOV     [--W15],[W5--]
01FF4:  MOV     [--W15],W5
01FF6:  RETURN  
....................  
.................... #list 
....................  
....................  
....................  
.................... //#FUSES PROTECT_HIGH            //General Segment Code Protect High Security 
.................... #FUSES WRTB                      //Boot block write protected 
.................... #FUSES CKSFSM                    //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES WDT                       //no Watch Dog Timer 
.................... #FUSES WPOSTS14                  //Watch Dog Timer PreScalar 1:8192 
.................... #FUSES PR_PLL                    //Primary Oscillator with PLL 
.................... #FUSES HS                        //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOWRT                     //Program memory not write protected 
.................... #use delay(clock=80M) 
*
00530:  CP0     W0
00532:  BTSC.B  42.1
00534:  BRA     546
00536:  REPEAT  #1C3B
00538:  NOP     
0053A:  REPEAT  #3FFE
0053C:  NOP     
0053E:  REPEAT  #3FFE
00540:  NOP     
00542:  DEC     W0,W0
00544:  BRA     NZ,536
00546:  RETURN  
....................  
.................... #WORD PLLFBD=0x0746 // osc PLL div reg 
.................... #WORD U2BRG=0x0238 
.................... #WORD U2MODE=0x0230 
....................  
.................... #WORD CLKDIV=0x0744  // osc con reg 
.................... #BIT PLLPOST1=CLKDIV.7 
.................... #BIT PLLPOST0=CLKDIV.6 
.................... #BIT PLLPRE4=CLKDIV.4 
.................... #BIT PLLPRE3=CLKDIV.3 
.................... #BIT PLLPRE2=CLKDIV.2 
.................... #BIT PLLPRE1=CLKDIV.1 
.................... #BIT PLLPRE0=CLKDIV.0 
....................  
.................... #WORD LATA=0x02C4  
.................... #WORD LATB=0x02CA 
.................... #WORD LATD=0x02D6 
.................... #WORD LATF=0x02E2 
.................... #WORD LATG=0x02E8   
.................... #WORD LATC=0x02D0 
....................  
.................... #use spi(spi2, FORCE_HW) 
.................... #use standard_io(B)//(B_outputs=PIN_B1, PIN_B2) 
....................  
.................... #define STATUS 0x00     // ADC1256 Register map 
.................... #define MUX 0x01  
.................... #define ADCON 0x02 
.................... #define DRATE 0x03 
.................... #define IO 0x04 
.................... #define OFCO 0x05 
.................... #define OFC1 0x06 
.................... #define OFC2 0x07 
.................... #define FSCO 0x08 
.................... #define FSC1 0x09 
.................... #define FSC2 0x0A 
....................  
.................... //#define uV 10000000  // для калибровки  
.................... #define uV 100000 // по умолчанию 
.................... #define mV 1000 
....................  
.................... #WORD PORTB=0x02C8 
.................... #WORD TRISB=0x02C6 
.................... #BIT  TRB0=TRISB.0 
.................... #BIT  TRB1=TRISB.1 
.................... #BIT  CN1_TRIS=TRISB.5 
.................... #BIT  CN2_TRIS=TRISB.4 
.................... #BIT  CN4_TRIS=TRISB.3 
.................... #BIT  CN3_TRIS=TRISB.2 
.................... #BIT  CN1=PORTB.5 
.................... #BIT  CN4=PORTB.3 
.................... #BIT  CN2=PORTB.4 
.................... #BIT  CN3=PORTB.2 
.................... #BIT  XPORT_RST_n=TRISB.15 
.................... #BIT  Status_LED_TRIS=TRISB.13 
.................... #BIT  TRB14=TRISB.14 
.................... #BIT  XPORT_RST_TRIS=TRISB.15 
.................... #BIT  RB1=LATB.1 
.................... #BIT  RB0=LATB.0 
.................... #BIT  Status_LED=LATB.13 
....................  
.................... #WORD PORTC=0x02CE 
.................... #WORD TRISC=0x02CC 
.................... //#BIT RC13=LATC.13 
.................... //#BIT RC14=LATC.14 
.................... #BIT RC13=PORTC.13 
.................... #BIT RC14=PORTC.14 
.................... #BIT  TRC13=TRISC.13 
.................... #BIT  TRC14=TRISC.14 
.................... #BIT  TRC1=TRISC.1 
.................... #BIT  TRC2=TRISC.2 
.................... #BIT  TRC4=TRISC.4 
.................... //_______________________________________ 
.................... #WORD PORTD=0x02D4 
.................... #WORD TRISD=0x02D2 
.................... #WORD ODCD=0x06D2 
....................  
.................... #BIT  TRD4=TRISD.4 
.................... #BIT  TRD5=TRISD.5 
.................... #BIT  TRD6=TRISD.6 
.................... #BIT  TRD7=TRISD.7 
.................... #BIT  TRD8=TRISD.8 
....................  
.................... #BIT  RD4=LATD.4 
.................... #BIT  RD5=LATD.5 
.................... #BIT  RD6=LATD.6 
.................... #BIT  RD7=LATD.7 
.................... #BIT  RD8=LATD.8 
.................... //_________________________________________________ 
.................... #WORD PORTF=0x02E0 
.................... #WORD TRISF=0x02DE 
.................... #BIT  UART2_RX_TRIS=TRISF.4 
.................... #BIT  UART2_TX_TRIS=TRISF.5 
....................  
.................... #WORD PORTG=0x02E6 
.................... #WORD TRISG=0x02E4 
.................... #BIT RG0=LATG.0 
.................... #BIT RG1=LATG.1 
.................... #BIT LCD_RW=LATG.12 
.................... #BIT LCD_RS=LATG.13 
.................... #BIT LCD_E=LATG.14 
.................... #BIT RG15=LATG.15 
.................... #BIT SCK2=LATG.6 // SPI2 pins 
.................... #BIT SDI2=LATG.7 
.................... #BIT SDO2=LATG.8 
.................... //#BIT SS2=LATG.9 
.................... #BIT SCK2_TRIS=TRISG.6 // SPI2 tris 
.................... #BIT SDI2_TRIS=TRISG.7 
.................... #BIT SDO2_TRIS=TRISG.8 
.................... #BIT TRG0=TRISG.0 
.................... #BIT TRG1=TRISG.1 
.................... #BIT LCD_RW_TRIS=TRISG.12 
.................... #BIT LCD_RS_TRIS=TRISG.13 
.................... #BIT LCD_E_TRIS=TRISG.14 
....................  
.................... //#BIT SS2_TRIS=TRISG.9 
....................  
.................... #define ADC_Dout SDI2 //???? Din ?? 
.................... #define ADC_Din SDO2  //???? Dout ?? 
....................  
.................... #BIT  ADC_RESET_TRIS=TRISD.3 
.................... #BIT  ADC2_RESET_TRIS=TRISD.0 
.................... #BIT  ADC_RESET=LATD.3 
.................... #BIT  ADC2_RESET=LATD.0 
....................  
.................... #BIT  ADC_SYNC_TRIS=TRISD.2 
.................... #BIT  ADC2_SYNC_TRIS=TRISD.11 
.................... #BIT  ADC_SYNC=LATD.2 
.................... #BIT  ADC2_SYNC=LATD.11 
....................  
.................... #BIT  ADC_CS_TRIS =TRISG.9 
.................... #BIT  ADC2_CS_TRIS=TRISD.10 
.................... #BIT  ADC_CS = LATG.9 
.................... #BIT  ADC2_CS= LATD.10 
....................  
.................... #BIT  ADC_DRDY_TRIS = TRISD.1 
.................... #BIT  ADC2_DRDY_TRIS= TRISD.9 
.................... #BIT  ADC_DRDY = PORTD.1 
.................... #BIT  ADC2_DRDY= PORTD.9 
....................  
.................... #define FCY      40000000 
.................... #define BAUDRATE 9600                 
.................... #define BRGVAL   ((FCY/BAUDRATE)/16)-1 
....................  
.................... #define CK_FLASH_END       (getenv("PROGRAM_MEMORY")-1)       
.................... #define CK_FLASH_PAGE_SIZE (getenv("FLASH_ERASE_SIZE")/2)  
.................... #define CK_NUM_PAGES (CK_FLASH_END/CK_FLASH_PAGE_SIZE)  
....................  
.................... #define CK_USER_PAGE (CK_FLASH_PAGE_SIZE*(CK_NUM_PAGES-1))  
....................  
.................... #org CK_USER_PAGE,CK_FLASH_END {}  
....................  
....................    typedef unsigned int16 U16; 
....................    typedef unsigned int8 U8; 
....................    typedef unsigned int32 U32; 
....................    typedef signed int32 S32; 
....................    typedef signed int16 S16; 
....................    typedef signed int8 S8; 
....................  
....................  
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #use rs232(UART2,baud=9600,parity=N,bits=8) 
....................  
....................    static S32 ADC_RByte1=0; 
....................    static S32 ADC_RByte2=0; 
....................    static S32 ADC_RByte3=0; 
....................    static S32 ADC_RByte_Sum=0; 
....................    static S32 ADCresult=0; 
....................    static float Vin;                           
....................    static U8 PGA; 
....................    //static float Vref=2.5; 
....................    static U8 Sps_buf,Global_Ch_Number=0; 
....................    static S16 ADCaddCoef; 
....................    static float ADCmulCoef; 
....................    float Final_T_in_K = 0; 
....................    U8 ostatok_int_dec,ostatok_int_sot  = 0; 
....................    U8 LCD_num_symb = 1;             // по умолчанию одна цифра для вывода Т на ЛСД 
....................    U8 flash_wr_data [] = {0,0,0,0}; // заготовка массива для записи во флэш 
....................    U8 Aver_Wr = 0; 
....................    U8 Sps_Wr = 0; 
....................    U8 CRC_Wr = 0; 
....................    U8 ADC_select = 0; // флаг выбора АЦП: 1ый или 2ой 
....................     
....................    U8 menu_item = 0; 
....................    volatile S8 menu_sel = 0; 
....................     
....................    U8 menu_fl = 0; 
....................    int1 meas_stop_fl = 0; 
....................    int1 LCD_clear_fl = 1; 
....................    int1 reset_fl = 0;    // флаг сброса системы 
....................     
....................    U8 NumAver = 1;       // размер усреднения 
....................    U8 ADC_sps_var = 1;   // переменная усреднения данных АЦП  
....................    U8 CRC1=0xFF,CRC2=0xFF, CRC_buf;   // константы EEPROM CRC 
....................    U8 flash_rd_data[4]; // заготовка массива для чтения из флэш 
....................    volatile S32 temp  = 0;        // промежуточный буфер для вычислений T 
....................       
.................... static unsigned int8 buf; // lcd buf 
.................... #BIT buf4=buf.4  
.................... #BIT buf5=buf.5 
.................... #BIT buf6=buf.6 
.................... #BIT buf7=buf.7 
....................     
....................  
.................... #include <LCD_16X4_Termo3.h> 
.................... /* 
.................... #define 'Б' 0xA0 
.................... #define 'Г' 0xA1 
.................... #define 'Ё' 0xA2 
.................... #define 'Ж' 0xA3 
.................... #define 'З' 0xA4 
.................... #define 'И' 0xA5 
.................... #define 'Й' 0xA6 
.................... #define 'Л' 0xA7 
.................... #define 'П' 0xA8 
.................... #define 'У' 0xA9 
.................... #define 'Ф' 0xAA 
.................... #define 'Ч' 0xAB 
.................... #define 'Ш' 0xAC 
.................... #define 'Ъ' 0xAD 
.................... #define 'Ы' 0xAE 
.................... #define 'Э' 0xAF 
.................... */ 
....................  
....................  
.................... #define one   0x00 
.................... #define two   0x40 
.................... #define three 0x10 
.................... #define four  0x50 
....................  
....................  
.................... static void LCDWriteNibble(unsigned char uc) 
.................... {                                            
....................   uc=uc << 4; /* Align with bits 7-4*/ 
00548:  MOV.B   868,W0L
0054A:  CLR.B   1
0054C:  SL      W0,#4,W0
0054E:  MOV.B   W0L,868
....................   LCD_RW=0; 
00550:  BCLR.B  2E9.4
....................   buf=uc; 
00552:  MOV.B   868,W0L
00554:  MOV.B   W0L,83F
....................   RG0=buf4; 
00556:  BCLR.B  2E8.0
00558:  BTSC.B  83F.4
0055A:  BSET.B  2E8.0
....................   RG1=buf5; 
0055C:  BCLR.B  2E8.1
0055E:  BTSC.B  83F.5
00560:  BSET.B  2E8.1
....................   RB1=buf6; 
00562:  BCLR.B  2CA.1
00564:  BTSC.B  83F.6
00566:  BSET.B  2CA.1
....................   RB0=buf7; 
00568:  BCLR.B  2CA.0
0056A:  BTSC.B  83F.7
0056C:  BSET.B  2CA.0
....................   //delay_ms(50); 
....................   delay_ms(1); 
0056E:  REPEAT  #1C3E
00570:  NOP     
00572:  REPEAT  #3FFF
00574:  NOP     
00576:  REPEAT  #3FFF
00578:  NOP     
....................   LCD_E=1; 
0057A:  BSET.B  2E9.6
....................   //delay_us(100); 
....................   delay_us(2); 
0057C:  REPEAT  #4E
0057E:  NOP     
....................   LCD_E=0; 
00580:  BCLR.B  2E9.6
....................   delay_us(100); 
00582:  REPEAT  #F9E
00584:  NOP     
....................   LCD_RW=1;    
00586:  BSET.B  2E9.4
00588:  RETURN  
.................... } 
....................  
.................... static void LCDWriteData(unsigned char uc) 
*
00664:  MOV     W5,[W15++]
.................... { 
....................    
....................     LCD_RS=0; 
00666:  BCLR.B  2E9.5
....................     //delay_ms(50); 
....................     delay_us(500); 
00668:  REPEAT  #E1E
0066A:  NOP     
0066C:  REPEAT  #3FFF
0066E:  NOP     
....................     LCD_RS=1; 
00670:  BSET.B  2E9.5
....................     LCD_RW=1;// ?????????????? ???????? ????????????? 
00672:  BSET.B  2E9.4
....................     LCDWriteNibble(uc>>4);//???? ???????? ??????? 
00674:  MOV     862,W5
00676:  CLR.B   B
00678:  CLR.B   B
0067A:  LSR     W5,#4,W5
0067C:  PUSH    868
0067E:  MOV.B   W5L,[W15-#2]
00680:  POP     868
00682:  CALL    548
....................     LCDWriteNibble(uc); 
00686:  MOV.B   862,W0L
00688:  MOV.B   W0L,868
0068A:  CALL    548
0068E:  MOV     [--W15],W5
00690:  RETURN  
....................    
.................... } 
....................  
.................... static void LCDCommand(unsigned char uc) 
*
0058A:  MOV     W5,[W15++]
.................... { 
....................     LCD_RS=0; /* Instruction mode */ 
0058C:  BCLR.B  2E9.5
....................     delay_us(500); 
0058E:  REPEAT  #E1E
00590:  NOP     
00592:  REPEAT  #3FFF
00594:  NOP     
....................     //delay_ms(5); 
....................     LCD_RW=1;// ?????????????? ???????? ????????????? 
00596:  BSET.B  2E9.4
....................     LCDWriteNibble(uc>>4); 
00598:  MOV     850,W5
0059A:  CLR.B   B
0059C:  CLR.B   B
0059E:  LSR     W5,#4,W5
005A0:  PUSH    868
005A2:  MOV.B   W5L,[W15-#2]
005A4:  POP     868
005A6:  CALL    548
....................     LCDWriteNibble(uc);   
005AA:  MOV.B   850,W0L
005AC:  MOV.B   W0L,868
005AE:  CALL    548
005B2:  MOV     [--W15],W5
005B4:  RETURN  
.................... } 
....................  
.................... static void LCDSetCursor(unsigned char ucPos) 
*
006A6:  MOV     W5,[W15++]
.................... { 
....................   LCDCommand(0x80 | ucPos); 
006A8:  MOV     84C,W5
006AA:  IOR     #80,W5
006AC:  PUSH    850
006AE:  MOV.B   W5L,[W15-#2]
006B0:  POP     850
006B2:  CALL    58A
006B6:  MOV     [--W15],W5
006B8:  RETURN  
.................... } 
....................  
.................... static void LCDClear(void) 
.................... { 
....................    LCDCommand(0x1); 
*
00656:  MOV.B   #1,W0L
00658:  MOV.B   W0L,850
0065A:  CALL    58A
....................    Delay_us(200); 
0065E:  REPEAT  #1F3E
00660:  NOP     
00662:  RETURN  
....................    //delay_ms(5); 
.................... } 
....................  
.................... static void LCDInit(void) 
.................... { 
....................   LCD_E=0; 
*
005B6:  BCLR.B  2E9.6
....................   LCD_RS=0; 
005B8:  BCLR.B  2E9.5
....................   //Delay_ms(1000); // 
....................   delay_ms(2000); 
005BA:  MOV     #7D0,W0
005BC:  CALL    530
....................   LCDWriteNibble(3); 
005C0:  MOV.B   #3,W0L
005C2:  MOV.B   W0L,868
005C4:  CALL    548
....................   //Delay_us(200); 
....................   Delay_ms(1); 
005C8:  REPEAT  #1C3E
005CA:  NOP     
005CC:  REPEAT  #3FFF
005CE:  NOP     
005D0:  REPEAT  #3FFF
005D2:  NOP     
....................   LCDWriteNibble(3); 
005D4:  MOV.B   #3,W0L
005D6:  MOV.B   W0L,868
005D8:  CALL    548
....................   Delay_ms(1); 
005DC:  REPEAT  #1C3E
005DE:  NOP     
005E0:  REPEAT  #3FFF
005E2:  NOP     
005E4:  REPEAT  #3FFF
005E6:  NOP     
....................   //Delay_us(200); 
....................   LCDWriteNibble(3); 
005E8:  MOV.B   #3,W0L
005EA:  MOV.B   W0L,868
005EC:  CALL    548
....................   Delay_ms(1); 
005F0:  REPEAT  #1C3E
005F2:  NOP     
005F4:  REPEAT  #3FFF
005F6:  NOP     
005F8:  REPEAT  #3FFF
005FA:  NOP     
....................   //Delay_us(200); 
....................   LCDWriteNibble(2); 
005FC:  MOV.B   #2,W0L
005FE:  MOV.B   W0L,868
00600:  CALL    548
....................   Delay_ms(1); 
00604:  REPEAT  #1C3E
00606:  NOP     
00608:  REPEAT  #3FFF
0060A:  NOP     
0060C:  REPEAT  #3FFF
0060E:  NOP     
....................   //Delay_us(200); 
....................    
....................   LCDCommand(0x28);//4-?????? ?????, 2 ??????, ????? 5x8 ????? 
00610:  MOV.B   #28,W0L
00612:  MOV.B   W0L,850
00614:  CALL    58A
....................    
....................   LCDCommand(0x08);// ????????? ???????, ????????? ??????, ????????? ???????? ??????? 
00618:  MOV.B   #8,W0L
0061A:  MOV.B   W0L,850
0061C:  CALL    58A
....................    
....................  // LCDCommand(0x0C);// ???????? ???????, ???????? ??????, ???????? ???????? ??????? 
....................   LCDCommand(0b00001100);// ???????? ???????, ???????? ??????, ???????? ???????? ??????? 
00620:  MOV.B   #C,W0L
00622:  MOV.B   W0L,850
00624:  CALL    58A
....................    
....................   LCDCommand(0x06);// ?????? ????? ????????? ?????? ??? ?????? ?????? 
00628:  MOV.B   #6,W0L
0062A:  MOV.B   W0L,850
0062C:  CALL    58A
....................   LCDCommand(0x1);// ??????? ?????? ? ??????????? ??????? ? ?????? ???????  
00630:  MOV.B   #1,W0L
00632:  MOV.B   W0L,850
00634:  CALL    58A
....................   // delay_ms(2); 
....................   Delay_ms(8); 
00638:  MOV     #8,W0
0063A:  CALL    530
....................   LCDCommand(0x06);// ?????? ????? ????????? ?????? ??? ?????? ??????  
0063E:  MOV.B   #6,W0L
00640:  MOV.B   W0L,850
00642:  CALL    58A
....................   LCDCommand(0x40);//????????? ?????? DRAM 
00646:  MOV.B   #40,W0L
00648:  MOV.B   W0L,850
0064A:  CALL    58A
....................   //delay_ms(10); 
....................   Delay_ms(20); 
0064E:  MOV     #14,W0
00650:  CALL    530
00654:  RETURN  
....................  } 
....................  
.................... static void LCDPutCh(char c) 
.................... { 
....................   LCDWriteData(c); 
*
00692:  MOV.B   860,W0L
00694:  MOV.B   W0L,862
00696:  CALL    664
0069A:  RETURN  
.................... } 
....................  
.................... static void LCDMsg(char c) 
.................... { 
....................      
....................     LCDPutCh(c); 
0069C:  MOV.B   84E,W0L
0069E:  MOV.B   W0L,860
006A0:  CALL    692
006A4:  RETURN  
.................... } 
....................  
.................... static void LCDWelcome(void) 
*
006BA:  MOV     W5,[W15++]
.................... { 
....................     LCDClear(); 
006BC:  CALL    656
....................     LCDMsg("   8 Channel"); 
006C0:  MOV     #0,W5
006C2:  MOV     W5,W0
006C4:  CALL    200
006C8:  IOR.B   #0,W0L
006CA:  BTSC.B  42.1
006CC:  BRA     6D8
006CE:  INC     W5,W5
006D0:  MOV.B   W0L,84E
006D2:  CALL    69C
006D6:  BRA     6C2
....................     LCDSetCursor(0x40); 
006D8:  MOV.B   #40,W0L
006DA:  MOV.B   W0L,84C
006DC:  CALL    6A6
....................     LCDMsg("  Thermometry"); 
006E0:  MOV     #0,W5
006E2:  MOV     W5,W0
006E4:  CALL    21A
006E8:  IOR.B   #0,W0L
006EA:  BTSC.B  42.1
006EC:  BRA     6F8
006EE:  INC     W5,W5
006F0:  MOV.B   W0L,84E
006F2:  CALL    69C
006F6:  BRA     6E2
....................     LCDSetCursor(0x50); 
006F8:  MOV.B   #50,W0L
006FA:  MOV.B   W0L,84C
006FC:  CALL    6A6
....................     LCDMsg(" ___LHEP_JINR___"); 
00700:  MOV     #0,W5
00702:  MOV     W5,W0
00704:  CALL    234
00708:  IOR.B   #0,W0L
0070A:  BTSC.B  42.1
0070C:  BRA     718
0070E:  INC     W5,W5
00710:  MOV.B   W0L,84E
00712:  CALL    69C
00716:  BRA     702
....................     Delay_ms(1000); 
00718:  MOV     #3E8,W0
0071A:  CALL    530
....................     LCDClear();    
0071E:  CALL    656
00722:  MOV     [--W15],W5
00724:  RETURN  
.................... } 
....................  
.................... static void LCDPutU16(U32 _u16,U8 u8NumDigs) 
*
01E12:  MOV     W5,[W15++]
.................... { 
....................     
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000; 
01E14:  BCLR.B  43.0
01E16:  MOV     84A,W0
01E18:  MOV     84C,W1
01E1A:  MOV     #2710,W2
01E1C:  MOV     #0,W3
01E1E:  CALL    142A
01E22:  MOV     W0,850
01E24:  MOV     W1,852
....................    u16b=u16a*10000; 
01E26:  MOV     850,W0
01E28:  MOV     852,W1
01E2A:  MOV     #2710,W2
01E2C:  MOV     #0,W3
01E2E:  CALL    147E
01E32:  MOV     W0,854
01E34:  MOV     W1,856
....................  
....................     if (u8NumDigs>=5) 
01E36:  MOV     84E,W4
01E38:  CP.B    W4L,#5
01E3A:  BRA     NC,1E4C
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01E3C:  MOV     #30,W4
01E3E:  MOV     850,W3
01E40:  ADD.B   W3L,W4L,W5L
01E42:  PUSH    860
01E44:  MOV.B   W5L,[W15-#2]
01E46:  POP     860
01E48:  CALL    692
....................     } 
....................  
....................     _u16-=u16b; 
01E4C:  MOV     84A,W4
01E4E:  MOV     854,W3
01E50:  SUB     W4,W3,W0
01E52:  MOV     W0,84A
01E54:  MOV     84C,W4
01E56:  MOV     856,W3
01E58:  SUBB    W4,W3,W0
01E5A:  MOV     W0,84C
....................     u16a=_u16/1000; 
01E5C:  BCLR.B  43.0
01E5E:  MOV     84A,W0
01E60:  MOV     84C,W1
01E62:  MOV     #3E8,W2
01E64:  MOV     #0,W3
01E66:  CALL    142A
01E6A:  MOV     W0,850
01E6C:  MOV     W1,852
....................     u16b=u16a*1000; 
01E6E:  MOV     850,W0
01E70:  MOV     852,W1
01E72:  MOV     #3E8,W2
01E74:  MOV     #0,W3
01E76:  CALL    147E
01E7A:  MOV     W0,854
01E7C:  MOV     W1,856
....................     if (u8NumDigs>=4) 
01E7E:  MOV     84E,W4
01E80:  CP.B    W4L,#4
01E82:  BRA     NC,1E94
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01E84:  MOV     #30,W4
01E86:  MOV     850,W3
01E88:  ADD.B   W3L,W4L,W5L
01E8A:  PUSH    860
01E8C:  MOV.B   W5L,[W15-#2]
01E8E:  POP     860
01E90:  CALL    692
....................     } 
....................  
....................     _u16-=u16b; 
01E94:  MOV     84A,W4
01E96:  MOV     854,W3
01E98:  SUB     W4,W3,W0
01E9A:  MOV     W0,84A
01E9C:  MOV     84C,W4
01E9E:  MOV     856,W3
01EA0:  SUBB    W4,W3,W0
01EA2:  MOV     W0,84C
....................     u16a=_u16/100; 
01EA4:  BCLR.B  43.0
01EA6:  MOV     84A,W0
01EA8:  MOV     84C,W1
01EAA:  MOV     #64,W2
01EAC:  MOV     #0,W3
01EAE:  CALL    142A
01EB2:  MOV     W0,850
01EB4:  MOV     W1,852
....................     u16b=u16a*100; 
01EB6:  MOV     850,W0
01EB8:  MOV     852,W1
01EBA:  MOV     #64,W2
01EBC:  MOV     #0,W3
01EBE:  CALL    147E
01EC2:  MOV     W0,854
01EC4:  MOV     W1,856
....................     if (u8NumDigs>=3) 
01EC6:  MOV     84E,W4
01EC8:  CP.B    W4L,#3
01ECA:  BRA     NC,1EDC
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01ECC:  MOV     #30,W4
01ECE:  MOV     850,W3
01ED0:  ADD.B   W3L,W4L,W5L
01ED2:  PUSH    860
01ED4:  MOV.B   W5L,[W15-#2]
01ED6:  POP     860
01ED8:  CALL    692
....................        
....................     } 
....................  
....................     _u16-=u16b; 
01EDC:  MOV     84A,W4
01EDE:  MOV     854,W3
01EE0:  SUB     W4,W3,W0
01EE2:  MOV     W0,84A
01EE4:  MOV     84C,W4
01EE6:  MOV     856,W3
01EE8:  SUBB    W4,W3,W0
01EEA:  MOV     W0,84C
....................     u16a=_u16/10; 
01EEC:  BCLR.B  43.0
01EEE:  MOV     84A,W0
01EF0:  MOV     84C,W1
01EF2:  MOV     #A,W2
01EF4:  MOV     #0,W3
01EF6:  CALL    142A
01EFA:  MOV     W0,850
01EFC:  MOV     W1,852
....................     u16b=u16a*10; 
01EFE:  MOV     850,W0
01F00:  MOV     852,W1
01F02:  MOV     #A,W2
01F04:  MOV     #0,W3
01F06:  CALL    147E
01F0A:  MOV     W0,854
01F0C:  MOV     W1,856
....................    if (u8NumDigs>=2) 
01F0E:  MOV     84E,W4
01F10:  CP.B    W4L,#2
01F12:  BRA     NC,1F24
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01F14:  MOV     #30,W4
01F16:  MOV     850,W3
01F18:  ADD.B   W3L,W4L,W5L
01F1A:  PUSH    860
01F1C:  MOV.B   W5L,[W15-#2]
01F1E:  POP     860
01F20:  CALL    692
....................     } 
....................  
....................     _u16-=u16b; 
01F24:  MOV     84A,W4
01F26:  MOV     854,W3
01F28:  SUB     W4,W3,W0
01F2A:  MOV     W0,84A
01F2C:  MOV     84C,W4
01F2E:  MOV     856,W3
01F30:  SUBB    W4,W3,W0
01F32:  MOV     W0,84C
....................     if (u8NumDigs>=1) 
01F34:  MOV     84E,W4
01F36:  CP.B    W4L,#1
01F38:  BRA     NC,1F4A
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
01F3A:  MOV     #30,W4
01F3C:  MOV     84A,W3
01F3E:  ADD.B   W3L,W4L,W5L
01F40:  PUSH    860
01F42:  MOV.B   W5L,[W15-#2]
01F44:  POP     860
01F46:  CALL    692
....................     } 
01F4A:  MOV     [--W15],W5
01F4C:  RETURN  
....................    
.................... } 
....................  
.................... static void LCDPutU32(U32 _u16,U8 u8NumDigs) 
*
014AE:  MOV     W5,[W15++]
.................... { 
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000000; 
014B0:  BCLR.B  43.0
014B2:  MOV     84C,W0
014B4:  MOV     84E,W1
014B6:  MOV     #9680,W2
014B8:  MOV     #98,W3
014BA:  CALL    142A
014BE:  MOV     W0,852
014C0:  MOV     W1,854
....................    u16b=u16a*10000000; 
014C2:  MOV     852,W0
014C4:  MOV     854,W1
014C6:  MOV     #9680,W2
014C8:  MOV     #98,W3
014CA:  CALL    147E
014CE:  MOV     W0,856
014D0:  MOV     W1,858
....................  
....................     if (u8NumDigs>=7) 
014D2:  MOV     850,W4
014D4:  CP.B    W4L,#7
014D6:  BRA     NC,14E8
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
014D8:  MOV     #30,W4
014DA:  MOV     852,W3
014DC:  ADD.B   W3L,W4L,W5L
014DE:  PUSH    860
014E0:  MOV.B   W5L,[W15-#2]
014E2:  POP     860
014E4:  CALL    692
....................     } 
....................       _u16-=u16b; 
014E8:  MOV     84C,W4
014EA:  MOV     856,W3
014EC:  SUB     W4,W3,W0
014EE:  MOV     W0,84C
014F0:  MOV     84E,W4
014F2:  MOV     858,W3
014F4:  SUBB    W4,W3,W0
014F6:  MOV     W0,84E
....................        
....................    u16a=_u16/1000000; 
014F8:  BCLR.B  43.0
014FA:  MOV     84C,W0
014FC:  MOV     84E,W1
014FE:  MOV     #4240,W2
01500:  MOV     #F,W3
01502:  CALL    142A
01506:  MOV     W0,852
01508:  MOV     W1,854
....................    u16b=u16a*1000000; 
0150A:  MOV     852,W0
0150C:  MOV     854,W1
0150E:  MOV     #4240,W2
01510:  MOV     #F,W3
01512:  CALL    147E
01516:  MOV     W0,856
01518:  MOV     W1,858
....................        
....................     if (u8NumDigs>=6) 
0151A:  MOV     850,W4
0151C:  CP.B    W4L,#6
0151E:  BRA     NC,1530
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01520:  MOV     #30,W4
01522:  MOV     852,W3
01524:  ADD.B   W3L,W4L,W5L
01526:  PUSH    860
01528:  MOV.B   W5L,[W15-#2]
0152A:  POP     860
0152C:  CALL    692
....................     } 
....................       _u16-=u16b; 
01530:  MOV     84C,W4
01532:  MOV     856,W3
01534:  SUB     W4,W3,W0
01536:  MOV     W0,84C
01538:  MOV     84E,W4
0153A:  MOV     858,W3
0153C:  SUBB    W4,W3,W0
0153E:  MOV     W0,84E
....................        
....................    u16a=_u16/100000; 
01540:  BCLR.B  43.0
01542:  MOV     84C,W0
01544:  MOV     84E,W1
01546:  MOV     #86A0,W2
01548:  MOV     #1,W3
0154A:  CALL    142A
0154E:  MOV     W0,852
01550:  MOV     W1,854
....................    u16b=u16a*100000; 
01552:  MOV     852,W0
01554:  MOV     854,W1
01556:  MOV     #86A0,W2
01558:  MOV     #1,W3
0155A:  CALL    147E
0155E:  MOV     W0,856
01560:  MOV     W1,858
....................  
....................     if (u8NumDigs>=5) 
01562:  MOV     850,W4
01564:  CP.B    W4L,#5
01566:  BRA     NC,1578
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01568:  MOV     #30,W4
0156A:  MOV     852,W3
0156C:  ADD.B   W3L,W4L,W5L
0156E:  PUSH    860
01570:  MOV.B   W5L,[W15-#2]
01572:  POP     860
01574:  CALL    692
....................     } 
....................  
....................     _u16-=u16b; 
01578:  MOV     84C,W4
0157A:  MOV     856,W3
0157C:  SUB     W4,W3,W0
0157E:  MOV     W0,84C
01580:  MOV     84E,W4
01582:  MOV     858,W3
01584:  SUBB    W4,W3,W0
01586:  MOV     W0,84E
....................     u16a=_u16/10000; 
01588:  BCLR.B  43.0
0158A:  MOV     84C,W0
0158C:  MOV     84E,W1
0158E:  MOV     #2710,W2
01590:  MOV     #0,W3
01592:  CALL    142A
01596:  MOV     W0,852
01598:  MOV     W1,854
....................     u16b=u16a*10000; 
0159A:  MOV     852,W0
0159C:  MOV     854,W1
0159E:  MOV     #2710,W2
015A0:  MOV     #0,W3
015A2:  CALL    147E
015A6:  MOV     W0,856
015A8:  MOV     W1,858
....................     if (u8NumDigs>=4) 
015AA:  MOV     850,W4
015AC:  CP.B    W4L,#4
015AE:  BRA     NC,15C0
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
015B0:  MOV     #30,W4
015B2:  MOV     852,W3
015B4:  ADD.B   W3L,W4L,W5L
015B6:  PUSH    860
015B8:  MOV.B   W5L,[W15-#2]
015BA:  POP     860
015BC:  CALL    692
....................     } 
....................  
....................     _u16-=u16b; 
015C0:  MOV     84C,W4
015C2:  MOV     856,W3
015C4:  SUB     W4,W3,W0
015C6:  MOV     W0,84C
015C8:  MOV     84E,W4
015CA:  MOV     858,W3
015CC:  SUBB    W4,W3,W0
015CE:  MOV     W0,84E
....................     u16a=_u16/1000; 
015D0:  BCLR.B  43.0
015D2:  MOV     84C,W0
015D4:  MOV     84E,W1
015D6:  MOV     #3E8,W2
015D8:  MOV     #0,W3
015DA:  CALL    142A
015DE:  MOV     W0,852
015E0:  MOV     W1,854
....................     u16b=u16a*1000; 
015E2:  MOV     852,W0
015E4:  MOV     854,W1
015E6:  MOV     #3E8,W2
015E8:  MOV     #0,W3
015EA:  CALL    147E
015EE:  MOV     W0,856
015F0:  MOV     W1,858
....................     if (u8NumDigs>=3) 
015F2:  MOV     850,W4
015F4:  CP.B    W4L,#3
015F6:  BRA     NC,1608
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
015F8:  MOV     #30,W4
015FA:  MOV     852,W3
015FC:  ADD.B   W3L,W4L,W5L
015FE:  PUSH    860
01600:  MOV.B   W5L,[W15-#2]
01602:  POP     860
01604:  CALL    692
....................        
....................     } 
....................  
....................     _u16-=u16b; 
01608:  MOV     84C,W4
0160A:  MOV     856,W3
0160C:  SUB     W4,W3,W0
0160E:  MOV     W0,84C
01610:  MOV     84E,W4
01612:  MOV     858,W3
01614:  SUBB    W4,W3,W0
01616:  MOV     W0,84E
....................     u16a=_u16/100; 
01618:  BCLR.B  43.0
0161A:  MOV     84C,W0
0161C:  MOV     84E,W1
0161E:  MOV     #64,W2
01620:  MOV     #0,W3
01622:  CALL    142A
01626:  MOV     W0,852
01628:  MOV     W1,854
....................     u16b=u16a*100; 
0162A:  MOV     852,W0
0162C:  MOV     854,W1
0162E:  MOV     #64,W2
01630:  MOV     #0,W3
01632:  CALL    147E
01636:  MOV     W0,856
01638:  MOV     W1,858
....................    if (u8NumDigs>=2) 
0163A:  MOV     850,W4
0163C:  CP.B    W4L,#2
0163E:  BRA     NC,1650
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01640:  MOV     #30,W4
01642:  MOV     852,W3
01644:  ADD.B   W3L,W4L,W5L
01646:  PUSH    860
01648:  MOV.B   W5L,[W15-#2]
0164A:  POP     860
0164C:  CALL    692
....................     } 
....................  
....................    _u16-=u16b; 
01650:  MOV     84C,W4
01652:  MOV     856,W3
01654:  SUB     W4,W3,W0
01656:  MOV     W0,84C
01658:  MOV     84E,W4
0165A:  MOV     858,W3
0165C:  SUBB    W4,W3,W0
0165E:  MOV     W0,84E
....................     u16a=_u16/10; 
01660:  BCLR.B  43.0
01662:  MOV     84C,W0
01664:  MOV     84E,W1
01666:  MOV     #A,W2
01668:  MOV     #0,W3
0166A:  CALL    142A
0166E:  MOV     W0,852
01670:  MOV     W1,854
....................     u16b=u16a*10; 
01672:  MOV     852,W0
01674:  MOV     854,W1
01676:  MOV     #A,W2
01678:  MOV     #0,W3
0167A:  CALL    147E
0167E:  MOV     W0,856
01680:  MOV     W1,858
....................    if (u8NumDigs>=2) 
01682:  MOV     850,W4
01684:  CP.B    W4L,#2
01686:  BRA     NC,1698
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01688:  MOV     #30,W4
0168A:  MOV     852,W3
0168C:  ADD.B   W3L,W4L,W5L
0168E:  PUSH    860
01690:  MOV.B   W5L,[W15-#2]
01692:  POP     860
01694:  CALL    692
....................     } 
....................  
....................     _u16-=u16b; 
01698:  MOV     84C,W4
0169A:  MOV     856,W3
0169C:  SUB     W4,W3,W0
0169E:  MOV     W0,84C
016A0:  MOV     84E,W4
016A2:  MOV     858,W3
016A4:  SUBB    W4,W3,W0
016A6:  MOV     W0,84E
....................     if (u8NumDigs>=1) 
016A8:  MOV     850,W4
016AA:  CP.B    W4L,#1
016AC:  BRA     NC,16BE
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
016AE:  MOV     #30,W4
016B0:  MOV     84C,W3
016B2:  ADD.B   W3L,W4L,W5L
016B4:  PUSH    860
016B6:  MOV.B   W5L,[W15-#2]
016B8:  POP     860
016BA:  CALL    692
....................     } 
016BE:  MOV     [--W15],W5
016C0:  RETURN  
....................    
.................... } 
....................  
.................... static void LCDPutS32(S32 s32a,U8 u8NumDigs) 
.................... { 
....................   char c='+'; 
....................  
....................   if (s32a<0) 
....................   { 
....................     s32a=-s32a; 
....................     c='-'; 
....................   } 
....................   LCDPutCh(c); 
....................   LCDPutU32((U32)s32a,u8NumDigs); 
.................... } 
....................  
.................... #include <ADS1256.h> 
....................  
.................... static void ADC_wakeUp(){ 
....................  
....................    ADC_CS = 1; 
*
007C6:  BSET.B  2E9.1
....................    ADC2_CS = 1; 
007C8:  BSET.B  2D7.2
....................     
....................    ADC_RESET = 0; //When using the RESET pin, take it low to force a reset. 
007CA:  BCLR.B  2D6.3
....................    ADC2_RESET = 0; //When using the RESET pin, take it low to force a reset. 
007CC:  BCLR.B  2D6.0
....................    delay_us(200); 
007CE:  REPEAT  #1F3E
007D0:  NOP     
....................     
....................    ADC_RESET = 1; 
007D2:  BSET.B  2D6.3
....................    ADC2_RESET = 1; 
007D4:  BSET.B  2D6.0
....................     
....................    ADC_SYNC =0; 
007D6:  BCLR.B  2D6.2
....................    ADC2_SYNC =0;    
007D8:  BCLR.B  2D7.3
....................    delay_us(200); 
007DA:  REPEAT  #1F3E
007DC:  NOP     
....................     
....................    ADC_SYNC = 1; //To use the SYNC/PDWN pin, take it low and then high 
007DE:  BSET.B  2D6.2
....................    ADC2_SYNC = 1; //To use the SYNC/PDWN pin, take it low and then high 
007E0:  BSET.B  2D7.3
....................     
....................    delay_ms(2); 
007E2:  MOV     #2,W0
007E4:  CALL    530
007E8:  RETURN  
....................  
.................... } 
....................  
.................... static U8 RdReg(U8 RegName) 
.................... { 
....................    U8 RegValue = 0;  
....................    //1st Command Byte: 0001 rrrr where rrrr is the address of the first register to read. 
....................    //2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to read – 1 
....................    ADC_CS = 0; 
....................    delay_us(1); 
....................    Spi_write2(0x10+RegName); // 1st Command Byte,??????? ?????? 
....................    Spi_write2(0x00); // 1st Command Byte, ?????? ?????? ???? ???? 
....................    delay_us(8); // 50 CLK_IN PEDIODS 
....................    RegValue = Spi_read2(0); 
....................    delay_us(1); 
....................    ADC_CS =1; 
....................    delay_us(1); 
....................    Return RegValue;   
.................... } 
....................  
.................... static void WrReg(U8 RegName,CommandByte) 
007EA:  MOV     W5,[W15++]
.................... { 
....................    ADC_CS = 0; 
007EC:  BCLR.B  2E9.1
....................    ADC2_CS = 0; 
007EE:  BCLR.B  2D7.2
....................    delay_us(5); 
007F0:  REPEAT  #C6
007F2:  NOP     
....................    Spi_write2(0x50+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written. 
007F4:  MOV     84E,W4
007F6:  CLR.B   9
007F8:  MOV     #50,W3
007FA:  ADD     W3,W4,W5
007FC:  BCLR.B  260.6
007FE:  BTSS.B  260.0
00800:  BRA     806
00802:  MOV.B   268,W0L
00804:  BRA     7FE
00806:  PUSH    268
00808:  MOV.B   W5L,[W15-#2]
0080A:  POP     268
0080C:  BTSS.B  260.0
0080E:  BRA     80C
....................    delay_us(10); 
00810:  REPEAT  #18E
00812:  NOP     
....................    Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1. 
00814:  BCLR.B  260.6
00816:  BTSS.B  260.0
00818:  BRA     81E
0081A:  MOV.B   268,W0L
0081C:  BRA     816
0081E:  CLR.B   268
00820:  BTSS.B  260.0
00822:  BRA     820
....................    delay_us(10); 
00824:  REPEAT  #18E
00826:  NOP     
....................    Spi_write2(CommandByte); 
00828:  BCLR.B  260.6
0082A:  BTSS.B  260.0
0082C:  BRA     832
0082E:  MOV.B   268,W0L
00830:  BRA     82A
00832:  MOV.B   84F,W0L
00834:  MOV.B   W0L,268
00836:  BTSS.B  260.0
00838:  BRA     836
....................    delay_us(10); 
0083A:  REPEAT  #18E
0083C:  NOP     
....................    ADC_CS = 1; 
0083E:  BSET.B  2E9.1
....................    ADC2_CS = 1; 
00840:  BSET.B  2D7.2
....................    delay_us(50); 
00842:  REPEAT  #7CE
00844:  NOP     
00846:  MOV     [--W15],W5
00848:  RETURN  
.................... } 
....................  
.................... static S32 ADC_RData(){             
....................  
....................      ADC_CS = 0; 
....................      delay_us(1); 
....................      Spi_write2(0x01); 
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      delay_us(1); 
....................      m1: 
....................      if(!ADC_DRDY){ 
....................      ADC_CS = 0; 
....................      delay_us(1); 
....................      ADC_Rbyte1 = Spi_read2(0); 
....................      ADC_Rbyte2 = Spi_read2(0); 
....................      ADC_Rbyte3 = Spi_read2(0); 
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      ADC_RByte_Sum = (ADC_Rbyte1<<16) + (ADC_Rbyte2<<8) + ADC_Rbyte3; 
....................      return ADC_RByte_Sum; 
....................      } 
....................      else goto m1; 
.................... } 
....................  
.................... static void ADC_StartRdContin(){ 
....................  
....................      if    (ADC_select) {ADC_CS = 1; ADC2_CS = 0;} 
*
00B28:  CP0.B   835
00B2A:  BRA     Z,B34
00B2C:  BSET.B  2E9.1
00B2E:  BCLR.B  2D7.2
00B30:  GOTO    B38
....................      else  {ADC_CS = 0; ADC2_CS = 1;} 
00B34:  BCLR.B  2E9.1
00B36:  BSET.B  2D7.2
....................      delay_us(1);                                          
00B38:  REPEAT  #26
00B3A:  NOP     
....................      Spi_write2(0x03);              
00B3C:  BCLR.B  260.6
00B3E:  BTSS.B  260.0
00B40:  BRA     B46
00B42:  MOV.B   268,W0L
00B44:  BRA     B3E
00B46:  MOV.B   #3,W0L
00B48:  MOV.B   W0L,268
00B4A:  BTSS.B  260.0
00B4C:  BRA     B4A
....................      delay_us(1); 
00B4E:  REPEAT  #26
00B50:  NOP     
....................      ADC_CS = 1; 
00B52:  BSET.B  2E9.1
....................      ADC2_CS = 1; 
00B54:  BSET.B  2D7.2
00B56:  RETURN  
.................... } 
....................  
.................... static S32 ADC_RdataC(){                                               
*
00BD6:  MOV     W5,[W15++]
00BD8:  MOV     W6,[W15++]
....................                                                                    
....................      if (ADC_select) {ADC_CS = 1; ADC2_CS = 0;} 
00BDA:  CP0.B   835
00BDC:  BRA     Z,BE6
00BDE:  BSET.B  2E9.1
00BE0:  BCLR.B  2D7.2
00BE2:  GOTO    BEA
....................      else            {ADC_CS = 0; ADC2_CS = 1;} 
00BE6:  BCLR.B  2E9.1
00BE8:  BSET.B  2D7.2
....................      delay_us(1);                                          
00BEA:  REPEAT  #26
00BEC:  NOP     
....................      Spi_write2(0x03);              
00BEE:  BCLR.B  260.6
00BF0:  BTSS.B  260.0
00BF2:  BRA     BF8
00BF4:  MOV.B   268,W0L
00BF6:  BRA     BF0
00BF8:  MOV.B   #3,W0L
00BFA:  MOV.B   W0L,268
00BFC:  BTSS.B  260.0
00BFE:  BRA     BFC
....................      delay_us(1); 
00C00:  REPEAT  #26
00C02:  NOP     
....................      ADC_CS = 1; 
00C04:  BSET.B  2E9.1
....................      ADC2_CS = 1; 
00C06:  BSET.B  2D7.2
....................       
....................      if (ADC_select == 0){ 
00C08:  CP0.B   835
00C0A:  BRA     NZ,C76
....................       While(ADC_DRDY) 
00C0C:  BTSS.B  2D4.1
00C0E:  BRA     C18
....................       delay_us(1); 
00C10:  REPEAT  #26
00C12:  NOP     
00C14:  GOTO    C0C
....................       ADC_CS = 0; 
00C18:  BCLR.B  2E9.1
....................       delay_us(1); 
00C1A:  REPEAT  #26
00C1C:  NOP     
....................       ADC_Rbyte1 = Spi_read2(0); 
00C1E:  BCLR.B  260.6
00C20:  BTSS.B  260.0
00C22:  BRA     C28
00C24:  MOV.B   268,W0L
00C26:  BRA     C20
00C28:  CLR.B   268
00C2A:  BTSS.B  260.0
00C2C:  BRA     C2A
00C2E:  MOV.B   268,W0L
00C30:  CLR.B   1
00C32:  MOV     #0,W1
00C34:  MOV     W0,806
00C36:  MOV     W1,808
....................       ADC_Rbyte2 = Spi_read2(0); 
00C38:  BCLR.B  260.6
00C3A:  BTSS.B  260.0
00C3C:  BRA     C42
00C3E:  MOV.B   268,W0L
00C40:  BRA     C3A
00C42:  CLR.B   268
00C44:  BTSS.B  260.0
00C46:  BRA     C44
00C48:  MOV.B   268,W0L
00C4A:  CLR.B   1
00C4C:  MOV     #0,W1
00C4E:  MOV     W0,80A
00C50:  MOV     W1,80C
....................       ADC_Rbyte3 = Spi_read2(0); 
00C52:  BCLR.B  260.6
00C54:  BTSS.B  260.0
00C56:  BRA     C5C
00C58:  MOV.B   268,W0L
00C5A:  BRA     C54
00C5C:  CLR.B   268
00C5E:  BTSS.B  260.0
00C60:  BRA     C5E
00C62:  MOV.B   268,W0L
00C64:  CLR.B   1
00C66:  MOV     #0,W1
00C68:  MOV     W0,80E
00C6A:  MOV     W1,810
....................       delay_us(1); 
00C6C:  REPEAT  #26
00C6E:  NOP     
....................       ADC_CS = 1; 
00C70:  BSET.B  2E9.1
....................           } 
00C72:  GOTO    CDC
....................       
....................      else { 
....................       While(ADC2_DRDY) 
00C76:  BTSS.B  2D5.1
00C78:  BRA     C82
....................       delay_us(1); 
00C7A:  REPEAT  #26
00C7C:  NOP     
00C7E:  GOTO    C76
....................       ADC2_CS = 0; 
00C82:  BCLR.B  2D7.2
....................       delay_us(1); 
00C84:  REPEAT  #26
00C86:  NOP     
....................       ADC_Rbyte1 = Spi_read2(0); 
00C88:  BCLR.B  260.6
00C8A:  BTSS.B  260.0
00C8C:  BRA     C92
00C8E:  MOV.B   268,W0L
00C90:  BRA     C8A
00C92:  CLR.B   268
00C94:  BTSS.B  260.0
00C96:  BRA     C94
00C98:  MOV.B   268,W0L
00C9A:  CLR.B   1
00C9C:  MOV     #0,W1
00C9E:  MOV     W0,806
00CA0:  MOV     W1,808
....................       ADC_Rbyte2 = Spi_read2(0); 
00CA2:  BCLR.B  260.6
00CA4:  BTSS.B  260.0
00CA6:  BRA     CAC
00CA8:  MOV.B   268,W0L
00CAA:  BRA     CA4
00CAC:  CLR.B   268
00CAE:  BTSS.B  260.0
00CB0:  BRA     CAE
00CB2:  MOV.B   268,W0L
00CB4:  CLR.B   1
00CB6:  MOV     #0,W1
00CB8:  MOV     W0,80A
00CBA:  MOV     W1,80C
....................       ADC_Rbyte3 = Spi_read2(0); 
00CBC:  BCLR.B  260.6
00CBE:  BTSS.B  260.0
00CC0:  BRA     CC6
00CC2:  MOV.B   268,W0L
00CC4:  BRA     CBE
00CC6:  CLR.B   268
00CC8:  BTSS.B  260.0
00CCA:  BRA     CC8
00CCC:  MOV.B   268,W0L
00CCE:  CLR.B   1
00CD0:  MOV     #0,W1
00CD2:  MOV     W0,80E
00CD4:  MOV     W1,810
....................       delay_us(1); 
00CD6:  REPEAT  #26
00CD8:  NOP     
....................       ADC2_CS = 1;   
00CDA:  BSET.B  2D7.2
....................           } 
....................       
....................      ADC_RByte_Sum = (ADC_Rbyte1<<24) + (ADC_Rbyte2<<16) + (ADC_Rbyte3<<8); 
00CDC:  MOV.B   806,W0L
00CDE:  MOV.B   W0L,D
00CE0:  CLR.B   W6
00CE2:  CLR.B   B
00CE4:  CLR.B   W5
00CE6:  MOV     80A,W1
00CE8:  MOV     #0,W0
00CEA:  ADD     W0,W5,W5
00CEC:  ADDC    W1,W6,W6
00CEE:  MOV.B   810,W0L
00CF0:  MOV.B   W0L,3
00CF2:  MOV.B   80F,W0L
00CF4:  MOV.B   W0L,W1L
00CF6:  MOV.B   80E,W0L
00CF8:  MOV.B   W0L,1
00CFA:  CLR.B   W0
00CFC:  ADD     W0,W5,W0
00CFE:  MOV     W0,812
00D00:  ADDC    W1,W6,W0
00D02:  MOV     W0,814
....................      return ADC_RByte_Sum/256; 
00D04:  BCLR.B  43.0
00D06:  MOV     812,W0
00D08:  MOV     814,W1
00D0A:  MOV     #100,W2
00D0C:  MOV     #0,W3
00D0E:  CALL    B58
00D12:  MOV.D   W0,W0
00D14:  MOV     [--W15],W6
00D16:  MOV     [--W15],W5
00D18:  RETURN  
....................       
....................      } 
....................  
.................... static void ADC_StopRd(){ 
....................     
....................      if    (ADC_select) {ADC_CS = 1; ADC2_CS = 0;} 
*
0084A:  CP0.B   835
0084C:  BRA     Z,856
0084E:  BSET.B  2E9.1
00850:  BCLR.B  2D7.2
00852:  GOTO    85A
....................      else  {ADC_CS = 0; ADC2_CS = 1;} 
00856:  BCLR.B  2E9.1
00858:  BSET.B  2D7.2
....................    delay_us(5); 
0085A:  REPEAT  #C6
0085C:  NOP     
....................    Spi_write2(0x0F);   
0085E:  BCLR.B  260.6
00860:  BTSS.B  260.0
00862:  BRA     868
00864:  MOV.B   268,W0L
00866:  BRA     860
00868:  MOV.B   #F,W0L
0086A:  MOV.B   W0L,268
0086C:  BTSS.B  260.0
0086E:  BRA     86C
....................    delay_us(5); 
00870:  REPEAT  #C6
00872:  NOP     
....................    ADC2_CS = 1; 
00874:  BSET.B  2D7.2
....................    ADC_CS = 1; 
00876:  BSET.B  2E9.1
....................    delay_us(50); 
00878:  REPEAT  #7CE
0087A:  NOP     
0087C:  RETURN  
....................  
.................... } 
....................  
.................... static void ADC_sps_set(U8 SPS){ 
....................  
....................    ADC_StopRd();                                                               
0087E:  CALL    84A
....................    Sps_buf = SPS; 
00882:  MOV.B   84A,W0L
00884:  MOV.B   W0L,81F
....................    WrReg(DRATE,SPS);  
00886:  MOV.B   #3,W0L
00888:  MOV.B   W0L,84E
0088A:  MOV.B   84A,W0L
0088C:  MOV.B   W0L,84F
0088E:  CALL    7EA
00892:  RETURN  
....................                   
....................    // ???????? ???_????? ? ??????????           
.................... }  
....................  
.................... static void ADC_SelfCal(){ 
....................                       
....................    ADC_CS = 0; 
*
009C0:  BCLR.B  2E9.1
....................    ADC2_CS = 0; 
009C2:  BCLR.B  2D7.2
....................    delay_us(1); 
009C4:  REPEAT  #26
009C6:  NOP     
....................    Spi_write2(0xF0); 
009C8:  BCLR.B  260.6
009CA:  BTSS.B  260.0
009CC:  BRA     9D2
009CE:  MOV.B   268,W0L
009D0:  BRA     9CA
009D2:  MOV.B   #F0,W0L
009D4:  MOV.B   W0L,268
009D6:  BTSS.B  260.0
009D8:  BRA     9D6
....................     delay_us(1); 
009DA:  REPEAT  #26
009DC:  NOP     
....................    ADC_CS = 1; 
009DE:  BSET.B  2E9.1
....................    ADC2_CS = 1; 
009E0:  BSET.B  2D7.2
....................    Switch (Sps_buf) {      
009E2:  MOV.B   81F,W0L
009E4:  CLR.B   1
009E6:  XOR     #F0,W0
009E8:  BRA     Z,A18
009EA:  XOR     #10,W0
009EC:  BRA     Z,A20
009EE:  XOR     #30,W0
009F0:  BRA     Z,A28
009F2:  XOR     #10,W0
009F4:  BRA     Z,A30
009F6:  XOR     #70,W0
009F8:  BRA     Z,A3C
009FA:  XOR     #11,W0
009FC:  BRA     Z,A48
009FE:  XOR     #33,W0
00A00:  BRA     Z,A5C
00A02:  XOR     #10,W0
00A04:  BRA     Z,A66
00A06:  XOR     #E1,W0
00A08:  BRA     Z,A74
00A0A:  XOR     #20,W0
00A0C:  BRA     Z,A7E
00A0E:  XOR     #60,W0
00A10:  BRA     Z,A88
00A12:  XOR     #30,W0
00A14:  BRA     Z,A92
00A16:  BRA     A9C
....................      
....................       case 0xF0:    
....................        delay_us(220);         
00A18:  REPEAT  #225E
00A1A:  NOP     
....................         break;                       
00A1C:  GOTO    A9C
....................        
....................       case 0xE0: 
....................        delay_us(255);  
00A20:  REPEAT  #27D6
00A22:  NOP     
....................         break; 
00A24:  GOTO    A9C
....................          
....................       case 0xD0: 
....................        delay_us(315);  
00A28:  REPEAT  #3136
00A2A:  NOP     
....................         break; 
00A2C:  GOTO    A9C
....................          
....................       case 0xC0: 
....................        delay_us(445);  
00A30:  REPEAT  #586
00A32:  NOP     
00A34:  REPEAT  #3FFF
00A36:  NOP     
....................         break; 
00A38:  GOTO    A9C
....................          
....................       case 0xB0: 
....................        delay_us(685);  
00A3C:  REPEAT  #2B06
00A3E:  NOP     
00A40:  REPEAT  #3FFF
00A42:  NOP     
....................         break; 
00A44:  GOTO    A9C
....................          
....................       case 0xA1: 
....................        delay_ms(1); 
00A48:  REPEAT  #1C3E
00A4A:  NOP     
00A4C:  REPEAT  #3FFF
00A4E:  NOP     
00A50:  REPEAT  #3FFF
00A52:  NOP     
....................        delay_us(185);                
00A54:  REPEAT  #1CE6
00A56:  NOP     
....................         break;       
00A58:  GOTO    A9C
....................          
....................       case 0x92: 
....................        delay_ms(5); 
00A5C:  MOV     #5,W0
00A5E:  CALL    530
....................         break; 
00A62:  GOTO    A9C
....................          
....................       case 0x82: 
....................        delay_ms(10); 
00A66:  MOV     #A,W0
00A68:  CALL    530
....................        delay_us(200); 
00A6C:  REPEAT  #1F3E
00A6E:  NOP     
....................         break; 
00A70:  GOTO    A9C
....................                     
....................       case 0x63: 
....................        delay_ms(21);  
00A74:  MOV     #15,W0
00A76:  CALL    530
....................         break; 
00A7A:  GOTO    A9C
....................          
....................       case 0x43: 
....................        delay_ms(41);  
00A7E:  MOV     #29,W0
00A80:  CALL    530
....................         break; 
00A84:  GOTO    A9C
....................          
....................       case 0x23: 
....................        delay_ms(101);  
00A88:  MOV     #65,W0
00A8A:  CALL    530
....................         break;          
00A8E:  GOTO    A9C
....................              
....................       case 0x13: 
....................        delay_ms(201);  
00A92:  MOV     #C9,W0
00A94:  CALL    530
....................         break;                           
00A98:  GOTO    A9C
....................      } 
00A9C:  RETURN  
....................       
.................... } 
....................  
.................... static void ADC_setCh(U8 Ch_Number){ 
....................  
....................    ADC_StopRd(); 
*
00D1A:  CALL    84A
....................     
....................    Global_Ch_Number = Ch_Number; 
00D1E:  MOV.B   84C,W0L
00D20:  MOV.B   W0L,820
....................    if (Ch_Number > 4) ADC_select = 1; 
00D22:  MOV     84C,W4
00D24:  CP.B    W4L,#4
00D26:  BRA     LEU,D30
00D28:  MOV.B   #1,W0L
00D2A:  MOV.B   W0L,835
00D2C:  GOTO    D32
....................    else ADC_select = 0; 
00D30:  CLR.B   835
....................       
....................    Switch (Ch_Number) { 
00D32:  MOV.B   84C,W0L
00D34:  CLR.B   1
00D36:  XOR     #4,W0
00D38:  BRA     Z,D58
00D3A:  XOR     #7,W0
00D3C:  BRA     Z,D68
00D3E:  XOR     #1,W0
00D40:  BRA     Z,D78
00D42:  XOR     #3,W0
00D44:  BRA     Z,D88
00D46:  XOR     #9,W0
00D48:  BRA     Z,D98
00D4A:  XOR     #F,W0
00D4C:  BRA     Z,DA8
00D4E:  XOR     #1,W0
00D50:  BRA     Z,DB8
00D52:  XOR     #3,W0
00D54:  BRA     Z,DC8
00D56:  BRA     DD8
....................  
....................     case 4: WrReg(MUX,0x10); break; 
00D58:  MOV.B   #1,W0L
00D5A:  MOV.B   W0L,84E
00D5C:  MOV.B   #10,W0L
00D5E:  MOV.B   W0L,84F
00D60:  CALL    7EA
00D64:  GOTO    DD8
....................     case 3: WrReg(MUX,0x32); break; 
00D68:  MOV.B   #1,W0L
00D6A:  MOV.B   W0L,84E
00D6C:  MOV.B   #32,W0L
00D6E:  MOV.B   W0L,84F
00D70:  CALL    7EA
00D74:  GOTO    DD8
....................     case 2: WrReg(MUX,0x54); break; 
00D78:  MOV.B   #1,W0L
00D7A:  MOV.B   W0L,84E
00D7C:  MOV.B   #54,W0L
00D7E:  MOV.B   W0L,84F
00D80:  CALL    7EA
00D84:  GOTO    DD8
....................     case 1: WrReg(MUX,0x76); break; 
00D88:  MOV.B   #1,W0L
00D8A:  MOV.B   W0L,84E
00D8C:  MOV.B   #76,W0L
00D8E:  MOV.B   W0L,84F
00D90:  CALL    7EA
00D94:  GOTO    DD8
....................      
....................     case 8: WrReg(MUX,0x10); break; 
00D98:  MOV.B   #1,W0L
00D9A:  MOV.B   W0L,84E
00D9C:  MOV.B   #10,W0L
00D9E:  MOV.B   W0L,84F
00DA0:  CALL    7EA
00DA4:  GOTO    DD8
....................     case 7: WrReg(MUX,0x32); break; 
00DA8:  MOV.B   #1,W0L
00DAA:  MOV.B   W0L,84E
00DAC:  MOV.B   #32,W0L
00DAE:  MOV.B   W0L,84F
00DB0:  CALL    7EA
00DB4:  GOTO    DD8
....................     case 6: WrReg(MUX,0x54); break; 
00DB8:  MOV.B   #1,W0L
00DBA:  MOV.B   W0L,84E
00DBC:  MOV.B   #54,W0L
00DBE:  MOV.B   W0L,84F
00DC0:  CALL    7EA
00DC4:  GOTO    DD8
....................     case 5: WrReg(MUX,0x76); break;  
00DC8:  MOV.B   #1,W0L
00DCA:  MOV.B   W0L,84E
00DCC:  MOV.B   #76,W0L
00DCE:  MOV.B   W0L,84F
00DD0:  CALL    7EA
00DD4:  GOTO    DD8
....................      
....................            } 
....................    ADC_SelfCal(); 
00DD8:  CALL    9C0
....................    ADC_StartRdContin(); 
00DDC:  CALL    B28
....................    ADC_RdataC(); 
00DE0:  CALL    BD6
....................    ADC_RdataC(); 
00DE4:  CALL    BD6
....................    ADC_RdataC(); 
00DE8:  CALL    BD6
....................    ADC_RdataC(); 
00DEC:  CALL    BD6
00DF0:  RETURN  
....................     
....................  
.................... } 
....................  
.................... static S32 Read_ADC_vol_in(S32 k){ 
*
012F0:  MOV     W5,[W15++]
012F2:  MOV     #C,W5
012F4:  REPEAT  #4
012F6:  MOV     [W5++],[W15++]
012F8:  CLR     85C
012FA:  CLR     85E
....................     S32 VinInt = 0; 
....................     ADCresult = ADC_RDataC(); 
012FC:  CALL    BD6
01300:  MOV     W0,816
01302:  MOV     W1,818
....................     ADCresult=ADCresult+ADCaddCoef; // Аддитивная ошибка, ошибка смещения  
01304:  MOV     822,W0
01306:  CLR     W1
01308:  BTSC    W0.F
0130A:  SETM    W1
0130C:  ADD     816
0130E:  MOV     W1,W0
01310:  ADDC    818,W0
01312:  MOV     W0,818
....................     Vin = ((ADCresult*5)/(8388608.0*PGA))*ADCmulCoef; 
01314:  MOV     816,W0
01316:  MOV     818,W1
01318:  MOV     #5,W2
0131A:  MOV     #0,W3
0131C:  CALL    DF2
01320:  MOV     W0,W5
01322:  MOV     W1,W6
01324:  MOV     #0,W1
01326:  MOV     #0,W2
01328:  MOV     #0,W3
0132A:  MOV.B   81E,W0L
0132C:  CLR.B   1
0132E:  CALL    E34
01332:  MOV     W5,[W15++]
01334:  MOV     W6,[W15++]
01336:  MOV     W0,W4
01338:  MOV     W1,W5
0133A:  MOV     W2,W6
0133C:  MOV     W3,W7
0133E:  MOV     #0,W0
01340:  MOV     #0,W1
01342:  MOV     #0,W2
01344:  MOV     #4160,W3
01346:  CALL    E98
0134A:  MOV     [--W15],W6
0134C:  MOV     [--W15],W5
0134E:  MOV     W0,W7
01350:  MOV     W1,W8
01352:  MOV     W2,W9
01354:  MOV     W3,W10
01356:  MOV     W5,W0
01358:  MOV     W6,W1
0135A:  CLR     W3
0135C:  BTSC    W1.F
0135E:  SETM    W3
01360:  MOV     W3,W2
01362:  CALL    FA8
01366:  MOV     W5,[W15++]
01368:  MOV     W6,[W15++]
0136A:  MOV     W7,[W15++]
0136C:  MOV     W7,W4
0136E:  MOV     W8,W5
01370:  MOV     W9,W6
01372:  MOV     W10,W7
01374:  CALL    100C
01378:  MOV     [--W15],W7
0137A:  MOV     [--W15],W6
0137C:  MOV     [--W15],W5
0137E:  MOV     W0,W5
01380:  MOV     W1,W6
01382:  MOV     W2,W7
01384:  MOV     W3,W8
01386:  MOV     826,W2
01388:  MOV     824,W1
0138A:  MOV     #0,W0
0138C:  CALL    1114
01390:  MOV     W5,[W15++]
01392:  MOV     W6,[W15++]
01394:  MOV     W7,[W15++]
01396:  MOV     W0,W4
01398:  MOV     W5,W0
0139A:  MOV     W1,W5
0139C:  MOV     W6,W1
0139E:  MOV     W2,W6
013A0:  MOV     W7,W2
013A2:  MOV     W3,W7
013A4:  MOV     W8,W3
013A6:  CALL    E98
013AA:  MOV     [--W15],W7
013AC:  MOV     [--W15],W6
013AE:  MOV     [--W15],W5
013B0:  CALL    115A
013B4:  MOV     W1,81A
013B6:  MOV     W2,81C
....................     VinInt = Vin*k; 
013B8:  MOV     858,W0
013BA:  MOV     85A,W1
013BC:  CALL    119E
013C0:  MOV     W0,W2
013C2:  MOV     W1,W3
013C4:  MOV     81A,W0
013C6:  MOV     81C,W1
013C8:  CALL    11EC
013CC:  CALL    12B0
013D0:  MOV     W0,85C
013D2:  MOV     W1,85E
....................     return VinInt; 
013D4:  MOV     85C,W0
013D6:  MOV     85E,W1
013D8:  MOV     #14,W5
013DA:  REPEAT  #4
013DC:  MOV     [--W15],[W5--]
013DE:  MOV     [--W15],W5
013E0:  RETURN  
.................... }                
....................  
.................... static S32 ADC_vol_average(U8 NumSamples){ 
013E2:  CLR     852
013E4:  CLR     854
....................     
....................    S32 A,Sum = 0;                
....................    U8 i; 
....................     
....................    for (i=0;i<NumSamples;i++){ 
013E6:  CLR.B   84D
013E8:  MOV.B   84D,W0L
013EA:  MOV     84C,W4
013EC:  CP.B    W4L,W0L
013EE:  BRA     LEU,1414
....................         
....................        A = Read_ADC_vol_in(uV); 
013F0:  MOV     #86A0,W4
013F2:  MOV     W4,858
013F4:  MOV     #1,W4
013F6:  MOV     W4,85A
013F8:  CALL    12F0
013FC:  MOV     W0,84E
013FE:  MOV     W1,850
....................        Sum = Sum + A;     
01400:  MOV     852,W0
01402:  ADD     84E,W0
01404:  MOV     W0,852
01406:  MOV     850,W4
01408:  MOV     854,W3
0140A:  ADDC    W3,W4,W0
0140C:  MOV     W0,854
0140E:  INC.B   084D
01410:  GOTO    13E8
....................    }                                   
....................    return Sum/NumSamples; 
01414:  BCLR.B  43.0
01416:  MOV.B   84C,W0L
01418:  MOV.B   W0L,4
0141A:  CLR.B   5
0141C:  MOV     #0,W3
0141E:  MOV     852,W0
01420:  MOV     854,W1
01422:  CALL    B58
01426:  MOV.D   W0,W0
01428:  RETURN  
.................... } 
....................  
.................... static void ADC_set_PGA(u8 PGA_val){ 
....................    
....................   PGA = PGA_val; 
*
0092A:  MOV.B   84A,W0L
0092C:  MOV.B   W0L,81E
....................  
.................... /* PGA 
.................... 000 = 1 (default) 
.................... 001 = 2 
.................... 010 = 4 
.................... 011 = 8 
.................... 100 = 16 
.................... 101 = 32 
.................... 110 = 64 
.................... 111 = 64*/ 
....................  
....................    switch (PGA_val){ 
0092E:  MOV.B   84A,W0L
00930:  CLR.B   1
00932:  XOR     #1,W0
00934:  BRA     Z,950
00936:  XOR     #3,W0
00938:  BRA     Z,95E
0093A:  XOR     #6,W0
0093C:  BRA     Z,96E
0093E:  XOR     #C,W0
00940:  BRA     Z,97E
00942:  XOR     #18,W0
00944:  BRA     Z,98E
00946:  XOR     #30,W0
00948:  BRA     Z,99E
0094A:  XOR     #60,W0
0094C:  BRA     Z,9AE
0094E:  BRA     9BE
....................       case 1: 
....................        WrReg(ADCON,0); 
00950:  MOV.B   #2,W0L
00952:  MOV.B   W0L,84E
00954:  CLR.B   84F
00956:  CALL    7EA
....................       break; 
0095A:  GOTO    9BE
....................        
....................       case 2: 
....................        WrReg(ADCON,1); 
0095E:  MOV.B   #2,W0L
00960:  MOV.B   W0L,84E
00962:  MOV.B   #1,W0L
00964:  MOV.B   W0L,84F
00966:  CALL    7EA
....................       break; 
0096A:  GOTO    9BE
....................        
....................       case 4: 
....................        WrReg(ADCON,2); 
0096E:  MOV.B   #2,W0L
00970:  MOV.B   W0L,84E
00972:  MOV.B   #2,W0L
00974:  MOV.B   W0L,84F
00976:  CALL    7EA
....................       break; 
0097A:  GOTO    9BE
....................        
....................       case 8: 
....................        WrReg(ADCON,3); 
0097E:  MOV.B   #2,W0L
00980:  MOV.B   W0L,84E
00982:  MOV.B   #3,W0L
00984:  MOV.B   W0L,84F
00986:  CALL    7EA
....................       break; 
0098A:  GOTO    9BE
....................        
....................       case 16: 
....................        WrReg(ADCON,4); 
0098E:  MOV.B   #2,W0L
00990:  MOV.B   W0L,84E
00992:  MOV.B   #4,W0L
00994:  MOV.B   W0L,84F
00996:  CALL    7EA
....................       break; 
0099A:  GOTO    9BE
....................        
....................       case 32: 
....................        WrReg(ADCON,5); 
0099E:  MOV.B   #2,W0L
009A0:  MOV.B   W0L,84E
009A2:  MOV.B   #5,W0L
009A4:  MOV.B   W0L,84F
009A6:  CALL    7EA
....................       break; 
009AA:  GOTO    9BE
....................        
....................       case 64: 
....................        WrReg(ADCON,6); 
009AE:  MOV.B   #2,W0L
009B0:  MOV.B   W0L,84E
009B2:  MOV.B   #6,W0L
009B4:  MOV.B   W0L,84F
009B6:  CALL    7EA
....................       break;  
009BA:  GOTO    9BE
....................    } 
009BE:  RETURN  
.................... } 
....................  
.................... static void ADC_init(){ 
....................     
....................   WrReg(STATUS,2); 
*
00894:  CLR.B   84E
00896:  MOV.B   #2,W0L
00898:  MOV.B   W0L,84F
0089A:  CALL    7EA
....................       // 
....................    if(ADC_sps_var>7)  ADC_sps_var = 7; 
0089E:  MOV     83A,W4
008A0:  LSR     W4,#8,W4
008A2:  CP.B    W4L,#7
008A4:  BRA     LEU,8AA
008A6:  MOV.B   #7,W0L
008A8:  MOV.B   W0L,83B
....................    if(ADC_sps_var==0) ADC_sps_var = 1; 
008AA:  CP0.B   83B
008AC:  BRA     NZ,8B2
008AE:  MOV.B   #1,W0L
008B0:  MOV.B   W0L,83B
....................     switch (ADC_sps_var){                // передача величины скорости измерений АЦП  
008B2:  MOV.B   83B,W0L
008B4:  CLR.B   1
008B6:  XOR     #1,W0
008B8:  BRA     Z,8D4
008BA:  XOR     #3,W0
008BC:  BRA     Z,8E0
008BE:  XOR     #1,W0
008C0:  BRA     Z,8EC
008C2:  XOR     #7,W0
008C4:  BRA     Z,8F8
008C6:  XOR     #1,W0
008C8:  BRA     Z,904
008CA:  XOR     #3,W0
008CC:  BRA     Z,910
008CE:  XOR     #1,W0
008D0:  BRA     Z,91C
008D2:  BRA     928
....................       case 1: ADC_sps_set(0x23);  break; // 10   sps 
008D4:  MOV.B   #23,W0L
008D6:  MOV.B   W0L,84A
008D8:  CALL    87E
008DC:  GOTO    928
....................       case 2: ADC_sps_set(0x43);  break; // 25   sps 
008E0:  MOV.B   #43,W0L
008E2:  MOV.B   W0L,84A
008E4:  CALL    87E
008E8:  GOTO    928
....................       case 3: ADC_sps_set(0x63);  break; // 50   sps 
008EC:  MOV.B   #63,W0L
008EE:  MOV.B   W0L,84A
008F0:  CALL    87E
008F4:  GOTO    928
....................       case 4: ADC_sps_set(0x82);  break; // 100  sps 
008F8:  MOV.B   #82,W0L
008FA:  MOV.B   W0L,84A
008FC:  CALL    87E
00900:  GOTO    928
....................       case 5: ADC_sps_set(0x91);  break; // 500  sps 
00904:  MOV.B   #91,W0L
00906:  MOV.B   W0L,84A
00908:  CALL    87E
0090C:  GOTO    928
....................       case 6: ADC_sps_set(0xA1);  break; // 1000 sps 
00910:  MOV.B   #A1,W0L
00912:  MOV.B   W0L,84A
00914:  CALL    87E
00918:  GOTO    928
....................       case 7: ADC_sps_set(0xC0);  break; // 3750 sps 
0091C:  MOV.B   #C0,W0L
0091E:  MOV.B   W0L,84A
00920:  CALL    87E
00924:  GOTO    928
....................       } 
00928:  RETURN  
....................  
.................... } 
....................  
.................... static float power(float t, U8 k) // возведение t в степень k 
.................... { 
....................   float res = 1.0; 
....................   while (k)  
....................       { 
....................         if (k & 1)  
....................            res *= t; 
....................         t *= t; 
....................         k >>= 1; 
....................       } 
....................   return res; 
.................... } 
....................  
.................... static float ADC_vol_to_T(){ 
....................     float R = 1000; 
....................     float Temper,k1,k2,k3,k4,k5,k6,k7 = 0; 
....................     float p,z1,z2,z3,z4,z5,z6 = 0; 
....................     U8 Temper_int = 0; 
....................    temp = ADC_vol_average(NumAver); 
....................    p=R/(temp/10); // приводим к кОм 
....................    switch (Global_Ch_Number){ 
.................... //------------------------------------------- 
....................       case 4: // структура 
.................... k1=12.1972840491798706; 
.................... k2=-103.27107382635586; 
.................... k3=397.925821471959352; 
.................... k4=-567.703864333219826; 
.................... k5=208.592693047598004; 
.................... k6=315.492219684645534; 
.................... k7=-92.5740048021543771; 
....................       break; 
.................... //------------------------------------------- 
....................       case 3: // спаи 
.................... k1=3.06244888759101741; 
.................... k2=-30.3586341044865549; 
.................... k3=241.908977336715907; 
.................... k4=-649.756288938224316; 
.................... k5=955.307573420926928; 
.................... k6=-485.428257496096194; 
.................... k7=136.248866791371256; 
....................       break; 
....................       //------------------------------------------- 
....................       case 2: // Пер 
.................... k1=17.2566714868880808; 
.................... k2=-215.322746395599097; 
.................... k3=1219.40785944648087; 
.................... k4=-3277.70955596119165; 
.................... k5=4778.55193661898375; 
.................... k6=-3251.6292140185833; 
.................... k7=954.333331361413002; 
....................       break;  
.................... //------------------------------------------- 
....................       case 1: // соленоид 
.................... k1 = 4.005067403952125460; 
.................... k2 = -55.2455571058671922; 
.................... k3 = 448.087557092308998; 
.................... k4 = -1390.99036489240825;  
.................... k5 = 2271.71780132129788;  
.................... k6 = -1387.04864621348679;  
.................... k7 = 500.36806705314666; 
....................       break;          
.................... //------------------------------------------- 
....................    } 
....................    z1 = k1+k2*p; 
....................    z2 = k3*(power(p,2)); 
....................    z3 = k4*(power(p,3)); 
....................    z4 = k5*(power(p,4)); 
....................    z5 = k6*(power(p,5)); 
....................    z6 = k7*(power(p,6)); 
....................    Temper = (z1+z2+z3+z4+z5+z6); 
....................    Temper_int = Temper; 
....................    ostatok_int_dec = (Temper-Temper_int)*10; 
....................    ostatok_int_sot = (Temper-Temper_int)*100; 
....................    if (ostatok_int_sot > 4) ostatok_int_dec++; 
....................    if (Temper<10) { LCD_num_symb = 1;} 
....................    if (Temper>=10){ LCD_num_symb = 2;} 
....................    if (Temper>=100){LCD_num_symb = 3;} 
....................    return Temper; 
....................    } 
....................  
.................... /* 
....................  
.................... static U8 RdReg(U8 RegName) 
.................... { 
....................    U8 RegValue = 0;  
....................    //1st Command Byte: 0001 rrrr where rrrr is the address of the first register to read. 
....................    //2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to read – 1 
....................    ADC_CS = 0; 
....................    delay_us(1); 
....................    Spi_write2(0x10+RegName); // 1st Command Byte,??????? ?????? 
....................    Spi_write2(0x00); // 1st Command Byte, ?????? ?????? ???? ???? 
....................    delay_us(8); // 50 CLK_IN PEDIODS 
....................    RegValue = Spi_read2(0); 
....................    delay_us(1); 
....................    ADC_CS =1; 
....................    delay_us(1); 
....................    Return RegValue;   
.................... } 
....................  
.................... static void WrReg(U8 RegName,CommandByte) 
.................... { 
....................    //if   (ADC_select) {ADC_CS = 0; ADC2_CS = 1;} 
....................    //else              {ADC_CS = 1; ADC2_CS = 0;} 
....................    ADC_CS = 0; 
....................    //ADC2_CS = 0; 
....................    delay_us(5); 
....................    Spi_write2(0x50+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written. 
....................    delay_us(10); 
....................    Spi_write2(0);            // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1. 
....................    delay_us(10); 
....................    Spi_write2(CommandByte); 
....................    delay_us(10); 
....................    ADC_CS = 1; 
....................    //ADC2_CS = 1; 
....................    delay_us(50); 
.................... } 
....................  
.................... static S32 ADC_RData(){             
....................  
....................      //if   (ADC_select) {ADC_CS = 0; ADC2_CS = 1;} 
....................      //else              {ADC_CS = 1; ADC2_CS = 0;} 
....................      ADC_CS = 0; 
....................      delay_us(1); 
....................      Spi_write2(0x01); 
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      //ADC2_CS = 1; 
....................      delay_us(1); 
....................      m1: 
....................      if(!ADC_DRDY | !ADC2_DRDY){ 
....................      if   (ADC_select) {ADC_CS = 0; ADC2_CS = 1;} 
....................      else              {ADC_CS = 1; ADC2_CS = 0;} 
....................      delay_us(1); 
....................      ADC_Rbyte1 = Spi_read2(0); 
....................      ADC_Rbyte2 = Spi_read2(0); 
....................      ADC_Rbyte3 = Spi_read2(0); 
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      //ADC2_CS = 1; 
....................      ADC_RByte_Sum = (ADC_Rbyte1<<16) + (ADC_Rbyte2<<8) + ADC_Rbyte3; 
....................      return ADC_RByte_Sum; 
....................      } 
....................      else goto m1; 
.................... } 
....................  
.................... static void ADC_StartRdContin(){ 
....................  
....................      //if   (ADC_select) {ADC_CS = 0; ADC2_CS = 1;} 
....................      //else              {ADC_CS = 1; ADC2_CS = 0;}  
....................      ADC_CS = 0; 
....................      delay_us(1);                                          
....................      Spi_write2(0x03);              
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      //ADC2_CS = 1; 
....................      
.................... } 
....................  
.................... static S32 ADC_RdataC(){                                               
....................                                                                
....................      //ADC_StartRdContin(); 
....................      //if   (ADC_select) {ADC_CS = 0; ADC2_CS = 1;} 
....................      //else              {ADC_CS = 1; ADC2_CS = 0;} 
....................      ADC_CS = 0; 
....................      delay_us(1);                                          
....................      Spi_write2(0x03); //ADC_StartRdContin             
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      //ADC2_CS = 1; 
....................      //While(ADC_DRDY | ADC2_DRDY) 
....................      While(ADC_DRDY) 
....................      delay_us(1); 
....................      //if   (ADC_select) {ADC_CS = 0; ADC2_CS = 1;} 
....................      //else              {ADC_CS = 1; ADC2_CS = 0;} 
....................      //ADC2_CS = 0 
....................      ADC_CS = 0; 
....................      delay_us(1); 
....................      ADC_Rbyte1 = Spi_read2(0); 
....................      ADC_Rbyte2 = Spi_read2(0); 
....................      ADC_Rbyte3 = Spi_read2(0); 
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      //ADC2_CS = 1; 
....................      ADC_RByte_Sum = (ADC_Rbyte1<<24) + (ADC_Rbyte2<<16) + (ADC_Rbyte3<<8); 
....................      return ADC_RByte_Sum/256; 
....................      } 
....................  
.................... static void ADC_StopRd(){ 
....................     
....................    ADC_CS = 0; 
....................    //ADC2_CS = 0; 
....................    delay_us(5); 
....................    Spi_write2(0x0F);   
....................    delay_us(5); 
....................    ADC_CS = 1; 
....................    //ADC2_CS = 1; 
....................    delay_us(50); 
....................  
.................... } 
....................  
.................... static void ADC_sps_set(U8 SPS){ 
....................  
....................    ADC_StopRd();                                                               
....................    Sps_buf = SPS; 
....................    WrReg(DRATE,SPS);  
....................                   
....................    // ???????? ???_????? ? ??????????           
.................... }  
....................  
.................... static void ADC_SelfCal(){ 
....................                       
....................    ADC_CS = 0; 
....................    //ADC2_CS = 0; 
....................    delay_us(1); 
....................    Spi_write2(0xF0); 
....................     delay_us(1); 
....................    ADC_CS = 1; 
....................    //ADC2_CS = 1;   
....................    Switch (Sps_buf) {      
....................      
....................       case 0xF0:    
....................        delay_us(220);         
....................         break;                       
....................        
....................       case 0xE0: 
....................        delay_us(255);  
....................         break; 
....................          
....................       case 0xD0: 
....................        delay_us(315);  
....................         break; 
....................          
....................       case 0xC0: 
....................        delay_us(445);  
....................         break; 
....................          
....................       case 0xB0: 
....................        delay_us(685);  
....................         break; 
....................          
....................       case 0xA1: 
....................        delay_ms(1); 
....................        delay_us(185);                
....................         break;       
....................          
....................       case 0x92: 
....................        delay_ms(5); 
....................         break; 
....................          
....................       case 0x82: 
....................        delay_ms(10); 
....................        delay_us(200); 
....................         break; 
....................                     
....................       case 0x63: 
....................        delay_ms(21);  
....................         break; 
....................          
....................       case 0x43: 
....................        delay_ms(41);  
....................         break; 
....................          
....................       case 0x23: 
....................        delay_ms(101);  
....................         break;          
....................              
....................       case 0x13: 
....................        delay_ms(201);  
....................         break;                           
....................      } 
....................       
.................... } 
....................  
.................... static void ADC_setCh(U8 Ch_Number){ 
....................    ADC_StopRd(); 
....................    Global_Ch_Number = Ch_Number; 
....................     
....................    //if (Ch_number>4) {ADC_select = 0;} 
....................    //else ADC_select = 1;  
....................     
....................    Switch (Ch_Number) { 
....................  
....................     case 4: WrReg(MUX,0x10); break; 
....................     case 3: WrReg(MUX,0x32); break; 
....................     case 2: WrReg(MUX,0x54); break; 
....................     case 1: WrReg(MUX,0x76); break; 
....................      
....................     case 8: WrReg(MUX,0x10); break; 
....................     case 7: WrReg(MUX,0x32); break; 
....................     case 6: WrReg(MUX,0x54); break; 
....................     case 5: WrReg(MUX,0x76); break;  
....................    ADC_SelfCal(); 
....................    ADC_StartRdContin(); 
....................    ADC_RdataC(); 
....................    ADC_RdataC(); 
....................    ADC_RdataC(); 
....................    ADC_RdataC(); 
....................     
.................... } 
.................... } 
....................  
.................... static S32 Read_ADC_vol_in(S32 k){ 
....................     S32 VinInt; 
....................     ADCresult = ADC_RDataC(); 
....................     //ADCresult=ADCresult+ADCaddCoef; // Аддитивная ошибка, ошибка смещения  
....................     Vin = ((ADCresult*5)/(8388608.0*PGA));//*ADCmulCoef; 
....................     VinInt = Vin*k; 
....................     return VinInt; 
.................... }                
....................  
.................... static S32 ADC_vol_average(U8 NumSamples){ 
....................     
....................    S32 A,Sum = 0;                
....................    U8 i; 
....................     
....................    for (i=0; i<NumSamples; i++) { 
....................         
....................        A = Read_ADC_vol_in(uV); 
....................        Sum = Sum + A;     
....................    }                                   
....................    return Sum/NumSamples; 
.................... } 
....................  
.................... static void ADC_set_PGA(u8 PGA_val){ 
....................    
....................   PGA = PGA_val; 
....................  
....................    switch (PGA_val){ 
....................       case 1: 
....................        WrReg(ADCON,0); 
....................       break; 
....................        
....................       case 2: 
....................        WrReg(ADCON,1); 
....................       break; 
....................        
....................       case 4: 
....................        WrReg(ADCON,2); 
....................       break; 
....................        
....................       case 8: 
....................        WrReg(ADCON,3); 
....................       break; 
....................        
....................       case 16: 
....................        WrReg(ADCON,4); 
....................       break; 
....................        
....................       case 32: 
....................        WrReg(ADCON,5); 
....................       break; 
....................        
....................       case 64: 
....................        WrReg(ADCON,6); 
....................       break;  
....................    } 
.................... } 
....................  
.................... static void ADC_wakeUp(){ 
....................  
....................    ADC_CS = 1;  
....................    //ADC2_CS = 1; 
....................    ADC_RESET = 0; //When using the RESET pin, take it low to force a reset. 
....................    //ADC2_RESET = 0; //When using the RESET pin, take it low to force a reset. 
....................    delay_us(100); 
....................    ADC_RESET = 1; 
....................    //ADC2_RESET = 1; 
....................    ADC_SYNC =0; 
....................    //ADC2_SYNC =0; 
....................    delay_us(100); 
....................    ADC_SYNC = 1; //To use the SYNC/PDWN pin, take it low and then high 
....................    //ADC2_SYNC = 1; //To use the SYNC/PDWN pin, take it low and then high 
....................    delay_ms(1); 
....................  
.................... }  
....................  
.................... static void ADC_init(){ 
....................     
....................   WrReg(STATUS,2); 
....................   ADC_set_PGA(8);    // 
....................    if(ADC_sps_var>7)  ADC_sps_var = 7; 
....................    if(ADC_sps_var==0) ADC_sps_var = 1; 
....................     switch (ADC_sps_var){                // передача величины скорости измерений АЦП  
....................       case 1: ADC_sps_set(0x23);  break; // 10   sps 
....................       case 2: ADC_sps_set(0x43);  break; // 25   sps 
....................       case 3: ADC_sps_set(0x63);  break; // 50   sps 
....................       case 4: ADC_sps_set(0x82);  break; // 100  sps 
....................       case 5: ADC_sps_set(0x91);  break; // 500  sps 
....................       case 6: ADC_sps_set(0xA1);  break; // 1000 sps 
....................       case 7: ADC_sps_set(0xC0);  break; // 3750 sps 
....................       } 
....................  
.................... } 
....................  
.................... static float power(float t, U8 k) // возведение t в степень k 
.................... { 
....................   float res = 1.0; 
....................   while (k)  
....................       { 
....................         if (k & 1)  
....................            res *= t; 
....................         t *= t; 
....................         k >>= 1; 
....................       } 
....................   return res; 
.................... } 
....................  
.................... static float ADC_vol_to_T(){ 
....................     float R = 1000; 
....................     float Temper,k1,k2,k3,k4,k5,k6,k7 = 0; 
....................     float p,z1,z2,z3,z4,z5,z6 = 0; 
....................     U8 Temper_int = 0; 
....................    temp = ADC_vol_average(NumAver); 
....................    p=R/(temp/10); // приводим к кОм 
....................    switch (Global_Ch_Number){ 
.................... //------------------------------------------- 
....................       case 4: // структура 
.................... k1=12.1972840491798706; 
.................... k2=-103.27107382635586; 
.................... k3=397.925821471959352; 
.................... k4=-567.703864333219826; 
.................... k5=208.592693047598004; 
.................... k6=315.492219684645534; 
.................... k7=-92.5740048021543771; 
....................       break; 
.................... //------------------------------------------- 
....................       case 3: // спаи 
.................... k1=3.06244888759101741; 
.................... k2=-30.3586341044865549; 
.................... k3=241.908977336715907; 
.................... k4=-649.756288938224316; 
.................... k5=955.307573420926928; 
.................... k6=-485.428257496096194; 
.................... k7=136.248866791371256; 
....................       break; 
....................       //------------------------------------------- 
....................       case 2: // Пер 
.................... k1=17.2566714868880808; 
.................... k2=-215.322746395599097; 
.................... k3=1219.40785944648087; 
.................... k4=-3277.70955596119165; 
.................... k5=4778.55193661898375; 
.................... k6=-3251.6292140185833; 
.................... k7=954.333331361413002; 
....................       break;  
.................... //------------------------------------------- 
....................       case 1: // соленоид 
.................... k1 = 4.005067403952125460; 
.................... k2 = -55.2455571058671922; 
.................... k3 = 448.087557092308998; 
.................... k4 = -1390.99036489240825;  
.................... k5 = 2271.71780132129788;  
.................... k6 = -1387.04864621348679;  
.................... k7 = 500.36806705314666; 
....................       break;          
.................... //------------------------------------------- 
....................    } 
....................    z1 = k1+k2*p; 
....................    z2 = k3*(power(p,2)); 
....................    z3 = k4*(power(p,3)); 
....................    z4 = k5*(power(p,4)); 
....................    z5 = k6*(power(p,5)); 
....................    z6 = k7*(power(p,6)); 
....................    Temper = (z1+z2+z3+z4+z5+z6); 
....................    Temper_int = Temper; 
....................    ostatok_int_dec = (Temper-Temper_int)*10; 
....................    ostatok_int_sot = (Temper-Temper_int)*100; 
....................    if (ostatok_int_sot > 4) ostatok_int_dec++; 
....................    if (Temper<10) { LCD_num_symb = 1;} 
....................    if (Temper>=10){ LCD_num_symb = 2;} 
....................    if (Temper>=100){LCD_num_symb = 3;} 
....................    return Temper; 
....................    } 
....................    */ 
....................  
....................  
.................... /*############################################################################*/ 
....................  
.................... static void Rd_Flash(){ 
*
00754:  MOV     W5,[W15++]
....................  
....................   read_program_memory(CK_USER_PAGE,flash_rd_data,4); 
00756:  MOV     #5000,W0
00758:  MOV     #1,W1
0075A:  MOV     #840,W2
0075C:  MOV     #4,W3
0075E:  CALL    726
....................   delay_ms(5); 
00762:  MOV     #5,W0
00764:  CALL    530
....................   NumAver = flash_rd_data[1];  
00768:  MOV.B   841,W0L
0076A:  MOV.B   W0L,83A
....................   ADC_sps_var = flash_rd_data[0]; 
0076C:  MOV.B   840,W0L
0076E:  MOV.B   W0L,83B
....................   CRC_buf = flash_rd_data[2]; 
00770:  MOV.B   842,W0L
00772:  MOV.B   W0L,83E
00774:  MOV     [--W15],W5
00776:  RETURN  
....................  
.................... } 
....................  
.................... static void Wr_Flash(){ 
....................  
....................   flash_wr_data[0] = Aver_Wr;  
*
01FF8:  MOV.B   832,W0L
01FFA:  MOV.B   W0L,82E
....................   flash_wr_data[1] = Sps_Wr; 
01FFC:  MOV.B   833,W0L
01FFE:  MOV.B   W0L,82F
....................   flash_wr_data[2] = CRC_Wr; 
02000:  MOV.B   834,W0L
02002:  MOV.B   W0L,830
....................   //flash_wr_data[4] = 0x00; 
....................   write_program_memory(CK_USER_PAGE,flash_wr_data,4); 
02004:  MOV     #5000,W0
02006:  MOV     #1,W1
02008:  MOV     #82E,W2
0200A:  MOV     #4,W3
0200C:  CALL    1F76
....................   delay_ms(2); 
02010:  MOV     #2,W0
02012:  CALL    530
02016:  RETURN  
....................  
....................  //if(Rd_Flash(buf_index)==in_wr_data) return 1; else return 0; 
.................... } 
....................  
.................... unsigned char Crc8(unsigned char *pcBlock, unsigned int len) 
*
00778:  MOV     W5,[W15++]
0077A:  SETM.B  84E
.................... { 
....................  
....................  
....................   //Name  : CRC-8 
....................   //Poly  : 0x31    x^8 + x^5 + x^4 + 1 
....................   //Init  : 0xFF 
....................   //Revert: false 
....................   //XorOut: 0x00 
....................   //Check : 0xF7 ("123456789") 
....................   //MaxLen: 15 байт(127 бит) - обнаружение 
....................   // одинарных, двойных, тройных и всех нечетных ошибок 
....................  
....................     unsigned char crc = 0xFF; 
....................     unsigned int i; 
....................   
....................     while (len--) 
0077C:  MOV     84C,W0
0077E:  DEC     084C
00780:  CP0     W0
00782:  BRA     Z,7BE
....................     { 
....................         crc ^= *pcBlock++; 
00784:  MOV     84A,W0
00786:  INC     084A
00788:  MOV     W0,W4
0078A:  MOV.B   [W4],W0L
0078C:  XOR.B   84E
....................   
....................         for (i = 0; i < 8; i++) 
0078E:  CLR     850
00790:  MOV     850,W4
00792:  CP      W4,#8
00794:  BRA     C,7BA
....................             crc = crc & 0x80 ? (crc << 1) ^ 0x31 : crc << 1; 
00796:  MOV.B   84E,W0L
00798:  AND     #80,W0
0079A:  CP0     W0
0079C:  BRA     Z,7AC
0079E:  MOV     84E,W5
007A0:  CLR.B   B
007A2:  SL      W5,#1,W5
007A4:  MOV     W5,W0
007A6:  XOR     #31,W0
007A8:  GOTO    7B2
007AC:  MOV.B   84E,W0L
007AE:  CLR.B   1
007B0:  SL      W0,#1,W0
007B2:  MOV.B   W0L,84E
007B4:  INC     0850
007B6:  GOTO    790
007BA:  GOTO    77C
....................     } 
....................   
....................     return crc; 
007BE:  MOV.B   84E,W0L
007C0:  MOV.B   W0L,0
007C2:  MOV     [--W15],W5
007C4:  RETURN  
.................... } 
....................  
.................... static void OscSetup(){ 
....................   //Fcy=Fosc/2 
....................   //Fin=10M 
....................   //Fosc=Fin(M/(N1*N2)) 
....................   U2BRG = 259;// BAUD Rate Setting for 9600 
*
0049A:  MOV     #103,W4
0049C:  MOV     W4,238
....................   U2MODE = 0b1010101010010000; 
0049E:  MOV     #AA90,W4
004A0:  MOV     W4,230
....................   PLLFBD = 30; // ???. ????. ??????? PLL M = 30 
004A2:  MOV     #1E,W4
004A4:  MOV     W4,746
....................    
....................   PLLPRE4 = 0; // ???. ????. ??????? PLL N1 = 2 
004A6:  BCLR.B  744.4
....................   PLLPRE3 = 0; 
004A8:  BCLR.B  744.3
....................   PLLPRE2 = 0; 
004AA:  BCLR.B  744.2
....................   PLLPRE1 = 0; 
004AC:  BCLR.B  744.1
....................   PLLPRE0 = 0; 
004AE:  BCLR.B  744.0
....................    
....................   PLLPOST0=0; // ???. ????. ??????? PLL N2 = 2 
004B0:  BCLR.B  744.6
....................   PLLPOST1=0; 
004B2:  BCLR.B  744.7
004B4:  RETURN  
....................      
....................    } 
....................  
.................... static void EnableInt (){ 
....................   ENABLE_INTERRUPTS(INTR_GLOBAL); 
004B6:  BCLR.B  81.7
004B8:  CLR     42
004BA:  BSET.B  81.7
....................   enable_interrupts(INTR_CN_PIN|PIN_B5);  
004BC:  BSET.B  60.7
004BE:  BSET.B  96.3
....................   enable_interrupts(INTR_CN_PIN|PIN_B5); 
004C0:  BSET.B  60.7
004C2:  BSET.B  96.3
....................   enable_interrupts(INTR_CN_PIN|PIN_B4); 
004C4:  BSET.B  60.6
004C6:  BSET.B  96.3
....................   enable_interrupts(INTR_CN_PIN|PIN_B3); 
004C8:  BSET.B  60.5
004CA:  BSET.B  96.3
....................   enable_interrupts(INTR_CN_PIN|PIN_B2); 
004CC:  BSET.B  60.4
004CE:  BSET.B  96.3
....................   enable_interrupts(INT_TIMER1); 
004D0:  BSET.B  94.3
....................   EXT_INT_EDGE(L_TO_H); 
004D2:  BCLR.B  82.0
004D4:  RETURN  
.................... } 
....................  
.................... static void DisableInt (){ 
....................   DISABLE_INTERRUPTS(INTR_GLOBAL); 
*
00402:  BCLR.B  81.7
00404:  MOV     #E0,W4
00406:  MOV     W4,42
00408:  BSET.B  81.7
....................   disable_interrupts(INTR_CN_PIN|PIN_B5);  
0040A:  BCLR.B  60.7
....................   disable_interrupts(INTR_CN_PIN|PIN_B5); 
0040C:  BCLR.B  60.7
....................   disable_interrupts(INTR_CN_PIN|PIN_B4); 
0040E:  BCLR.B  60.6
....................   disable_interrupts(INTR_CN_PIN|PIN_B3); 
00410:  BCLR.B  60.5
....................   disable_interrupts(INTR_CN_PIN|PIN_B2); 
00412:  BCLR.B  60.4
00414:  RETURN  
.................... } 
....................  
.................... static void MCU_init(){ 
....................  
....................   setup_timer1(TMR_INTERNAL | TMR_DIV_BY_64); // таймер 1 сбрасывает собачий таймер 
*
004D6:  CLR     104
004D8:  SETM    102
004DA:  MOV     #8020,W4
004DC:  MOV     W4,104
....................   set_timer1(20000); //reset the timer. 
004DE:  MOV     #4E20,W4
004E0:  MOV     W4,100
....................    
....................    SETUP_SPI2(SPI_MASTER|SPI_SCK_IDLE_LOW|SPI_XMIT_H_TO_L|SPI_MODE_8B|SPI_SAMPLE_AT_END|SPI_SS_DISABLED|SPI_CLK_DIV_128); 
004E2:  BCLR.B  261.7
004E4:  BCLR.B  260.6
004E6:  MOV     #221,W4
004E8:  MOV     W4,262
004EA:  BSET.B  261.7
....................    //f SCLK SPI = 312,5 kHz 
....................    //setup_timer1(TMR_DISABLED|TMR_DIV_BY_1); 
....................    //enable_interrupts(INT_EXT0); 
....................    //enable_interrupts(INT_TIMER1); 
....................    
....................  SCK2_TRIS=0; // SPI2 tris 
004EC:  BCLR.B  2E4.6
....................  SDI2_TRIS=1; 
004EE:  BSET.B  2E4.7
....................  SDO2_TRIS=0; 
004F0:  BCLR.B  2E5.0
....................   
....................  CN1_TRIS = 1; 
004F2:  BSET.B  2C6.5
....................  CN2_TRIS = 1; 
004F4:  BSET.B  2C6.4
....................  CN3_TRIS = 1; 
004F6:  BSET.B  2C6.2
....................  CN4_TRIS = 1; 
004F8:  BSET.B  2C6.3
....................   
....................  TRG0 = 0; // lcd buf tris 
004FA:  BCLR.B  2E4.0
....................  TRG1 = 0; 
004FC:  BCLR.B  2E4.1
....................  TRB1 = 0; 
004FE:  BCLR.B  2C6.1
....................  TRB0 = 0; 
00500:  BCLR.B  2C6.0
....................   
....................  LCD_RS_TRIS=0; 
00502:  BCLR.B  2E5.5
....................  LCD_RW_TRIS=0; 
00504:  BCLR.B  2E5.4
....................  LCD_E_TRIS=0; 
00506:  BCLR.B  2E5.6
....................   
....................  ADC_CS_TRIS=0;      ADC2_CS_TRIS=0; 
00508:  BCLR.B  2E5.1
0050A:  BCLR.B  2D3.2
....................  ADC_RESET_TRIS=0;   ADC2_RESET_TRIS=0; 
0050C:  BCLR.B  2D2.3
0050E:  BCLR.B  2D2.0
....................  ADC_SYNC_TRIS=0;    ADC2_SYNC_TRIS=0; 
00510:  BCLR.B  2D2.2
00512:  BCLR.B  2D3.3
....................  ADC_DRDY_TRIS=1;    ADC2_DRDY_TRIS=1;       // опрос готовнсти данных АЦП 
00514:  BSET.B  2D2.1
00516:  BSET.B  2D3.1
....................   
....................  UART2_RX_TRIS=1; 
00518:  BSET.B  2DE.4
....................  UART2_TX_TRIS=0; 
0051A:  BCLR.B  2DE.5
....................  XPORT_RST_TRIS=0; 
0051C:  BCLR.B  2C7.7
....................   
....................  XPORT_RST_n = 0; 
0051E:  BCLR.B  2C7.7
....................  delay_us(500); 
00520:  REPEAT  #E1E
00522:  NOP     
00524:  REPEAT  #3FFF
00526:  NOP     
....................  XPORT_RST_n = 1; 
00528:  BSET.B  2C7.7
....................  EnableInt(); 
0052A:  CALL    4B6
0052E:  RETURN  
.................... } 
....................  
.................... static void Bpush_delay(){ 
*
01B4C:  CLR     84A
....................     
....................    U16 counter = 0; 
....................     
....................    do {counter++;}  
01B4E:  INC     084A
....................    while (counter<2000);    
01B50:  MOV     84A,W4
01B52:  MOV     #7D0,W3
01B54:  CP      W3,W4
01B56:  BRA     GTU,1B4E
....................    EnableInt();  
01B58:  CALL    4B6
01B5C:  RETURN  
.................... } 
....................  
.................... static void LCD_print_menu(){ 
01B5E:  MOV     W5,[W15++]
.................... LCDsetCursor(one); 
01B60:  CLR.B   84C
01B62:  CALL    6A6
.................... LCDMsg("ADC sps set  "); 
01B66:  MOV     #0,W5
01B68:  MOV     W5,W0
01B6A:  CALL    252
01B6E:  IOR.B   #0,W0L
01B70:  BTSC.B  42.1
01B72:  BRA     1B7E
01B74:  INC     W5,W5
01B76:  MOV.B   W0L,84E
01B78:  CALL    69C
01B7C:  BRA     1B68
.................... LCDsetCursor(two); 
01B7E:  MOV.B   #40,W0L
01B80:  MOV.B   W0L,84C
01B82:  CALL    6A6
.................... LCDMsg("Average set  "); 
01B86:  MOV     #0,W5
01B88:  MOV     W5,W0
01B8A:  CALL    26C
01B8E:  IOR.B   #0,W0L
01B90:  BTSC.B  42.1
01B92:  BRA     1B9E
01B94:  INC     W5,W5
01B96:  MOV.B   W0L,84E
01B98:  CALL    69C
01B9C:  BRA     1B88
.................... LCDsetCursor(three); 
01B9E:  MOV.B   #10,W0L
01BA0:  MOV.B   W0L,84C
01BA2:  CALL    6A6
.................... LCDMsg("Reset device "); 
01BA6:  MOV     #0,W5
01BA8:  MOV     W5,W0
01BAA:  CALL    286
01BAE:  IOR.B   #0,W0L
01BB0:  BTSC.B  42.1
01BB2:  BRA     1BBE
01BB4:  INC     W5,W5
01BB6:  MOV.B   W0L,84E
01BB8:  CALL    69C
01BBC:  BRA     1BA8
.................... LCDsetCursor(four); 
01BBE:  MOV.B   #50,W0L
01BC0:  MOV.B   W0L,84C
01BC2:  CALL    6A6
.................... LCDMsg("Return back  "); 
01BC6:  MOV     #0,W5
01BC8:  MOV     W5,W0
01BCA:  CALL    2A0
01BCE:  IOR.B   #0,W0L
01BD0:  BTSC.B  42.1
01BD2:  BRA     1BDE
01BD4:  INC     W5,W5
01BD6:  MOV.B   W0L,84E
01BD8:  CALL    69C
01BDC:  BRA     1BC8
01BDE:  MOV     [--W15],W5
01BE0:  RETURN  
.................... } 
....................  
.................... static void LCD_main_menu (void) { 
01BE2:  MOV     W5,[W15++]
.................... //DisableInt(); 
.................... LCD_print_menu(); 
01BE4:  CALL    1B5E
....................  
....................    //if(CN4){Bpush_delay(); if(CN4) menu_sel++;} 
....................    //if(CN3){Bpush_delay(); if(CN3) menu_sel--;} 
....................    switch (menu_sel){ 
01BE8:  MOV.B   837,W0L
01BEA:  CLR.B   1
01BEC:  XOR     #0,W0
01BEE:  BRA     Z,1BFE
01BF0:  XOR     #1,W0
01BF2:  BRA     Z,1C82
01BF4:  XOR     #3,W0
01BF6:  BRA     Z,1D06
01BF8:  XOR     #1,W0
01BFA:  BRA     Z,1D8A
01BFC:  BRA     1E0E
....................     case 0:  
....................        LCDsetCursor(0x0D); LCDMsg("<--"); 
01BFE:  MOV.B   #D,W0L
01C00:  MOV.B   W0L,84C
01C02:  CALL    6A6
01C06:  MOV     #0,W5
01C08:  MOV     W5,W0
01C0A:  CALL    2BA
01C0E:  IOR.B   #0,W0L
01C10:  BTSC.B  42.1
01C12:  BRA     1C1E
01C14:  INC     W5,W5
01C16:  MOV.B   W0L,84E
01C18:  CALL    69C
01C1C:  BRA     1C08
....................        LCDsetCursor(0x4D); LCDMsg("   "); // стирание стрелки от предыдущего 
01C1E:  MOV.B   #4D,W0L
01C20:  MOV.B   W0L,84C
01C22:  CALL    6A6
01C26:  MOV     #0,W5
01C28:  MOV     W5,W0
01C2A:  CALL    2CA
01C2E:  IOR.B   #0,W0L
01C30:  BTSC.B  42.1
01C32:  BRA     1C3E
01C34:  INC     W5,W5
01C36:  MOV.B   W0L,84E
01C38:  CALL    69C
01C3C:  BRA     1C28
....................        LCDsetCursor(0x1D); LCDMsg("   "); // элемента меню 
01C3E:  MOV.B   #1D,W0L
01C40:  MOV.B   W0L,84C
01C42:  CALL    6A6
01C46:  MOV     #0,W5
01C48:  MOV     W5,W0
01C4A:  CALL    2CA
01C4E:  IOR.B   #0,W0L
01C50:  BTSC.B  42.1
01C52:  BRA     1C5E
01C54:  INC     W5,W5
01C56:  MOV.B   W0L,84E
01C58:  CALL    69C
01C5C:  BRA     1C48
....................        LCDsetCursor(0x5D); LCDMsg("   "); 
01C5E:  MOV.B   #5D,W0L
01C60:  MOV.B   W0L,84C
01C62:  CALL    6A6
01C66:  MOV     #0,W5
01C68:  MOV     W5,W0
01C6A:  CALL    2CA
01C6E:  IOR.B   #0,W0L
01C70:  BTSC.B  42.1
01C72:  BRA     1C7E
01C74:  INC     W5,W5
01C76:  MOV.B   W0L,84E
01C78:  CALL    69C
01C7C:  BRA     1C68
....................     break; 
01C7E:  GOTO    1E0E
....................      
....................     case 1:  
....................        LCDsetCursor(0x0D); LCDMsg("   "); 
01C82:  MOV.B   #D,W0L
01C84:  MOV.B   W0L,84C
01C86:  CALL    6A6
01C8A:  MOV     #0,W5
01C8C:  MOV     W5,W0
01C8E:  CALL    2CA
01C92:  IOR.B   #0,W0L
01C94:  BTSC.B  42.1
01C96:  BRA     1CA2
01C98:  INC     W5,W5
01C9A:  MOV.B   W0L,84E
01C9C:  CALL    69C
01CA0:  BRA     1C8C
....................        LCDsetCursor(0x4D); LCDMsg("<--"); // стирание стрелки от предыдущего 
01CA2:  MOV.B   #4D,W0L
01CA4:  MOV.B   W0L,84C
01CA6:  CALL    6A6
01CAA:  MOV     #0,W5
01CAC:  MOV     W5,W0
01CAE:  CALL    2BA
01CB2:  IOR.B   #0,W0L
01CB4:  BTSC.B  42.1
01CB6:  BRA     1CC2
01CB8:  INC     W5,W5
01CBA:  MOV.B   W0L,84E
01CBC:  CALL    69C
01CC0:  BRA     1CAC
....................        LCDsetCursor(0x1D); LCDMsg("   "); // элемента меню 
01CC2:  MOV.B   #1D,W0L
01CC4:  MOV.B   W0L,84C
01CC6:  CALL    6A6
01CCA:  MOV     #0,W5
01CCC:  MOV     W5,W0
01CCE:  CALL    2CA
01CD2:  IOR.B   #0,W0L
01CD4:  BTSC.B  42.1
01CD6:  BRA     1CE2
01CD8:  INC     W5,W5
01CDA:  MOV.B   W0L,84E
01CDC:  CALL    69C
01CE0:  BRA     1CCC
....................        LCDsetCursor(0x5D); LCDMsg("   "); 
01CE2:  MOV.B   #5D,W0L
01CE4:  MOV.B   W0L,84C
01CE6:  CALL    6A6
01CEA:  MOV     #0,W5
01CEC:  MOV     W5,W0
01CEE:  CALL    2CA
01CF2:  IOR.B   #0,W0L
01CF4:  BTSC.B  42.1
01CF6:  BRA     1D02
01CF8:  INC     W5,W5
01CFA:  MOV.B   W0L,84E
01CFC:  CALL    69C
01D00:  BRA     1CEC
....................     break; 
01D02:  GOTO    1E0E
....................      
....................     case 2:  
....................        LCDsetCursor(0x0D); LCDMsg("   "); 
01D06:  MOV.B   #D,W0L
01D08:  MOV.B   W0L,84C
01D0A:  CALL    6A6
01D0E:  MOV     #0,W5
01D10:  MOV     W5,W0
01D12:  CALL    2CA
01D16:  IOR.B   #0,W0L
01D18:  BTSC.B  42.1
01D1A:  BRA     1D26
01D1C:  INC     W5,W5
01D1E:  MOV.B   W0L,84E
01D20:  CALL    69C
01D24:  BRA     1D10
....................        LCDsetCursor(0x4D); LCDMsg("   "); // стирание стрелки от предыдущего 
01D26:  MOV.B   #4D,W0L
01D28:  MOV.B   W0L,84C
01D2A:  CALL    6A6
01D2E:  MOV     #0,W5
01D30:  MOV     W5,W0
01D32:  CALL    2CA
01D36:  IOR.B   #0,W0L
01D38:  BTSC.B  42.1
01D3A:  BRA     1D46
01D3C:  INC     W5,W5
01D3E:  MOV.B   W0L,84E
01D40:  CALL    69C
01D44:  BRA     1D30
....................        LCDsetCursor(0x1D); LCDMsg("<--"); // элемента меню 
01D46:  MOV.B   #1D,W0L
01D48:  MOV.B   W0L,84C
01D4A:  CALL    6A6
01D4E:  MOV     #0,W5
01D50:  MOV     W5,W0
01D52:  CALL    2BA
01D56:  IOR.B   #0,W0L
01D58:  BTSC.B  42.1
01D5A:  BRA     1D66
01D5C:  INC     W5,W5
01D5E:  MOV.B   W0L,84E
01D60:  CALL    69C
01D64:  BRA     1D50
....................        LCDsetCursor(0x5D); LCDMsg("   "); 
01D66:  MOV.B   #5D,W0L
01D68:  MOV.B   W0L,84C
01D6A:  CALL    6A6
01D6E:  MOV     #0,W5
01D70:  MOV     W5,W0
01D72:  CALL    2CA
01D76:  IOR.B   #0,W0L
01D78:  BTSC.B  42.1
01D7A:  BRA     1D86
01D7C:  INC     W5,W5
01D7E:  MOV.B   W0L,84E
01D80:  CALL    69C
01D84:  BRA     1D70
....................     break; 
01D86:  GOTO    1E0E
....................      
....................     case 3:  
....................        LCDsetCursor(0x0D); LCDMsg("   "); 
01D8A:  MOV.B   #D,W0L
01D8C:  MOV.B   W0L,84C
01D8E:  CALL    6A6
01D92:  MOV     #0,W5
01D94:  MOV     W5,W0
01D96:  CALL    2CA
01D9A:  IOR.B   #0,W0L
01D9C:  BTSC.B  42.1
01D9E:  BRA     1DAA
01DA0:  INC     W5,W5
01DA2:  MOV.B   W0L,84E
01DA4:  CALL    69C
01DA8:  BRA     1D94
....................        LCDsetCursor(0x4D); LCDMsg("   "); // стирание стрелки от предыдущего 
01DAA:  MOV.B   #4D,W0L
01DAC:  MOV.B   W0L,84C
01DAE:  CALL    6A6
01DB2:  MOV     #0,W5
01DB4:  MOV     W5,W0
01DB6:  CALL    2CA
01DBA:  IOR.B   #0,W0L
01DBC:  BTSC.B  42.1
01DBE:  BRA     1DCA
01DC0:  INC     W5,W5
01DC2:  MOV.B   W0L,84E
01DC4:  CALL    69C
01DC8:  BRA     1DB4
....................        LCDsetCursor(0x1D); LCDMsg("   "); // элемента меню 
01DCA:  MOV.B   #1D,W0L
01DCC:  MOV.B   W0L,84C
01DCE:  CALL    6A6
01DD2:  MOV     #0,W5
01DD4:  MOV     W5,W0
01DD6:  CALL    2CA
01DDA:  IOR.B   #0,W0L
01DDC:  BTSC.B  42.1
01DDE:  BRA     1DEA
01DE0:  INC     W5,W5
01DE2:  MOV.B   W0L,84E
01DE4:  CALL    69C
01DE8:  BRA     1DD4
....................        LCDsetCursor(0x5D); LCDMsg("<--"); 
01DEA:  MOV.B   #5D,W0L
01DEC:  MOV.B   W0L,84C
01DEE:  CALL    6A6
01DF2:  MOV     #0,W5
01DF4:  MOV     W5,W0
01DF6:  CALL    2BA
01DFA:  IOR.B   #0,W0L
01DFC:  BTSC.B  42.1
01DFE:  BRA     1E0A
01E00:  INC     W5,W5
01E02:  MOV.B   W0L,84E
01E04:  CALL    69C
01E08:  BRA     1DF4
....................     break; 
01E0A:  GOTO    1E0E
....................    }   
01E0E:  MOV     [--W15],W5
01E10:  RETURN  
.................... } 
....................  
.................... static void Full_dev_reset(){ 
*
00A9E:  MOV     W5,[W15++]
....................   LCDClear(); 
00AA0:  CALL    656
....................   LCDsetCursor(one); 
00AA4:  CLR.B   84C
00AA6:  CALL    6A6
....................   LCDMsg("   Reset done"); 
00AAA:  MOV     #0,W5
00AAC:  MOV     W5,W0
00AAE:  CALL    2DA
00AB2:  IOR.B   #0,W0L
00AB4:  BTSC.B  42.1
00AB6:  BRA     AC2
00AB8:  INC     W5,W5
00ABA:  MOV.B   W0L,84E
00ABC:  CALL    69C
00AC0:  BRA     AAC
....................   LCDsetCursor(three); 
00AC2:  MOV.B   #10,W0L
00AC4:  MOV.B   W0L,84C
00AC6:  CALL    6A6
....................   LCDMsg("Starting device!"); 
00ACA:  MOV     #0,W5
00ACC:  MOV     W5,W0
00ACE:  CALL    2F4
00AD2:  IOR.B   #0,W0L
00AD4:  BTSC.B  42.1
00AD6:  BRA     AE2
00AD8:  INC     W5,W5
00ADA:  MOV.B   W0L,84E
00ADC:  CALL    69C
00AE0:  BRA     ACC
....................   delay_ms(1000); 
00AE2:  MOV     #3E8,W0
00AE4:  CALL    530
....................   OscSetup(); 
00AE8:  CALL    49A
....................   MCU_init(); 
00AEC:  CALL    4D6
....................   LCDInit(); 
00AF0:  CALL    5B6
....................   reset_fl = 0; 
00AF4:  BCLR.B  839.2
....................   ADC_wakeUp(); 
00AF6:  CALL    7C6
....................   ADC_wakeUp();  
00AFA:  CALL    7C6
....................   ADC_init(); 
00AFE:  CALL    894
....................   ADC_set_PGA(8); 
00B02:  MOV.B   #8,W0L
00B04:  MOV.B   W0L,84A
00B06:  CALL    92A
....................   ADC_sps_set(0x23); //0x023 - 10 sps, 0x43 - 25 sps, 0x63 - 50 sps 
00B0A:  MOV.B   #23,W0L
00B0C:  MOV.B   W0L,84A
00B0E:  CALL    87E
....................                      //0x82 - 100 sps, 0x91 - 500 sps 
....................                      //0xA1 - 1000 sps, 0xC0 - 3750 sps 
....................   ADC_SelfCal(); 
00B12:  CALL    9C0
....................   meas_stop_fl = 0; // вкл. режим измерений 
00B16:  BCLR.B  839.0
....................   menu_fl = 0;      // отключение меню 
00B18:  CLR.B   838
....................   menu_item = 0;    // сброс элемента меню 
00B1A:  CLR.B   836
....................   NumAver = 10;      // сброс величины усреднения данных АЦП 
00B1C:  MOV.B   #A,W0L
00B1E:  MOV.B   W0L,83A
....................   LCDClear();       // очистка дисплея 
00B20:  CALL    656
00B24:  MOV     [--W15],W5
00B26:  RETURN  
....................  
.................... } 
....................  
.................... static void ADC_rd_and_print_ch(U8 chanel){ 
*
017CE:  MOV     W5,[W15++]
017D0:  MOV     W6,[W15++]
....................  
....................    switch (chanel){ 
017D2:  MOV.B   84A,W0L
017D4:  CLR.B   1
017D6:  XOR     #1,W0
017D8:  BRA     Z,17F8
017DA:  XOR     #3,W0
017DC:  BRA     Z,1860
017DE:  XOR     #1,W0
017E0:  BRA     Z,18CA
017E2:  XOR     #7,W0
017E4:  BRA     Z,1934
017E6:  XOR     #1,W0
017E8:  BRA     Z,199E
017EA:  XOR     #3,W0
017EC:  BRA     Z,1A08
017EE:  XOR     #1,W0
017F0:  BRA     Z,1A72
017F2:  XOR     #F,W0
017F4:  BRA     Z,1ADC
017F6:  BRA     1B46
.................... //---------------- АЦП 1 --------------------------------------//      
....................  case 1:  
....................   LCDsetCursor(one); 
017F8:  CLR.B   84C
017FA:  CALL    6A6
....................   //LCDMsg("CTP"); 
....................   //LCDMsg('1'); 
....................   //LCDMsg(':'); 
....................   ADCaddCoef = -28;      // смещение нуля для канала 1 
017FE:  MOV     #FFE4,W4
01800:  MOV     W4,822
....................   ADCmulCoef = 1.00012; // мультипликат. ошибка для канала 1 
01802:  MOV     #3EF,W4
01804:  MOV     W4,824
01806:  MOV     #3F80,W4
01808:  MOV     W4,826
....................   ADC_setCh(1); 
0180A:  MOV.B   #1,W0L
0180C:  MOV.B   W0L,84C
0180E:  CALL    D1A
....................   //Final_T_in_K = ADC_vol_to_T(); 
....................   temp = abs(ADC_vol_average(NumAver));   // убираем знак числа !!! 
01812:  MOV.B   83A,W0L
01814:  MOV.B   W0L,84C
01816:  CALL    13E2
0181A:  MOV     W0,W5
0181C:  MOV     W1,W6
0181E:  MOV     W5,W0
01820:  MOV     W6,W1
01822:  BTSS    W1.F
01824:  BRA     182E
01826:  MOV     #0,W4
01828:  SUB     W4,W5,W0
0182A:  MOV     #0,W4
0182C:  SUBB    W4,W6,W1
0182E:  MOV     W0,844
01830:  MOV     W1,846
....................   LCDPutU32(temp,6); 
01832:  MOV.B   #6,W0L
01834:  MOV.B   W0L,850
01836:  PUSH    844
01838:  POP     84C
0183A:  PUSH    846
0183C:  POP     84E
0183E:  CALL    14AE
....................   //LCDsetCursor(0x0A); 
....................   //LCDPutU16(Final_T_in_K,LCD_num_symb); 
....................   //LCDMsg("."); 
....................   //LCDPutU16(ostatok_int_dec,1); 
....................   //if(LCD_num_symb==1){LCDMsg("K  ");} //очистка строки  
....................   //if(LCD_num_symb==2){LCDMsg("K "); } 
....................   //if(LCD_num_symb==3){LCDMsg("K");  } 
....................   Printf("a%05Lu\n",temp); 
01842:  BTSC.B  233.1
01844:  BRA     1842
01846:  MOV     #61,W4
01848:  MOV     W4,234
0184A:  MOV     844,W0
0184C:  MOV     846,W1
0184E:  MOV     #8005,W4
01850:  CALL    1706
01854:  BTSC.B  233.1
01856:  BRA     1854
01858:  MOV     #A,W4
0185A:  MOV     W4,234
....................   //LCDsetCursor(0x03); 
....................   //LCDsetCursor(0x01); 
....................   //LCDMsg(" "); 
....................  break; 
0185C:  GOTO    1B46
.................... //---------------- 2 датчик --------------------------------------// 
....................  case 2:  
....................   LCDsetCursor(two); 
01860:  MOV.B   #40,W0L
01862:  MOV.B   W0L,84C
01864:  CALL    6A6
....................   //LCDMsg("C"); 
....................   //LCDMsg('2'); 
....................   //LCDputCH(0xA8);// П 
....................   //LCDMsg(':'); 
....................   ADCaddCoef = 35;          // смещение нуля для канала 2 
01868:  MOV     #23,W4
0186A:  MOV     W4,822
....................   ADCmulCoef = 1.00013;   // мультипликат. ошибка для канала 2 
0186C:  MOV     #443,W4
0186E:  MOV     W4,824
01870:  MOV     #3F80,W4
01872:  MOV     W4,826
....................   ADC_setCh(2); 
01874:  MOV.B   #2,W0L
01876:  MOV.B   W0L,84C
01878:  CALL    D1A
....................   //Final_T_in_K = ADC_vol_to_T(); 
....................   temp = abs(ADC_vol_average(NumAver));   // убираем знак числа !!! 
0187C:  MOV.B   83A,W0L
0187E:  MOV.B   W0L,84C
01880:  CALL    13E2
01884:  MOV     W0,W5
01886:  MOV     W1,W6
01888:  MOV     W5,W0
0188A:  MOV     W6,W1
0188C:  BTSS    W1.F
0188E:  BRA     1898
01890:  MOV     #0,W4
01892:  SUB     W4,W5,W0
01894:  MOV     #0,W4
01896:  SUBB    W4,W6,W1
01898:  MOV     W0,844
0189A:  MOV     W1,846
....................   LCDPutU32(temp,6); 
0189C:  MOV.B   #6,W0L
0189E:  MOV.B   W0L,850
018A0:  PUSH    844
018A2:  POP     84C
018A4:  PUSH    846
018A6:  POP     84E
018A8:  CALL    14AE
....................   //LCDsetCursor(0x4A); 
....................   //LCDPutU16(Final_T_in_K,LCD_num_symb); 
....................   //LCDMsg("."); 
....................   //LCDPutU16(ostatok_int_dec,1); 
....................   //if(LCD_num_symb==1){LCDMsg("K  ");} //очистка строки  
....................   //if(LCD_num_symb==2){LCDMsg("K "); } 
....................   //if(LCD_num_symb==3){LCDMsg("K");  } 
....................   Printf("b%05Lu\n",temp); 
018AC:  BTSC.B  233.1
018AE:  BRA     18AC
018B0:  MOV     #62,W4
018B2:  MOV     W4,234
018B4:  MOV     844,W0
018B6:  MOV     846,W1
018B8:  MOV     #8005,W4
018BA:  CALL    1706
018BE:  BTSC.B  233.1
018C0:  BRA     18BE
018C2:  MOV     #A,W4
018C4:  MOV     W4,234
....................   //LCDsetCursor(0x41); 
....................   //LCDMsg(" "); 
....................  break; 
018C6:  GOTO    1B46
.................... //---------------- 3 датчик --------------------------------------//   
....................  case 3:  
....................   LCDsetCursor(three); 
018CA:  MOV.B   #10,W0L
018CC:  MOV.B   W0L,84C
018CE:  CALL    6A6
....................   //LCDputCH(0xA8);// П 
....................   //LCDMsg('E'); 
....................   //LCDMsg('P'); 
....................   //LCDMsg('3'); 
....................   //LCDMsg(':'); 
....................   ADCaddCoef = 70;        // смещение нуля для канала 3 
018D2:  MOV     #46,W4
018D4:  MOV     W4,822
....................   ADCmulCoef = 1.00013;  // мультипликат. ошибка для канала 3 
018D6:  MOV     #443,W4
018D8:  MOV     W4,824
018DA:  MOV     #3F80,W4
018DC:  MOV     W4,826
....................   ADC_setCh(3); 
018DE:  MOV.B   #3,W0L
018E0:  MOV.B   W0L,84C
018E2:  CALL    D1A
....................   //Final_T_in_K = ADC_vol_to_T(); 
....................   temp = abs(ADC_vol_average(NumAver));   // убираем знак числа !!! 
018E6:  MOV.B   83A,W0L
018E8:  MOV.B   W0L,84C
018EA:  CALL    13E2
018EE:  MOV     W0,W5
018F0:  MOV     W1,W6
018F2:  MOV     W5,W0
018F4:  MOV     W6,W1
018F6:  BTSS    W1.F
018F8:  BRA     1902
018FA:  MOV     #0,W4
018FC:  SUB     W4,W5,W0
018FE:  MOV     #0,W4
01900:  SUBB    W4,W6,W1
01902:  MOV     W0,844
01904:  MOV     W1,846
....................   LCDPutU32(temp,6); 
01906:  MOV.B   #6,W0L
01908:  MOV.B   W0L,850
0190A:  PUSH    844
0190C:  POP     84C
0190E:  PUSH    846
01910:  POP     84E
01912:  CALL    14AE
....................   //LCDMsg(" "); 
....................   //LCDPutU16(Final_T_in_K,LCD_num_symb); 
....................   //LCDMsg("."); 
....................   //LCDPutU16(ostatok_int_dec,1); 
....................   //if(LCD_num_symb==1){LCDMsg("K  ");} //очистка строки  
....................   //if(LCD_num_symb==2){LCDMsg("K "); } 
....................   //if(LCD_num_symb==3){LCDMsg("K");  } 
....................   Printf("c%05Lu\n",temp); 
01916:  BTSC.B  233.1
01918:  BRA     1916
0191A:  MOV     #63,W4
0191C:  MOV     W4,234
0191E:  MOV     844,W0
01920:  MOV     846,W1
01922:  MOV     #8005,W4
01924:  CALL    1706
01928:  BTSC.B  233.1
0192A:  BRA     1928
0192C:  MOV     #A,W4
0192E:  MOV     W4,234
....................   //LCDsetCursor(0x11); 
....................   //LCDMsg(" "); 
....................  break; 
01930:  GOTO    1B46
.................... //---------------- 4 датчик --------------------------------------//     
....................    case 4:  
....................   LCDsetCursor(four); 
01934:  MOV.B   #50,W0L
01936:  MOV.B   W0L,84C
01938:  CALL    6A6
....................   //LCDMsg("CO"); 
....................   //LCDputCH(0xA7); // Л 
....................   //LCDMsg('4'); 
....................   //LCDMsg(':'); 
....................   ADCaddCoef = 40;        // смещение нуля для канала 4 
0193C:  MOV     #28,W4
0193E:  MOV     W4,822
....................   ADCmulCoef = 1.00012;        // мультипликат. ошибка для канала 4 
01940:  MOV     #3EF,W4
01942:  MOV     W4,824
01944:  MOV     #3F80,W4
01946:  MOV     W4,826
....................   ADC_setCh(4); 
01948:  MOV.B   #4,W0L
0194A:  MOV.B   W0L,84C
0194C:  CALL    D1A
....................   //Final_T_in_K = ADC_vol_to_T(); 
....................   temp = abs(ADC_vol_average(NumAver));   // убираем знак числа !!! 
01950:  MOV.B   83A,W0L
01952:  MOV.B   W0L,84C
01954:  CALL    13E2
01958:  MOV     W0,W5
0195A:  MOV     W1,W6
0195C:  MOV     W5,W0
0195E:  MOV     W6,W1
01960:  BTSS    W1.F
01962:  BRA     196C
01964:  MOV     #0,W4
01966:  SUB     W4,W5,W0
01968:  MOV     #0,W4
0196A:  SUBB    W4,W6,W1
0196C:  MOV     W0,844
0196E:  MOV     W1,846
....................   LCDPutU32(temp,6); 
01970:  MOV.B   #6,W0L
01972:  MOV.B   W0L,850
01974:  PUSH    844
01976:  POP     84C
01978:  PUSH    846
0197A:  POP     84E
0197C:  CALL    14AE
....................   //LCDMsg(" "); 
....................   //LCDPutU16(Final_T_in_K,LCD_num_symb); 
....................   //LCDMsg("."); 
....................   //LCDPutU16(ostatok_int_dec,1); 
....................   //if(LCD_num_symb==1){LCDMsg("K  ");} //очистка строки  
....................   //if(LCD_num_symb==2){LCDMsg("K "); } 
....................   //if(LCD_num_symb==3){LCDMsg("K");  } 
....................   Printf("d%05Lu\n",temp); 
01980:  BTSC.B  233.1
01982:  BRA     1980
01984:  MOV     #64,W4
01986:  MOV     W4,234
01988:  MOV     844,W0
0198A:  MOV     846,W1
0198C:  MOV     #8005,W4
0198E:  CALL    1706
01992:  BTSC.B  233.1
01994:  BRA     1992
01996:  MOV     #A,W4
01998:  MOV     W4,234
....................   //LCDsetCursor(0x51); 
....................   //LCDMsg(" ");  
....................    break; 
0199A:  GOTO    1B46
.................... //----------------------------------------------------------------// 
.................... //------------------- АЦП 2 --------------------------------------//     
....................    case 5:  
....................   LCDsetCursor(0x08); 
0199E:  MOV.B   #8,W0L
019A0:  MOV.B   W0L,84C
019A2:  CALL    6A6
....................   //LCDMsg("CO"); 
....................   //LCDputCH(0xA7); // Л 
....................   //LCDMsg('5'); 
....................   //LCDMsg(':'); 
....................   ADCaddCoef = 69;         // смещение нуля для канала 4 
019A6:  MOV     #45,W4
019A8:  MOV     W4,822
....................   ADCmulCoef = 1.00015;         // мультипликат. ошибка для канала 4 
019AA:  MOV     #4EA,W4
019AC:  MOV     W4,824
019AE:  MOV     #3F80,W4
019B0:  MOV     W4,826
....................   ADC_setCh(5); 
019B2:  MOV.B   #5,W0L
019B4:  MOV.B   W0L,84C
019B6:  CALL    D1A
....................   //Final_T_in_K = ADC_vol_to_T(); 
....................   temp = abs(ADC_vol_average(NumAver));   // убираем знак числа !!! 
019BA:  MOV.B   83A,W0L
019BC:  MOV.B   W0L,84C
019BE:  CALL    13E2
019C2:  MOV     W0,W5
019C4:  MOV     W1,W6
019C6:  MOV     W5,W0
019C8:  MOV     W6,W1
019CA:  BTSS    W1.F
019CC:  BRA     19D6
019CE:  MOV     #0,W4
019D0:  SUB     W4,W5,W0
019D2:  MOV     #0,W4
019D4:  SUBB    W4,W6,W1
019D6:  MOV     W0,844
019D8:  MOV     W1,846
....................   LCDPutU32(temp,6); 
019DA:  MOV.B   #6,W0L
019DC:  MOV.B   W0L,850
019DE:  PUSH    844
019E0:  POP     84C
019E2:  PUSH    846
019E4:  POP     84E
019E6:  CALL    14AE
....................   //LCDMsg(" "); 
....................   //LCDPutU16(Final_T_in_K,LCD_num_symb); 
....................   //LCDMsg("."); 
....................   //LCDPutU16(ostatok_int_dec,1); 
....................   //if(LCD_num_symb==1){LCDMsg("K  ");} //очистка строки  
....................   //if(LCD_num_symb==2){LCDMsg("K "); } 
....................   //if(LCD_num_symb==3){LCDMsg("K");  } 
....................   Printf("e%05Lu\n",temp); 
019EA:  BTSC.B  233.1
019EC:  BRA     19EA
019EE:  MOV     #65,W4
019F0:  MOV     W4,234
019F2:  MOV     844,W0
019F4:  MOV     846,W1
019F6:  MOV     #8005,W4
019F8:  CALL    1706
019FC:  BTSC.B  233.1
019FE:  BRA     19FC
01A00:  MOV     #A,W4
01A02:  MOV     W4,234
....................   //LCDsetCursor(0x09); 
....................   //LCDMsg(" ");  
....................    break; 
01A04:  GOTO    1B46
.................... //--------------------------------------------------------------//     
....................    case 6:  
....................   LCDsetCursor(0x48); 
01A08:  MOV.B   #48,W0L
01A0A:  MOV.B   W0L,84C
01A0C:  CALL    6A6
....................   //LCDMsg("CO"); 
....................   //LCDputCH(0xA7); // Л 
....................   //LCDMsg('6'); 
....................   //LCDMsg(':'); 
....................   ADCaddCoef = -2;         // смещение нуля для канала 6 
01A10:  MOV     #FFFE,W4
01A12:  MOV     W4,822
....................   ADCmulCoef = 1.00018;         // мультипликат. ошибка для канала 6 
01A14:  MOV     #5E6,W4
01A16:  MOV     W4,824
01A18:  MOV     #3F80,W4
01A1A:  MOV     W4,826
....................   ADC_setCh(6); 
01A1C:  MOV.B   #6,W0L
01A1E:  MOV.B   W0L,84C
01A20:  CALL    D1A
....................   //Final_T_in_K = ADC_vol_to_T(); 
....................   temp = abs(ADC_vol_average(NumAver));   // убираем знак числа !!! 
01A24:  MOV.B   83A,W0L
01A26:  MOV.B   W0L,84C
01A28:  CALL    13E2
01A2C:  MOV     W0,W5
01A2E:  MOV     W1,W6
01A30:  MOV     W5,W0
01A32:  MOV     W6,W1
01A34:  BTSS    W1.F
01A36:  BRA     1A40
01A38:  MOV     #0,W4
01A3A:  SUB     W4,W5,W0
01A3C:  MOV     #0,W4
01A3E:  SUBB    W4,W6,W1
01A40:  MOV     W0,844
01A42:  MOV     W1,846
....................   LCDPutU32(temp,6); 
01A44:  MOV.B   #6,W0L
01A46:  MOV.B   W0L,850
01A48:  PUSH    844
01A4A:  POP     84C
01A4C:  PUSH    846
01A4E:  POP     84E
01A50:  CALL    14AE
....................   //LCDMsg(" "); 
....................   //LCDPutU16(Final_T_in_K,LCD_num_symb); 
....................   //LCDMsg("."); 
....................   //LCDPutU16(ostatok_int_dec,1); 
....................   //if(LCD_num_symb==1){LCDMsg("K  ");} //очистка строки  
....................   //if(LCD_num_symb==2){LCDMsg("K "); } 
....................   //if(LCD_num_symb==3){LCDMsg("K");  } 
....................   Printf("f%05Lu\n",temp); 
01A54:  BTSC.B  233.1
01A56:  BRA     1A54
01A58:  MOV     #66,W4
01A5A:  MOV     W4,234
01A5C:  MOV     844,W0
01A5E:  MOV     846,W1
01A60:  MOV     #8005,W4
01A62:  CALL    1706
01A66:  BTSC.B  233.1
01A68:  BRA     1A66
01A6A:  MOV     #A,W4
01A6C:  MOV     W4,234
....................   //LCDsetCursor(0x49); 
....................   //LCDMsg(" ");  
....................    break; 
01A6E:  GOTO    1B46
.................... //--------------------------------------------------------------//     
....................    case 7:  
....................   LCDsetCursor(0x18); 
01A72:  MOV.B   #18,W0L
01A74:  MOV.B   W0L,84C
01A76:  CALL    6A6
....................   //LCDMsg("CO"); 
....................   //LCDputCH(0xA7); // Л 
....................   //LCDMsg('7'); 
....................   //LCDMsg(':'); 
....................   ADCaddCoef = -2;         // смещение нуля для канала 7 
01A7A:  MOV     #FFFE,W4
01A7C:  MOV     W4,822
....................   ADCmulCoef = 1.00015;         // мультипликат. ошибка для канала 7 
01A7E:  MOV     #4EA,W4
01A80:  MOV     W4,824
01A82:  MOV     #3F80,W4
01A84:  MOV     W4,826
....................   ADC_setCh(7); 
01A86:  MOV.B   #7,W0L
01A88:  MOV.B   W0L,84C
01A8A:  CALL    D1A
....................   //Final_T_in_K = ADC_vol_to_T(); 
....................   temp = abs(ADC_vol_average(NumAver));   // убираем знак числа !!! 
01A8E:  MOV.B   83A,W0L
01A90:  MOV.B   W0L,84C
01A92:  CALL    13E2
01A96:  MOV     W0,W5
01A98:  MOV     W1,W6
01A9A:  MOV     W5,W0
01A9C:  MOV     W6,W1
01A9E:  BTSS    W1.F
01AA0:  BRA     1AAA
01AA2:  MOV     #0,W4
01AA4:  SUB     W4,W5,W0
01AA6:  MOV     #0,W4
01AA8:  SUBB    W4,W6,W1
01AAA:  MOV     W0,844
01AAC:  MOV     W1,846
....................   LCDPutU32(temp,6); 
01AAE:  MOV.B   #6,W0L
01AB0:  MOV.B   W0L,850
01AB2:  PUSH    844
01AB4:  POP     84C
01AB6:  PUSH    846
01AB8:  POP     84E
01ABA:  CALL    14AE
....................   //LCDMsg(" "); 
....................   //LCDPutU16(Final_T_in_K,LCD_num_symb); 
....................   //LCDMsg("."); 
....................   //LCDPutU16(ostatok_int_dec,1); 
....................   //if(LCD_num_symb==1){LCDMsg("K  ");} //очистка строки  
....................   //if(LCD_num_symb==2){LCDMsg("K "); } 
....................   //if(LCD_num_symb==3){LCDMsg("K");  } 
....................   Printf("g%05Lu\n",temp); 
01ABE:  BTSC.B  233.1
01AC0:  BRA     1ABE
01AC2:  MOV     #67,W4
01AC4:  MOV     W4,234
01AC6:  MOV     844,W0
01AC8:  MOV     846,W1
01ACA:  MOV     #8005,W4
01ACC:  CALL    1706
01AD0:  BTSC.B  233.1
01AD2:  BRA     1AD0
01AD4:  MOV     #A,W4
01AD6:  MOV     W4,234
....................   //LCDsetCursor(0x19); 
....................   //LCDMsg(" ");  
....................    break; 
01AD8:  GOTO    1B46
....................  //--------------------------------------------------------------//     
....................    case 8:  
....................   LCDsetCursor(0x58); 
01ADC:  MOV.B   #58,W0L
01ADE:  MOV.B   W0L,84C
01AE0:  CALL    6A6
....................   //LCDMsg("CO"); 
....................   //LCDputCH(0xA7); // Л 
....................   //LCDMsg('8'); 
....................   //LCDMsg(':'); 
....................   ADCaddCoef = -2;         // смещение нуля для канала 8 
01AE4:  MOV     #FFFE,W4
01AE6:  MOV     W4,822
....................   ADCmulCoef = 1.00014;         // мультипликат. ошибка для канала 8 
01AE8:  MOV     #496,W4
01AEA:  MOV     W4,824
01AEC:  MOV     #3F80,W4
01AEE:  MOV     W4,826
....................   ADC_setCh(8); 
01AF0:  MOV.B   #8,W0L
01AF2:  MOV.B   W0L,84C
01AF4:  CALL    D1A
....................   //Final_T_in_K = ADC_vol_to_T(); 
....................   temp = abs(ADC_vol_average(NumAver));   // убираем знак числа !!! 
01AF8:  MOV.B   83A,W0L
01AFA:  MOV.B   W0L,84C
01AFC:  CALL    13E2
01B00:  MOV     W0,W5
01B02:  MOV     W1,W6
01B04:  MOV     W5,W0
01B06:  MOV     W6,W1
01B08:  BTSS    W1.F
01B0A:  BRA     1B14
01B0C:  MOV     #0,W4
01B0E:  SUB     W4,W5,W0
01B10:  MOV     #0,W4
01B12:  SUBB    W4,W6,W1
01B14:  MOV     W0,844
01B16:  MOV     W1,846
....................   LCDPutU32(temp,6); 
01B18:  MOV.B   #6,W0L
01B1A:  MOV.B   W0L,850
01B1C:  PUSH    844
01B1E:  POP     84C
01B20:  PUSH    846
01B22:  POP     84E
01B24:  CALL    14AE
....................   //LCDMsg(" "); 
....................   //LCDPutU16(Final_T_in_K,LCD_num_symb); 
....................   //LCDMsg("."); 
....................   //LCDPutU16(ostatok_int_dec,1); 
....................   //if(LCD_num_symb==1){LCDMsg("K  ");} //очистка строки  
....................   //if(LCD_num_symb==2){LCDMsg("K "); } 
....................   //if(LCD_num_symb==3){LCDMsg("K");  } 
....................   Printf("h%05Lu\n",temp); 
01B28:  BTSC.B  233.1
01B2A:  BRA     1B28
01B2C:  MOV     #68,W4
01B2E:  MOV     W4,234
01B30:  MOV     844,W0
01B32:  MOV     846,W1
01B34:  MOV     #8005,W4
01B36:  CALL    1706
01B3A:  BTSC.B  233.1
01B3C:  BRA     1B3A
01B3E:  MOV     #A,W4
01B40:  MOV     W4,234
....................   //LCDsetCursor(0x59); 
....................   //LCDMsg(" ");  
....................    break; 
01B42:  GOTO    1B46
....................    }   
01B46:  MOV     [--W15],W6
01B48:  MOV     [--W15],W5
01B4A:  RETURN  
.................... } 
....................  
.................... static void save_to_flash(){ 
....................        
....................    Sps_Wr = NumAver; 
*
02018:  MOV.B   83A,W0L
0201A:  MOV.B   W0L,833
....................    Aver_Wr = ADC_sps_var; // сохранение sps значения во флеш 
0201C:  MOV.B   83B,W0L
0201E:  MOV.B   W0L,832
....................    CRC_Wr = CRC8(flash_wr_data,2); 
02020:  MOV     #82E,W4
02022:  MOV     W4,84A
02024:  MOV     #2,W4
02026:  MOV     W4,84C
02028:  CALL    778
0202C:  MOV.B   W0L,834
....................    Wr_Flash(); 
0202E:  CALL    1FF8
02032:  RETURN  
....................     
....................    }  
....................  
.................... #int_cni 
.................... static void cn_irq_handler(void) { 
*
00416:  PUSH    42
00418:  PUSH    36
0041A:  PUSH    32
0041C:  MOV     W0,[W15++]
0041E:  MOV     #2,W0
00420:  REPEAT  #C
00422:  MOV     [W0++],[W15++]
....................  
....................    DisableInt();                    // отключение прерываний для обработки дребезка  
00424:  CALL    402
....................    meas_stop_fl = 1;                // взвод флага остановки измерений 
00428:  BSET.B  839.0
....................    menu_fl = 1;                     // взвод флага перехода в меню 
0042A:  MOV.B   #1,W0L
0042C:  MOV.B   W0L,838
....................     if (menu_item == 1) 
0042E:  MOV     836,W4
00430:  CP.B    W4L,#1
00432:  BRA     NZ,44A
....................   { 
....................     if (menu_sel>3) {menu_sel=0;} 
00434:  MOV.B   837,W0L
00436:  SE      W0,W0
00438:  CP      W0,#3
0043A:  BRA     LE,43E
0043C:  CLR.B   837
....................     if (menu_sel<0) {menu_sel=3;} 
0043E:  MOV.B   837,W0L
00440:  SE      W0,W0
00442:  CP      W0,#0
00444:  BRA     GE,44A
00446:  MOV.B   #3,W0L
00448:  MOV.B   W0L,837
....................   } 
....................    if (CN2==1) {menu_item = 1;} 
0044A:  BTSS.B  2C8.4
0044C:  BRA     452
0044E:  MOV.B   #1,W0L
00450:  MOV.B   W0L,836
....................    if (CN3==1) {menu_sel--;} 
00452:  BTSS.B  2C8.2
00454:  BRA     458
00456:  DEC.B   0837
....................    if (CN4==1) {menu_sel++;} 
00458:  BTSS.B  2C8.3
0045A:  BRA     45E
0045C:  INC.B   0837
....................    clear_interrupt(INTR_CN_PIN); 
0045E:  BCLR.B  82.7
....................  
.................... } 
....................  
00460:  BCLR.B  86.3
00462:  MOV     #1A,W0
00464:  REPEAT  #C
00466:  MOV     [--W15],[W0--]
00468:  MOV     [--W15],W0
0046A:  POP     32
0046C:  POP     36
0046E:  POP     42
00470:  RETFIE  
.................... #int_timer1 
.................... static void timer1_irq_handler(void) { 
00472:  PUSH    42
00474:  PUSH    36
00476:  PUSH    32
00478:  MOV     W0,[W15++]
0047A:  MOV     #2,W0
0047C:  REPEAT  #C
0047E:  MOV     [W0++],[W15++]
.................... restart_wdt();     // сбос собачего таймера 
00480:  CLRWDT  
.................... set_timer1(20000); //reset the timer. 
00482:  MOV     #4E20,W4
00484:  MOV     W4,100
.................... clear_interrupt(int_timer1); 
00486:  BCLR.B  84.3
00488:  BCLR.B  84.3
0048A:  MOV     #1A,W0
0048C:  REPEAT  #C
0048E:  MOV     [--W15],[W0--]
00490:  MOV     [--W15],W0
00492:  POP     32
00494:  POP     36
00496:  POP     42
00498:  RETFIE  
.................... } 
....................  
....................  
.................... /*############################################################################*/ 
....................  
.................... static void main() 
*
02034:  MOV     #2780,W15
02036:  MOV     #27FF,W0
02038:  MOV     W0,20
0203A:  NOP     
0203C:  MOV     #4444,W0
0203E:  MOV     W0,A4
02040:  MOV     #4444,W0
02042:  MOV     W0,AC
02044:  BSET.B  81.7
02046:  BCLR.B  261.7
02048:  BCLR.B  2E5.0
0204A:  BSET.B  2E4.7
0204C:  BCLR.B  2E4.6
0204E:  BCLR.B  260.6
02050:  MOV     #3B,W4
02052:  MOV     W4,262
02054:  BSET.B  261.7
02056:  MOV     #8000,W4
02058:  MOV     W4,230
0205A:  MOV     #400,W4
0205C:  MOV     W4,232
0205E:  MOV     #103,W4
02060:  MOV     W4,238
02062:  CLR     806
02064:  CLR     808
02066:  CLR     80A
02068:  CLR     80C
0206A:  CLR     80E
0206C:  CLR     810
0206E:  CLR     812
02070:  CLR     814
02072:  CLR     816
02074:  CLR     818
02076:  CLR.B   820
02078:  CLR     828
0207A:  CLR     82A
0207C:  CLR.B   82C
0207E:  MOV.B   #1,W0L
02080:  MOV.B   W0L,82D
02082:  CLR.B   832
02084:  CLR.B   833
02086:  CLR.B   834
02088:  CLR.B   835
0208A:  CLR.B   836
0208C:  CLR.B   837
0208E:  CLR.B   838
02090:  BCLR.B  839.0
02092:  BSET.B  839.1
02094:  BCLR.B  839.2
02096:  MOV.B   #1,W0L
02098:  MOV.B   W0L,83A
0209A:  MOV.B   #1,W0L
0209C:  MOV.B   W0L,83B
0209E:  SETM.B  83C
020A0:  MOV.B   #FF,W0L
020A2:  MOV.B   W0L,83D
020A4:  CLR     844
020A6:  CLR     846
020A8:  SETM    32C
020AA:  SETM    32A
020AC:  CLR     800
020AE:  CLR     81A
020B0:  CLR     81C
020B2:  CLR.B   81E
020B4:  CLR.B   81F
020B6:  CLR     822
020B8:  CLR     824
020BA:  CLR     826
020BC:  CLR     82E
020BE:  CLR     830
020C0:  CLR.B   83F
020C2:  MOV.B   #1,W0L
020C4:  MOV.B   W0L,848
.................... {  
....................   U8 ch = 1;             // начальная установка канала измерений АЦП 
....................    
....................   OscSetup(); 
020C6:  CALL    49A
....................   MCU_init();         
020CA:  CALL    4D6
....................  
....................   LCDInit(); 
020CE:  CALL    5B6
....................   lCDwelcome(); 
020D2:  CALL    6BA
....................  
....................   LCDSetCursor(one); 
020D6:  CLR.B   84C
020D8:  CALL    6A6
....................   LCDMsg("  Reading data"); 
020DC:  MOV     #0,W5
020DE:  MOV     W5,W0
020E0:  CALL    312
020E4:  IOR.B   #0,W0L
020E6:  BTSC.B  42.1
020E8:  BRA     20F4
020EA:  INC     W5,W5
020EC:  MOV.B   W0L,84E
020EE:  CALL    69C
020F2:  BRA     20DE
....................   LCDSetCursor(two); 
020F4:  MOV.B   #40,W0L
020F6:  MOV.B   W0L,84C
020F8:  CALL    6A6
....................   LCDMsg("   from ROM..."); 
020FC:  MOV     #0,W5
020FE:  MOV     W5,W0
02100:  CALL    32E
02104:  IOR.B   #0,W0L
02106:  BTSC.B  42.1
02108:  BRA     2114
0210A:  INC     W5,W5
0210C:  MOV.B   W0L,84E
0210E:  CALL    69C
02112:  BRA     20FE
....................    
....................   Rd_Flash();                        // чтение денных из флеш для расчета контр. суммы 
02114:  CALL    754
....................   crc1 = CRC_buf;                    // сохраненная контр. сумма     
02118:  MOV.B   83E,W0L
0211A:  MOV.B   W0L,83C
....................   crc2 = CRC8(flash_rd_data,2);      // текущая контр. сумма 
0211C:  MOV     #840,W4
0211E:  MOV     W4,84A
02120:  MOV     #2,W4
02122:  MOV     W4,84C
02124:  CALL    778
02128:  MOV.B   W0L,83D
....................    
....................   LCDSetCursor(three); 
0212A:  MOV.B   #10,W0L
0212C:  MOV.B   W0L,84C
0212E:  CALL    6A6
....................    
....................   if (crc1==crc2){LCDMsg("       OK!");} 
02132:  MOV.B   83C,W0L
02134:  CP.B    83D
02136:  BRA     NZ,2154
02138:  MOV     #0,W5
0213A:  MOV     W5,W0
0213C:  CALL    34A
02140:  IOR.B   #0,W0L
02142:  BTSC.B  42.1
02144:  BRA     2150
02146:  INC     W5,W5
02148:  MOV.B   W0L,84E
0214A:  CALL    69C
0214E:  BRA     213A
02150:  GOTO    2174
....................   else { 
....................   LCDMsg("   CRC error!"); 
02154:  MOV     #0,W5
02156:  MOV     W5,W0
02158:  CALL    362
0215C:  IOR.B   #0,W0L
0215E:  BTSC.B  42.1
02160:  BRA     216C
02162:  INC     W5,W5
02164:  MOV.B   W0L,84E
02166:  CALL    69C
0216A:  BRA     2156
....................   ADC_sps_var = 1;   // сброс значений по умолчанию  
0216C:  MOV.B   #1,W0L
0216E:  MOV.B   W0L,83B
....................   NumAver = 1;       // тк произошел сбой контр. суммы 
02170:  MOV.B   #1,W0L
02172:  MOV.B   W0L,83A
....................    } 
....................     
....................       ADC_wakeUp();      // Сброс АЦП  
02174:  CALL    7C6
....................       ADC_wakeUp();      // перед инициализацией 
02178:  CALL    7C6
....................       ADC_init();        // Инициализация АЦП 
0217C:  CALL    894
....................       ADC_init();        // Инициализация АЦП 
02180:  CALL    894
....................       ADC_set_PGA(8); 
02184:  MOV.B   #8,W0L
02186:  MOV.B   W0L,84A
02188:  CALL    92A
....................       ADC_set_PGA(8); 
0218C:  MOV.B   #8,W0L
0218E:  MOV.B   W0L,84A
02190:  CALL    92A
....................       ADC_SelfCal();     // Автокалибровка АЦП 
02194:  CALL    9C0
....................  
....................   delay_ms(2000); 
02198:  MOV     #7D0,W0
0219A:  CALL    530
....................          
....................   LCDclear(); 
0219E:  CALL    656
....................    
.................... /*############################################################################*/   
....................  
....................   while(true){ 
....................    
....................  
....................   if (reset_fl)     {Full_dev_reset();}        // полный сброс системы  
021A2:  BTSS.B  839.2
021A4:  BRA     21AA
021A6:  CALL    A9E
....................    
....................   if (!meas_stop_fl){ADC_rd_and_print_ch(ch);} // чтение четырех каналов АЦП, 
021AA:  BTSC.B  839.0
021AC:  BRA     21B6
021AE:  MOV.B   848,W0L
021B0:  MOV.B   W0L,84A
021B2:  CALL    17CE
....................                                                // вывод на дисплей и UART 
....................   if (menu_fl){                                // вызов и обработка меню 
021B6:  CP0.B   838
021B8:  BRA     Z,2500
....................    
....................    if (LCD_clear_fl){LCD_clear_fl = 0; LCDClear();} // очистка экрана 
021BA:  BTSS.B  839.1
021BC:  BRA     21C4
021BE:  BCLR.B  839.1
021C0:  CALL    656
....................    
....................   Bpush_delay();                   // подавление дребезга кнопок 
021C4:  CALL    1B4C
....................   
....................   switch (menu_item){                   // древо меню 
021C8:  MOV.B   836,W0L
021CA:  CLR.B   1
021CC:  XOR     #0,W0
021CE:  BRA     Z,21E2
021D0:  XOR     #1,W0
021D2:  BRA     Z,21E8
021D4:  XOR     #3,W0
021D6:  BRA     Z,2286
021D8:  XOR     #1,W0
021DA:  BRA     Z,240E
021DC:  XOR     #7,W0
021DE:  BRA     Z,247C
021E0:  BRA     2500
.................... //----------------------------------------------------------------------------//                                                            
....................   case 0: meas_stop_fl = 0; break;     // возврат в измерения 
021E2:  BCLR.B  839.0
021E4:  GOTO    2500
.................... //----------------------------------------------------------------------------//    
....................   case 1:  
....................           LCD_main_menu();             // ADC average set 
021E8:  CALL    1BE2
....................            if  (CN2 == 1){ 
021EC:  BTSS.B  2C8.4
021EE:  BRA     2282
....................             Bpush_delay(); 
021F0:  CALL    1B4C
....................             if ((CN2 == 1) & (menu_sel==0)){ // ADC sps set menu 
021F4:  CLR     W0
021F6:  BTSC.B  2C8.4
021F8:  INC     W0,W0
021FA:  MOV.B   W0L,W6L
021FC:  MOV.B   837,W0L
021FE:  SE      W0,W0
02200:  CP0     W0
02202:  BRA     Z,220A
02204:  CLR.B   W0
02206:  GOTO    220C
0220A:  MOV.B   #1,W0L
0220C:  AND.B   W6L,W0L,W0L
0220E:  CP0.B   W0L
02210:  BRA     Z,2218
....................                   LCD_clear_fl = 1; menu_item = 2; }    
02212:  BSET.B  839.1
02214:  MOV.B   #2,W0L
02216:  MOV.B   W0L,836
....................                    
....................             if ((CN2 == 1) & (menu_sel==1)){ // ADC average set 
02218:  CLR     W0
0221A:  BTSC.B  2C8.4
0221C:  INC     W0,W0
0221E:  MOV.B   W0L,W6L
02220:  MOV.B   837,W0L
02222:  SE      W0,W0
02224:  CP      W0,#1
02226:  BRA     Z,222E
02228:  CLR.B   W0
0222A:  GOTO    2230
0222E:  MOV.B   #1,W0L
02230:  AND.B   W6L,W0L,W0L
02232:  CP0.B   W0L
02234:  BRA     Z,223C
....................                   LCD_clear_fl = 1; menu_item = 3; } 
02236:  BSET.B  839.1
02238:  MOV.B   #3,W0L
0223A:  MOV.B   W0L,836
....................                    
....................             if ((CN2 == 1) & (menu_sel==2)){ // Reset device 
0223C:  CLR     W0
0223E:  BTSC.B  2C8.4
02240:  INC     W0,W0
02242:  MOV.B   W0L,W6L
02244:  MOV.B   837,W0L
02246:  SE      W0,W0
02248:  CP      W0,#2
0224A:  BRA     Z,2252
0224C:  CLR.B   W0
0224E:  GOTO    2254
02252:  MOV.B   #1,W0L
02254:  AND.B   W6L,W0L,W0L
02256:  CP0.B   W0L
02258:  BRA     Z,2260
....................                   LCD_clear_fl = 1; menu_item = 4; }                    
0225A:  BSET.B  839.1
0225C:  MOV.B   #4,W0L
0225E:  MOV.B   W0L,836
....................    
....................             if ((CN2 == 1) & (menu_sel==3)){ // Return back 
02260:  CLR     W0
02262:  BTSC.B  2C8.4
02264:  INC     W0,W0
02266:  MOV.B   W0L,W6L
02268:  MOV.B   837,W0L
0226A:  SE      W0,W0
0226C:  CP      W0,#3
0226E:  BRA     Z,2276
02270:  CLR.B   W0
02272:  GOTO    2278
02276:  MOV.B   #1,W0L
02278:  AND.B   W6L,W0L,W0L
0227A:  CP0.B   W0L
0227C:  BRA     Z,2282
....................                   LCD_clear_fl = 1; menu_item--; }} 
0227E:  BSET.B  839.1
02280:  DEC.B   0836
....................             break; 
02282:  GOTO    2500
.................... //----------------------------------------------------------------------------//   
....................    case 2:                               // ADC sps set menu 
....................     
....................    LCDsetCursor(one); 
02286:  CLR.B   84C
02288:  CALL    6A6
....................    LCDMsg("Samples per sec."); 
0228C:  MOV     #0,W5
0228E:  MOV     W5,W0
02290:  CALL    37C
02294:  IOR.B   #0,W0L
02296:  BTSC.B  42.1
02298:  BRA     22A4
0229A:  INC     W5,W5
0229C:  MOV.B   W0L,84E
0229E:  CALL    69C
022A2:  BRA     228E
....................    LCDsetCursor(three); 
022A4:  MOV.B   #10,W0L
022A6:  MOV.B   W0L,84C
022A8:  CALL    6A6
....................    if(CN4){Bpush_delay(); if(CN4) ADC_sps_var=ADC_sps_var-1; delay_ms(200);} 
022AC:  BTSS.B  2C8.3
022AE:  BRA     22C6
022B0:  CALL    1B4C
022B4:  BTSS.B  2C8.3
022B6:  BRA     22C0
022B8:  MOV     83A,W4
022BA:  LSR     W4,#8,W4
022BC:  SUB.B   W4L,#1,W0L
022BE:  MOV.B   W0L,83B
022C0:  MOV     #C8,W0
022C2:  CALL    530
....................    if(CN3){Bpush_delay(); if(CN3) ADC_sps_var=ADC_sps_var+1; delay_ms(200);} 
022C6:  BTSS.B  2C8.2
022C8:  BRA     22E2
022CA:  CALL    1B4C
022CE:  BTSS.B  2C8.2
022D0:  BRA     22DC
022D2:  MOV     83A,W4
022D4:  LSR     W4,#8,W4
022D6:  ADD.B   W4L,#1,W4L
022D8:  MOV.B   W4L,W0L
022DA:  MOV.B   W0L,83B
022DC:  MOV     #C8,W0
022DE:  CALL    530
....................    if(ADC_sps_var>7)  ADC_sps_var = 7; 
022E2:  MOV     83A,W4
022E4:  LSR     W4,#8,W4
022E6:  CP.B    W4L,#7
022E8:  BRA     LEU,22EE
022EA:  MOV.B   #7,W0L
022EC:  MOV.B   W0L,83B
....................    if(ADC_sps_var==0) ADC_sps_var = 1; 
022EE:  CP0.B   83B
022F0:  BRA     NZ,22F6
022F2:  MOV.B   #1,W0L
022F4:  MOV.B   W0L,83B
....................     switch (ADC_sps_var){                // передача величины скорости измерений АЦП  
022F6:  MOV.B   83B,W0L
022F8:  CLR.B   1
022FA:  XOR     #1,W0
022FC:  BRA     Z,2318
022FE:  XOR     #3,W0
02300:  BRA     Z,233A
02302:  XOR     #1,W0
02304:  BRA     Z,235C
02306:  XOR     #7,W0
02308:  BRA     Z,237E
0230A:  XOR     #1,W0
0230C:  BRA     Z,23A0
0230E:  XOR     #3,W0
02310:  BRA     Z,23C2
02312:  XOR     #1,W0
02314:  BRA     Z,23E4
02316:  BRA     2406
....................       case 1: ADC_sps_set(0x23); LCDsetCursor(0x16); LCDputU16(10,4);  break; // 10   sps 
02318:  MOV.B   #23,W0L
0231A:  MOV.B   W0L,84A
0231C:  CALL    87E
02320:  MOV.B   #16,W0L
02322:  MOV.B   W0L,84C
02324:  CALL    6A6
02328:  MOV.B   #4,W0L
0232A:  MOV.B   W0L,84E
0232C:  MOV     #A,W4
0232E:  MOV     W4,84A
02330:  CLR     84C
02332:  CALL    1E12
02336:  GOTO    2406
....................       case 2: ADC_sps_set(0x43); LCDsetCursor(0x16); LCDputU16(25,4);  break; // 25   sps 
0233A:  MOV.B   #43,W0L
0233C:  MOV.B   W0L,84A
0233E:  CALL    87E
02342:  MOV.B   #16,W0L
02344:  MOV.B   W0L,84C
02346:  CALL    6A6
0234A:  MOV.B   #4,W0L
0234C:  MOV.B   W0L,84E
0234E:  MOV     #19,W4
02350:  MOV     W4,84A
02352:  CLR     84C
02354:  CALL    1E12
02358:  GOTO    2406
....................       case 3: ADC_sps_set(0x63); LCDsetCursor(0x16); LCDputU16(50,4);  break; // 50   sps 
0235C:  MOV.B   #63,W0L
0235E:  MOV.B   W0L,84A
02360:  CALL    87E
02364:  MOV.B   #16,W0L
02366:  MOV.B   W0L,84C
02368:  CALL    6A6
0236C:  MOV.B   #4,W0L
0236E:  MOV.B   W0L,84E
02370:  MOV     #32,W4
02372:  MOV     W4,84A
02374:  CLR     84C
02376:  CALL    1E12
0237A:  GOTO    2406
....................       case 4: ADC_sps_set(0x82); LCDsetCursor(0x16); LCDputU16(100,4); break; // 100  sps 
0237E:  MOV.B   #82,W0L
02380:  MOV.B   W0L,84A
02382:  CALL    87E
02386:  MOV.B   #16,W0L
02388:  MOV.B   W0L,84C
0238A:  CALL    6A6
0238E:  MOV.B   #4,W0L
02390:  MOV.B   W0L,84E
02392:  MOV     #64,W4
02394:  MOV     W4,84A
02396:  CLR     84C
02398:  CALL    1E12
0239C:  GOTO    2406
....................       case 5: ADC_sps_set(0x91); LCDsetCursor(0x16); LCDputU16(500,4); break; // 500  sps 
023A0:  MOV.B   #91,W0L
023A2:  MOV.B   W0L,84A
023A4:  CALL    87E
023A8:  MOV.B   #16,W0L
023AA:  MOV.B   W0L,84C
023AC:  CALL    6A6
023B0:  MOV.B   #4,W0L
023B2:  MOV.B   W0L,84E
023B4:  MOV     #1F4,W4
023B6:  MOV     W4,84A
023B8:  CLR     84C
023BA:  CALL    1E12
023BE:  GOTO    2406
....................       case 6: ADC_sps_set(0xA1); LCDsetCursor(0x16); LCDputU16(1000,4);break; // 1000 sps 
023C2:  MOV.B   #A1,W0L
023C4:  MOV.B   W0L,84A
023C6:  CALL    87E
023CA:  MOV.B   #16,W0L
023CC:  MOV.B   W0L,84C
023CE:  CALL    6A6
023D2:  MOV.B   #4,W0L
023D4:  MOV.B   W0L,84E
023D6:  MOV     #3E8,W4
023D8:  MOV     W4,84A
023DA:  CLR     84C
023DC:  CALL    1E12
023E0:  GOTO    2406
....................       case 7: ADC_sps_set(0xC0); LCDsetCursor(0x16); LCDputU16(3750,4);break; // 3750 sps 
023E4:  MOV.B   #C0,W0L
023E6:  MOV.B   W0L,84A
023E8:  CALL    87E
023EC:  MOV.B   #16,W0L
023EE:  MOV.B   W0L,84C
023F0:  CALL    6A6
023F4:  MOV.B   #4,W0L
023F6:  MOV.B   W0L,84E
023F8:  MOV     #EA6,W4
023FA:  MOV     W4,84A
023FC:  CLR     84C
023FE:  CALL    1E12
02402:  GOTO    2406
....................       }      
....................    save_to_flash(); 
02406:  CALL    2018
....................    break;   
0240A:  GOTO    2500
.................... //----------------------------------------------------------------------------// 
....................    case 3:                               // ADC average size menu 
....................     
....................    LCDsetCursor(one); 
0240E:  CLR.B   84C
02410:  CALL    6A6
....................    LCDMsg("    Average"); 
02414:  MOV     #0,W5
02416:  MOV     W5,W0
02418:  CALL    39A
0241C:  IOR.B   #0,W0L
0241E:  BTSC.B  42.1
02420:  BRA     242C
02422:  INC     W5,W5
02424:  MOV.B   W0L,84E
02426:  CALL    69C
0242A:  BRA     2416
....................    LCDsetCursor(three); 
0242C:  MOV.B   #10,W0L
0242E:  MOV.B   W0L,84C
02430:  CALL    6A6
....................    if(CN4){Bpush_delay(); if(CN4) --NumAver; delay_ms(100);} // декремент величины усреднения 
02434:  BTSS.B  2C8.3
02436:  BRA     2448
02438:  CALL    1B4C
0243C:  BTSS.B  2C8.3
0243E:  BRA     2442
02440:  DEC.B   083A
02442:  MOV     #64,W0
02444:  CALL    530
....................    if(CN3){Bpush_delay(); if(CN3) ++NumAver; delay_ms(100);} // инкремент величины усреднения 
02448:  BTSS.B  2C8.2
0244A:  BRA     245C
0244C:  CALL    1B4C
02450:  BTSS.B  2C8.2
02452:  BRA     2456
02454:  INC.B   083A
02456:  MOV     #64,W0
02458:  CALL    530
....................    LCDsetCursor(0x16); 
0245C:  MOV.B   #16,W0L
0245E:  MOV.B   W0L,84C
02460:  CALL    6A6
....................    LCDputU16(NumAver,3); 
02464:  MOV.B   83A,W0L
02466:  MOV.B   W0L,84A
02468:  CLR.B   84B
0246A:  CLR     84C
0246C:  MOV.B   #3,W0L
0246E:  MOV.B   W0L,84E
02470:  CALL    1E12
....................     
....................    save_to_flash(); 
02474:  CALL    2018
....................    break; 
02478:  GOTO    2500
.................... //----------------------------------------------------------------------------//   
....................    case 4:                               // Reset menu 
....................     
....................    LCDsetCursor(one); 
0247C:  CLR.B   84C
0247E:  CALL    6A6
....................    LCDMsg(" Reset device?"); 
02482:  MOV     #0,W5
02484:  MOV     W5,W0
02486:  CALL    3B2
0248A:  IOR.B   #0,W0L
0248C:  BTSC.B  42.1
0248E:  BRA     249A
02490:  INC     W5,W5
02492:  MOV.B   W0L,84E
02494:  CALL    69C
02498:  BRA     2484
....................    LCDsetCursor(three); 
0249A:  MOV.B   #10,W0L
0249C:  MOV.B   W0L,84C
0249E:  CALL    6A6
....................    LCDMsg("    Yes -> +"); 
024A2:  MOV     #0,W5
024A4:  MOV     W5,W0
024A6:  CALL    3CE
024AA:  IOR.B   #0,W0L
024AC:  BTSC.B  42.1
024AE:  BRA     24BA
024B0:  INC     W5,W5
024B2:  MOV.B   W0L,84E
024B4:  CALL    69C
024B8:  BRA     24A4
....................    LCDsetCursor(four); 
024BA:  MOV.B   #50,W0L
024BC:  MOV.B   W0L,84C
024BE:  CALL    6A6
....................    LCDMsg("    No  -> -"); 
024C2:  MOV     #0,W5
024C4:  MOV     W5,W0
024C6:  CALL    3E8
024CA:  IOR.B   #0,W0L
024CC:  BTSC.B  42.1
024CE:  BRA     24DA
024D0:  INC     W5,W5
024D2:  MOV.B   W0L,84E
024D4:  CALL    69C
024D8:  BRA     24C4
....................    if(CN3){Bpush_delay(); if(CN3) {reset_fl = 1;}}    // поднятие флага RESET для сброса всей системы 
024DA:  BTSS.B  2C8.2
024DC:  BRA     24E8
024DE:  CALL    1B4C
024E2:  BTSS.B  2C8.2
024E4:  BRA     24E8
024E6:  BSET.B  839.2
....................    if(CN4){Bpush_delay(); if(CN4) {menu_item= 1;}}    // отмена и выход в меню 
024E8:  BTSS.B  2C8.3
024EA:  BRA     24F8
024EC:  CALL    1B4C
024F0:  BTSS.B  2C8.3
024F2:  BRA     24F8
024F4:  MOV.B   #1,W0L
024F6:  MOV.B   W0L,836
....................     
....................    save_to_flash(); 
024F8:  CALL    2018
....................    break; 
024FC:  GOTO    2500
....................    }   
....................   }   
....................    
....................   ch++;                                        // инкремент номера канала 
02500:  INC.B   0848
....................   if (ch > 8) ch = 1;                          // диапазон каналов 
02502:  MOV     848,W4
02504:  CP.B    W4L,#8
02506:  BRA     LEU,250C
02508:  MOV.B   #1,W0L
0250A:  MOV.B   W0L,848
0250C:  GOTO    21A2
....................    
....................  } 
.................... } 
.................... /*############################################################################*/ 
02510:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 00CE   WRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0083   PR_PLL IESO
          H: FF00  
   Word  5L: 0006   HS NOOSCIO CKSFSM
          H: FF00  
   Word  6L: 00DD   WPOSTS14 WPRES128 WINDIS WDT
          H: FF00  
   Word  7L: 00E7   PUT128
          H: FF00  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: FF00  
