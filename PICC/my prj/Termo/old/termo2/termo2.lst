CCS PCH C Compiler, Version 4.120, 5967               30-мар-12 18:18

               Filename: c:\program files\picc\projects\termo2\termo2.lst

               ROM used: 3904 bytes (48%)
                         Largest free fragment is 4288
               RAM used: 48 (9%) at main() level
                         89 (17%) worst case
               Stack:    7 locations

*
0000:  GOTO   09B0
.................... //#include "C:\Program Files\PICC\Projects\PRJ\ 
.................... #include <18F4320.h> 
.................... //////// Standard Header file for the PIC18F4320 device //////////////// 
.................... #device PIC18F4320 
.................... #list 
....................  
.................... //#device adc=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES H4                       //High speed osc with HW enabled 4X PLL 
.................... //#FUSES HS                       //High speed osc  
.................... #FUSES NOFCMEN                  //Fail-safe clock monitor disabled 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... #FUSES BORV45                   //Brownout reset at 4.5V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                      //NO Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
....................  
.................... #use delay(clock=40000000) 
*
0050:  CLRF   FEA
0052:  MOVLW  3A
0054:  MOVWF  FE9
0056:  MOVF   FEF,W
0058:  BZ    0076
005A:  MOVLW  0C
005C:  MOVWF  01
005E:  CLRF   00
0060:  DECFSZ 00,F
0062:  BRA    0060
0064:  DECFSZ 01,F
0066:  BRA    005E
0068:  MOVLW  F7
006A:  MOVWF  00
006C:  DECFSZ 00,F
006E:  BRA    006C
0070:  BRA    0072
0072:  DECFSZ FEF,F
0074:  BRA    005A
0076:  RETURN 0
0078:  MOVLW  02
007A:  SUBWF  3A,F
007C:  BNC   0094
007E:  CLRF   FEA
0080:  MOVLW  3A
0082:  MOVWF  FE9
0084:  MOVF   FEF,W
0086:  BZ    0094
0088:  MOVLW  02
008A:  MOVWF  00
008C:  DECFSZ 00,F
008E:  BRA    008C
0090:  DECFSZ FEF,F
0092:  BRA    0088
0094:  GOTO   00DE (RETURN)
.................... #use rs232(uart1,baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... #BYTE TRISA = 0xF92 
.................... #BYTE TRISB = 0xF93 
.................... #BYTE TRISC = 0xF94  
.................... #BYTE TRISD = 0xF95 
.................... #BYTE TRISE = 0xF96 
....................  
.................... #BYTE PORTA = 0xF80 
.................... #BYTE PORTB = 0xF81 
.................... #BYTE PORTC = 0xF82 
.................... #BYTE PORTD = 0xF83 
.................... #BYTE PORTE = 0xF84 
....................  
.................... #BYTE SSPSTAT = 0xFC7 // SPI contr. bytes        
.................... #BYTE SSPCON = 0xFC6                            
....................  
.................... #BIT SMP = SSPSTAT.7                                     
.................... #BIT CKE = SSPSTAT.6                                   
.................... #BIT CKP = SSPCON.4// SERIAL CLK POL       
....................        
.................... #BIT RA0 = PORTA.0 
.................... #BIT RA1 = PORTA.1 
.................... #BIT RA2 = PORTA.2 
.................... #BIT RA3 = PORTA.3 
.................... #BIT RA4 = PORTA.4 
.................... #BIT RA5 = PORTA.5 
....................  
.................... #BIT RE0 = PORTE.0 
....................  
.................... #BIT TRA5 = TRISA.5 
.................... #BIT TRA4 = TRISA.4 
.................... #BIT TRA3 = TRISA.3 
.................... #BIT TRA2 = TRISA.2 
.................... #BIT TRA1 = TRISA.1 
.................... #BIT TRA0 = TRISA.0 
....................  
.................... #BIT TRE0 = TRISE.0 
....................  
.................... #BIT TRC5 = TRISC.5 
.................... #BIT TRC3 = TRISC.3 
.................... #BIT TRC4 = TRISC.4 
.................... #BIT TRC6 = TRISC.6 
.................... #BIT TRC7 = TRISC.7 
....................  
.................... #BIT RB5 = PORTB.5 
.................... #BIT LCD_RS = PORTD.2  
.................... #BIT LCD_RW = PORTD.3 
.................... #BIT LCD_E = PORTD.0 
....................  
.................... //#BIT PORTD0 = PORTD.0 
.................... #BIT PORTD4 = PORTD.4 
.................... #BIT PORTD5 = PORTD.5 
.................... #BIT PORTD6 = PORTD.6 
.................... #BIT PORTD7 = PORTD.7 
....................  
.................... #BIT PORTB1 = PORTB.1 
.................... #BIT PORTB2 = PORTB.2 
.................... #BIT PORTB3 = PORTB.3 
.................... #BIT PORTB4 = PORTB.4 
....................  
.................... #BIT PORTC5 = PORTC.5 
.................... #BIT PORTC6 = PORTC.6 
.................... #BIT PORTC7 = PORTC.7 
....................  
.................... #define Din RA0  //нога Dout МК 
.................... #define Dout RA1 //нога Din МК 
.................... #define SCLK RA2 
.................... #define DRDY RA3//7-ая 
.................... #define DSYNC RA4//6 нога мк 
.................... #define RESET RA5//7-ая 
....................  
.................... #define CS RE0  //нога 8 МК 
....................  
.................... typedef unsigned int32 U32; 
.................... typedef int16 U16; 
.................... typedef signed int16 S16; 
.................... typedef unsigned int8 U8; 
....................  
.................... Char PGA = 3; 
.................... //0 - PGA=1, 1-PGA=2, 2-PGA=4, 3-PGA=8, 4-PGA=16  
.................... static U8 buf; 
.................... const U8 SETUP=0x00,MUX=0x01,ACR=0x02,IDAC1=0x03, 
.................... IDAC2=0x04,ODAC=0x05,DIO=0x06,DIR=0x07,DEC0=0x08, 
.................... MDEC1=0x09,OCR0=0x0A,OCR1=0x0B,OCR2=0x0C, 
.................... FSR0=0x0D,FSR1=0x0E,FSR2=0x0F; 
....................  
.................... /* 
.................... static U8 count=0; 
.................... static U8 hp = 33;// мощность нагревателя в %  
.................... static int1 tmaxfl = 0,pwrfl=0,dtfl=1; 
.................... static U8 ADCNumSamples = 20; 
.................... static int1 henfl=0; 
.................... static U16 tmax = 30; 
.................... static U8 MenuItemNum = 0;//номер пункта меню 
....................  
....................  
....................  static u8 i; 
....................  static U8 t_out[4]={0,0,0,0}; 
....................  static U8 b_hold[4]={0,0,0,0}; 
....................  static U8 b_push[4]={0,0,0,0}; 
....................  static int1 Pbfl = 0,PbFl1=0; 
....................  */ 
....................  
.................... #BIT buf4=buf.4 
.................... #BIT buf5=buf.5 
.................... #BIT buf6=buf.6 
.................... #BIT buf7=buf.7 
....................  
.................... static U16 U16EERead(U8 Adr){ 
.................... U8 value; 
.................... U16 DATA; 
.................... DATA = read_eeprom(Adr+1);//ст.байт 
.................... DATA=DATA<<8; 
.................... DATA = DATA+read_eeprom(Adr);//мл.байт 
.................... return DATA; 
.................... } 
....................  
.................... static U8 U16EEWrite(U16 Data, U8 Adr){ 
.................... U8 value; 
.................... value=DATA; 
.................... write_eeprom (Adr, value);//ст.байт 
.................... value=DATA>>8; 
.................... write_eeprom (Adr+1, value);//мл.байт 
.................... delay_ms(10); 
.................... if(U16EERead(Adr)==DATA) return 1; 
....................  else return 0; 
.................... } 
....................  
.................... /* 
....................   Name  : CRC-8 
....................   Poly  : 0x31    x^8 + x^5 + x^4 + 1 
....................   Init  : 0xFF 
....................   Revert: false 
....................   XorOut: 0x00 
....................   Check : 0xF7 ("123456789") 
....................   MaxLen: 15 байт(127 бит) - обнаружение 
....................     одинарных, двойных, тройных и всех нечетных ошибок 
.................... */ 
.................... unsigned char Crc8(unsigned char *pcBlock, unsigned int len) 
.................... { 
....................     unsigned char crc = 0xFF; 
....................     unsigned int i; 
....................   
....................     while (len--) 
....................     { 
....................         crc ^= *pcBlock++; 
....................   
....................         for (i = 0; i < 8; i++) 
....................             crc = crc & 0x80 ? (crc << 1) ^ 0x31 : crc << 1; 
....................     } 
....................   
....................     return crc; 
.................... } 
....................  
.................... /* 
.................... static int1 PBScan(U8 pb){ 
.................... // сканирование кнопок 
.................... //pb-номер кнопки(0-3); 
....................      
....................     switch (pb){ 
....................       case 0: 
....................          return !portb1; 
....................       break; 
....................       case 1: 
....................          return !PORTB2; 
....................       break; 
....................       case 2: 
....................          return !PORTB3; 
....................       break; 
....................       case 3: 
....................          return !PORTB4; 
....................       break; 
....................       default: 
....................          return 0; 
....................      
....................     } 
.................... } 
.................... */ 
.................... /***************** LCD functions *****************/ 
.................... static void LCDWriteNibble(unsigned char uc) /* RS must be set/reset before calling */ 
.................... {                                            
....................   uc=uc << 4; /* Align with bits 7-4*/ 
0098:  SWAPF  39,F
009A:  MOVLW  F0
009C:  ANDWF  39,F
....................   LCD_RW=0; 
009E:  BCF    F83.3
....................   buf=uc; 
00A0:  MOVFF  39,05
....................   PORTD4=buf4; 
00A4:  BTFSS  05.4
00A6:  BCF    F83.4
00A8:  BTFSC  05.4
00AA:  BSF    F83.4
....................   PORTD5=buf5; 
00AC:  BTFSS  05.5
00AE:  BCF    F83.5
00B0:  BTFSC  05.5
00B2:  BSF    F83.5
....................   PORTD6=buf6; 
00B4:  BTFSS  05.6
00B6:  BCF    F83.6
00B8:  BTFSC  05.6
00BA:  BSF    F83.6
....................   PORTD7=buf7; 
00BC:  BTFSS  05.7
00BE:  BCF    F83.7
00C0:  BTFSC  05.7
00C2:  BSF    F83.7
....................   //delay_ms(50); 
....................   delay_ms(1); 
00C4:  MOVLW  01
00C6:  MOVWF  3A
00C8:  RCALL  0050
....................   LCD_E=1; 
00CA:  BSF    F83.0
....................   //delay_us(100); 
....................   delay_us(2); 
00CC:  MOVLW  06
00CE:  MOVWF  00
00D0:  DECFSZ 00,F
00D2:  BRA    00D0
00D4:  NOP   
....................   LCD_E=0; 
00D6:  BCF    F83.0
....................   delay_us(100); 
00D8:  MOVLW  64
00DA:  MOVWF  3A
00DC:  BRA    0078
....................   LCD_RW=1;    
00DE:  BSF    F83.3
.................... } 
00E0:  RETURN 0
....................  
.................... static void LCDWriteData(unsigned char uc) 
.................... { 
....................    
....................     LCD_RS=0; 
*
018C:  BCF    F83.2
....................     //delay_ms(50); 
....................     delay_ms(1); 
018E:  MOVLW  01
0190:  MOVWF  3A
0192:  RCALL  0050
....................     LCD_RS=1; 
0194:  BSF    F83.2
....................     LCD_RW=1;// Восстановление байтовой синхронизации 
0196:  BSF    F83.3
....................     LCDWriteNibble(uc>>4);//двиг разрядов старших 
0198:  SWAPF  37,W
019A:  MOVWF  38
019C:  MOVLW  0F
019E:  ANDWF  38,F
01A0:  MOVFF  38,39
01A4:  RCALL  0098
....................     LCDWriteNibble(uc); 
01A6:  MOVFF  37,39
01AA:  RCALL  0098
....................    
.................... } 
01AC:  GOTO   01B6 (RETURN)
....................  
.................... static void LCDCommand(unsigned char uc) 
.................... { 
....................     LCD_RS=0; /* Instruction mode */ 
*
00E2:  BCF    F83.2
....................     //delay_ms(1); 
....................     delay_ms(5); 
00E4:  MOVLW  05
00E6:  MOVWF  3A
00E8:  RCALL  0050
....................     LCD_RW=1;// Восстановление байтовой синхронизации 
00EA:  BSF    F83.3
....................     LCDWriteNibble(uc>>4); 
00EC:  SWAPF  2C,W
00EE:  MOVWF  2D
00F0:  MOVLW  0F
00F2:  ANDWF  2D,F
00F4:  MOVFF  2D,39
00F8:  RCALL  0098
....................     LCDWriteNibble(uc);   
00FA:  MOVFF  2C,39
00FE:  RCALL  0098
.................... } 
0100:  RETURN 0
....................  
.................... static void LCDSetCursor(unsigned char ucPos) 
.................... { 
....................   LCDCommand(0x80 | ucPos); 
*
01E0:  MOVF   2A,W
01E2:  IORLW  80
01E4:  MOVWF  2B
01E6:  MOVWF  2C
01E8:  RCALL  00E2
.................... } 
01EA:  RETURN 0
....................  
.................... static void LCDClear(void) 
.................... { 
....................    LCDCommand(0x1); 
*
017E:  MOVLW  01
0180:  MOVWF  2C
0182:  RCALL  00E2
....................    //Delay_ms(1); 
....................    delay_ms(5); 
0184:  MOVLW  05
0186:  MOVWF  3A
0188:  RCALL  0050
.................... } 
018A:  RETURN 0
....................  
.................... static void LCDInit(void) 
.................... { 
....................   LCD_E=0; 
*
0102:  BCF    F83.0
....................   LCD_RS=0; 
0104:  BCF    F83.2
....................   //Delay_ms(1000); // 
....................   delay_ms(2000); 
0106:  MOVLW  08
0108:  MOVWF  28
010A:  MOVLW  FA
010C:  MOVWF  3A
010E:  RCALL  0050
0110:  DECFSZ 28,F
0112:  BRA    010A
....................   LCDWriteNibble(3); 
0114:  MOVLW  03
0116:  MOVWF  39
0118:  RCALL  0098
....................   //Delay_us(200); 
....................   Delay_ms(1); 
011A:  MOVLW  01
011C:  MOVWF  3A
011E:  RCALL  0050
....................   LCDWriteNibble(3); 
0120:  MOVLW  03
0122:  MOVWF  39
0124:  RCALL  0098
....................   Delay_ms(1); 
0126:  MOVLW  01
0128:  MOVWF  3A
012A:  RCALL  0050
....................   //Delay_us(200); 
....................   LCDWriteNibble(3); 
012C:  MOVLW  03
012E:  MOVWF  39
0130:  RCALL  0098
....................   Delay_ms(1); 
0132:  MOVLW  01
0134:  MOVWF  3A
0136:  RCALL  0050
....................   //Delay_us(200); 
....................   LCDWriteNibble(2); 
0138:  MOVLW  02
013A:  MOVWF  39
013C:  RCALL  0098
....................   Delay_ms(1); 
013E:  MOVLW  01
0140:  MOVWF  3A
0142:  RCALL  0050
....................   //Delay_us(200); 
....................    
....................   LCDCommand(0x28);//4-битный режим, 2 строки, шрифт 5x8 точек 
0144:  MOVLW  28
0146:  MOVWF  2C
0148:  RCALL  00E2
....................    
....................   LCDCommand(0x08);// Выключить дисплей, выключить курсор, выключить моргание курсора 
014A:  MOVLW  08
014C:  MOVWF  2C
014E:  RCALL  00E2
....................    
....................  // LCDCommand(0x0C);// Включить дисплей, включить курсор, включить моргание курсора 
....................   LCDCommand(0b00001100);// Включить дисплей, включить курсор, включить моргание курсора 
0150:  MOVLW  0C
0152:  MOVWF  2C
0154:  RCALL  00E2
....................    
....................   LCDCommand(0x06);// ?????? ????? ????????? ?????? ??? ?????? ?????? 
0156:  MOVLW  06
0158:  MOVWF  2C
015A:  RCALL  00E2
....................   LCDCommand(0x1);// ??????? ?????? ? ??????????? ??????? ? ?????? ???????  
015C:  MOVLW  01
015E:  MOVWF  2C
0160:  RCALL  00E2
....................   // delay_ms(2); 
....................   Delay_ms(8); 
0162:  MOVLW  08
0164:  MOVWF  3A
0166:  RCALL  0050
....................   LCDCommand(0x06);// ?????? ????? ????????? ?????? ??? ?????? ??????  
0168:  MOVLW  06
016A:  MOVWF  2C
016C:  RCALL  00E2
....................   LCDCommand(0x40);//????????? ?????? DRAM 
016E:  MOVLW  40
0170:  MOVWF  2C
0172:  RCALL  00E2
....................   //delay_ms(10); 
....................   Delay_ms(20); 
0174:  MOVLW  14
0176:  MOVWF  3A
0178:  RCALL  0050
....................  } 
017A:  GOTO   0A52 (RETURN)
....................  
.................... /* 
.................... static void LCDInit(void) 
....................  
.................... { 
....................    // ЧТО ЗА (3) 
....................   LCD_E=0; 
....................   LCD_RS=0; 
....................   Delay_ms(1); // 
....................   LCDWriteNibble(3); 
....................   Delay_ms(1); 
....................   LCDWriteNibble(3); 
....................   Delay_ms(1); 
....................   LCDWriteNibble(3); 
....................   Delay_ms(1); 
....................   LCDWriteNibble(3); 
....................   Delay_ms(1); 
....................   
....................   // ИНФОРМАЦИЯ ИЗ ДАТАШИТА 
....................    
....................   LCDCommand(0x28);//4-битный режим, 2 строки, шрифт 5x8 точек 
....................     
....................   LCDCommand(0x08);// Выключить дисплей, выключить курсор, выключить моргание курсора 
....................   
....................   LCDCommand(0x0F);// Включить дисплей, включить курсор, включить моргание курсора 
....................   Delay_ms(5000); 
....................   LCDCommand(0x06);// Курсор будет двигаться вправо при выводе текста 
....................   
....................   LCDCommand(0x1);// Очистка экрана и перемещение курсора в первую позицию  
....................      
....................   LCDCommand(0x06);// Курсор будет двигаться вправо при выводе текста  
....................    
....................   LCDCommand(0x40);//Установка адреса DRAM 
....................    
....................    
....................  } 
....................  */ 
....................   
....................  static void LCDPutCh(char c) 
.................... { 
....................   LCDWriteData(c); 
*
01B0:  MOVFF  36,37
01B4:  BRA    018C
.................... } 
01B6:  RETURN 0
....................  
.................... static void LCDPutU32(U32 _u16,U8 u8NumDigs) 
.................... { 
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000000; 
*
0582:  BCF    FD8.1
0584:  MOVFF  2B,46
0588:  MOVFF  2A,45
058C:  MOVFF  29,44
0590:  MOVFF  28,43
0594:  CLRF   4A
0596:  MOVLW  98
0598:  MOVWF  49
059A:  MOVLW  96
059C:  MOVWF  48
059E:  MOVLW  80
05A0:  MOVWF  47
05A2:  RCALL  038E
05A4:  MOVFF  03,30
05A8:  MOVFF  02,2F
05AC:  MOVFF  01,2E
05B0:  MOVFF  00,2D
....................    u16b=u16a*10000000; 
05B4:  MOVFF  30,38
05B8:  MOVFF  2F,37
05BC:  MOVFF  2E,36
05C0:  MOVFF  2D,35
05C4:  CLRF   3C
05C6:  MOVLW  98
05C8:  MOVWF  3B
05CA:  MOVLW  96
05CC:  MOVWF  3A
05CE:  MOVLW  80
05D0:  MOVWF  39
05D2:  RCALL  04EE
05D4:  MOVFF  03,34
05D8:  MOVFF  02,33
05DC:  MOVFF  01,32
05E0:  MOVFF  00,31
....................  
....................     if (u8NumDigs>=7) 
05E4:  MOVF   2C,W
05E6:  SUBLW  06
05E8:  BC    05F4
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
05EA:  MOVLW  30
05EC:  ADDWF  2D,W
05EE:  MOVWF  35
05F0:  MOVWF  36
05F2:  RCALL  01B0
....................     } 
....................       _u16-=u16b; 
05F4:  MOVF   31,W
05F6:  SUBWF  28,F
05F8:  MOVF   32,W
05FA:  SUBWFB 29,F
05FC:  MOVF   33,W
05FE:  SUBWFB 2A,F
0600:  MOVF   34,W
0602:  SUBWFB 2B,F
....................        
....................    u16a=_u16/1000000; 
0604:  BCF    FD8.1
0606:  MOVFF  2B,46
060A:  MOVFF  2A,45
060E:  MOVFF  29,44
0612:  MOVFF  28,43
0616:  CLRF   4A
0618:  MOVLW  0F
061A:  MOVWF  49
061C:  MOVLW  42
061E:  MOVWF  48
0620:  MOVLW  40
0622:  MOVWF  47
0624:  RCALL  038E
0626:  MOVFF  03,30
062A:  MOVFF  02,2F
062E:  MOVFF  01,2E
0632:  MOVFF  00,2D
....................    u16b=u16a*1000000; 
0636:  MOVFF  30,38
063A:  MOVFF  2F,37
063E:  MOVFF  2E,36
0642:  MOVFF  2D,35
0646:  CLRF   3C
0648:  MOVLW  0F
064A:  MOVWF  3B
064C:  MOVLW  42
064E:  MOVWF  3A
0650:  MOVLW  40
0652:  MOVWF  39
0654:  RCALL  04EE
0656:  MOVFF  03,34
065A:  MOVFF  02,33
065E:  MOVFF  01,32
0662:  MOVFF  00,31
....................        
....................     if (u8NumDigs>=6) 
0666:  MOVF   2C,W
0668:  SUBLW  05
066A:  BC    0676
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
066C:  MOVLW  30
066E:  ADDWF  2D,W
0670:  MOVWF  35
0672:  MOVWF  36
0674:  RCALL  01B0
....................     } 
....................       _u16-=u16b; 
0676:  MOVF   31,W
0678:  SUBWF  28,F
067A:  MOVF   32,W
067C:  SUBWFB 29,F
067E:  MOVF   33,W
0680:  SUBWFB 2A,F
0682:  MOVF   34,W
0684:  SUBWFB 2B,F
....................        
....................    u16a=_u16/100000; 
0686:  BCF    FD8.1
0688:  MOVFF  2B,46
068C:  MOVFF  2A,45
0690:  MOVFF  29,44
0694:  MOVFF  28,43
0698:  CLRF   4A
069A:  MOVLW  01
069C:  MOVWF  49
069E:  MOVLW  86
06A0:  MOVWF  48
06A2:  MOVLW  A0
06A4:  MOVWF  47
06A6:  RCALL  038E
06A8:  MOVFF  03,30
06AC:  MOVFF  02,2F
06B0:  MOVFF  01,2E
06B4:  MOVFF  00,2D
....................    u16b=u16a*100000; 
06B8:  MOVFF  30,38
06BC:  MOVFF  2F,37
06C0:  MOVFF  2E,36
06C4:  MOVFF  2D,35
06C8:  CLRF   3C
06CA:  MOVLW  01
06CC:  MOVWF  3B
06CE:  MOVLW  86
06D0:  MOVWF  3A
06D2:  MOVLW  A0
06D4:  MOVWF  39
06D6:  RCALL  04EE
06D8:  MOVFF  03,34
06DC:  MOVFF  02,33
06E0:  MOVFF  01,32
06E4:  MOVFF  00,31
....................  
....................     if (u8NumDigs>=5) 
06E8:  MOVF   2C,W
06EA:  SUBLW  04
06EC:  BC    06F8
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
06EE:  MOVLW  30
06F0:  ADDWF  2D,W
06F2:  MOVWF  35
06F4:  MOVWF  36
06F6:  RCALL  01B0
....................     } 
....................  
....................     _u16-=u16b; 
06F8:  MOVF   31,W
06FA:  SUBWF  28,F
06FC:  MOVF   32,W
06FE:  SUBWFB 29,F
0700:  MOVF   33,W
0702:  SUBWFB 2A,F
0704:  MOVF   34,W
0706:  SUBWFB 2B,F
....................     u16a=_u16/10000; 
0708:  BCF    FD8.1
070A:  MOVFF  2B,46
070E:  MOVFF  2A,45
0712:  MOVFF  29,44
0716:  MOVFF  28,43
071A:  CLRF   4A
071C:  CLRF   49
071E:  MOVLW  27
0720:  MOVWF  48
0722:  MOVLW  10
0724:  MOVWF  47
0726:  RCALL  038E
0728:  MOVFF  03,30
072C:  MOVFF  02,2F
0730:  MOVFF  01,2E
0734:  MOVFF  00,2D
....................     u16b=u16a*10000; 
0738:  MOVFF  30,38
073C:  MOVFF  2F,37
0740:  MOVFF  2E,36
0744:  MOVFF  2D,35
0748:  CLRF   3C
074A:  CLRF   3B
074C:  MOVLW  27
074E:  MOVWF  3A
0750:  MOVLW  10
0752:  MOVWF  39
0754:  RCALL  04EE
0756:  MOVFF  03,34
075A:  MOVFF  02,33
075E:  MOVFF  01,32
0762:  MOVFF  00,31
....................     if (u8NumDigs>=4) 
0766:  MOVF   2C,W
0768:  SUBLW  03
076A:  BC    0776
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
076C:  MOVLW  30
076E:  ADDWF  2D,W
0770:  MOVWF  35
0772:  MOVWF  36
0774:  RCALL  01B0
....................     } 
....................  
....................     _u16-=u16b; 
0776:  MOVF   31,W
0778:  SUBWF  28,F
077A:  MOVF   32,W
077C:  SUBWFB 29,F
077E:  MOVF   33,W
0780:  SUBWFB 2A,F
0782:  MOVF   34,W
0784:  SUBWFB 2B,F
....................     u16a=_u16/1000; 
0786:  BCF    FD8.1
0788:  MOVFF  2B,46
078C:  MOVFF  2A,45
0790:  MOVFF  29,44
0794:  MOVFF  28,43
0798:  CLRF   4A
079A:  CLRF   49
079C:  MOVLW  03
079E:  MOVWF  48
07A0:  MOVLW  E8
07A2:  MOVWF  47
07A4:  RCALL  038E
07A6:  MOVFF  03,30
07AA:  MOVFF  02,2F
07AE:  MOVFF  01,2E
07B2:  MOVFF  00,2D
....................     u16b=u16a*1000; 
07B6:  MOVFF  30,38
07BA:  MOVFF  2F,37
07BE:  MOVFF  2E,36
07C2:  MOVFF  2D,35
07C6:  CLRF   3C
07C8:  CLRF   3B
07CA:  MOVLW  03
07CC:  MOVWF  3A
07CE:  MOVLW  E8
07D0:  MOVWF  39
07D2:  RCALL  04EE
07D4:  MOVFF  03,34
07D8:  MOVFF  02,33
07DC:  MOVFF  01,32
07E0:  MOVFF  00,31
....................     if (u8NumDigs>=3) 
07E4:  MOVF   2C,W
07E6:  SUBLW  02
07E8:  BC    07F4
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
07EA:  MOVLW  30
07EC:  ADDWF  2D,W
07EE:  MOVWF  35
07F0:  MOVWF  36
07F2:  RCALL  01B0
....................        
....................     } 
....................  
....................     _u16-=u16b; 
07F4:  MOVF   31,W
07F6:  SUBWF  28,F
07F8:  MOVF   32,W
07FA:  SUBWFB 29,F
07FC:  MOVF   33,W
07FE:  SUBWFB 2A,F
0800:  MOVF   34,W
0802:  SUBWFB 2B,F
....................     u16a=_u16/100; 
0804:  BCF    FD8.1
0806:  MOVFF  2B,46
080A:  MOVFF  2A,45
080E:  MOVFF  29,44
0812:  MOVFF  28,43
0816:  CLRF   4A
0818:  CLRF   49
081A:  CLRF   48
081C:  MOVLW  64
081E:  MOVWF  47
0820:  RCALL  038E
0822:  MOVFF  03,30
0826:  MOVFF  02,2F
082A:  MOVFF  01,2E
082E:  MOVFF  00,2D
....................     u16b=u16a*100; 
0832:  MOVFF  30,38
0836:  MOVFF  2F,37
083A:  MOVFF  2E,36
083E:  MOVFF  2D,35
0842:  CLRF   3C
0844:  CLRF   3B
0846:  CLRF   3A
0848:  MOVLW  64
084A:  MOVWF  39
084C:  RCALL  04EE
084E:  MOVFF  03,34
0852:  MOVFF  02,33
0856:  MOVFF  01,32
085A:  MOVFF  00,31
....................    if (u8NumDigs>=2) 
085E:  MOVF   2C,W
0860:  SUBLW  01
0862:  BC    086E
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0864:  MOVLW  30
0866:  ADDWF  2D,W
0868:  MOVWF  35
086A:  MOVWF  36
086C:  RCALL  01B0
....................     } 
....................  
....................    _u16-=u16b; 
086E:  MOVF   31,W
0870:  SUBWF  28,F
0872:  MOVF   32,W
0874:  SUBWFB 29,F
0876:  MOVF   33,W
0878:  SUBWFB 2A,F
087A:  MOVF   34,W
087C:  SUBWFB 2B,F
....................     u16a=_u16/10; 
087E:  BCF    FD8.1
0880:  MOVFF  2B,46
0884:  MOVFF  2A,45
0888:  MOVFF  29,44
088C:  MOVFF  28,43
0890:  CLRF   4A
0892:  CLRF   49
0894:  CLRF   48
0896:  MOVLW  0A
0898:  MOVWF  47
089A:  RCALL  038E
089C:  MOVFF  03,30
08A0:  MOVFF  02,2F
08A4:  MOVFF  01,2E
08A8:  MOVFF  00,2D
....................     u16b=u16a*10; 
08AC:  MOVFF  30,38
08B0:  MOVFF  2F,37
08B4:  MOVFF  2E,36
08B8:  MOVFF  2D,35
08BC:  CLRF   3C
08BE:  CLRF   3B
08C0:  CLRF   3A
08C2:  MOVLW  0A
08C4:  MOVWF  39
08C6:  RCALL  04EE
08C8:  MOVFF  03,34
08CC:  MOVFF  02,33
08D0:  MOVFF  01,32
08D4:  MOVFF  00,31
....................    if (u8NumDigs>=2) 
08D8:  MOVF   2C,W
08DA:  SUBLW  01
08DC:  BC    08E8
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
08DE:  MOVLW  30
08E0:  ADDWF  2D,W
08E2:  MOVWF  35
08E4:  MOVWF  36
08E6:  RCALL  01B0
....................     } 
....................  
....................     _u16-=u16b; 
08E8:  MOVF   31,W
08EA:  SUBWF  28,F
08EC:  MOVF   32,W
08EE:  SUBWFB 29,F
08F0:  MOVF   33,W
08F2:  SUBWFB 2A,F
08F4:  MOVF   34,W
08F6:  SUBWFB 2B,F
....................     if (u8NumDigs>=1) 
08F8:  MOVF   2C,W
08FA:  SUBLW  00
08FC:  BC    0908
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
08FE:  MOVLW  30
0900:  ADDWF  28,W
0902:  MOVWF  35
0904:  MOVWF  36
0906:  RCALL  01B0
....................     } 
....................    
.................... } 
0908:  RETURN 0
....................  
.................... static void LCDPutU16(U32 _u16,U8 u8NumDigs) 
.................... { 
....................     
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000; 
....................    u16b=u16a*10000; 
....................  
....................     if (u8NumDigs>=5) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/1000; 
....................     u16b=u16a*1000; 
....................     if (u8NumDigs>=4) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/100; 
....................     u16b=u16a*100; 
....................     if (u8NumDigs>=3) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................        
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/10; 
....................     u16b=u16a*10; 
....................    if (u8NumDigs>=2) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     if (u8NumDigs>=1) 
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
....................     } 
....................    
.................... } 
....................  
.................... /* 
....................  static void LCDPutU16(U32 _u16,U8 u8NumDigs) 
.................... { 
....................     
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000; 
....................    u16b=u16a*10000; 
....................  
....................     if (u8NumDigs>=5) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/1000; 
....................     u16b=u16a*1000; 
....................     if (u8NumDigs>=4) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/100; 
....................     u16b=u16a*100; 
....................     if (u8NumDigs>=3) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................        
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/10; 
....................     u16b=u16a*10; 
....................    if (u8NumDigs>=2) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     if (u8NumDigs>=1) 
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
....................     } 
....................    
.................... } 
.................... */ 
.................... static void LCDPutS16(S16 s16a,U8 u8NumDigs) 
.................... { 
....................   char c='+'; 
....................  
....................   if (s16a<0) 
....................   { 
....................     s16a=-s16a; 
....................     c='-'; 
....................   } 
....................   LCDPutCh(c); 
....................   LCDPutU16((U16)s16a,u8NumDigs); 
.................... } 
....................  
.................... static void LCDMsg(char c) 
.................... { 
....................     LCDPutCh(c); 
*
01B8:  MOVFF  2C,36
01BC:  RCALL  01B0
.................... } 
01BE:  RETURN 0
....................  
....................  static void LCDWelcome(void) 
.................... { 
....................     U16 u16a; 
....................     LCDClear(); 
*
01EC:  RCALL  017E
....................     LCDMsg("CRYO TERM. test"); 
01EE:  MOVLW  04
01F0:  MOVWF  FF6
01F2:  MOVLW  00
01F4:  MOVWF  FF7
01F6:  RCALL  01C0
....................     //Delay_ms(2000); 
....................     LCDSetCursor(0x40); 
01F8:  MOVLW  40
01FA:  MOVWF  2A
01FC:  RCALL  01E0
....................     LCDMsg("Firmware test");  
01FE:  MOVLW  14
0200:  MOVWF  FF6
0202:  MOVLW  00
0204:  MOVWF  FF7
0206:  RCALL  01C0
....................     Delay_ms(500); 
0208:  MOVLW  02
020A:  MOVWF  2A
020C:  MOVLW  FA
020E:  MOVWF  3A
0210:  RCALL  0050
0212:  DECFSZ 2A,F
0214:  BRA    020C
....................     LCDClear();    
0216:  RCALL  017E
.................... } 
0218:  GOTO   0A56 (RETURN)
.................... /* 
.................... #int_TIMER 
.................... void  TIMER1_isr(void){ 
.................... // прерывание каждую мс 
.................... set_timer1(64910);  
.................... for(i=0; i<4; ++i){ 
.................... //нажата ли кнопка? 
....................  if (PBScan(i)){ 
....................   //кнопка зажата 
....................    //порог подавления дребезга достигнут 
....................    if(t_out[i]==30) { 
....................           //да 
....................           //флаг "Удерживается" установлен 
....................           if(!b_hold[i]){ 
....................             //нет 
....................             b_hold[i]=1;//утановить флаг "Удерживается" 
....................             b_push[i]=1;//установить флаг "нажато" 
....................            } 
....................           //да 
....................        } 
....................       else 
....................       //порог подавления дребезга не достигнут 
....................       { 
....................       ++t_out[i];//инкримент переменной подавления дребезга 
....................       } 
....................    } 
....................    else 
....................    // кнопка не нажата 
....................    { 
....................    t_out[i]=0; //обнуление переменной подавления дребезга 
....................    b_hold[i]=0; //сброс флага "удерживается" 
....................    } 
.................... } 
.................... //***********кнопки обработаны*********************** 
....................    
....................   if(b_push[2]){ 
....................      b_push[2]=0; 
....................      Pbfl = 1; 
....................        ++MenuItemNum; 
....................      //   Pbfl = 1; 
....................         
....................    } if(MenuItemNum>6) MenuItemNum=0; 
....................    
....................        
.................... clear_interrupt(int_timer1);//сброс прерываения..обяз 
.................... } 
....................  
.................... #int_TIMER3 
.................... void  TIMER3_isr(void)  
.................... { 
.................... // прерывание каждые 100 мс 
.................... // управление нагревателем 
.................... set_timer3(59300); 
....................     
....................    if(count>hp) pwrfl=0; 
....................             else pwrfl=1; 
....................              
....................     if(tmaxfl&&pwrfl&&dtfl&&henfl){ 
....................     PORTC5 = 1; 
....................     }else PORTC5 = 0; 
....................      
....................     if(count>99){ 
....................         count = 0; 
....................         } 
....................  count ++; 
....................  
.................... clear_interrupt(int_timer3); 
.................... } 
....................  
.................... u16 ADC_read(u8 ch){ 
....................   U32 ADC_value; 
....................   u8 i; 
....................   ADC_value=0; 
....................   set_adc_channel(ch); // установка порта АЦП 
....................    delay_us(20); 
....................    for(i=0;i<ADCNumSamples;i++){ 
....................    ADC_value = read_adc()+ADC_value;// получение значений с АЦП 
....................    delay_ms(2); 
....................    } 
....................    return ADC_value/ADCNumSamples; 
.................... } 
.................... */ 
....................  
.................... //----------------ADS1216 functions----------------------------- 
.................... /* 
.................... static void WrByte(char b){ 
....................    //cs = 0; 
....................    //delay_us(10); 
....................    spi_write(b); 
....................     
.................... } 
.................... */ 
.................... static void WrByte(char b){ 
.................... spi_write(b); 
*
02C2:  MOVF   FC9,W
02C4:  MOVFF  53,FC9
02C8:  RRCF   FC7,W
02CA:  BNC   02C8
.................... /* 
.................... int i; 
.................... for (i = 0; i<8; i++){ 
....................    SCLK = 0; 
....................    delay_us(5); 
....................    buf = b; 
....................    Dout=buf7; 
....................    //delay_us(2); 
....................    delay_us(10); 
....................    //Dout=buf7; 
....................    SCLK = 1; 
....................    delay_us(10); 
....................    b=b<<1; 
....................    } 
....................    SCLK = 0; 
....................   */ 
.................... } 
02CC:  RETURN 0
....................  
.................... static void WrByte1(char b){ 
.................... int i; 
.................... for (i = 0; i<8; i++){ 
....................    SCLK = 1; 
....................    buf = b; 
....................    Dout=buf7; 
....................    //delay_us(2); 
....................    delay_us(10); 
....................    //Dout=buf7; 
....................    SCLK = 0; 
....................    //delay_us(10); 
....................    b=b<<1; 
....................    } 
....................    SCLK = 1; 
.................... } 
....................  
.................... static char RdByte(void){ 
....................  
.................... int i; 
.................... char b=0; 
.................... for (i = 0; i<8; i++){ 
....................    SCLK = 0; 
....................    //delay_us(2); 
....................    delay_us(10); 
....................    b=b<<1; 
....................     
....................    SCLK = 1; 
....................    delay_us(10); 
....................    b=b+Din; 
....................    } 
.................... SCLK = 0; 
.................... return b; 
.................... } 
....................  
.................... static char RdByte1(void){ 
.................... char b = 0; 
.................... b = SPI_read(Din); 
.................... return b; 
.................... } 
....................  
.................... static void WrReg1(char RegAdr,Wbyte){ 
.................... //CS = 0; 
.................... WrByte(0x50+RegAdr);  
.................... delay_us(40); 
.................... WrByte(0x0); 
.................... delay_us(40); 
.................... WrByte(Wbyte); 
.................... //delay_us(20); 
.................... //delay_us(10); 
.................... //CS = 1; 
.................... } 
....................  
.................... static void WrReg(char RegAdr,Wbyte){ 
.................... //CS = 0; 
.................... //WrByte(0x50+RegAdr); 
.................... Spi_write(0x50+RegAdr); 
*
021C:  MOVLW  50
021E:  ADDWF  39,W
0220:  MOVWF  3B
0222:  MOVF   FC9,W
0224:  MOVFF  3B,FC9
0228:  RRCF   FC7,W
022A:  BNC   0228
.................... delay_us(10); 
022C:  MOVLW  21
022E:  MOVWF  00
0230:  DECFSZ 00,F
0232:  BRA    0230
.................... Spi_write(0x0); 
0234:  MOVF   FC9,W
0236:  CLRF   FC9
0238:  RRCF   FC7,W
023A:  BNC   0238
.................... delay_us(10); 
023C:  MOVLW  21
023E:  MOVWF  00
0240:  DECFSZ 00,F
0242:  BRA    0240
.................... Spi_write(Wbyte); 
0244:  MOVF   FC9,W
0246:  MOVFF  3A,FC9
024A:  RRCF   FC7,W
024C:  BNC   024A
.................... //delay_us(20); 
.................... //delay_us(10); 
.................... //CS = 1; 
.................... } 
024E:  RETURN 0
....................  
.................... static char RdReg1(char RegAdr){ 
.................... char b; 
.................... //CS = 0; 
.................... WrByte(0x10+RegAdr); 
.................... //WrByte(0xF0+RegAdr); 
.................... delay_us(40); 
.................... WrByte(0);// число читаемых байт - 1 
.................... delay_us(40); 
.................... Rdbyte(); // мусор 
.................... delay_us(40); 
.................... b=RdByte(); 
....................  
.................... delay_us(20); 
.................... //CS = 1; 
.................... return (b); 
....................  
.................... } 
....................  
.................... static char RdReg(char RegAdr){ 
.................... char b; 
.................... //CS = 0; 
.................... Spi_write(0x10+RegAdr); 
.................... //WrByte(0xF0+RegAdr); 
.................... delay_us(10); 
.................... Spi_write(0);// число читаемых байт - 1 
.................... //delay_us(10); 
.................... //Spi_read(0); // мусор 
.................... delay_us(10); 
.................... b=Spi_read(0); 
....................  
.................... delay_us(20); 
.................... //CS = 1; 
.................... return (b); 
....................  
.................... } 
....................  
.................... static char RdRam(char RamAdr){ 
.................... char b = 0; 
.................... //CS = 0; 
.................... WrByte(0x20+RamAdr); 
.................... //delay_us(40); 
.................... WrByte(0x0); 
.................... //delay_us(40); 
.................... b=RdByte(); 
.................... //delay_us(40); 
.................... //CS = 1; 
.................... return (b); 
....................  
.................... } 
....................  
.................... static char Rdata(void){ 
.................... char b =0; 
.................... WrByte(0x01); 
.................... delay_us(50); 
.................... SPI_read(0); 
.................... b = SPI_read(0)*SPI_read(0)*SPI_read(0); 
.................... return b; 
.................... } 
....................  
.................... static void AdsInit (void){ 
.................... cs=0; 
0250:  BCF    F84.0
.................... delay_us(20); 
0252:  MOVLW  42
0254:  MOVWF  00
0256:  DECFSZ 00,F
0258:  BRA    0256
025A:  NOP   
....................    WrReg(SETUP,0b00011110);        //SETUP  -->   buf en, ref en = 2.5 В, modulator clk/128 
025C:  CLRF   39
025E:  MOVLW  1E
0260:  MOVWF  3A
0262:  RCALL  021C
....................   WrReg(MUX,0x01);     
0264:  MOVLW  01
0266:  MOVWF  39
0268:  MOVWF  3A
026A:  RCALL  021C
....................   //WrReg(MUX,0xff);   //MUX    -->   Ain0 & Ain1 
....................    WrReg(ACR,PGA);    //ACR    -->   PGA = 0 (Vin = +-2.5 B +- 1.5 мкВ, Источники тока обнаружения обрыва внешн датчика ОТКЛ.) 
026C:  MOVLW  02
026E:  MOVWF  39
0270:  MOVFF  04,3A
0274:  RCALL  021C
....................    WrReg(IDAC1,0x00);    //IDAC1  -->  
0276:  MOVLW  03
0278:  MOVWF  39
027A:  CLRF   3A
027C:  RCALL  021C
....................    WrReg(IDAC2,0x00);    //IDAC2  --> 
027E:  MOVLW  04
0280:  MOVWF  39
0282:  CLRF   3A
0284:  RCALL  021C
....................    WrReg(ODAC,0);    //ODAC   -->   ЦАП смещения диапазона вх. напряжений 
0286:  MOVLW  05
0288:  MOVWF  39
028A:  CLRF   3A
028C:  RCALL  021C
....................    WrReg(DIO,0x00);    //DIO    -->   0 или 1 на Din0 -Din7  
028E:  MOVLW  06
0290:  MOVWF  39
0292:  CLRF   3A
0294:  RCALL  021C
....................    WrReg(DIR,0x00);    //DIR    -->   конфигурация вх/вых Din0 - Din7 
0296:  MOVLW  07
0298:  MOVWF  39
029A:  CLRF   3A
029C:  RCALL  021C
....................    WrReg(DEC0,0b11111000);  // fвыборок = 36 Гц. DEC0   -->   полоса пропускания фильтра? -3дБ = 50 Гц * Dec0  
029E:  MOVLW  08
02A0:  MOVWF  39
02A2:  MOVLW  F8
02A4:  MOVWF  3A
02A6:  RCALL  021C
....................    WrReg(MDEC1,0b01110111); //M/DEC1 -->   полярность вх.напряжений, биты 4-5 sinc3 фильтр 
02A8:  MOVLW  09
02AA:  MOVWF  39
02AC:  MOVLW  77
02AE:  MOVWF  3A
02B0:  RCALL  021C
.................... delay_us(20);  
02B2:  MOVLW  42
02B4:  MOVWF  00
02B6:  DECFSZ 00,F
02B8:  BRA    02B6
02BA:  NOP   
.................... cs=1; 
02BC:  BSF    F84.0
.................... } 
02BE:  GOTO   0A72 (RETURN)
....................  
.................... static void SelfCal (void){ 
.................... cs=0; 
*
02CE:  BCF    F84.0
....................   delay_us(20); 
02D0:  MOVLW  42
02D2:  MOVWF  00
02D4:  DECFSZ 00,F
02D6:  BRA    02D4
02D8:  NOP   
....................   Wrbyte(0xF0); 
02DA:  MOVLW  F0
02DC:  MOVWF  53
02DE:  RCALL  02C2
....................   delay_us(20); 
02E0:  MOVLW  42
02E2:  MOVWF  00
02E4:  DECFSZ 00,F
02E6:  BRA    02E4
02E8:  NOP   
.................... cs=1; 
02EA:  BSF    F84.0
.................... } 
02EC:  GOTO   0A74 (RETURN)
....................  
.................... static unsigned int32 Adc_Rdata(void){ 
....................  
.................... unsigned int32 r1,r2,r3; 
.................... unsigned int32 Sum; 
....................  
.................... //While (!DRDY) 
.................... l1: 
.................... if (!DRDY){ 
02F0:  BTFSC  F80.3
02F2:  BRA    038A
.................... set_timer2(0); 
02F4:  CLRF   FCC
....................    CS = 0; 
02F6:  BCF    F84.0
....................    WrByte(0x01); 
02F8:  MOVLW  01
02FA:  MOVWF  53
02FC:  RCALL  02C2
....................    delay_us(20);         
02FE:  MOVLW  42
0300:  MOVWF  00
0302:  DECFSZ 00,F
0304:  BRA    0302
0306:  NOP   
....................     r1 = spi_read(0);    
0308:  MOVF   FC9,W
030A:  CLRF   FC9
030C:  RRCF   FC7,W
030E:  BNC   030C
0310:  CLRF   46
0312:  CLRF   45
0314:  CLRF   44
0316:  MOVFF  FC9,43
....................     r2 = spi_read(0); 
031A:  MOVF   FC9,W
031C:  CLRF   FC9
031E:  RRCF   FC7,W
0320:  BNC   031E
0322:  CLRF   4A
0324:  CLRF   49
0326:  CLRF   48
0328:  MOVFF  FC9,47
....................     r3 = spi_read(0); 
032C:  MOVF   FC9,W
032E:  CLRF   FC9
0330:  RRCF   FC7,W
0332:  BNC   0330
0334:  CLRF   4E
0336:  CLRF   4D
0338:  CLRF   4C
033A:  MOVFF  FC9,4B
....................    cs=1; 
033E:  BSF    F84.0
....................  
.................... Sum = (r1<<16)+(r2<<8)+r3; 
0340:  MOVFF  44,57
0344:  MOVFF  43,56
0348:  CLRF   54
034A:  CLRF   55
034C:  CLRF   00
034E:  MOVF   00,W
0350:  ADDWF  54,F
0352:  MOVF   47,W
0354:  ADDWFC 55,F
0356:  MOVF   48,W
0358:  ADDWFC 56,F
035A:  MOVF   49,W
035C:  ADDWFC 57,F
035E:  MOVF   4B,W
0360:  ADDWF  54,W
0362:  MOVWF  4F
0364:  MOVF   4C,W
0366:  ADDWFC 55,W
0368:  MOVWF  50
036A:  MOVF   4D,W
036C:  ADDWFC 56,W
036E:  MOVWF  51
0370:  MOVF   4E,W
0372:  ADDWFC 57,W
0374:  MOVWF  52
.................... return Sum; 
0376:  MOVFF  4F,00
037A:  MOVFF  50,01
037E:  MOVFF  51,02
0382:  MOVFF  52,03
0386:  BRA    038C
.................... }else goto l1; 
0388:  BRA    038C
038A:  BRA    02F0
.................... } 
038C:  RETURN 0
....................  
.................... static unsigned int32 Middle_Sum (char n){ 
*
041C:  CLRF   3D
041E:  CLRF   3C
0420:  CLRF   3B
0422:  CLRF   3A
0424:  CLRF   41
0426:  CLRF   40
0428:  CLRF   3F
042A:  CLRF   3E
.................... unsigned int32 a1 = 0; 
.................... unsigned int32 a2 = 0; 
.................... int i; 
....................    for(i=0;i<n;i++){ 
042C:  CLRF   42
042E:  MOVF   39,W
0430:  SUBWF  42,W
0432:  BC    045A
....................    a1 = Adc_Rdata(); 
0434:  RCALL  02F0
0436:  MOVFF  03,3D
043A:  MOVFF  02,3C
043E:  MOVFF  01,3B
0442:  MOVFF  00,3A
....................    a2 = a1+a2; 
0446:  MOVF   3A,W
0448:  ADDWF  3E,F
044A:  MOVF   3B,W
044C:  ADDWFC 3F,F
044E:  MOVF   3C,W
0450:  ADDWFC 40,F
0452:  MOVF   3D,W
0454:  ADDWFC 41,F
....................    } 
0456:  INCF   42,F
0458:  BRA    042E
....................    a2=a2/n; 
045A:  BCF    FD8.1
045C:  MOVFF  41,46
0460:  MOVFF  40,45
0464:  MOVFF  3F,44
0468:  MOVFF  3E,43
046C:  CLRF   4A
046E:  CLRF   49
0470:  CLRF   48
0472:  MOVFF  39,47
0476:  RCALL  038E
0478:  MOVFF  03,41
047C:  MOVFF  02,40
0480:  MOVFF  01,3F
0484:  MOVFF  00,3E
.................... return a2; 
0488:  MOVFF  3E,00
048C:  MOVFF  3F,01
0490:  MOVFF  40,02
0494:  MOVFF  41,03
....................  
.................... } 
0498:  GOTO   04CC (RETURN)
....................  
.................... static unsigned int32 AdcChData (char Ch){ 
....................  
.................... unsigned int32 r1,r2,r3; 
.................... unsigned int32 Sum; 
....................  
.................... cs =0; 
049C:  BCF    F84.0
.................... delay_us(20); 
049E:  MOVLW  42
04A0:  MOVWF  00
04A2:  DECFSZ 00,F
04A4:  BRA    04A2
04A6:  NOP   
....................    Wrreg(MUX, Ch); 
04A8:  MOVLW  01
04AA:  MOVWF  39
04AC:  MOVFF  28,3A
04B0:  RCALL  021C
.................... delay_us(20); 
04B2:  MOVLW  42
04B4:  MOVWF  00
04B6:  DECFSZ 00,F
04B8:  BRA    04B6
04BA:  NOP   
.................... cs=1; 
04BC:  BSF    F84.0
....................     Adc_Rdata(); 
04BE:  RCALL  02F0
....................     Adc_Rdata(); 
04C0:  RCALL  02F0
....................     Adc_Rdata(); 
04C2:  RCALL  02F0
....................     Adc_Rdata(); 
04C4:  RCALL  02F0
.................... Sum = Middle_Sum(5); 
04C6:  MOVLW  05
04C8:  MOVWF  39
04CA:  BRA    041C
04CC:  MOVFF  03,38
04D0:  MOVFF  02,37
04D4:  MOVFF  01,36
04D8:  MOVFF  00,35
.................... return Sum; 
04DC:  MOVFF  35,00
04E0:  MOVFF  36,01
04E4:  MOVFF  37,02
04E8:  MOVFF  38,03
....................  
.................... } 
04EC:  RETURN 0
....................  
.................... static u16 powr (char n){ 
*
0542:  MOVLW  01
0544:  MOVWF  2D
.................... char a = 1; 
.................... Return (a<<n); 
0546:  MOVFF  2D,00
054A:  MOVF   2C,W
054C:  MOVWF  01
054E:  BZ    0558
0550:  BCF    FD8.0
0552:  RLCF   00,F
0554:  DECFSZ 01,F
0556:  BRA    0550
0558:  MOVF   00,W
055A:  CLRF   03
055C:  MOVWF  01
055E:  MOVF   03,W
0560:  MOVWF  02
.................... } 
0562:  RETURN 0
....................  
....................  
.................... //--------------------------------------------------------------- 
....................  
.................... void main() 
.................... { 
*
09B0:  CLRF   FF8
09B2:  BCF    FD0.7
09B4:  CLRF   FEA
09B6:  CLRF   FE9
09B8:  MOVLW  40
09BA:  MOVWF  FAF
09BC:  MOVLW  A2
09BE:  MOVWF  FAC
09C0:  MOVLW  90
09C2:  MOVWF  FAB
09C4:  MOVLW  03
09C6:  MOVWF  04
09C8:  MOVF   FC1,W
09CA:  ANDLW  C0
09CC:  IORLW  0F
09CE:  MOVWF  FC1
09D0:  MOVLW  07
09D2:  MOVWF  FB4
09D4:  CLRF   05
09D6:  CLRF   06
09D8:  BCF    10.0
09DA:  CLRF   24
09DC:  CLRF   23
09DE:  CLRF   22
09E0:  MOVLW  95
09E2:  MOVWF  21
09E4:  MOVLW  02
09E6:  MOVWF  25
09E8:  SETF   26
09EA:  SETF   27
....................  u8 j=0; 
....................  char buf1[8],b; 
....................  int1 EEWrFl=0; 
....................  unsigned int32 Vin; 
....................  unsigned int32 Mid; 
....................  U16 t, t1, t2,tr; 
....................  unsigned int32 LSB_weight = 149;// нВ 
....................   
....................  //LSB_weight = 0,298023223876953125 мкВ = 298 нВ 
....................   
.................... //Sum = (r1<<16)+(r2<<8)+r3; 
....................   
....................  U8 dt = 2,CRC1=0xFF,CRC2=0xFF; 
....................   
....................    SMP = 1; // стробирование входных данных по cпадающему фронту 
09EC:  BSF    FC7.7
....................    CKE = 0;//необходимая полярность SCK 
09EE:  BCF    FC7.6
....................    CKP = 0; // необходимая полярность SCK 
09F0:  BCF    FC6.4
....................     
....................    setup_wdt(WDT_OFF); 
09F2:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
09F4:  MOVLW  80
09F6:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T2_DIV_BY_4); 
09F8:  MOVLW  85
09FA:  MOVWF  FCD
....................    setup_timer_2 ( T2_DIV_BY_4, 1, 1); 
09FC:  MOVLW  00
09FE:  IORLW  05
0A00:  MOVWF  FCA
0A02:  MOVLW  01
0A04:  MOVWF  FCB
....................    //setup_timer_3(T3_INTERNAL|T3_DIV_BY_4); 
....................    setup_comparator(NC_NC_NC_NC); 
0A06:  MOVLW  07
0A08:  MOVWF  FB4
0A0A:  MOVF   F92,W
0A0C:  MOVWF  F92
0A0E:  MOVLW  21
0A10:  MOVWF  00
0A12:  DECFSZ 00,F
0A14:  BRA    0A12
0A16:  MOVF   FB4,W
0A18:  BCF    FA1.6
....................    setup_vref(FALSE); 
0A1A:  CLRF   FB5
....................  
....................  setup_spi(spi_master | spi_l_to_h | SPI_CLK_T2); 
0A1C:  BCF    FC6.5
0A1E:  BCF    F94.5
0A20:  BSF    F94.4
0A22:  BCF    F94.3
0A24:  MOVLW  23
0A26:  MOVWF  FC6
0A28:  MOVLW  00
0A2A:  MOVWF  FC7
....................  
....................    TRA0 = 1;//на вход 
0A2C:  BSF    F92.0
....................    TRA1 = 1; 
0A2E:  BSF    F92.1
....................    TRA2 = 1; 
0A30:  BSF    F92.2
....................    TRA3 = 1; 
0A32:  BSF    F92.3
....................    TRA4 = 0; 
0A34:  BCF    F92.4
....................    TRA5 = 0;//вых 
0A36:  BCF    F92.5
....................    TRC3= 0; 
0A38:  BCF    F94.3
....................    TRC4=1; 
0A3A:  BSF    F94.4
....................    TRC6=0; 
0A3C:  BCF    F94.6
....................    TRC7=1; 
0A3E:  BSF    F94.7
....................      //xmit=PIN_C6,rcv=PIN_C7 
....................   
....................   DSYNC = 1; 
0A40:  BSF    F80.4
....................    
....................     
....................    //TRISC=0b11101111; 
....................    TRC5=0; 
0A42:  BCF    F94.5
....................    TRISD=0b00000000; 
0A44:  CLRF   F95
....................    TRISB=0b11110110;   //rb7-rb4 как входы 
0A46:  MOVLW  F6
0A48:  MOVWF  F93
....................    TRISE=0b00000000;   //E.0 - вых 
0A4A:  CLRF   F96
....................    CS = 1; 
0A4C:  BSF    F84.0
....................  
....................    LCDInit();  
0A4E:  GOTO   0102
....................     
....................   /*   
....................      LCDClear(); 
....................      LCDSetCursor(0x0); 
....................     LCDMsg("Reading data "); 
....................     LCDSetCursor(0x40); 
....................     LCDMsg("from EEPROM..."); 
....................      
....................     for (j=0;j<5;j++) 
....................           buf1[j]=read_eeprom (j); 
....................        crc1=CRC8(buf1,3); 
....................        crc2=buf1[3]; 
....................        if(crc1==crc2){     
....................      
....................       //delay_ms(500); 
....................       LCDMsg("OK"); 
....................       tmax=buf1[0]; 
....................       dt=buf1[1]; 
....................       hp=buf1[2];  
....................        }else { 
....................              LCDSetCursor(0x10); 
....................              LCDMsg("CRC error !"); 
....................              } 
....................      
....................     LCDSetCursor(0x50); 
....................     LCDMsg("CRC1="); 
....................     LCDPutU16(CRC1,3); 
....................     LCDMsg("CRC2="); 
....................     LCDPutU16(crc2,3);         
....................     delay_ms(1000); 
....................      
....................      Delay_ms(1000); 
....................      LCDClear(); 
....................      
....................     set_timer3(59285);  
....................     set_timer1(64910);  
....................     enable_interrupts(INT_TIMER1); 
....................     enable_interrupts(INT_TIMER3); 
....................     enable_interrupts(GLOBAL); 
....................   */ 
....................   // LCDMsg("CRC2=");  
....................    
....................   LCDWelcome(); 
0A52:  GOTO   01EC
....................  // LCDMsg("Ready!"); 
....................  
....................   reset=0; 
0A56:  BCF    F80.5
....................    delay_us(15); 
0A58:  MOVLW  31
0A5A:  MOVWF  00
0A5C:  DECFSZ 00,F
0A5E:  BRA    0A5C
0A60:  BRA    0A62
....................    reset=1; 
0A62:  BSF    F80.5
....................    Cs=1; 
0A64:  BSF    F84.0
....................    delay_ms(1); 
0A66:  MOVLW  01
0A68:  MOVWF  3A
0A6A:  CALL   0050
....................     
.................... // LCDClear(); 
....................   
....................    AdsInit(); 
0A6E:  GOTO   0250
....................   
....................    SelfCal(); 
0A72:  BRA    02CE
....................  
.................... /* 
....................     delay_us(100); 
....................     cs=0; 
....................     delay_us(20); 
....................    WrReg(SETUP,0b00011110);   
....................     delay_us(20); 
....................     cs=1; 
....................      
....................      
....................    delay_us(100); 
....................     cs=0; 
....................     delay_us(20); 
....................     WrReg(MUX,0x01); 
....................     delay_us(20); 
....................     cs=1; 
....................      
....................     delay_us(100); 
....................     cs=0; 
....................     delay_us(20); 
....................     WrReg(ACR,0x03);   
....................     delay_us(20); 
....................     cs=1; 
....................      
....................   */ 
....................      
....................    LCDclear(); 
0A74:  CALL   017E
....................     
....................     
....................    while(true){ 
....................     
.................... //--------------------- 1 датчик------------------- 
....................   LCDSetCursor(0x0C); 
0A78:  MOVLW  0C
0A7A:  MOVWF  2A
0A7C:  CALL   01E0
....................   LCDputCH('*'); 
0A80:  MOVLW  2A
0A82:  MOVWF  36
0A84:  CALL   01B0
....................   Mid = AdcChData(0x10); 
0A88:  MOVLW  10
0A8A:  MOVWF  28
0A8C:  RCALL  049C
0A8E:  MOVFF  03,18
0A92:  MOVFF  02,17
0A96:  MOVFF  01,16
0A9A:  MOVFF  00,15
....................   Vin = (Mid*LSB_weight)/(1000*powr(PGA)); 
0A9E:  MOVFF  18,38
0AA2:  MOVFF  17,37
0AA6:  MOVFF  16,36
0AAA:  MOVFF  15,35
0AAE:  MOVFF  24,3C
0AB2:  MOVFF  23,3B
0AB6:  MOVFF  22,3A
0ABA:  MOVFF  21,39
0ABE:  RCALL  04EE
0AC0:  MOVFF  03,2B
0AC4:  MOVFF  02,2A
0AC8:  MOVFF  01,29
0ACC:  MOVFF  00,28
0AD0:  MOVFF  04,2C
0AD4:  RCALL  0542
0AD6:  MOVFF  02,03
0ADA:  MOVFF  01,2C
0ADE:  MOVFF  02,2D
0AE2:  MOVLW  03
0AE4:  MOVWF  2F
0AE6:  MOVLW  E8
0AE8:  MOVWF  2E
0AEA:  MOVFF  02,31
0AEE:  MOVFF  01,30
0AF2:  RCALL  0564
0AF4:  MOVFF  02,03
0AF8:  MOVFF  01,2C
0AFC:  MOVFF  02,2D
0B00:  MOVFF  FEA,2F
0B04:  MOVFF  FE9,2E
0B08:  BCF    FD8.1
0B0A:  MOVFF  2B,46
0B0E:  MOVFF  2A,45
0B12:  MOVFF  29,44
0B16:  MOVFF  28,43
0B1A:  CLRF   4A
0B1C:  CLRF   49
0B1E:  MOVFF  02,48
0B22:  MOVFF  01,47
0B26:  RCALL  038E
0B28:  MOVFF  2F,FEA
0B2C:  MOVFF  2E,FE9
0B30:  MOVFF  03,14
0B34:  MOVFF  02,13
0B38:  MOVFF  01,12
0B3C:  MOVFF  00,11
....................   LCDSetCursor(0x00); 
0B40:  CLRF   2A
0B42:  CALL   01E0
....................   LCDMsg("CTP:"); 
0B46:  MOVLW  22
0B48:  MOVWF  FF6
0B4A:  MOVLW  00
0B4C:  MOVWF  FF7
0B4E:  CALL   01C0
....................   LCDSetCursor(4); 
0B52:  MOVLW  04
0B54:  MOVWF  2A
0B56:  CALL   01E0
....................   lcdPutU32(Vin,4); 
0B5A:  MOVFF  14,2B
0B5E:  MOVFF  13,2A
0B62:  MOVFF  12,29
0B66:  MOVFF  11,28
0B6A:  MOVLW  04
0B6C:  MOVWF  2C
0B6E:  RCALL  0582
....................   LCDMsg(" uV  "); 
0B70:  MOVLW  28
0B72:  MOVWF  FF6
0B74:  MOVLW  00
0B76:  MOVWF  FF7
0B78:  CALL   01C0
....................   Printf("%Lu\n",Vin); 
0B7C:  MOVLW  41
0B7E:  MOVWF  FE9
0B80:  MOVFF  14,2B
0B84:  MOVFF  13,2A
0B88:  MOVFF  12,29
0B8C:  MOVFF  11,28
0B90:  RCALL  090A
0B92:  MOVLW  0A
0B94:  BTFSS  F9E.4
0B96:  BRA    0B94
0B98:  MOVWF  FAD
.................... //------------------------------------------------ 
....................   //Printf("%u\n",1); 
....................   //Printf("B\n\r"); 
.................... //--------------------- 2 датчик------------------- 
....................    LCDSetCursor(0x4C); 
0B9A:  MOVLW  4C
0B9C:  MOVWF  2A
0B9E:  CALL   01E0
....................    LCDputCH('*'); 
0BA2:  MOVLW  2A
0BA4:  MOVWF  36
0BA6:  CALL   01B0
....................    Mid = AdcChData(0x32); 
0BAA:  MOVLW  32
0BAC:  MOVWF  28
0BAE:  RCALL  049C
0BB0:  MOVFF  03,18
0BB4:  MOVFF  02,17
0BB8:  MOVFF  01,16
0BBC:  MOVFF  00,15
....................    Vin = (Mid*LSB_weight)/(1000*powr(PGA));  
0BC0:  MOVFF  18,38
0BC4:  MOVFF  17,37
0BC8:  MOVFF  16,36
0BCC:  MOVFF  15,35
0BD0:  MOVFF  24,3C
0BD4:  MOVFF  23,3B
0BD8:  MOVFF  22,3A
0BDC:  MOVFF  21,39
0BE0:  RCALL  04EE
0BE2:  MOVFF  03,2B
0BE6:  MOVFF  02,2A
0BEA:  MOVFF  01,29
0BEE:  MOVFF  00,28
0BF2:  MOVFF  04,2C
0BF6:  RCALL  0542
0BF8:  MOVFF  02,03
0BFC:  MOVFF  01,2C
0C00:  MOVFF  02,2D
0C04:  MOVLW  03
0C06:  MOVWF  2F
0C08:  MOVLW  E8
0C0A:  MOVWF  2E
0C0C:  MOVFF  02,31
0C10:  MOVFF  01,30
0C14:  RCALL  0564
0C16:  MOVFF  02,03
0C1A:  MOVFF  01,2C
0C1E:  MOVFF  02,2D
0C22:  MOVFF  FEA,2F
0C26:  MOVFF  FE9,2E
0C2A:  BCF    FD8.1
0C2C:  MOVFF  2B,46
0C30:  MOVFF  2A,45
0C34:  MOVFF  29,44
0C38:  MOVFF  28,43
0C3C:  CLRF   4A
0C3E:  CLRF   49
0C40:  MOVFF  02,48
0C44:  MOVFF  01,47
0C48:  CALL   038E
0C4C:  MOVFF  2F,FEA
0C50:  MOVFF  2E,FE9
0C54:  MOVFF  03,14
0C58:  MOVFF  02,13
0C5C:  MOVFF  01,12
0C60:  MOVFF  00,11
....................    LCDSetCursor(0x40); 
0C64:  MOVLW  40
0C66:  MOVWF  2A
0C68:  CALL   01E0
....................    LCDMsg("C"); 
0C6C:  MOVLW  2E
0C6E:  MOVWF  FF6
0C70:  MOVLW  00
0C72:  MOVWF  FF7
0C74:  CALL   01C0
....................    LCDputCH(0xA8); 
0C78:  MOVLW  A8
0C7A:  MOVWF  36
0C7C:  CALL   01B0
....................    LCDMsg(" :"); 
0C80:  MOVLW  30
0C82:  MOVWF  FF6
0C84:  MOVLW  00
0C86:  MOVWF  FF7
0C88:  CALL   01C0
....................    lcdPutU32(Vin,4); 
0C8C:  MOVFF  14,2B
0C90:  MOVFF  13,2A
0C94:  MOVFF  12,29
0C98:  MOVFF  11,28
0C9C:  MOVLW  04
0C9E:  MOVWF  2C
0CA0:  RCALL  0582
....................    LCDMsg(" uV  "); 
0CA2:  MOVLW  34
0CA4:  MOVWF  FF6
0CA6:  MOVLW  00
0CA8:  MOVWF  FF7
0CAA:  CALL   01C0
....................    Printf("%Lu\n",Vin); 
0CAE:  MOVLW  41
0CB0:  MOVWF  FE9
0CB2:  MOVFF  14,2B
0CB6:  MOVFF  13,2A
0CBA:  MOVFF  12,29
0CBE:  MOVFF  11,28
0CC2:  RCALL  090A
0CC4:  MOVLW  0A
0CC6:  BTFSS  F9E.4
0CC8:  BRA    0CC6
0CCA:  MOVWF  FAD
.................... //------------------------------------------------   
....................    
.................... //--------------------- 3 датчик------------------- 
....................   LCDSetCursor(0x1C); 
0CCC:  MOVLW  1C
0CCE:  MOVWF  2A
0CD0:  CALL   01E0
....................   LCDputCH('*'); 
0CD4:  MOVLW  2A
0CD6:  MOVWF  36
0CD8:  CALL   01B0
....................   Mid = AdcChData(0x54); 
0CDC:  MOVLW  54
0CDE:  MOVWF  28
0CE0:  CALL   049C
0CE4:  MOVFF  03,18
0CE8:  MOVFF  02,17
0CEC:  MOVFF  01,16
0CF0:  MOVFF  00,15
....................   Vin = (Mid*LSB_weight)/(1000*powr(PGA));   
0CF4:  MOVFF  18,38
0CF8:  MOVFF  17,37
0CFC:  MOVFF  16,36
0D00:  MOVFF  15,35
0D04:  MOVFF  24,3C
0D08:  MOVFF  23,3B
0D0C:  MOVFF  22,3A
0D10:  MOVFF  21,39
0D14:  CALL   04EE
0D18:  MOVFF  03,2B
0D1C:  MOVFF  02,2A
0D20:  MOVFF  01,29
0D24:  MOVFF  00,28
0D28:  MOVFF  04,2C
0D2C:  RCALL  0542
0D2E:  MOVFF  02,03
0D32:  MOVFF  01,2C
0D36:  MOVFF  02,2D
0D3A:  MOVLW  03
0D3C:  MOVWF  2F
0D3E:  MOVLW  E8
0D40:  MOVWF  2E
0D42:  MOVFF  02,31
0D46:  MOVFF  01,30
0D4A:  RCALL  0564
0D4C:  MOVFF  02,03
0D50:  MOVFF  01,2C
0D54:  MOVFF  02,2D
0D58:  MOVFF  FEA,2F
0D5C:  MOVFF  FE9,2E
0D60:  BCF    FD8.1
0D62:  MOVFF  2B,46
0D66:  MOVFF  2A,45
0D6A:  MOVFF  29,44
0D6E:  MOVFF  28,43
0D72:  CLRF   4A
0D74:  CLRF   49
0D76:  MOVFF  02,48
0D7A:  MOVFF  01,47
0D7E:  CALL   038E
0D82:  MOVFF  2F,FEA
0D86:  MOVFF  2E,FE9
0D8A:  MOVFF  03,14
0D8E:  MOVFF  02,13
0D92:  MOVFF  01,12
0D96:  MOVFF  00,11
....................   LCDSetCursor(0x10); 
0D9A:  MOVLW  10
0D9C:  MOVWF  2A
0D9E:  CALL   01E0
....................    LCDputCH(0xA8); 
0DA2:  MOVLW  A8
0DA4:  MOVWF  36
0DA6:  CALL   01B0
....................   LCDMsg('E'); 
0DAA:  MOVLW  45
0DAC:  MOVWF  2C
0DAE:  CALL   01B8
....................   LCDMsg("P:"); 
0DB2:  MOVLW  3A
0DB4:  MOVWF  FF6
0DB6:  MOVLW  00
0DB8:  MOVWF  FF7
0DBA:  CALL   01C0
....................   lcdPutU32(Vin,4); 
0DBE:  MOVFF  14,2B
0DC2:  MOVFF  13,2A
0DC6:  MOVFF  12,29
0DCA:  MOVFF  11,28
0DCE:  MOVLW  04
0DD0:  MOVWF  2C
0DD2:  CALL   0582
....................   LCDMsg(" uV  "); 
0DD6:  MOVLW  3E
0DD8:  MOVWF  FF6
0DDA:  MOVLW  00
0DDC:  MOVWF  FF7
0DDE:  CALL   01C0
....................   Printf("%Lu\n",Vin); 
0DE2:  MOVLW  41
0DE4:  MOVWF  FE9
0DE6:  MOVFF  14,2B
0DEA:  MOVFF  13,2A
0DEE:  MOVFF  12,29
0DF2:  MOVFF  11,28
0DF6:  RCALL  090A
0DF8:  MOVLW  0A
0DFA:  BTFSS  F9E.4
0DFC:  BRA    0DFA
0DFE:  MOVWF  FAD
.................... //------------------------------------------------  
....................    
....................    
.................... //--------------------- 4 датчик-------------------  
....................   LCDSetCursor(0x5C); 
0E00:  MOVLW  5C
0E02:  MOVWF  2A
0E04:  CALL   01E0
....................   LCDputCH('*'); 
0E08:  MOVLW  2A
0E0A:  MOVWF  36
0E0C:  CALL   01B0
....................   Mid = AdcChData(0x76); 
0E10:  MOVLW  76
0E12:  MOVWF  28
0E14:  CALL   049C
0E18:  MOVFF  03,18
0E1C:  MOVFF  02,17
0E20:  MOVFF  01,16
0E24:  MOVFF  00,15
....................   Vin = (Mid*LSB_weight)/(1000*powr(PGA)); 
0E28:  MOVFF  18,38
0E2C:  MOVFF  17,37
0E30:  MOVFF  16,36
0E34:  MOVFF  15,35
0E38:  MOVFF  24,3C
0E3C:  MOVFF  23,3B
0E40:  MOVFF  22,3A
0E44:  MOVFF  21,39
0E48:  CALL   04EE
0E4C:  MOVFF  03,2B
0E50:  MOVFF  02,2A
0E54:  MOVFF  01,29
0E58:  MOVFF  00,28
0E5C:  MOVFF  04,2C
0E60:  CALL   0542
0E64:  MOVFF  02,03
0E68:  MOVFF  01,2C
0E6C:  MOVFF  02,2D
0E70:  MOVLW  03
0E72:  MOVWF  2F
0E74:  MOVLW  E8
0E76:  MOVWF  2E
0E78:  MOVFF  02,31
0E7C:  MOVFF  01,30
0E80:  CALL   0564
0E84:  MOVFF  02,03
0E88:  MOVFF  01,2C
0E8C:  MOVFF  02,2D
0E90:  MOVFF  FEA,2F
0E94:  MOVFF  FE9,2E
0E98:  BCF    FD8.1
0E9A:  MOVFF  2B,46
0E9E:  MOVFF  2A,45
0EA2:  MOVFF  29,44
0EA6:  MOVFF  28,43
0EAA:  CLRF   4A
0EAC:  CLRF   49
0EAE:  MOVFF  02,48
0EB2:  MOVFF  01,47
0EB6:  CALL   038E
0EBA:  MOVFF  2F,FEA
0EBE:  MOVFF  2E,FE9
0EC2:  MOVFF  03,14
0EC6:  MOVFF  02,13
0ECA:  MOVFF  01,12
0ECE:  MOVFF  00,11
....................   LCDSetCursor(0x50); 
0ED2:  MOVLW  50
0ED4:  MOVWF  2A
0ED6:  CALL   01E0
....................   LCDMsg("CO"); 
0EDA:  MOVLW  44
0EDC:  MOVWF  FF6
0EDE:  MOVLW  00
0EE0:  MOVWF  FF7
0EE2:  CALL   01C0
....................   LCDputCH(0xA7); 
0EE6:  MOVLW  A7
0EE8:  MOVWF  36
0EEA:  CALL   01B0
....................   LCDMsg(":"); 
0EEE:  MOVLW  48
0EF0:  MOVWF  FF6
0EF2:  MOVLW  00
0EF4:  MOVWF  FF7
0EF6:  CALL   01C0
....................   lcdPutU32(Vin,4); 
0EFA:  MOVFF  14,2B
0EFE:  MOVFF  13,2A
0F02:  MOVFF  12,29
0F06:  MOVFF  11,28
0F0A:  MOVLW  04
0F0C:  MOVWF  2C
0F0E:  CALL   0582
....................   LCDMsg(" uV  "); 
0F12:  MOVLW  4A
0F14:  MOVWF  FF6
0F16:  MOVLW  00
0F18:  MOVWF  FF7
0F1A:  CALL   01C0
....................   //LCDSetCursor(7); 
....................   Printf("%Lu\n",Vin); 
0F1E:  MOVLW  41
0F20:  MOVWF  FE9
0F22:  MOVFF  14,2B
0F26:  MOVFF  13,2A
0F2A:  MOVFF  12,29
0F2E:  MOVFF  11,28
0F32:  RCALL  090A
0F34:  MOVLW  0A
0F36:  BTFSS  F9E.4
0F38:  BRA    0F36
0F3A:  MOVWF  FAD
.................... //------------------------------------------------  
....................  
....................  
....................   /* 
....................   PbFl1=Pbfl; // для синхронности изменения MenuItem и PbFl 
....................    switch (MenuItemNum){ 
....................       case 0: 
....................       if(Pbfl1){ 
....................          Pbfl=0; 
....................          delay_ms(1); 
....................          LCDClear(); 
....................       } 
....................    //нулевой пункт меню 
....................   //****************Первый датчик****************** 
....................    ADC_value=ADC_read(0); 
....................    LCDSetCursor(0x0);  
....................    t = ADC_value*2; 
....................    t1 = t/10; 
....................    t2 = t - t1*10; 
....................    LCDMsg("t1="); 
....................    LCDPutU16(t1,3);//знака 
....................    LCDMsg('.'); 
....................    LCDPutU16(t2,1); 
....................    LCDPutCh(0xEF); 
....................    LCDMsg("C   HP");  
.................... //****************второй датчик****************** 
....................    ADC_value=ADC_read(1); // установка порта АЦП 
....................    LCDSetCursor(0x40);  
....................    t = ADC_value*2; 
....................    tr=t; 
....................    t1 = t/10; 
....................    t2 = t - t1*10; 
....................    LCDMsg("t2="); 
....................    LCDPutU16(t1,3); 
....................    LCDMsg('.'); 
....................    LCDPutU16(t2,1); 
....................    LCDPutCh(0xEF); 
....................    LCDMsg("C  "); 
....................    LCDPutU16(hp,3); 
....................    LCDMsg('%'); 
....................     
....................    //****************третий датчик****************** 
....................    ADC_value=ADC_read(2); 
....................    LCDSetCursor(0x10);  
....................    t = ADC_value*2; 
....................    t1 = t/10; 
....................    t2 = t - t1*10; 
....................    LCDMsg("t3="); 
....................    LCDPutU16(t1,3); 
....................    LCDMsg('.'); 
....................    LCDPutU16(t2,1); 
....................    LCDPutCh(0xEF); 
....................    LCDMsg("C  "); 
....................    LCDMsg(" dt"); 
....................     
....................    //********************************** 
....................    LCDSetCursor(0x50);  
....................    LCDMsg("tmax="); 
....................    LCDPutU16(tmax,3);//знака.разряда 
....................    LCDPutCh(0xEF); 
....................    LCDMsg("C  "); 
....................  //  LCDMsg("dt="); 
....................    LCDPutU16(dt,2);//знака.разряда 
....................    LCDPutCh(0xEF); 
....................    LCDMsg('C'); 
....................     
....................   //**************флаг максимальн.температуры 
....................    if (tr>=tmax*10){ 
....................       tmaxfl = 0; 
....................       dtfl=0; 
....................       }else  tmaxfl=1;      
....................          if(tr<=(tmax*10-dt*10)) dtfl = 1; 
....................           
....................       break; 
....................       case 1: 
....................       if(Pbfl1){ 
....................          Pbfl=0; 
....................          LCDClear(); 
....................       } 
....................          LCDSetCursor(0x0); 
....................          LCDMsg("tmax="); 
....................          LCDPutU16(tmax,3); 
....................          LCDPutCh(0xEF); 
....................          LCDMsg('C'); 
....................           
....................           //увеличение tmax 
....................   if (b_push[1]){ 
....................        b_push[1]=0; 
....................         tmax++;  
....................   } 
....................   //уменьшение tmax 
....................   if (b_push[3]){ 
....................        b_push[3]=0; 
....................         tmax--;  
....................   } 
....................   if(tmax<1)tmax = 1; 
....................   if(tmax>150)tmax = 150; 
....................    
....................       break; 
....................       case 2: 
....................        if(Pbfl1){ 
....................          Pbfl=0; 
....................          LCDClear(); 
....................       } 
....................          LCDSetCursor(0x0); 
....................          LCDMsg("dt="); 
....................          LCDPutU16(dt,2); 
....................          LCDPutCh(0xEF); 
....................          LCDMsg('C'); 
....................           
....................            //увеличение dt 
....................   if (b_push[1]){ 
....................        b_push[1]=0; 
....................         dt++;  
....................   } 
....................   //уменьшение dt 
....................   if (b_push[3]){ 
....................        b_push[3]=0; 
....................         dt--; 
....................   } 
....................   if(dt<1)dt = 1; 
....................   if(dt>50)dt = 50; 
....................           
....................       break; 
....................       case 3: 
....................       if(Pbfl1){ 
....................          Pbfl=0; 
....................          LCDClear(); 
....................       } 
....................          LCDSetCursor(0x0); 
....................          LCDMsg("HP="); 
....................          LCDPutU16(hp,3); 
....................          LCDMsg('%'); 
....................           
....................        //увеличение Hp 
....................   if (b_push[1]){ 
....................        b_push[1]=0; 
....................         hp++;  
....................   } 
....................   //уменьшение Hp 
....................   if (b_push[3]){ 
....................        b_push[3]=0; 
....................         hp--; 
....................         
....................   } 
....................    if(hp<1)hp = 1; 
....................   if(hp>100)hp = 100; 
....................           
....................        break; 
....................        case 4: 
....................       if(Pbfl1){ 
....................          Pbfl=0; 
....................          LCDClear(); 
....................       } 
....................      if (b_push[1]){ 
....................        b_push[1]=0; 
....................         henfl=1;//Heater en ; 
....................         
....................   } 
....................   //уменьшение Hp 
....................   if (b_push[3]){ 
....................        b_push[3]=0; 
....................        henfl=0;//Heater Dis ; 
....................            
....................   }   
....................       LCDSetCursor(0x0); 
....................      if(henfl)  LCDMsg("Heater ON "); else LCDMsg("Heater OFF"); 
....................           
....................       break; 
....................       case 5: 
....................         if(Pbfl1){ 
....................            Pbfl=0; 
....................            LCDClear();  
....................          LCDSetCursor(0x0); 
....................          LCDMsg("Write current ");  
....................          LCDSetCursor(0x40); 
....................          LCDMsg("parameters to   "); 
....................          LCDSetCursor(0x10); 
....................          LCDMsg("EEPROM ?");   
....................          LCDSetCursor(0x50); 
....................          LCDMsg(" NO  "); 
....................        } 
....................               
....................      if (b_push[1]){ 
....................        b_push[1]=0; 
....................        EEWrFl=1; 
....................        LCDSetCursor(0x50); 
....................        LCDMsg(" YES "); 
....................       } 
....................     if (b_push[3]){ 
....................        b_push[3]=0; 
....................        EEWrFl=0; 
....................        LCDSetCursor(0x50); 
....................        LCDMsg(" NO  "); 
....................     }        
....................       break; 
....................       case 6: 
....................       if(Pbfl1){ 
....................            Pbfl=0; 
....................         // LCDClear(); 
....................       } 
....................          if(EEWrFl){ 
....................            LCDClear(); 
....................            LCDSetCursor(0x0); 
....................            LCDMsg("Writing data  "); 
....................            LCDSetCursor(0x40); 
....................            LCDMsg("to EEPROM... "); 
....................            buf1[0]=tmax; 
....................            buf1[1]=dt; 
....................            buf1[2]=hp; 
....................            buf1[3]=CRC8(buf1,3);//Вычисление контрольной суммы 
....................            disable_interrupts(GLOBAL); 
....................            //устанавливать адрес последней ячейки EEPROM на неиспользуемую область!!! 
....................             for (j=0;j<5;++j) 
....................               write_eeprom (j, buf1[j]); 
....................               enable_interrupts(GLOBAL); 
....................            EEWrFl=0; 
....................             
....................            //delay_ms(500); 
....................            //LCDClear(); 
....................            LCDMsg("OK" ); 
....................            LCDSetCursor(0x10); 
....................            LCDMsg(" CRC=" ); 
....................            LCDPutU16(buf1[3],3); 
....................            delay_ms(500); 
....................          } 
....................           MenuItemNum=0; 
....................           PbFl=1; 
....................           
....................          break; 
....................       
....................       default: 
....................       MenuItemNum=0;    
....................           
....................     } 
.................... */ 
....................   } 
0F3C:  BRA    0A78
....................  
.................... } 
0F3E:  SLEEP 

Configuration Fuses:
   Word  1: 8600   H4 NOFCMEN IESO
   Word  2: 0E03   NOPUT BROWNOUT BORV45 NOWDT WDT128
   Word  3: 8300   CCP2C1 PBADEN MCLR
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
