CCS PCH C Compiler, Version 5.015, 5967               21-май-17 14:23

               Filename:   E:\work\Projects\ponkin\PICC\my prj\XYZ magnitometer\Актуальная Версия 2.1_5.019\V2.1.lst

               ROM used:   11988 bytes (37%)
                           Largest free fragment is 20776
               RAM used:   165 (5%) at main() level
                           226 (6%) worst case
               Stack used: 11 locations (7 in main + 4 for interrupts)
               Stack size: 31

*
0000:  GOTO   26F8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.4
004A:  GOTO   0054
004E:  BTFSC  FF2.1
0050:  GOTO   027E
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   03BE
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVF   04,W
0098:  MOVFF  06,FE0
009C:  MOVFF  05,FD8
00A0:  RETFIE 0
....................  
.................... /******************************************************/ 
.................... /* Software V2.3 for magnetic induction's tester V2.1 */ 
.................... /******************************************************/ 
.................... // последние изменения 15.03.17 
....................  
.................... #include <V2.1.h> 
.................... #include <18F25K80.h> 
.................... //////////// Standard Header file for the PIC18F25K80 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F25K80 
00A2:  DATA 20,20
00A4:  DATA 20,C8
00A6:  DATA E7,EC
00A8:  DATA E5,F0
00AA:  DATA E8,F2
00AC:  DATA E5,EB
00AE:  DATA FC,00
00B0:  DATA 20,20
00B2:  DATA 20,EC
00B4:  DATA E0,E3
00B6:  DATA ED,E8
00B8:  DATA F2,ED
00BA:  DATA EE,E9
00BC:  DATA 00,00
00BE:  DATA 20,E8
00C0:  DATA ED,E4
00C2:  DATA F3,EA
00C4:  DATA F6,E8
00C6:  DATA E8,2E
00C8:  DATA 20,76
00CA:  DATA 32,2E
00CC:  DATA 34,20
00CE:  DATA 00,00
00D0:  DATA 20,20
00D2:  DATA 20,20
00D4:  DATA 20,20
00D6:  DATA 20,20
00D8:  DATA 20,20
00DA:  DATA 20,20
00DC:  DATA 20,20
00DE:  DATA 20,20
00E0:  DATA 00,00
00E2:  DATA 20,20
00E4:  DATA 20,20
00E6:  DATA C4,C0
00E8:  DATA D2,D7
00EA:  DATA C8,CA
00EC:  DATA 20,20
00EE:  DATA 20,20
00F0:  DATA 20,00
00F2:  DATA 20,20
00F4:  DATA 20,20
00F6:  DATA 20,20
00F8:  DATA CD,C5
00FA:  DATA 20,20
00FC:  DATA 20,20
00FE:  DATA 20,20
0100:  DATA 20,00
0102:  DATA 20,20
0104:  DATA 20,CF
0106:  DATA CE,C4
0108:  DATA CA,CB
010A:  DATA DE,D7
010C:  DATA C5,CD
010E:  DATA 21,20
0110:  DATA 20,00
0112:  DATA 20,20
0114:  DATA 20,20
0116:  DATA 20,20
0118:  DATA 20,20
011A:  DATA 20,20
011C:  DATA 20,20
011E:  DATA 20,20
0120:  DATA 20,20
0122:  DATA 00,00
0124:  DATA 20,D3
0126:  DATA F1,F2
0128:  DATA E0,ED
012A:  DATA EE,E2
012C:  DATA EA,E0
012E:  DATA 20,ED
0130:  DATA F3,EB
0132:  DATA FF,20
0134:  DATA 00,00
0136:  DATA 42,78
0138:  DATA 20,3D
013A:  DATA 20,00
013C:  DATA 20,C3
013E:  DATA F1,2E
0140:  DATA 20,00
0142:  DATA 42,79
0144:  DATA 20,3D
0146:  DATA 20,00
0148:  DATA 20,C3
014A:  DATA F1,2E
014C:  DATA 20,00
014E:  DATA 42,7A
0150:  DATA 20,3D
0152:  DATA 20,00
0154:  DATA 20,C3
0156:  DATA F1,2E
0158:  DATA 20,00
015A:  DATA 20,D3
015C:  DATA F1,F2
015E:  DATA E0,ED
0160:  DATA EE,E2
0162:  DATA EA,E0
0164:  DATA 20,ED
0166:  DATA F3,EB
0168:  DATA FF,20
016A:  DATA 00,00
016C:  DATA 20,42
016E:  DATA 78,20
0170:  DATA 3D,20
0172:  DATA 00,00
0174:  DATA 20,C3
0176:  DATA F1,2E
0178:  DATA 20,00
017A:  DATA 20,42
017C:  DATA 79,20
017E:  DATA 3D,20
0180:  DATA 00,00
0182:  DATA 20,C3
0184:  DATA F1,2E
0186:  DATA 20,00
0188:  DATA 20,42
018A:  DATA 7A,20
018C:  DATA 3D,20
018E:  DATA 00,00
0190:  DATA 20,C3
0192:  DATA F1,2E
0194:  DATA 20,00
*
03DA:  DATA CE,C1
03DC:  DATA CD,C0
03DE:  DATA D0,D3
03E0:  DATA C6,C5
03E2:  DATA CD,20
03E4:  DATA C4,C0
03E6:  DATA D2,D7
03E8:  DATA C8,CA
03EA:  DATA 00,00
03EC:  DATA 20,20
03EE:  DATA 20,20
03F0:  DATA 20,20
03F2:  DATA D2,E8
03F4:  DATA EF,3A
03F6:  DATA 20,20
03F8:  DATA 20,20
03FA:  DATA 20,20
03FC:  DATA 00,00
03FE:  DATA 20,20
0400:  DATA 42,6D
0402:  DATA 61,78
0404:  DATA 20,3D
0406:  DATA 20,31
0408:  DATA 2E,33
040A:  DATA 20,6B
040C:  DATA 47,53
040E:  DATA 20,20
0410:  DATA 20,00
0412:  DATA 20,42
0414:  DATA 6D,61
0416:  DATA 78,20
0418:  DATA 3D,20
041A:  DATA 38,2E
041C:  DATA 31,20
041E:  DATA 47,53
0420:  DATA 20,20
0422:  DATA 20,20
0424:  DATA 00,00
0426:  DATA 20,20
0428:  DATA 20,CE
042A:  DATA F8,E8
042C:  DATA E1,EA
042E:  DATA E0,20
0430:  DATA 49,44
0432:  DATA 20,20
0434:  DATA 20,20
0436:  DATA 00,00
0438:  DATA C4,E0
043A:  DATA F2,F7
043C:  DATA E8,EA
043E:  DATA 20,4E
0440:  DATA 3A,20
0442:  DATA 20,00
0444:  DATA CA,EE
0446:  DATA FD,F4
0448:  DATA F4,E8
044A:  DATA F6,E8
044C:  DATA E5,ED
044E:  DATA F2,FB
0450:  DATA 3A,00
0452:  DATA 4B,78
0454:  DATA 20,3D
0456:  DATA 20,00
0458:  DATA 4B,79
045A:  DATA 20,3D
045C:  DATA 20,00
045E:  DATA 4B,7A
0460:  DATA 20,3D
0462:  DATA 20,00
0464:  DATA 20,72
0466:  DATA 00,00
0468:  DATA 20,20
046A:  DATA 31,2C
046C:  DATA 33,20
046E:  DATA 6B,47
0470:  DATA 73,20
0472:  DATA 20,00
0474:  DATA 20,72
0476:  DATA 00,00
0478:  DATA 20,20
047A:  DATA 20,38
047C:  DATA 2C,31
047E:  DATA 20,47
0480:  DATA 73,20
0482:  DATA 00,00
0484:  DATA 20,20
0486:  DATA 20,20
0488:  DATA 20,20
048A:  DATA 20,20
048C:  DATA 20,20
048E:  DATA 20,20
0490:  DATA 20,2A
0492:  DATA 00,00
0494:  DATA 6F,6B
0496:  DATA 0A,0D
0498:  DATA 00,00
049A:  DATA 69,64
049C:  DATA 3D,00
049E:  DATA 63,6D
04A0:  DATA 64,20
04A2:  DATA 65,72
04A4:  DATA 72,6F
04A6:  DATA 72,0A
04A8:  DATA 0D,00
04AA:  DATA 65,72
04AC:  DATA 72,20
04AE:  DATA 70,31
04B0:  DATA 0A,0D
04B2:  DATA 00,00
04B4:  DATA 65,72
04B6:  DATA 72,20
04B8:  DATA 70,32
04BA:  DATA 0A,0D
04BC:  DATA 00,00
04BE:  DATA 65,72
04C0:  DATA 72,20
04C2:  DATA 70,33
04C4:  DATA 0A,0D
04C6:  DATA 00,00
04C8:  DATA 65,72
04CA:  DATA 72,20
04CC:  DATA 70,34
04CE:  DATA 0A,0D
04D0:  DATA 00,00
04D2:  DATA 20,C7
04D4:  DATA E0,EF
04D6:  DATA E8,F1
04D8:  DATA FC,20
04DA:  DATA E2,20
04DC:  DATA CF,C7
04DE:  DATA D3,2E
04E0:  DATA 2E,2E
04E2:  DATA 00,00
04E4:  DATA 65,72
04E6:  DATA 72,20
04E8:  DATA 70,0A
04EA:  DATA 0D,00
04EC:  DATA 20,C7
04EE:  DATA E0,EF
04F0:  DATA E8,F1
04F2:  DATA FC,20
04F4:  DATA E2,20
04F6:  DATA CF,C7
04F8:  DATA D3,2E
04FA:  DATA 2E,2E
04FC:  DATA 00,00
04FE:  DATA 20,20
0500:  DATA 20,20
0502:  DATA 20,20
0504:  DATA 20,20
0506:  DATA 20,20
0508:  DATA 20,20
050A:  DATA 20,20
050C:  DATA 00,00
*
0674:  TBLRD*+
0676:  MOVF   FF5,F
0678:  BZ    0692
067A:  MOVFF  FF6,BE
067E:  MOVFF  FF7,BF
0682:  MOVFF  FF5,C0
0686:  BRA    066A
0688:  MOVFF  BE,FF6
068C:  MOVFF  BF,FF7
0690:  BRA    0674
0692:  RETURN 0
*
0BF8:  BTFSC  FD8.1
0BFA:  BRA    0C02
0BFC:  CLRF   FEA
0BFE:  MOVLW  D7
0C00:  MOVWF  FE9
0C02:  CLRF   00
0C04:  CLRF   01
0C06:  CLRF   02
0C08:  CLRF   03
0C0A:  CLRF   xD7
0C0C:  CLRF   xD8
0C0E:  CLRF   xD9
0C10:  CLRF   xDA
0C12:  MOVF   xD6,W
0C14:  IORWF  xD5,W
0C16:  IORWF  xD4,W
0C18:  IORWF  xD3,W
0C1A:  BZ    0C74
0C1C:  MOVLW  20
0C1E:  MOVWF  xDB
0C20:  BCF    FD8.0
0C22:  RLCF   xCF,F
0C24:  RLCF   xD0,F
0C26:  RLCF   xD1,F
0C28:  RLCF   xD2,F
0C2A:  RLCF   xD7,F
0C2C:  RLCF   xD8,F
0C2E:  RLCF   xD9,F
0C30:  RLCF   xDA,F
0C32:  MOVF   xD6,W
0C34:  SUBWF  xDA,W
0C36:  BNZ   0C48
0C38:  MOVF   xD5,W
0C3A:  SUBWF  xD9,W
0C3C:  BNZ   0C48
0C3E:  MOVF   xD4,W
0C40:  SUBWF  xD8,W
0C42:  BNZ   0C48
0C44:  MOVF   xD3,W
0C46:  SUBWF  xD7,W
0C48:  BNC   0C68
0C4A:  MOVF   xD3,W
0C4C:  SUBWF  xD7,F
0C4E:  MOVF   xD4,W
0C50:  BTFSS  FD8.0
0C52:  INCFSZ xD4,W
0C54:  SUBWF  xD8,F
0C56:  MOVF   xD5,W
0C58:  BTFSS  FD8.0
0C5A:  INCFSZ xD5,W
0C5C:  SUBWF  xD9,F
0C5E:  MOVF   xD6,W
0C60:  BTFSS  FD8.0
0C62:  INCFSZ xD6,W
0C64:  SUBWF  xDA,F
0C66:  BSF    FD8.0
0C68:  RLCF   00,F
0C6A:  RLCF   01,F
0C6C:  RLCF   02,F
0C6E:  RLCF   03,F
0C70:  DECFSZ xDB,F
0C72:  BRA    0C20
0C74:  MOVFF  D7,FEF
0C78:  MOVFF  D8,FEC
0C7C:  MOVFF  D9,FEC
0C80:  MOVFF  DA,FEC
0C84:  RETURN 0
0C86:  CLRF   xD7
0C88:  CLRF   xD8
0C8A:  MOVLW  01
0C8C:  MOVWF  xD9
0C8E:  CLRF   FDA
0C90:  CLRF   FD9
0C92:  CLRF   xDC
0C94:  MOVLW  CF
0C96:  MOVWF  xDB
0C98:  CLRF   FEA
0C9A:  MOVLW  D3
0C9C:  MOVWF  FE9
0C9E:  MOVFF  DC,FE2
0CA2:  MOVFF  DB,FE1
0CA6:  MOVFF  D9,DA
0CAA:  BCF    FD8.0
0CAC:  MOVF   FE5,W
0CAE:  MULWF  FEE
0CB0:  MOVF   FF3,W
0CB2:  ADDWFC xD7,F
0CB4:  MOVF   FF4,W
0CB6:  ADDWFC xD8,F
0CB8:  DECFSZ xDA,F
0CBA:  BRA    0CAA
0CBC:  MOVFF  D7,FDE
0CC0:  MOVFF  D8,D7
0CC4:  CLRF   xD8
0CC6:  BTFSC  FD8.0
0CC8:  INCF   xD8,F
0CCA:  INCF   xDB,F
0CCC:  BTFSC  FD8.2
0CCE:  INCF   xDC,F
0CD0:  INCF   xD9,F
0CD2:  MOVF   xD9,W
0CD4:  SUBLW  05
0CD6:  BNZ   0C98
0CD8:  RETURN 0
*
0EE0:  MOVF   xC8,W
0EE2:  BTFSC  FD8.2
0EE4:  BRA    0FC8
0EE6:  MOVWF  00
0EE8:  MOVF   xCC,W
0EEA:  BTFSC  FD8.2
0EEC:  BRA    0FC8
0EEE:  ADDWF  00,F
0EF0:  BNC   0EFA
0EF2:  MOVLW  81
0EF4:  ADDWF  00,F
0EF6:  BC    0FC8
0EF8:  BRA    0F02
0EFA:  MOVLW  7F
0EFC:  SUBWF  00,F
0EFE:  BNC   0FC8
0F00:  BZ    0FC8
0F02:  MOVFF  C9,D0
0F06:  MOVF   xCD,W
0F08:  XORWF  xD0,F
0F0A:  BSF    xC9.7
0F0C:  BSF    xCD.7
0F0E:  MOVF   xCB,W
0F10:  MULWF  xCF
0F12:  MOVFF  FF4,D2
0F16:  MOVF   xCA,W
0F18:  MULWF  xCE
0F1A:  MOVFF  FF4,03
0F1E:  MOVFF  FF3,D1
0F22:  MULWF  xCF
0F24:  MOVF   FF3,W
0F26:  ADDWF  xD2,F
0F28:  MOVF   FF4,W
0F2A:  ADDWFC xD1,F
0F2C:  MOVLW  00
0F2E:  ADDWFC 03,F
0F30:  MOVF   xCB,W
0F32:  MULWF  xCE
0F34:  MOVF   FF3,W
0F36:  ADDWF  xD2,F
0F38:  MOVF   FF4,W
0F3A:  ADDWFC xD1,F
0F3C:  MOVLW  00
0F3E:  CLRF   02
0F40:  ADDWFC 03,F
0F42:  ADDWFC 02,F
0F44:  MOVF   xC9,W
0F46:  MULWF  xCF
0F48:  MOVF   FF3,W
0F4A:  ADDWF  xD1,F
0F4C:  MOVF   FF4,W
0F4E:  ADDWFC 03,F
0F50:  MOVLW  00
0F52:  ADDWFC 02,F
0F54:  MOVF   xC9,W
0F56:  MULWF  xCE
0F58:  MOVF   FF3,W
0F5A:  ADDWF  03,F
0F5C:  MOVF   FF4,W
0F5E:  ADDWFC 02,F
0F60:  MOVLW  00
0F62:  CLRF   01
0F64:  ADDWFC 01,F
0F66:  MOVF   xCB,W
0F68:  MULWF  xCD
0F6A:  MOVF   FF3,W
0F6C:  ADDWF  xD1,F
0F6E:  MOVF   FF4,W
0F70:  ADDWFC 03,F
0F72:  MOVLW  00
0F74:  ADDWFC 02,F
0F76:  ADDWFC 01,F
0F78:  MOVF   xCA,W
0F7A:  MULWF  xCD
0F7C:  MOVF   FF3,W
0F7E:  ADDWF  03,F
0F80:  MOVF   FF4,W
0F82:  ADDWFC 02,F
0F84:  MOVLW  00
0F86:  ADDWFC 01,F
0F88:  MOVF   xC9,W
0F8A:  MULWF  xCD
0F8C:  MOVF   FF3,W
0F8E:  ADDWF  02,F
0F90:  MOVF   FF4,W
0F92:  ADDWFC 01,F
0F94:  INCF   00,F
0F96:  BTFSC  01.7
0F98:  BRA    0FA4
0F9A:  RLCF   xD1,F
0F9C:  RLCF   03,F
0F9E:  RLCF   02,F
0FA0:  RLCF   01,F
0FA2:  DECF   00,F
0FA4:  MOVLW  00
0FA6:  BTFSS  xD1.7
0FA8:  BRA    0FBE
0FAA:  INCF   03,F
0FAC:  ADDWFC 02,F
0FAE:  ADDWFC 01,F
0FB0:  MOVF   01,W
0FB2:  BNZ   0FBE
0FB4:  MOVF   02,W
0FB6:  BNZ   0FBE
0FB8:  MOVF   03,W
0FBA:  BNZ   0FBE
0FBC:  INCF   00,F
0FBE:  BTFSC  xD0.7
0FC0:  BSF    01.7
0FC2:  BTFSS  xD0.7
0FC4:  BCF    01.7
0FC6:  BRA    0FD0
0FC8:  CLRF   00
0FCA:  CLRF   01
0FCC:  CLRF   02
0FCE:  CLRF   03
0FD0:  RETURN 0
0FD2:  MOVF   xA2,W
0FD4:  SUBLW  B6
0FD6:  MOVWF  xA2
0FD8:  CLRF   03
0FDA:  MOVFF  A3,A6
0FDE:  BSF    xA3.7
0FE0:  BCF    FD8.0
0FE2:  RRCF   xA3,F
0FE4:  RRCF   xA4,F
0FE6:  RRCF   xA5,F
0FE8:  RRCF   03,F
0FEA:  RRCF   02,F
0FEC:  RRCF   01,F
0FEE:  RRCF   00,F
0FF0:  DECFSZ xA2,F
0FF2:  BRA    0FE0
0FF4:  BTFSS  xA6.7
0FF6:  BRA    100E
0FF8:  COMF   00,F
0FFA:  COMF   01,F
0FFC:  COMF   02,F
0FFE:  COMF   03,F
1000:  INCF   00,F
1002:  BTFSC  FD8.2
1004:  INCF   01,F
1006:  BTFSC  FD8.2
1008:  INCF   02,F
100A:  BTFSC  FD8.2
100C:  INCF   03,F
100E:  RETURN 0
*
1470:  MOVLW  8E
1472:  MOVWF  00
1474:  MOVFF  C9,01
1478:  MOVFF  C8,02
147C:  CLRF   03
147E:  BTFSS  xC9.7
1480:  BRA    148C
1482:  COMF   01,F
1484:  COMF   02,F
1486:  INCF   02,F
1488:  BNZ   148C
148A:  INCF   01,F
148C:  MOVF   01,F
148E:  BNZ   14A2
1490:  MOVFF  02,01
1494:  CLRF   02
1496:  MOVLW  08
1498:  SUBWF  00,F
149A:  MOVF   01,F
149C:  BNZ   14A2
149E:  CLRF   00
14A0:  BRA    14B6
14A2:  BCF    FD8.0
14A4:  BTFSC  01.7
14A6:  BRA    14B0
14A8:  RLCF   02,F
14AA:  RLCF   01,F
14AC:  DECF   00,F
14AE:  BRA    14A2
14B0:  BTFSC  xC9.7
14B2:  BRA    14B6
14B4:  BCF    01.7
14B6:  GOTO   1506 (RETURN)
*
1578:  MOVLW  8E
157A:  MOVWF  00
157C:  MOVF   xBE,W
157E:  SUBWF  00,F
1580:  MOVFF  BF,02
1584:  MOVFF  C0,01
1588:  BSF    02.7
158A:  MOVF   00,F
158C:  BZ    15A0
158E:  BCF    FD8.0
1590:  MOVF   02,F
1592:  BNZ   1598
1594:  MOVF   01,F
1596:  BZ    15A0
1598:  RRCF   02,F
159A:  RRCF   01,F
159C:  DECFSZ 00,F
159E:  BRA    158E
15A0:  BTFSS  xBF.7
15A2:  BRA    15AE
15A4:  COMF   01,F
15A6:  COMF   02,F
15A8:  INCF   01,F
15AA:  BTFSC  FD8.2
15AC:  INCF   02,F
15AE:  RETURN 0
15B0:  MOVFF  FEA,C6
15B4:  MOVFF  FE9,C5
15B8:  BTFSS  xBF.7
15BA:  BRA    15CC
15BC:  BSF    xC5.7
15BE:  BTFSS  xC5.4
15C0:  INCF   xC5,F
15C2:  COMF   xBE,F
15C4:  COMF   xBF,F
15C6:  INCF   xBE,F
15C8:  BTFSC  FD8.2
15CA:  INCF   xBF,F
15CC:  SWAPF  xBF,W
15CE:  IORLW  F0
15D0:  MOVWF  xC1
15D2:  ADDWF  xC1,F
15D4:  ADDLW  E2
15D6:  MOVWF  xC2
15D8:  ADDLW  32
15DA:  MOVWF  xC4
15DC:  MOVF   xBF,W
15DE:  ANDLW  0F
15E0:  ADDWF  xC2,F
15E2:  ADDWF  xC2,F
15E4:  ADDWF  xC4,F
15E6:  ADDLW  E9
15E8:  MOVWF  xC3
15EA:  ADDWF  xC3,F
15EC:  ADDWF  xC3,F
15EE:  SWAPF  xBE,W
15F0:  ANDLW  0F
15F2:  ADDWF  xC3,F
15F4:  ADDWF  xC4,F
15F6:  RLCF   xC3,F
15F8:  RLCF   xC4,F
15FA:  COMF   xC4,F
15FC:  RLCF   xC4,F
15FE:  MOVF   xBE,W
1600:  ANDLW  0F
1602:  ADDWF  xC4,F
1604:  RLCF   xC1,F
1606:  MOVLW  07
1608:  MOVWF  xC0
160A:  MOVLW  0A
160C:  DECF   xC3,F
160E:  ADDWF  xC4,F
1610:  BNC   160C
1612:  DECF   xC2,F
1614:  ADDWF  xC3,F
1616:  BNC   1612
1618:  DECF   xC1,F
161A:  ADDWF  xC2,F
161C:  BNC   1618
161E:  DECF   xC0,F
1620:  ADDWF  xC1,F
1622:  BNC   161E
1624:  CLRF   FEA
1626:  MOVLW  C0
1628:  MOVWF  FE9
162A:  MOVLW  07
162C:  ANDWF  xC5,W
162E:  BCF    xC5.6
1630:  MOVF   FED,F
1632:  ANDWF  xC5,W
1634:  BNZ   1644
1636:  BTFSC  xC5.4
1638:  MOVF   FEE,F
163A:  BTFSC  xC5.4
163C:  BRA    1644
163E:  MOVLW  20
1640:  MOVWF  00
1642:  BRA    1684
1644:  ADDWF  FE9,F
1646:  MOVLW  00
1648:  ADDWFC FEA,F
164A:  MOVF   FE9,W
164C:  SUBLW  C4
164E:  BNZ   1656
1650:  MOVF   FEA,F
1652:  BNZ   1656
1654:  BSF    xC5.6
1656:  MOVF   FEF,W
1658:  MOVWF  00
165A:  BNZ   166C
165C:  BTFSC  xC5.6
165E:  BRA    166C
1660:  BTFSC  xC5.4
1662:  BRA    168C
1664:  BTFSC  xC5.3
1666:  BRA    166C
1668:  MOVLW  20
166A:  BRA    1682
166C:  BTFSS  xC5.7
166E:  BRA    167C
1670:  MOVLW  2D
1672:  MOVWF  00
1674:  MOVF   FED,W
1676:  BCF    xC5.6
1678:  BCF    xC5.7
167A:  BRA    1684
167C:  BSF    xC5.3
167E:  BCF    xC5.4
1680:  MOVLW  30
1682:  ADDWF  00,F
1684:  MOVF   00,W
1686:  BTFSS  F9E.4
1688:  BRA    1686
168A:  MOVWF  FAD
168C:  MOVF   FEE,W
168E:  BTFSS  xC5.6
1690:  BRA    164A
1692:  RETURN 0
*
1AFE:  MOVLW  B6
1B00:  MOVWF  00
1B02:  CLRF   03
1B04:  CLRF   02
1B06:  CLRF   01
1B08:  BCF    xA6.0
1B0A:  BTFSS  xA5.7
1B0C:  BRA    1B26
1B0E:  BSF    xA6.0
1B10:  COMF   xA2,F
1B12:  COMF   xA3,F
1B14:  COMF   xA4,F
1B16:  COMF   xA5,F
1B18:  INCF   xA2,F
1B1A:  BNZ   1B26
1B1C:  INCF   xA3,F
1B1E:  BNZ   1B26
1B20:  INCF   xA4,F
1B22:  BTFSC  FD8.2
1B24:  INCF   xA5,F
1B26:  MOVF   xA2,W
1B28:  IORWF  xA3,W
1B2A:  IORWF  xA4,W
1B2C:  IORWF  xA5,W
1B2E:  BNZ   1B34
1B30:  CLRF   00
1B32:  BRA    1B52
1B34:  BCF    FD8.0
1B36:  BTFSC  01.7
1B38:  BRA    1B4C
1B3A:  RLCF   xA2,F
1B3C:  RLCF   xA3,F
1B3E:  RLCF   xA4,F
1B40:  RLCF   xA5,F
1B42:  RLCF   03,F
1B44:  RLCF   02,F
1B46:  RLCF   01,F
1B48:  DECFSZ 00,F
1B4A:  BRA    1B34
1B4C:  BCF    01.7
1B4E:  BTFSC  xA6.0
1B50:  BSF    01.7
1B52:  RETURN 0
1B54:  MOVF   FE9,W
1B56:  MOVWF  xAA
1B58:  BTFSS  xA9.7
1B5A:  BRA    1B76
1B5C:  DECF   xAA,F
1B5E:  BSF    xAA.5
1B60:  COMF   xA6,F
1B62:  COMF   xA7,F
1B64:  COMF   xA8,F
1B66:  COMF   xA9,F
1B68:  INCF   xA6,F
1B6A:  BTFSC  FD8.2
1B6C:  INCF   xA7,F
1B6E:  BTFSC  FD8.2
1B70:  INCF   xA8,F
1B72:  BTFSC  FD8.2
1B74:  INCF   xA9,F
1B76:  MOVLW  3B
1B78:  MOVWF  xB1
1B7A:  MOVLW  9A
1B7C:  MOVWF  xB0
1B7E:  MOVLW  CA
1B80:  MOVWF  xAF
1B82:  CLRF   xAE
1B84:  MOVLW  0A
1B86:  MOVWF  xAC
1B88:  BSF    FD8.1
1B8A:  CLRF   FEA
1B8C:  MOVLW  A6
1B8E:  MOVWF  FE9
1B90:  MOVFF  A9,D2
1B94:  MOVFF  A8,D1
1B98:  MOVFF  A7,D0
1B9C:  MOVFF  A6,CF
1BA0:  MOVFF  B1,D6
1BA4:  MOVFF  B0,D5
1BA8:  MOVFF  AF,D4
1BAC:  MOVFF  AE,D3
1BB0:  CALL   0BF8
1BB4:  MOVF   01,W
1BB6:  MOVF   00,F
1BB8:  BNZ   1BD8
1BBA:  MOVF   xAC,W
1BBC:  XORLW  01
1BBE:  BZ    1BD8
1BC0:  MOVF   xAA,W
1BC2:  BZ    1BDC
1BC4:  ANDLW  0F
1BC6:  SUBWF  xAC,W
1BC8:  BZ    1BCC
1BCA:  BC    1C1A
1BCC:  BTFSC  xAA.7
1BCE:  BRA    1C1A
1BD0:  BTFSC  xAA.6
1BD2:  BRA    1BDC
1BD4:  MOVLW  20
1BD6:  BRA    1C10
1BD8:  MOVLW  20
1BDA:  ANDWF  xAA,F
1BDC:  BTFSS  xAA.5
1BDE:  BRA    1BF4
1BE0:  BCF    xAA.5
1BE2:  MOVFF  00,AA
1BE6:  MOVLW  2D
1BE8:  BTFSS  F9E.4
1BEA:  BRA    1BE8
1BEC:  MOVWF  FAD
1BEE:  MOVFF  AA,00
1BF2:  CLRF   xAA
1BF4:  MOVLW  30
1BF6:  BTFSS  xAA.5
1BF8:  BRA    1C10
1BFA:  BCF    xAA.5
1BFC:  MOVFF  00,AA
1C00:  MOVLW  2D
1C02:  BTFSS  F9E.4
1C04:  BRA    1C02
1C06:  MOVWF  FAD
1C08:  MOVFF  AA,00
1C0C:  CLRF   xAA
1C0E:  MOVLW  30
1C10:  ADDWF  00,F
1C12:  MOVF   00,W
1C14:  BTFSS  F9E.4
1C16:  BRA    1C14
1C18:  MOVWF  FAD
1C1A:  BCF    FD8.1
1C1C:  MOVFF  B1,D2
1C20:  MOVFF  B0,D1
1C24:  MOVFF  AF,D0
1C28:  MOVFF  AE,CF
1C2C:  CLRF   xD6
1C2E:  CLRF   xD5
1C30:  CLRF   xD4
1C32:  MOVLW  0A
1C34:  MOVWF  xD3
1C36:  CALL   0BF8
1C3A:  MOVFF  03,B1
1C3E:  MOVFF  02,B0
1C42:  MOVFF  01,AF
1C46:  MOVFF  00,AE
1C4A:  DECFSZ xAC,F
1C4C:  BRA    1B88
1C4E:  RETURN 0
*
21CA:  TBLRD*+
21CC:  MOVF   FF5,F
21CE:  BZ    21EA
21D0:  MOVFF  FF6,A2
21D4:  MOVFF  FF7,A3
21D8:  MOVF   FF5,W
21DA:  BTFSS  F9E.4
21DC:  BRA    21DA
21DE:  MOVWF  FAD
21E0:  MOVFF  A2,FF6
21E4:  MOVFF  A3,FF7
21E8:  BRA    21CA
21EA:  RETURN 0
21EC:  MOVFF  FEA,AC
21F0:  MOVFF  FE9,AB
21F4:  SWAPF  xA5,W
21F6:  IORLW  F0
21F8:  MOVWF  xA7
21FA:  ADDWF  xA7,F
21FC:  ADDLW  E2
21FE:  MOVWF  xA8
2200:  ADDLW  32
2202:  MOVWF  xAA
2204:  MOVF   xA5,W
2206:  ANDLW  0F
2208:  ADDWF  xA8,F
220A:  ADDWF  xA8,F
220C:  ADDWF  xAA,F
220E:  ADDLW  E9
2210:  MOVWF  xA9
2212:  ADDWF  xA9,F
2214:  ADDWF  xA9,F
2216:  SWAPF  xA4,W
2218:  ANDLW  0F
221A:  ADDWF  xA9,F
221C:  ADDWF  xAA,F
221E:  RLCF   xA9,F
2220:  RLCF   xAA,F
2222:  COMF   xAA,F
2224:  RLCF   xAA,F
2226:  MOVF   xA4,W
2228:  ANDLW  0F
222A:  ADDWF  xAA,F
222C:  RLCF   xA7,F
222E:  MOVLW  07
2230:  MOVWF  xA6
2232:  MOVLW  0A
2234:  DECF   xA9,F
2236:  ADDWF  xAA,F
2238:  BNC   2234
223A:  DECF   xA8,F
223C:  ADDWF  xA9,F
223E:  BNC   223A
2240:  DECF   xA7,F
2242:  ADDWF  xA8,F
2244:  BNC   2240
2246:  DECF   xA6,F
2248:  ADDWF  xA7,F
224A:  BNC   2246
224C:  CLRF   FEA
224E:  MOVLW  A6
2250:  MOVWF  FE9
2252:  MOVLW  07
2254:  ANDWF  xAB,W
2256:  BCF    xAB.6
2258:  ADDWF  FE9,F
225A:  MOVLW  00
225C:  ADDWFC FEA,F
225E:  MOVF   FE9,W
2260:  SUBLW  AA
2262:  BNZ   226A
2264:  MOVF   FEA,F
2266:  BNZ   226A
2268:  BSF    xAB.6
226A:  MOVF   FEF,W
226C:  MOVWF  00
226E:  BNZ   2280
2270:  BTFSC  xAB.6
2272:  BRA    2280
2274:  BTFSC  xAB.4
2276:  BRA    2290
2278:  BTFSC  xAB.3
227A:  BRA    2280
227C:  MOVLW  20
227E:  BRA    2286
2280:  BSF    xAB.3
2282:  BCF    xAB.4
2284:  MOVLW  30
2286:  ADDWF  00,F
2288:  MOVF   00,W
228A:  BTFSS  F9E.4
228C:  BRA    228A
228E:  MOVWF  FAD
2290:  MOVF   FEE,W
2292:  BTFSS  xAB.6
2294:  BRA    225E
2296:  RETURN 0
*
2308:  MOVF   xA4,W
230A:  MULWF  xA6
230C:  MOVFF  FF3,01
2310:  MOVFF  FF4,00
2314:  MULWF  xA7
2316:  MOVF   FF3,W
2318:  ADDWF  00,F
231A:  MOVF   xA5,W
231C:  MULWF  xA6
231E:  MOVF   FF3,W
2320:  ADDWFC 00,W
2322:  MOVWF  02
2324:  RETURN 0
2326:  MOVLW  8E
2328:  MOVWF  00
232A:  MOVFF  A3,01
232E:  MOVFF  A2,02
2332:  CLRF   03
2334:  MOVF   01,F
2336:  BNZ   234A
2338:  MOVFF  02,01
233C:  CLRF   02
233E:  MOVLW  08
2340:  SUBWF  00,F
2342:  MOVF   01,F
2344:  BNZ   234A
2346:  CLRF   00
2348:  BRA    235A
234A:  BCF    FD8.0
234C:  BTFSC  01.7
234E:  BRA    2358
2350:  RLCF   02,F
2352:  RLCF   01,F
2354:  DECF   00,F
2356:  BRA    234A
2358:  BCF    01.7
235A:  RETURN 0
235C:  MOVF   xA6,W
235E:  BTFSC  FD8.2
2360:  BRA    24AC
2362:  MOVWF  xB2
2364:  MOVF   xAA,W
2366:  BTFSC  FD8.2
2368:  BRA    24AC
236A:  SUBWF  xB2,F
236C:  BNC   2378
236E:  MOVLW  7F
2370:  ADDWF  xB2,F
2372:  BTFSC  FD8.0
2374:  BRA    24AC
2376:  BRA    2384
2378:  MOVLW  81
237A:  SUBWF  xB2,F
237C:  BTFSS  FD8.0
237E:  BRA    24AC
2380:  BTFSC  FD8.2
2382:  BRA    24AC
2384:  MOVFF  B2,00
2388:  CLRF   01
238A:  CLRF   02
238C:  CLRF   03
238E:  CLRF   xB1
2390:  MOVFF  A7,B0
2394:  BSF    xB0.7
2396:  MOVFF  A8,AF
239A:  MOVFF  A9,AE
239E:  MOVLW  19
23A0:  MOVWF  xB2
23A2:  MOVF   xAD,W
23A4:  SUBWF  xAE,F
23A6:  BC    23C2
23A8:  MOVLW  01
23AA:  SUBWF  xAF,F
23AC:  BC    23C2
23AE:  SUBWF  xB0,F
23B0:  BC    23C2
23B2:  SUBWF  xB1,F
23B4:  BC    23C2
23B6:  INCF   xB1,F
23B8:  INCF   xB0,F
23BA:  INCF   xAF,F
23BC:  MOVF   xAD,W
23BE:  ADDWF  xAE,F
23C0:  BRA    2412
23C2:  MOVF   xAC,W
23C4:  SUBWF  xAF,F
23C6:  BC    23EC
23C8:  MOVLW  01
23CA:  SUBWF  xB0,F
23CC:  BC    23EC
23CE:  SUBWF  xB1,F
23D0:  BC    23EC
23D2:  INCF   xB1,F
23D4:  INCF   xB0,F
23D6:  MOVF   xAC,W
23D8:  ADDWF  xAF,F
23DA:  MOVF   xAD,W
23DC:  ADDWF  xAE,F
23DE:  BNC   2412
23E0:  INCF   xAF,F
23E2:  BNZ   2412
23E4:  INCF   xB0,F
23E6:  BNZ   2412
23E8:  INCF   xB1,F
23EA:  BRA    2412
23EC:  MOVF   xAB,W
23EE:  IORLW  80
23F0:  SUBWF  xB0,F
23F2:  BC    2410
23F4:  MOVLW  01
23F6:  SUBWF  xB1,F
23F8:  BC    2410
23FA:  INCF   xB1,F
23FC:  MOVF   xAB,W
23FE:  IORLW  80
2400:  ADDWF  xB0,F
2402:  MOVF   xAC,W
2404:  ADDWF  xAF,F
2406:  BNC   23DA
2408:  INCF   xB0,F
240A:  BNZ   23DA
240C:  INCF   xB1,F
240E:  BRA    23DA
2410:  BSF    03.0
2412:  DECFSZ xB2,F
2414:  BRA    2418
2416:  BRA    242E
2418:  BCF    FD8.0
241A:  RLCF   xAE,F
241C:  RLCF   xAF,F
241E:  RLCF   xB0,F
2420:  RLCF   xB1,F
2422:  BCF    FD8.0
2424:  RLCF   03,F
2426:  RLCF   02,F
2428:  RLCF   01,F
242A:  RLCF   xB3,F
242C:  BRA    23A2
242E:  BTFSS  xB3.0
2430:  BRA    243E
2432:  BCF    FD8.0
2434:  RRCF   01,F
2436:  RRCF   02,F
2438:  RRCF   03,F
243A:  RRCF   xB3,F
243C:  BRA    2442
243E:  DECF   00,F
2440:  BZ    24AC
2442:  BTFSC  xB3.7
2444:  BRA    2482
2446:  BCF    FD8.0
2448:  RLCF   xAE,F
244A:  RLCF   xAF,F
244C:  RLCF   xB0,F
244E:  RLCF   xB1,F
2450:  MOVF   xAD,W
2452:  SUBWF  xAE,F
2454:  BC    2464
2456:  MOVLW  01
2458:  SUBWF  xAF,F
245A:  BC    2464
245C:  SUBWF  xB0,F
245E:  BC    2464
2460:  SUBWF  xB1,F
2462:  BNC   2498
2464:  MOVF   xAC,W
2466:  SUBWF  xAF,F
2468:  BC    2474
246A:  MOVLW  01
246C:  SUBWF  xB0,F
246E:  BC    2474
2470:  SUBWF  xB1,F
2472:  BNC   2498
2474:  MOVF   xAB,W
2476:  IORLW  80
2478:  SUBWF  xB0,F
247A:  BC    2482
247C:  MOVLW  01
247E:  SUBWF  xB1,F
2480:  BNC   2498
2482:  INCF   03,F
2484:  BNZ   2498
2486:  INCF   02,F
2488:  BNZ   2498
248A:  INCF   01,F
248C:  BNZ   2498
248E:  INCF   00,F
2490:  BZ    24AC
2492:  RRCF   01,F
2494:  RRCF   02,F
2496:  RRCF   03,F
2498:  MOVFF  A7,B2
249C:  MOVF   xAB,W
249E:  XORWF  xB2,F
24A0:  BTFSS  xB2.7
24A2:  BRA    24A8
24A4:  BSF    01.7
24A6:  BRA    24B4
24A8:  BCF    01.7
24AA:  BRA    24B4
24AC:  CLRF   00
24AE:  CLRF   01
24B0:  CLRF   02
24B2:  CLRF   03
24B4:  RETURN 0
24B6:  MOVFF  A3,AA
24BA:  MOVF   xA7,W
24BC:  XORWF  xAA,F
24BE:  BTFSS  xAA.7
24C0:  BRA    24CC
24C2:  BCF    FD8.2
24C4:  BCF    FD8.0
24C6:  BTFSC  xA3.7
24C8:  BSF    FD8.0
24CA:  BRA    252A
24CC:  MOVFF  A3,AA
24D0:  MOVFF  A6,AB
24D4:  MOVF   xA2,W
24D6:  SUBWF  xAB,F
24D8:  BZ    24E6
24DA:  BTFSS  xAA.7
24DC:  BRA    252A
24DE:  MOVF   FD8,W
24E0:  XORLW  01
24E2:  MOVWF  FD8
24E4:  BRA    252A
24E6:  MOVFF  A7,AB
24EA:  MOVF   xA3,W
24EC:  SUBWF  xAB,F
24EE:  BZ    24FC
24F0:  BTFSS  xAA.7
24F2:  BRA    252A
24F4:  MOVF   FD8,W
24F6:  XORLW  01
24F8:  MOVWF  FD8
24FA:  BRA    252A
24FC:  MOVFF  A8,AB
2500:  MOVF   xA4,W
2502:  SUBWF  xAB,F
2504:  BZ    2512
2506:  BTFSS  xAA.7
2508:  BRA    252A
250A:  MOVF   FD8,W
250C:  XORLW  01
250E:  MOVWF  FD8
2510:  BRA    252A
2512:  MOVFF  A9,AB
2516:  MOVF   xA5,W
2518:  SUBWF  xAB,F
251A:  BZ    2528
251C:  BTFSS  xAA.7
251E:  BRA    252A
2520:  MOVF   FD8,W
2522:  XORLW  01
2524:  MOVWF  FD8
2526:  BRA    252A
2528:  BCF    FD8.0
252A:  RETURN 0
....................  
.................... #list 
....................  
.................... //#device ADC=16 
....................  
....................  
.................... #FUSES WDT                       //Watch Dog Timer 
.................... #FUSES WDT4096                  //Watch Dog Timer PreScalar 1:32 
....................  
.................... #FUSES SOSC_DIG                 //Digital mode, I/O port functionality of RC0 and RC1 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #fuses HSM                       //High speed Osc, medium power 4MHz-16MHz 
.................... #fuses NOPLLEN                     //HW PLL disabled, PLL enabled in software 
....................  
.................... #use delay(clock=10MHz,crystal=10MHz) 
*
050E:  CLRF   FEA
0510:  MOVLW  BF
0512:  MOVWF  FE9
0514:  MOVF   FEF,W
0516:  BZ    0534
0518:  MOVLW  03
051A:  MOVWF  01
051C:  CLRF   00
051E:  DECFSZ 00,F
0520:  BRA    051E
0522:  DECFSZ 01,F
0524:  BRA    051C
0526:  MOVLW  3C
0528:  MOVWF  00
052A:  DECFSZ 00,F
052C:  BRA    052A
052E:  BRA    0530
0530:  DECFSZ FEF,F
0532:  BRA    0518
0534:  RETURN 0
0536:  MOVLW  07
0538:  SUBWF  xD5,F
053A:  BNC   0552
053C:  CLRF   FEA
053E:  MOVLW  D5
0540:  MOVWF  FE9
0542:  BCF    FD8.0
0544:  RRCF   FEF,F
0546:  MOVF   FEF,W
0548:  BZ    0552
054A:  BRA    054E
054C:  BRA    054E
054E:  DECFSZ FEF,F
0550:  BRA    054C
0552:  RETURN 0
....................  
.................... #BYTE TRISA = 0xF92 
.................... #BYTE TRISB = 0xF93 
.................... #BYTE TRISC = 0xF94 
.................... #BYTE PORTA = 0xF80 
.................... #BYTE PORTB = 0xF81 
.................... #BYTE PORTC = 0xF82  
.................... #BYTE LATB = 0xF8A 
.................... #BYTE LATC = 0xF8B 
.................... #BYTE RCREG = 0xFAE  
....................  
.................... #BYTE INTCON = 0xFF2    // ???????? ???????????? ?????????? 
.................... #BYTE INTCON2= 0xFF1 
....................   
.................... #BIT TRC7 = TRISC.7 
....................  
.................... /****** TEST ******/ 
.................... #BIT TRC6 = TRISC.6 
.................... //#BIT TEST_PIN = LATC.6 
.................... /******************/ 
....................  
.................... /****** SWITCHS ******/ 
.................... #BIT TRA0 = TRISA.0 
.................... #BIT TRA3 = TRISA.3 
.................... #BIT TRA5 = TRISA.5 
.................... #BIT TRB2 = TRISB.2 
.................... #BIT SB1 = PORTA.0 
.................... #BIT SB2 = PORTA.3 
.................... #BIT SB3 = PORTB.2 
.................... #BIT SB4 = PORTA.5 
.................... /*********************/ 
....................  
.................... /****** LCD ******/ 
.................... #BIT TRB1 = TRISB.1 
.................... #BIT TRB3 = TRISB.3 
.................... #BIT TRB4 = TRISB.4 
.................... #BIT TRB5 = TRISB.5 
.................... #BIT TRC0 = TRISC.0 
.................... #BIT TRC1 = TRISC.1 
.................... #BIT TRC2 = TRISC.2 
.................... #BIT TRC5 = TRISC.5 
.................... #BIT DB4 = LATC.5 
.................... #BIT DB5 = LATC.2 
.................... #BIT DB6 = LATC.1 
.................... #BIT DB7 = LATC.0 
.................... #BIT LCD_RS = LATB.5  
.................... #BIT LCD_RW = LATB.4 
.................... #BIT LCD_E = LATB.3 
.................... #BIT LED = LATB.1 
.................... /*****************/ 
....................  
.................... /****** SENSOR ******/ 
.................... #BIT TRB0 = TRISB.0 
.................... #BIT DRDY = PORTB.0 
.................... #BIT TRC3 = TRISC.3 
.................... #BIT TRC4 = TRISC.4 
.................... #use i2c(Master, sda = PIN_C4, scl = PIN_C3, Fast = 400000) 
*
0196:  MOVLW  08
0198:  MOVWF  01
019A:  NOP   
019C:  BCF    F8B.3
019E:  BCF    F94.3
01A0:  NOP   
01A2:  RLCF   xE1,F
01A4:  BCF    F8B.4
01A6:  BTFSC  FD8.0
01A8:  BSF    F94.4
01AA:  BTFSS  FD8.0
01AC:  BCF    F94.4
01AE:  BSF    F94.3
01B0:  BTFSS  F82.3
01B2:  BRA    01B0
01B4:  DECFSZ 01,F
01B6:  BRA    019A
01B8:  NOP   
01BA:  BCF    F8B.3
01BC:  BCF    F94.3
01BE:  NOP   
01C0:  BSF    F94.4
01C2:  NOP   
01C4:  NOP   
01C6:  BSF    F94.3
01C8:  BTFSS  F82.3
01CA:  BRA    01C8
01CC:  CLRF   01
01CE:  NOP   
01D0:  BTFSC  F82.4
01D2:  BSF    01.0
01D4:  BCF    F8B.3
01D6:  BCF    F94.3
01D8:  BCF    F8B.4
01DA:  BCF    F94.4
01DC:  RETURN 0
01DE:  MOVLW  08
01E0:  MOVWF  xE0
01E2:  MOVFF  00,E1
01E6:  BSF    F94.4
01E8:  NOP   
01EA:  BSF    F94.3
01EC:  BTFSS  F82.3
01EE:  BRA    01EC
01F0:  BTFSC  F82.4
01F2:  BSF    FD8.0
01F4:  BTFSS  F82.4
01F6:  BCF    FD8.0
01F8:  RLCF   01,F
01FA:  NOP   
01FC:  BCF    F94.3
01FE:  BCF    F8B.3
0200:  DECFSZ xE0,F
0202:  BRA    01E6
0204:  BSF    F94.4
0206:  NOP   
0208:  BCF    F8B.4
020A:  MOVF   xE1,W
020C:  BTFSS  FD8.2
020E:  BCF    F94.4
0210:  NOP   
0212:  BSF    F94.3
0214:  BTFSS  F82.3
0216:  BRA    0214
0218:  NOP   
021A:  BCF    F8B.3
021C:  BCF    F94.3
021E:  NOP   
0220:  BCF    F8B.4
0222:  BCF    F94.4
0224:  RETURN 0
.................... /********************/ 
....................  
.................... #use rs232(uart1,baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... #define DELAY 200 
....................  
.................... #define one   0x00 
.................... #define two   0x40 
.................... #define three 0x10 
.................... #define four  0x50 
....................  
.................... typedef unsigned int32 U32; 
.................... typedef int16 U16; 
.................... typedef signed int16 S16; 
.................... typedef int8 U8; 
.................... typedef signed int8 S8; 
.................... typedef signed int32 S32; 
....................  
.................... static U8 buf; 
....................  
.................... #BIT buf4 = buf.4 
.................... #BIT buf5 = buf.5 
.................... #BIT buf6 = buf.6 
.................... #BIT buf7 = buf.7 
....................  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <LCD for V2.1.c> 
.................... /***************** LCD functions *****************/ 
....................  
.................... void LCDWriteNibble(unsigned char uc) // RS must be set/reset before calling  
.................... {                                            
....................    uc=uc << 4; // Align with bits 7-4 
*
0554:  SWAPF  xD3,F
0556:  MOVLW  F0
0558:  ANDWF  xD3,F
....................    LCD_RW=0; 
055A:  BCF    F8A.4
....................    buf = uc; 
055C:  MOVFF  D3,17
....................     DB4 = buf4; 
0560:  BCF    F8B.5
0562:  BTFSC  17.4
0564:  BSF    F8B.5
....................     DB5 = buf5; 
0566:  BCF    F8B.2
0568:  BTFSC  17.5
056A:  BSF    F8B.2
....................     DB6 = buf6; 
056C:  BCF    F8B.1
056E:  BTFSC  17.6
0570:  BSF    F8B.1
....................     DB7 = buf7; 
0572:  BCF    F8B.0
0574:  BTFSC  17.7
0576:  BSF    F8B.0
....................    delay_us(500); 
0578:  MOVLW  02
057A:  MOVWF  xD4
057C:  MOVLW  F9
057E:  MOVWF  xD5
0580:  RCALL  0536
0582:  DECFSZ xD4,F
0584:  BRA    057C
....................    LCD_E = 1; 
0586:  BSF    F8A.3
....................    delay_us(2); 
0588:  BRA    058A
058A:  BRA    058C
058C:  NOP   
....................    LCD_E = 0; 
058E:  BCF    F8A.3
....................    delay_us(50); 
0590:  MOVLW  29
0592:  MOVWF  00
0594:  DECFSZ 00,F
0596:  BRA    0594
0598:  NOP   
059A:  RETURN 0
.................... } 
....................  
.................... void LCDWriteData(unsigned char uc) 
.................... {     
....................    LCD_RS = 0; 
*
0636:  BCF    F8A.5
....................     delay_us(500); 
0638:  MOVLW  02
063A:  MOVWF  xD2
063C:  MOVLW  F9
063E:  MOVWF  xD5
0640:  RCALL  0536
0642:  DECFSZ xD2,F
0644:  BRA    063C
....................     LCD_RS = 1; 
0646:  BSF    F8A.5
....................     LCD_RW = 1;// Р’РѕСЃСЃС‚Р°РЅРѕРІР»РµРЅРёРµ Р±Р°Р№С‚РѕРІРѕР№ СЃРёРЅС…СЂРѕРЅРёР·Р°С†РёРё 
0648:  BSF    F8A.4
....................     LCDWriteNibble(uc>>4);//РґРІРёРі СЂР°Р·СЂСЏРґРѕРІ СЃС‚Р°СЂС€РёС… 
064A:  SWAPF  xD1,W
064C:  MOVWF  xD2
064E:  MOVLW  0F
0650:  ANDWF  xD2,F
0652:  MOVFF  D2,D3
0656:  RCALL  0554
....................     LCDWriteNibble(uc); 
0658:  MOVFF  D1,D3
065C:  RCALL  0554
065E:  GOTO   0668 (RETURN)
.................... } 
....................  
.................... void LCDCommand(unsigned char uc) 
.................... { 
....................     LCD_RS = 0; // Instruction mode 
*
059C:  BCF    F8A.5
....................     delay_us(250); 
059E:  MOVLW  CF
05A0:  MOVWF  00
05A2:  DECFSZ 00,F
05A4:  BRA    05A2
05A6:  BRA    05A8
05A8:  NOP   
....................     LCD_RW = 1;// Р’РѕСЃСЃС‚Р°РЅРѕРІР»РµРЅРёРµ Р±Р°Р№С‚РѕРІРѕР№ СЃРёРЅС…СЂРѕРЅРёР·Р°С†РёРё 
05AA:  BSF    F8A.4
....................     LCDWriteNibble(uc>>4); 
05AC:  SWAPF  xC0,W
05AE:  MOVWF  xC1
05B0:  MOVLW  0F
05B2:  ANDWF  xC1,F
05B4:  MOVFF  C1,D3
05B8:  RCALL  0554
....................     LCDWriteNibble(uc);   
05BA:  MOVFF  C0,D3
05BE:  RCALL  0554
05C0:  RETURN 0
.................... } 
....................  
.................... void LCDSetCursor(unsigned char ucPos) 
.................... { 
....................   LCDCommand(0x80 | ucPos); 
*
0694:  MOVF   xBE,W
0696:  IORLW  80
0698:  MOVWF  xBF
069A:  MOVWF  xC0
069C:  RCALL  059C
069E:  RETURN 0
.................... } 
....................  
.................... void LCDClear(void) 
.................... { 
....................    LCDCommand(0x1); 
06A0:  MOVLW  01
06A2:  MOVWF  xC0
06A4:  RCALL  059C
....................    delay_us(200); 
06A6:  MOVLW  A6
06A8:  MOVWF  00
06AA:  DECFSZ 00,F
06AC:  BRA    06AA
06AE:  NOP   
06B0:  RETURN 0
.................... } 
....................  
.................... void LCDinit(void) 
.................... { 
....................   LCD_E=0; 
*
05C2:  BCF    F8A.3
....................   LCD_RS=0; 
05C4:  BCF    F8A.5
....................     
....................   Delay_ms(20); 
05C6:  MOVLW  14
05C8:  MOVWF  xBF
05CA:  RCALL  050E
....................    
....................   LCDWriteNibble(3); 
05CC:  MOVLW  03
05CE:  MOVWF  xD3
05D0:  RCALL  0554
....................   Delay_us(40); 
05D2:  MOVLW  20
05D4:  MOVWF  00
05D6:  DECFSZ 00,F
05D8:  BRA    05D6
05DA:  BRA    05DC
05DC:  NOP   
....................   LCDWriteNibble(3); 
05DE:  MOVLW  03
05E0:  MOVWF  xD3
05E2:  RCALL  0554
....................   Delay_us(40); 
05E4:  MOVLW  20
05E6:  MOVWF  00
05E8:  DECFSZ 00,F
05EA:  BRA    05E8
05EC:  BRA    05EE
05EE:  NOP   
....................   LCDWriteNibble(3); 
05F0:  MOVLW  03
05F2:  MOVWF  xD3
05F4:  RCALL  0554
....................   Delay_us(40); 
05F6:  MOVLW  20
05F8:  MOVWF  00
05FA:  DECFSZ 00,F
05FC:  BRA    05FA
05FE:  BRA    0600
0600:  NOP   
....................   LCDWriteNibble(2); 
0602:  MOVLW  02
0604:  MOVWF  xD3
0606:  RCALL  0554
....................   Delay_us(40); 
0608:  MOVLW  20
060A:  MOVWF  00
060C:  DECFSZ 00,F
060E:  BRA    060C
0610:  BRA    0612
0612:  NOP   
....................   
....................   LCDCommand(0x2A);//???????? 1 WIN CP1261 ??????? ?????   
0614:  MOVLW  2A
0616:  MOVWF  xC0
0618:  RCALL  059C
....................   LCDCommand(0x08);// ????????? ???????, ????????? ??????, ????????? ???????? ??????? 
061A:  MOVLW  08
061C:  MOVWF  xC0
061E:  RCALL  059C
....................   LCDCommand(0x1);// ??????? ?????? ? ??????????? ??????? ? ?????? ???????  
0620:  MOVLW  01
0622:  MOVWF  xC0
0624:  RCALL  059C
....................   LCDCommand(0x06);// ?????? ????? ????????? ?????? ??? ?????? ??????  
0626:  MOVLW  06
0628:  MOVWF  xC0
062A:  RCALL  059C
....................   LCDCommand(0b00001111); 
062C:  MOVLW  0F
062E:  MOVWF  xC0
0630:  RCALL  059C
0632:  GOTO   2842 (RETURN)
....................  
....................  } 
....................  
.................... void LCDPutCh(char c) 
.................... { 
....................   LCDWriteData(c); 
*
0662:  MOVFF  D0,D1
0666:  BRA    0636
0668:  RETURN 0
.................... } 
....................  
.................... void LCDPutU16(U32 _u16,U8 u8NumDigs) 
.................... {   
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000; 
*
1010:  BCF    FD8.1
1012:  MOVFF  AB,D2
1016:  MOVFF  AA,D1
101A:  MOVFF  A9,D0
101E:  MOVFF  A8,CF
1022:  CLRF   xD6
1024:  CLRF   xD5
1026:  MOVLW  27
1028:  MOVWF  xD4
102A:  MOVLW  10
102C:  MOVWF  xD3
102E:  RCALL  0BF8
1030:  MOVFF  03,B0
1034:  MOVFF  02,AF
1038:  MOVFF  01,AE
103C:  MOVFF  00,AD
....................    u16b=u16a*10000; 
1040:  MOVFF  B0,D2
1044:  MOVFF  AF,D1
1048:  MOVFF  AE,D0
104C:  MOVFF  AD,CF
1050:  CLRF   xD6
1052:  CLRF   xD5
1054:  MOVLW  27
1056:  MOVWF  xD4
1058:  MOVLW  10
105A:  MOVWF  xD3
105C:  RCALL  0C86
105E:  MOVFF  03,B4
1062:  MOVFF  02,B3
1066:  MOVFF  01,B2
106A:  MOVFF  00,B1
....................  
....................     if (u8NumDigs>=5) 
106E:  MOVF   xAC,W
1070:  SUBLW  04
1072:  BC    1080
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
1074:  MOVLW  30
1076:  ADDWF  xAD,W
1078:  MOVWF  xB5
107A:  MOVWF  xD0
107C:  CALL   0662
....................     } 
....................  
....................     _u16-=u16b; 
1080:  MOVF   xB1,W
1082:  SUBWF  xA8,F
1084:  MOVF   xB2,W
1086:  SUBWFB xA9,F
1088:  MOVF   xB3,W
108A:  SUBWFB xAA,F
108C:  MOVF   xB4,W
108E:  SUBWFB xAB,F
....................     u16a=_u16/1000; 
1090:  BCF    FD8.1
1092:  MOVFF  AB,D2
1096:  MOVFF  AA,D1
109A:  MOVFF  A9,D0
109E:  MOVFF  A8,CF
10A2:  CLRF   xD6
10A4:  CLRF   xD5
10A6:  MOVLW  03
10A8:  MOVWF  xD4
10AA:  MOVLW  E8
10AC:  MOVWF  xD3
10AE:  RCALL  0BF8
10B0:  MOVFF  03,B0
10B4:  MOVFF  02,AF
10B8:  MOVFF  01,AE
10BC:  MOVFF  00,AD
....................     u16b=u16a*1000; 
10C0:  MOVFF  B0,D2
10C4:  MOVFF  AF,D1
10C8:  MOVFF  AE,D0
10CC:  MOVFF  AD,CF
10D0:  CLRF   xD6
10D2:  CLRF   xD5
10D4:  MOVLW  03
10D6:  MOVWF  xD4
10D8:  MOVLW  E8
10DA:  MOVWF  xD3
10DC:  RCALL  0C86
10DE:  MOVFF  03,B4
10E2:  MOVFF  02,B3
10E6:  MOVFF  01,B2
10EA:  MOVFF  00,B1
....................      
....................     if (u8NumDigs>=4) 
10EE:  MOVF   xAC,W
10F0:  SUBLW  03
10F2:  BC    1108
....................     { 
....................       LCDPutCh((U8)u16a +'0'); 
10F4:  MOVLW  30
10F6:  ADDWF  xAD,W
10F8:  MOVWF  xB5
10FA:  MOVWF  xD0
10FC:  CALL   0662
....................       LCDPutCh('.'); 
1100:  MOVLW  2E
1102:  MOVWF  xD0
1104:  CALL   0662
....................     } 
....................  
....................     _u16-=u16b; 
1108:  MOVF   xB1,W
110A:  SUBWF  xA8,F
110C:  MOVF   xB2,W
110E:  SUBWFB xA9,F
1110:  MOVF   xB3,W
1112:  SUBWFB xAA,F
1114:  MOVF   xB4,W
1116:  SUBWFB xAB,F
....................     u16a=_u16/100; 
1118:  BCF    FD8.1
111A:  MOVFF  AB,D2
111E:  MOVFF  AA,D1
1122:  MOVFF  A9,D0
1126:  MOVFF  A8,CF
112A:  CLRF   xD6
112C:  CLRF   xD5
112E:  CLRF   xD4
1130:  MOVLW  64
1132:  MOVWF  xD3
1134:  RCALL  0BF8
1136:  MOVFF  03,B0
113A:  MOVFF  02,AF
113E:  MOVFF  01,AE
1142:  MOVFF  00,AD
....................     u16b=u16a*100; 
1146:  MOVFF  B0,D2
114A:  MOVFF  AF,D1
114E:  MOVFF  AE,D0
1152:  MOVFF  AD,CF
1156:  CLRF   xD6
1158:  CLRF   xD5
115A:  CLRF   xD4
115C:  MOVLW  64
115E:  MOVWF  xD3
1160:  RCALL  0C86
1162:  MOVFF  03,B4
1166:  MOVFF  02,B3
116A:  MOVFF  01,B2
116E:  MOVFF  00,B1
....................      
....................     if (u8NumDigs>=3) 
1172:  MOVF   xAC,W
1174:  SUBLW  02
1176:  BC    1184
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
1178:  MOVLW  30
117A:  ADDWF  xAD,W
117C:  MOVWF  xB5
117E:  MOVWF  xD0
1180:  CALL   0662
....................     } 
....................  
....................     _u16-=u16b; 
1184:  MOVF   xB1,W
1186:  SUBWF  xA8,F
1188:  MOVF   xB2,W
118A:  SUBWFB xA9,F
118C:  MOVF   xB3,W
118E:  SUBWFB xAA,F
1190:  MOVF   xB4,W
1192:  SUBWFB xAB,F
....................     u16a=_u16/10; 
1194:  BCF    FD8.1
1196:  MOVFF  AB,D2
119A:  MOVFF  AA,D1
119E:  MOVFF  A9,D0
11A2:  MOVFF  A8,CF
11A6:  CLRF   xD6
11A8:  CLRF   xD5
11AA:  CLRF   xD4
11AC:  MOVLW  0A
11AE:  MOVWF  xD3
11B0:  RCALL  0BF8
11B2:  MOVFF  03,B0
11B6:  MOVFF  02,AF
11BA:  MOVFF  01,AE
11BE:  MOVFF  00,AD
....................     u16b=u16a*10; 
11C2:  MOVFF  B0,D2
11C6:  MOVFF  AF,D1
11CA:  MOVFF  AE,D0
11CE:  MOVFF  AD,CF
11D2:  CLRF   xD6
11D4:  CLRF   xD5
11D6:  CLRF   xD4
11D8:  MOVLW  0A
11DA:  MOVWF  xD3
11DC:  RCALL  0C86
11DE:  MOVFF  03,B4
11E2:  MOVFF  02,B3
11E6:  MOVFF  01,B2
11EA:  MOVFF  00,B1
....................    if (u8NumDigs>=2) 
11EE:  MOVF   xAC,W
11F0:  SUBLW  01
11F2:  BC    1200
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
11F4:  MOVLW  30
11F6:  ADDWF  xAD,W
11F8:  MOVWF  xB5
11FA:  MOVWF  xD0
11FC:  CALL   0662
....................     } 
....................  
....................     _u16-=u16b; 
1200:  MOVF   xB1,W
1202:  SUBWF  xA8,F
1204:  MOVF   xB2,W
1206:  SUBWFB xA9,F
1208:  MOVF   xB3,W
120A:  SUBWFB xAA,F
120C:  MOVF   xB4,W
120E:  SUBWFB xAB,F
....................     if (u8NumDigs>=1) 
1210:  MOVF   xAC,W
1212:  SUBLW  00
1214:  BC    1222
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
1216:  MOVLW  30
1218:  ADDWF  xA8,W
121A:  MOVWF  xB5
121C:  MOVWF  xD0
121E:  CALL   0662
....................     } 
1222:  RETURN 0
....................    
.................... } 
....................  
.................... void LCDPutU16n(U32 _u16,U8 u8NumDigs) 
.................... {   
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000; 
*
0CDA:  BCF    FD8.1
0CDC:  MOVFF  C5,D2
0CE0:  MOVFF  C4,D1
0CE4:  MOVFF  C3,D0
0CE8:  MOVFF  C2,CF
0CEC:  CLRF   xD6
0CEE:  CLRF   xD5
0CF0:  MOVLW  27
0CF2:  MOVWF  xD4
0CF4:  MOVLW  10
0CF6:  MOVWF  xD3
0CF8:  RCALL  0BF8
0CFA:  MOVFF  03,CA
0CFE:  MOVFF  02,C9
0D02:  MOVFF  01,C8
0D06:  MOVFF  00,C7
....................    u16b=u16a*10000; 
0D0A:  MOVFF  CA,D2
0D0E:  MOVFF  C9,D1
0D12:  MOVFF  C8,D0
0D16:  MOVFF  C7,CF
0D1A:  CLRF   xD6
0D1C:  CLRF   xD5
0D1E:  MOVLW  27
0D20:  MOVWF  xD4
0D22:  MOVLW  10
0D24:  MOVWF  xD3
0D26:  RCALL  0C86
0D28:  MOVFF  03,CE
0D2C:  MOVFF  02,CD
0D30:  MOVFF  01,CC
0D34:  MOVFF  00,CB
....................  
....................     if (u8NumDigs>=5) 
0D38:  MOVF   xC6,W
0D3A:  SUBLW  04
0D3C:  BC    0D48
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0D3E:  MOVLW  30
0D40:  ADDWF  xC7,W
0D42:  MOVWF  xCF
0D44:  MOVWF  xD0
0D46:  RCALL  0662
....................     } 
....................  
....................     _u16-=u16b; 
0D48:  MOVF   xCB,W
0D4A:  SUBWF  xC2,F
0D4C:  MOVF   xCC,W
0D4E:  SUBWFB xC3,F
0D50:  MOVF   xCD,W
0D52:  SUBWFB xC4,F
0D54:  MOVF   xCE,W
0D56:  SUBWFB xC5,F
....................     u16a=_u16/1000; 
0D58:  BCF    FD8.1
0D5A:  MOVFF  C5,D2
0D5E:  MOVFF  C4,D1
0D62:  MOVFF  C3,D0
0D66:  MOVFF  C2,CF
0D6A:  CLRF   xD6
0D6C:  CLRF   xD5
0D6E:  MOVLW  03
0D70:  MOVWF  xD4
0D72:  MOVLW  E8
0D74:  MOVWF  xD3
0D76:  RCALL  0BF8
0D78:  MOVFF  03,CA
0D7C:  MOVFF  02,C9
0D80:  MOVFF  01,C8
0D84:  MOVFF  00,C7
....................     u16b=u16a*1000; 
0D88:  MOVFF  CA,D2
0D8C:  MOVFF  C9,D1
0D90:  MOVFF  C8,D0
0D94:  MOVFF  C7,CF
0D98:  CLRF   xD6
0D9A:  CLRF   xD5
0D9C:  MOVLW  03
0D9E:  MOVWF  xD4
0DA0:  MOVLW  E8
0DA2:  MOVWF  xD3
0DA4:  RCALL  0C86
0DA6:  MOVFF  03,CE
0DAA:  MOVFF  02,CD
0DAE:  MOVFF  01,CC
0DB2:  MOVFF  00,CB
....................      
....................     if (u8NumDigs>=4) 
0DB6:  MOVF   xC6,W
0DB8:  SUBLW  03
0DBA:  BC    0DC6
....................     { 
....................       LCDPutCh((U8)u16a +'0'); 
0DBC:  MOVLW  30
0DBE:  ADDWF  xC7,W
0DC0:  MOVWF  xCF
0DC2:  MOVWF  xD0
0DC4:  RCALL  0662
....................     } 
....................  
....................     _u16-=u16b; 
0DC6:  MOVF   xCB,W
0DC8:  SUBWF  xC2,F
0DCA:  MOVF   xCC,W
0DCC:  SUBWFB xC3,F
0DCE:  MOVF   xCD,W
0DD0:  SUBWFB xC4,F
0DD2:  MOVF   xCE,W
0DD4:  SUBWFB xC5,F
....................     u16a=_u16/100; 
0DD6:  BCF    FD8.1
0DD8:  MOVFF  C5,D2
0DDC:  MOVFF  C4,D1
0DE0:  MOVFF  C3,D0
0DE4:  MOVFF  C2,CF
0DE8:  CLRF   xD6
0DEA:  CLRF   xD5
0DEC:  CLRF   xD4
0DEE:  MOVLW  64
0DF0:  MOVWF  xD3
0DF2:  RCALL  0BF8
0DF4:  MOVFF  03,CA
0DF8:  MOVFF  02,C9
0DFC:  MOVFF  01,C8
0E00:  MOVFF  00,C7
....................     u16b=u16a*100; 
0E04:  MOVFF  CA,D2
0E08:  MOVFF  C9,D1
0E0C:  MOVFF  C8,D0
0E10:  MOVFF  C7,CF
0E14:  CLRF   xD6
0E16:  CLRF   xD5
0E18:  CLRF   xD4
0E1A:  MOVLW  64
0E1C:  MOVWF  xD3
0E1E:  RCALL  0C86
0E20:  MOVFF  03,CE
0E24:  MOVFF  02,CD
0E28:  MOVFF  01,CC
0E2C:  MOVFF  00,CB
....................      
....................     if (u8NumDigs>=3) 
0E30:  MOVF   xC6,W
0E32:  SUBLW  02
0E34:  BC    0E40
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0E36:  MOVLW  30
0E38:  ADDWF  xC7,W
0E3A:  MOVWF  xCF
0E3C:  MOVWF  xD0
0E3E:  RCALL  0662
....................     } 
....................  
....................     _u16-=u16b; 
0E40:  MOVF   xCB,W
0E42:  SUBWF  xC2,F
0E44:  MOVF   xCC,W
0E46:  SUBWFB xC3,F
0E48:  MOVF   xCD,W
0E4A:  SUBWFB xC4,F
0E4C:  MOVF   xCE,W
0E4E:  SUBWFB xC5,F
....................     u16a=_u16/10; 
0E50:  BCF    FD8.1
0E52:  MOVFF  C5,D2
0E56:  MOVFF  C4,D1
0E5A:  MOVFF  C3,D0
0E5E:  MOVFF  C2,CF
0E62:  CLRF   xD6
0E64:  CLRF   xD5
0E66:  CLRF   xD4
0E68:  MOVLW  0A
0E6A:  MOVWF  xD3
0E6C:  RCALL  0BF8
0E6E:  MOVFF  03,CA
0E72:  MOVFF  02,C9
0E76:  MOVFF  01,C8
0E7A:  MOVFF  00,C7
....................     u16b=u16a*10; 
0E7E:  MOVFF  CA,D2
0E82:  MOVFF  C9,D1
0E86:  MOVFF  C8,D0
0E8A:  MOVFF  C7,CF
0E8E:  CLRF   xD6
0E90:  CLRF   xD5
0E92:  CLRF   xD4
0E94:  MOVLW  0A
0E96:  MOVWF  xD3
0E98:  RCALL  0C86
0E9A:  MOVFF  03,CE
0E9E:  MOVFF  02,CD
0EA2:  MOVFF  01,CC
0EA6:  MOVFF  00,CB
....................    if (u8NumDigs>=2) 
0EAA:  MOVF   xC6,W
0EAC:  SUBLW  01
0EAE:  BC    0EBC
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0EB0:  MOVLW  30
0EB2:  ADDWF  xC7,W
0EB4:  MOVWF  xCF
0EB6:  MOVWF  xD0
0EB8:  CALL   0662
....................     } 
....................  
....................     _u16-=u16b; 
0EBC:  MOVF   xCB,W
0EBE:  SUBWF  xC2,F
0EC0:  MOVF   xCC,W
0EC2:  SUBWFB xC3,F
0EC4:  MOVF   xCD,W
0EC6:  SUBWFB xC4,F
0EC8:  MOVF   xCE,W
0ECA:  SUBWFB xC5,F
....................     if (u8NumDigs>=1) 
0ECC:  MOVF   xC6,W
0ECE:  SUBLW  00
0ED0:  BC    0EDE
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
0ED2:  MOVLW  30
0ED4:  ADDWF  xC2,W
0ED6:  MOVWF  xCF
0ED8:  MOVWF  xD0
0EDA:  CALL   0662
....................     } 
0EDE:  RETURN 0
....................    
.................... } 
....................  
.................... void LCDPutS16(S16 s16a,U8 u8NumDigs) 
*
1224:  MOVLW  2B
1226:  MOVWF  xA7
.................... { 
....................    char c='+'; 
....................  
....................    if (s16a<0) 
1228:  BTFSS  xA5.7
122A:  BRA    123A
....................    { 
....................       s16a=-s16a; 
122C:  COMF   xA4,F
122E:  COMF   xA5,F
1230:  INCF   xA4,F
1232:  BTFSC  FD8.2
1234:  INCF   xA5,F
....................       c='-'; 
1236:  MOVLW  2D
1238:  MOVWF  xA7
....................    } 
....................    LCDPutCh(c); 
123A:  MOVFF  A7,D0
123E:  CALL   0662
....................    LCDPutU16((U16)s16a, u8NumDigs); 
1242:  CLRF   xAB
1244:  CLRF   xAA
1246:  MOVFF  A5,A9
124A:  MOVFF  A4,A8
124E:  MOVFF  A6,AC
1252:  RCALL  1010
1254:  RETURN 0
.................... } 
....................  
.................... void LCDPutS16n(S16 s16a,U8 u8NumDigs) 
*
1694:  MOVLW  2B
1696:  MOVWF  xC1
.................... { 
....................    char c='+'; 
....................  
....................    if (s16a<0) 
1698:  BTFSS  xBF.7
169A:  BRA    16AA
....................    { 
....................       s16a=-s16a; 
169C:  COMF   xBE,F
169E:  COMF   xBF,F
16A0:  INCF   xBE,F
16A2:  BTFSC  FD8.2
16A4:  INCF   xBF,F
....................       c='-'; 
16A6:  MOVLW  2D
16A8:  MOVWF  xC1
....................    } 
....................    LCDPutCh(c); 
16AA:  MOVFF  C1,D0
16AE:  CALL   0662
....................    LCDPutU16n((U16)s16a, u8NumDigs); 
16B2:  CLRF   xC5
16B4:  CLRF   xC4
16B6:  MOVFF  BF,C3
16BA:  MOVFF  BE,C2
16BE:  MOVFF  C0,C6
16C2:  CALL   0CDA
16C6:  RETURN 0
.................... } 
....................  
.................... void LCDMsg(char c) 
.................... { 
....................     LCDPutCh(c); 
*
066A:  MOVFF  C0,D0
066E:  RCALL  0662
0670:  GOTO   0688 (RETURN)
.................... } 
....................  
.................... void LCDWelcome(void){ 
....................    LCDMsg("   Измеритель"); 
*
06B2:  MOVLW  A2
06B4:  MOVWF  FF6
06B6:  MOVLW  00
06B8:  MOVWF  FF7
06BA:  RCALL  0674
....................    LCDSetCursor(two); 
06BC:  MOVLW  40
06BE:  MOVWF  xBE
06C0:  RCALL  0694
....................    LCDMsg("   магнитной"); 
06C2:  MOVLW  B0
06C4:  MOVWF  FF6
06C6:  MOVLW  00
06C8:  MOVWF  FF7
06CA:  RCALL  0674
....................    LCDSetCursor(three); 
06CC:  MOVLW  10
06CE:  MOVWF  xBE
06D0:  RCALL  0694
....................    LCDMsg(" индукции. v2.4 "); 
06D2:  MOVLW  BE
06D4:  MOVWF  FF6
06D6:  MOVLW  00
06D8:  MOVWF  FF7
06DA:  RCALL  0674
....................    LCDSetCursor(four); 
06DC:  MOVLW  50
06DE:  MOVWF  xBE
06E0:  RCALL  0694
....................    LCDMsg("                "); 
06E2:  MOVLW  D0
06E4:  MOVWF  FF6
06E6:  MOVLW  00
06E8:  MOVWF  FF7
06EA:  RCALL  0674
....................    Delay_ms(1000); 
06EC:  MOVLW  04
06EE:  MOVWF  xA2
06F0:  MOVLW  FA
06F2:  MOVWF  xBF
06F4:  RCALL  050E
06F6:  DECFSZ xA2,F
06F8:  BRA    06F0
....................    LCDClear();   
06FA:  RCALL  06A0
06FC:  GOTO   2846 (RETURN)
.................... } 
....................  
.................... void NC_LCDMsg() 
.................... { 
....................  
....................     LCDSetCursor (one); 
*
213A:  CLRF   xBE
213C:  CALL   0694
....................     LCDMsg ("    ДАТЧИК     "); 
2140:  MOVLW  E2
2142:  MOVWF  FF6
2144:  MOVLW  00
2146:  MOVWF  FF7
2148:  CALL   0674
....................     LCDSetCursor (two); 
214C:  MOVLW  40
214E:  MOVWF  xBE
2150:  CALL   0694
....................     LCDMsg ("      НЕ       "); 
2154:  MOVLW  F2
2156:  MOVWF  FF6
2158:  MOVLW  00
215A:  MOVWF  FF7
215C:  CALL   0674
....................     LCDSetCursor (three); 
2160:  MOVLW  10
2162:  MOVWF  xBE
2164:  CALL   0694
....................     LCDMsg ("   ПОДКЛЮЧЕН!  "); 
2168:  MOVLW  02
216A:  MOVWF  FF6
216C:  MOVLW  01
216E:  MOVWF  FF7
2170:  CALL   0674
....................     LCDSetCursor (four); 
2174:  MOVLW  50
2176:  MOVWF  xBE
2178:  CALL   0694
....................     LCDMsg ("                "); 
217C:  MOVLW  12
217E:  MOVWF  FF6
2180:  MOVLW  01
2182:  MOVWF  FF7
2184:  CALL   0674
2188:  GOTO   2910 (RETURN)
.................... } 
....................  
....................  
.................... #define TLV493D_rd_addr 0xbd     // i2c адрес датчика при чтении  
.................... #define TLV493D_wr_addr 0xbc     // i2c адрес датчика при записи 
....................  
.................... #define TLV493D        37        // ID датчика Bmax = 1,3 kGs 
.................... #define HMC5883l       30        // ID датчика Bmax = 8,1 Gs 
....................  
.................... unsigned int1 int_fl = 0; 
.................... unsigned int1 SensErr = 0; 
.................... unsigned int1 set_zero_fl = 0; 
....................  
....................  
.................... char  ConfigRegA = 0x00, ConfigRegB = 0x01, ModeReg = 0x02, EEprom_adr = 0xA0; 
.................... signed int16 SumX=0;  
.................... signed int16 SumY=0;  
.................... signed int16 SumZ=0; 
....................         
.................... signed int16 SumX0=0;  
.................... signed int16 SumY0=0; 
.................... signed int16 SumZ0=0; 
....................  
.................... signed int32 average_Xg=0;  
.................... signed int32 average_Yg=0; 
.................... signed int32 average_Zg=0; 
....................               
.................... unsigned int16 Xh =0;    
.................... unsigned int8 Xl = 0; 
.................... unsigned int16 Yh =0; 
.................... unsigned int8 Yl = 0; 
.................... unsigned int16 Zh =0; 
.................... unsigned int8 Zl = 0; 
....................  
.................... float Xd = 0; 
.................... float Yd = 0; 
.................... float Zd = 0; 
.................... float kx = 1.0;   // калибровочные коэффициенты 
.................... float ky = 1.0; 
.................... float kz = 1.0; 
....................  
.................... U8 crc_buf_wr[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... U8 crc_buf_rd[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... U8 crc_wr_index = 0; 
.................... U8 crc_rd_index = 0; 
....................  
.................... U16 coord_sys = 0;      // переменная выбора системы координат измерений 
.................... U16 sens_type;          // тип датчика => 37 - TLV493D, 30 - HMC5883l         
.................... U16 sens_num;           // № датчика в базе Диалтек 
.................... U16 ROM_Adr = 0x0000; 
.................... int1 rom_rd_status = 0; // флаг статуса прочтения ПЗУ 
....................  
.................... U16 CRC_Wr; 
.................... U16 CRC1 = 0; 
.................... U16 CRC2 = 0;  
....................  
.................... U8 TLV493D_frm_cnt = 0; // переменная счета итераций измерения датчика TLV493D 
.................... U8 wr_ptr = 0, rd_ptr = 0;                         // счетчики чтения и записи в массив UART 
.................... U8 rx_buf[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // буфер для сохр. принятных команд 
....................  
.................... //****************** Sensor 1 funcs ************************************ 
.................... void SensWrData(unsigned int8 Adr, Data) 
.................... { 
....................     
....................    i2c_start (); 
*
0226:  BSF    F94.4
0228:  NOP   
022A:  BSF    F94.3
022C:  NOP   
022E:  BCF    F8B.4
0230:  BCF    F94.4
0232:  NOP   
0234:  BCF    F8B.3
0236:  BCF    F94.3
....................    i2c_write (0x3C); 
0238:  MOVLW  3C
023A:  MOVWF  xE1
023C:  RCALL  0196
....................  
....................    // The default (factory) HMC5883 7 - bit slave address 
....................    // is 0x3C for write operations, or 0x3D for read operations. 
....................    i2c_write (Adr); 
023E:  MOVFF  DF,E1
0242:  RCALL  0196
....................    i2c_write (Data); 
0244:  MOVFF  E0,E1
0248:  RCALL  0196
....................    i2c_stop (); 
024A:  BCF    F94.4
024C:  NOP   
024E:  BSF    F94.3
0250:  BTFSS  F82.3
0252:  BRA    0250
0254:  NOP   
0256:  BRA    0258
0258:  NOP   
025A:  BSF    F94.4
025C:  NOP   
025E:  RETURN 0
.................... } 
....................   
.................... char SensRdData(char Adr) 
.................... { 
....................     
....................    char Data = 0; 
....................     
....................    i2c_start (); 
....................    i2c_write (0x3C); // The default (factory) HMC5883 7 - bit slave address 
....................    // is 0x3C for write operations, or 0x3D for read operations. 
....................    i2c_write (Adr); // pointer 
....................    i2c_stop (); 
....................    delay_us (10); 
....................    i2c_start (); 
....................    i2c_write (0x3D); //i2c Read 
....................    delay_us (10); 
....................    Data = i2c_read (); 
....................    delay_us (10); 
....................    Data = i2c_read (); 
....................    delay_us (10); 
....................    i2c_stop (); 
....................     
....................    return Data; 
.................... } 
....................      
.................... void HMC5883l_Init () 
.................... { 
....................     
....................    //SensWrData (ConfigRegA, 0x14); // F = 30 Hz / 1 
....................    SensWrData (ConfigRegA, 0x18); // F = 75 Hz / 1 
0260:  MOVFF  1B,DF
0264:  MOVLW  18
0266:  MOVWF  xE0
0268:  RCALL  0226
....................    SensWrData (ConfigRegB, 0xE0); // range = + / - 8.1 Ga 
026A:  MOVFF  1C,DF
026E:  MOVLW  E0
0270:  MOVWF  xE0
0272:  RCALL  0226
....................    SensWrData (ModeReg, 0x00); // continuous measurment mode 
0274:  MOVFF  1D,DF
0278:  CLRF   xE0
027A:  RCALL  0226
027C:  RETURN 0
....................    //SensWrData (ModeReg, 0x01); // single measurment mode 
.................... } 
....................  
.................... signed int16 SelfCal() 
.................... { 
....................     
....................    unsigned int16 Xh = 0; 
....................    unsigned int8 Xl = 0; 
....................    unsigned int16 Yh = 0; 
....................    unsigned int8 Yl = 0; 
....................    unsigned int16 Zh = 0; 
....................    unsigned int8 Zl = 0; 
....................     
....................    HMC5883l_Init(); 
....................    delay_us (10); 
....................  
....................    if (int_fl) 
....................    { 
....................       i2c_start (); 
....................       i2c_write (0x3C); // The default (factory) HMC5883 7 - bit slave address 
....................       // is 0x3C for write operations, or 0x3D for read operations. 
....................       i2c_write (0x03); // pointer 
....................       i2c_stop (); 
....................       delay_us (10); 
....................        
....................       i2c_start (); 
....................       i2c_write (0x3D); //i2c Read 
....................       Xh = i2c_read (); // X MSB 
....................       Xl = i2c_read (); // X LSB 
....................       SumX = (Xh<<8)|Xl; //?????????????? ???????? ????????. ??? ? 
....................       Yh = i2c_read (); // Y MSB 
....................       Yl = i2c_read (); // Y LSB 
....................       SumY = (Yh<<8)|Yl; //?????????????? ???????? ????????. ??? Y 
....................       Zh = i2c_read (); // Z MSB 
....................       Zl = i2c_read (); // Z LSB 
....................       SumZ = (Zh<<8)|Zl; //?????????????? ???????? ????????. ??? Z 
....................       i2c_read (); //if adress pointer = 08, adress pointer = 03 
....................       i2c_stop (); 
....................    } 
....................  
....................     
....................    delay_us (10); 
....................    return 1; 
.................... } 
....................  
.................... void SensRdAll() 
.................... { 
....................     
....................    if (set_zero_fl) 
*
1C50:  BTFSS  1A.2
1C52:  BRA    1C94
....................    { 
....................       // утс. 0 
....................        
....................       LCDClear (); 
1C54:  CALL   06A0
....................       Lcdsetcursor (0); 
1C58:  CLRF   xBE
1C5A:  CALL   0694
....................       LcdMsg (" Установка нуля "); 
1C5E:  MOVLW  24
1C60:  MOVWF  FF6
1C62:  MOVLW  01
1C64:  MOVWF  FF7
1C66:  CALL   0674
....................       SumX0 = SumX; 
1C6A:  MOVFF  20,26
1C6E:  MOVFF  1F,25
....................       SumY0 = SumY; 
1C72:  MOVFF  22,28
1C76:  MOVFF  21,27
....................       SumZ0 = SumZ; 
1C7A:  MOVFF  24,2A
1C7E:  MOVFF  23,29
....................       delay_ms (1000); 
1C82:  MOVLW  04
1C84:  MOVWF  xA2
1C86:  MOVLW  FA
1C88:  MOVWF  xBF
1C8A:  CALL   050E
1C8E:  DECFSZ xA2,F
1C90:  BRA    1C86
....................       set_zero_fl = 0; 
1C92:  BCF    1A.2
....................    } 
....................  
....................     
....................    average_Zg = SumZ - SumZ0; //(average_Zg / 10) - SumZ0; 
1C94:  MOVF   29,W
1C96:  SUBWF  23,W
1C98:  MOVWF  00
1C9A:  MOVF   2A,W
1C9C:  SUBWFB 24,W
1C9E:  MOVWF  03
1CA0:  MOVF   00,W
1CA2:  MOVFF  03,01
1CA6:  CLRF   02
1CA8:  CLRF   03
1CAA:  BTFSS  01.7
1CAC:  BRA    1CB2
1CAE:  DECF   02,F
1CB0:  DECF   03,F
1CB2:  MOVFF  03,36
1CB6:  MOVFF  02,35
1CBA:  MOVFF  01,34
1CBE:  MOVFF  00,33
....................    average_Yg = SumY - SumY0; 
1CC2:  MOVF   27,W
1CC4:  SUBWF  21,W
1CC6:  MOVWF  00
1CC8:  MOVF   28,W
1CCA:  SUBWFB 22,W
1CCC:  MOVWF  03
1CCE:  MOVF   00,W
1CD0:  MOVFF  03,01
1CD4:  CLRF   02
1CD6:  CLRF   03
1CD8:  BTFSS  01.7
1CDA:  BRA    1CE0
1CDC:  DECF   02,F
1CDE:  DECF   03,F
1CE0:  MOVFF  03,32
1CE4:  MOVFF  02,31
1CE8:  MOVFF  01,30
1CEC:  MOVFF  00,2F
....................    average_Xg = SumX - SumX0; 
1CF0:  MOVF   25,W
1CF2:  SUBWF  1F,W
1CF4:  MOVWF  00
1CF6:  MOVF   26,W
1CF8:  SUBWFB 20,W
1CFA:  MOVWF  03
1CFC:  MOVF   00,W
1CFE:  MOVFF  03,01
1D02:  CLRF   02
1D04:  CLRF   03
1D06:  BTFSS  01.7
1D08:  BRA    1D0E
1D0A:  DECF   02,F
1D0C:  DECF   03,F
1D0E:  MOVFF  03,2E
1D12:  MOVFF  02,2D
1D16:  MOVFF  01,2C
1D1A:  MOVFF  00,2B
....................     
....................    //y = (8.1 * x) / 2048; 8.1 / 2048 = 0.0039550781252 
....................     
....................    Xd = average_Xg * 0.0039550781252; 
1D1E:  MOVFF  2E,A5
1D22:  MOVFF  2D,A4
1D26:  MOVFF  2C,A3
1D2A:  MOVFF  2B,A2
1D2E:  RCALL  1AFE
1D30:  MOVFF  03,CB
1D34:  MOVFF  02,CA
1D38:  MOVFF  01,C9
1D3C:  MOVFF  00,C8
1D40:  MOVLW  9A
1D42:  MOVWF  xCF
1D44:  MOVLW  99
1D46:  MOVWF  xCE
1D48:  MOVLW  01
1D4A:  MOVWF  xCD
1D4C:  MOVLW  77
1D4E:  MOVWF  xCC
1D50:  CALL   0EE0
1D54:  MOVFF  03,43
1D58:  MOVFF  02,42
1D5C:  MOVFF  01,41
1D60:  MOVFF  00,40
....................    Xd *= kx; // умножение на поправочный коэффициент из ПЗУ 
1D64:  MOVFF  43,CB
1D68:  MOVFF  42,CA
1D6C:  MOVFF  41,C9
1D70:  MOVFF  40,C8
1D74:  MOVFF  4F,CF
1D78:  MOVFF  4E,CE
1D7C:  MOVFF  4D,CD
1D80:  MOVFF  4C,CC
1D84:  CALL   0EE0
1D88:  MOVFF  03,43
1D8C:  MOVFF  02,42
1D90:  MOVFF  01,41
1D94:  MOVFF  00,40
....................    Yd = average_Yg * 0.0039550781252; 
1D98:  MOVFF  32,A5
1D9C:  MOVFF  31,A4
1DA0:  MOVFF  30,A3
1DA4:  MOVFF  2F,A2
1DA8:  RCALL  1AFE
1DAA:  MOVFF  03,CB
1DAE:  MOVFF  02,CA
1DB2:  MOVFF  01,C9
1DB6:  MOVFF  00,C8
1DBA:  MOVLW  9A
1DBC:  MOVWF  xCF
1DBE:  MOVLW  99
1DC0:  MOVWF  xCE
1DC2:  MOVLW  01
1DC4:  MOVWF  xCD
1DC6:  MOVLW  77
1DC8:  MOVWF  xCC
1DCA:  CALL   0EE0
1DCE:  MOVFF  03,47
1DD2:  MOVFF  02,46
1DD6:  MOVFF  01,45
1DDA:  MOVFF  00,44
....................    Yd *= ky; // умножение на поправочный коэффициент из ПЗУ 
1DDE:  MOVFF  47,CB
1DE2:  MOVFF  46,CA
1DE6:  MOVFF  45,C9
1DEA:  MOVFF  44,C8
1DEE:  MOVFF  53,CF
1DF2:  MOVFF  52,CE
1DF6:  MOVFF  51,CD
1DFA:  MOVFF  50,CC
1DFE:  CALL   0EE0
1E02:  MOVFF  03,47
1E06:  MOVFF  02,46
1E0A:  MOVFF  01,45
1E0E:  MOVFF  00,44
....................    Zd = average_Zg * 0.0039550781252; 
1E12:  MOVFF  36,A5
1E16:  MOVFF  35,A4
1E1A:  MOVFF  34,A3
1E1E:  MOVFF  33,A2
1E22:  RCALL  1AFE
1E24:  MOVFF  03,CB
1E28:  MOVFF  02,CA
1E2C:  MOVFF  01,C9
1E30:  MOVFF  00,C8
1E34:  MOVLW  9A
1E36:  MOVWF  xCF
1E38:  MOVLW  99
1E3A:  MOVWF  xCE
1E3C:  MOVLW  01
1E3E:  MOVWF  xCD
1E40:  MOVLW  77
1E42:  MOVWF  xCC
1E44:  CALL   0EE0
1E48:  MOVFF  03,4B
1E4C:  MOVFF  02,4A
1E50:  MOVFF  01,49
1E54:  MOVFF  00,48
....................    Zd *= -kz; // умножение на поправочный коэффициент из ПЗУ 
1E58:  MOVFF  54,00
1E5C:  MOVF   55,W
1E5E:  XORLW  80
1E60:  MOVWF  01
1E62:  MOVFF  56,02
1E66:  MOVFF  57,03
1E6A:  MOVFF  4B,CB
1E6E:  MOVFF  4A,CA
1E72:  MOVFF  49,C9
1E76:  MOVFF  48,C8
1E7A:  MOVFF  57,CF
1E7E:  MOVFF  56,CE
1E82:  MOVWF  xCD
1E84:  MOVFF  54,CC
1E88:  CALL   0EE0
1E8C:  MOVFF  03,4B
1E90:  MOVFF  02,4A
1E94:  MOVFF  01,49
1E98:  MOVFF  00,48
....................    // вручную изменили направление оси Z для приведения систем координат 
....................    // обоих датчиков к единой 
....................  
....................     
....................    // Значения поля Bx, By, Bz выводятся согласно пожеланию заказчика // 
....................  
....................    Printf ("x%05Ldh\n", ( (S32) (Xd * 1000))); // Zd отправка на ПК значений поля в Гс 
1E9C:  MOVFF  43,CB
1EA0:  MOVFF  42,CA
1EA4:  MOVFF  41,C9
1EA8:  MOVFF  40,C8
1EAC:  CLRF   xCF
1EAE:  CLRF   xCE
1EB0:  MOVLW  7A
1EB2:  MOVWF  xCD
1EB4:  MOVLW  88
1EB6:  MOVWF  xCC
1EB8:  CALL   0EE0
1EBC:  MOVFF  03,A5
1EC0:  MOVFF  02,A4
1EC4:  MOVFF  01,A3
1EC8:  MOVFF  00,A2
1ECC:  CALL   0FD2
1ED0:  MOVFF  03,A5
1ED4:  MOVFF  02,A4
1ED8:  MOVFF  01,A3
1EDC:  MOVFF  00,A2
1EE0:  MOVLW  78
1EE2:  BTFSS  F9E.4
1EE4:  BRA    1EE2
1EE6:  MOVWF  FAD
1EE8:  MOVLW  45
1EEA:  MOVWF  FE9
1EEC:  MOVFF  A5,A9
1EF0:  MOVFF  A4,A8
1EF4:  MOVFF  A3,A7
1EF8:  MOVFF  A2,A6
1EFC:  RCALL  1B54
1EFE:  MOVLW  68
1F00:  BTFSS  F9E.4
1F02:  BRA    1F00
1F04:  MOVWF  FAD
1F06:  MOVLW  0A
1F08:  BTFSS  F9E.4
1F0A:  BRA    1F08
1F0C:  MOVWF  FAD
....................    Printf ("y%05Ldh\n", ( (S32) (Yd * 1000))); //  
1F0E:  MOVFF  47,CB
1F12:  MOVFF  46,CA
1F16:  MOVFF  45,C9
1F1A:  MOVFF  44,C8
1F1E:  CLRF   xCF
1F20:  CLRF   xCE
1F22:  MOVLW  7A
1F24:  MOVWF  xCD
1F26:  MOVLW  88
1F28:  MOVWF  xCC
1F2A:  CALL   0EE0
1F2E:  MOVFF  03,A5
1F32:  MOVFF  02,A4
1F36:  MOVFF  01,A3
1F3A:  MOVFF  00,A2
1F3E:  CALL   0FD2
1F42:  MOVFF  03,A5
1F46:  MOVFF  02,A4
1F4A:  MOVFF  01,A3
1F4E:  MOVFF  00,A2
1F52:  MOVLW  79
1F54:  BTFSS  F9E.4
1F56:  BRA    1F54
1F58:  MOVWF  FAD
1F5A:  MOVLW  45
1F5C:  MOVWF  FE9
1F5E:  MOVFF  A5,A9
1F62:  MOVFF  A4,A8
1F66:  MOVFF  A3,A7
1F6A:  MOVFF  A2,A6
1F6E:  RCALL  1B54
1F70:  MOVLW  68
1F72:  BTFSS  F9E.4
1F74:  BRA    1F72
1F76:  MOVWF  FAD
1F78:  MOVLW  0A
1F7A:  BTFSS  F9E.4
1F7C:  BRA    1F7A
1F7E:  MOVWF  FAD
....................    Printf ("z%05Ldh\n", ( (S32) (Zd * 1000))); // Zd 
1F80:  MOVFF  4B,CB
1F84:  MOVFF  4A,CA
1F88:  MOVFF  49,C9
1F8C:  MOVFF  48,C8
1F90:  CLRF   xCF
1F92:  CLRF   xCE
1F94:  MOVLW  7A
1F96:  MOVWF  xCD
1F98:  MOVLW  88
1F9A:  MOVWF  xCC
1F9C:  CALL   0EE0
1FA0:  MOVFF  03,A5
1FA4:  MOVFF  02,A4
1FA8:  MOVFF  01,A3
1FAC:  MOVFF  00,A2
1FB0:  CALL   0FD2
1FB4:  MOVFF  03,A5
1FB8:  MOVFF  02,A4
1FBC:  MOVFF  01,A3
1FC0:  MOVFF  00,A2
1FC4:  MOVLW  7A
1FC6:  BTFSS  F9E.4
1FC8:  BRA    1FC6
1FCA:  MOVWF  FAD
1FCC:  MOVLW  45
1FCE:  MOVWF  FE9
1FD0:  MOVFF  A5,A9
1FD4:  MOVFF  A4,A8
1FD8:  MOVFF  A3,A7
1FDC:  MOVFF  A2,A6
1FE0:  RCALL  1B54
1FE2:  MOVLW  68
1FE4:  BTFSS  F9E.4
1FE6:  BRA    1FE4
1FE8:  MOVWF  FAD
1FEA:  MOVLW  0A
1FEC:  BTFSS  F9E.4
1FEE:  BRA    1FEC
1FF0:  MOVWF  FAD
....................    LcdSetCursor (one); 
1FF2:  CLRF   xBE
1FF4:  CALL   0694
....................    LcdMsg ("Bx = "); 
1FF8:  MOVLW  36
1FFA:  MOVWF  FF6
1FFC:  MOVLW  01
1FFE:  MOVWF  FF7
2000:  CALL   0674
....................    LcdPutS16 (Xd * 1000, 4); // zd 
2004:  MOVFF  43,CB
2008:  MOVFF  42,CA
200C:  MOVFF  41,C9
2010:  MOVFF  40,C8
2014:  CLRF   xCF
2016:  CLRF   xCE
2018:  MOVLW  7A
201A:  MOVWF  xCD
201C:  MOVLW  88
201E:  MOVWF  xCC
2020:  CALL   0EE0
2024:  MOVFF  03,C1
2028:  MOVFF  02,C0
202C:  MOVFF  01,BF
2030:  MOVFF  00,BE
2034:  CALL   1578
2038:  MOVFF  02,A3
203C:  MOVFF  01,A2
2040:  MOVFF  02,A5
2044:  MOVFF  01,A4
2048:  MOVLW  04
204A:  MOVWF  xA6
204C:  CALL   1224
....................    LcdMsg (" Гс. "); 
2050:  MOVLW  3C
2052:  MOVWF  FF6
2054:  MOVLW  01
2056:  MOVWF  FF7
2058:  CALL   0674
....................    LcdSetCursor (two); 
205C:  MOVLW  40
205E:  MOVWF  xBE
2060:  CALL   0694
....................    LcdMsg ("By = "); 
2064:  MOVLW  42
2066:  MOVWF  FF6
2068:  MOVLW  01
206A:  MOVWF  FF7
206C:  CALL   0674
....................    LcdPutS16 (Yd * 1000, 4); 
2070:  MOVFF  47,CB
2074:  MOVFF  46,CA
2078:  MOVFF  45,C9
207C:  MOVFF  44,C8
2080:  CLRF   xCF
2082:  CLRF   xCE
2084:  MOVLW  7A
2086:  MOVWF  xCD
2088:  MOVLW  88
208A:  MOVWF  xCC
208C:  CALL   0EE0
2090:  MOVFF  03,C1
2094:  MOVFF  02,C0
2098:  MOVFF  01,BF
209C:  MOVFF  00,BE
20A0:  CALL   1578
20A4:  MOVFF  02,A3
20A8:  MOVFF  01,A2
20AC:  MOVFF  02,A5
20B0:  MOVFF  01,A4
20B4:  MOVLW  04
20B6:  MOVWF  xA6
20B8:  CALL   1224
....................    LcdMsg (" Гс. "); 
20BC:  MOVLW  48
20BE:  MOVWF  FF6
20C0:  MOVLW  01
20C2:  MOVWF  FF7
20C4:  CALL   0674
....................    LcdSetCursor (three); 
20C8:  MOVLW  10
20CA:  MOVWF  xBE
20CC:  CALL   0694
....................    LcdMsg ("Bz = "); 
20D0:  MOVLW  4E
20D2:  MOVWF  FF6
20D4:  MOVLW  01
20D6:  MOVWF  FF7
20D8:  CALL   0674
....................    LcdPutS16 (Zd * 1000, 4); // Xd 
20DC:  MOVFF  4B,CB
20E0:  MOVFF  4A,CA
20E4:  MOVFF  49,C9
20E8:  MOVFF  48,C8
20EC:  CLRF   xCF
20EE:  CLRF   xCE
20F0:  MOVLW  7A
20F2:  MOVWF  xCD
20F4:  MOVLW  88
20F6:  MOVWF  xCC
20F8:  CALL   0EE0
20FC:  MOVFF  03,C1
2100:  MOVFF  02,C0
2104:  MOVFF  01,BF
2108:  MOVFF  00,BE
210C:  CALL   1578
2110:  MOVFF  02,A3
2114:  MOVFF  01,A2
2118:  MOVFF  02,A5
211C:  MOVFF  01,A4
2120:  MOVLW  04
2122:  MOVWF  xA6
2124:  CALL   1224
....................    LcdMsg (" Гс. "); 
2128:  MOVLW  54
212A:  MOVWF  FF6
212C:  MOVLW  01
212E:  MOVWF  FF7
2130:  CALL   0674
....................    int_fl = false; 
2134:  BCF    1A.0
2136:  GOTO   28CA (RETURN)
.................... } 
....................  
.................... //****************** Sensor 1 funcs ************************************ 
....................  
.................... //////////////////// Sensor 2 funcs ////////////////////////////////////   
....................  void TLV493D_reset() 
.................... { 
....................     i2c_start(); 
*
1434:  BSF    F94.4
1436:  NOP   
1438:  BSF    F94.3
143A:  NOP   
143C:  BCF    F8B.4
143E:  BCF    F94.4
1440:  NOP   
1442:  BCF    F8B.3
1444:  BCF    F94.3
1446:  CLRF   16
1448:  BTFSC  FF2.7
144A:  BSF    16.7
144C:  BCF    FF2.7
....................     i2c_write (0x00);  
144E:  CLRF   xE1
1450:  CALL   0196
1454:  BTFSC  16.7
1456:  BSF    FF2.7
....................     i2c_stop(); 
1458:  BCF    F94.4
145A:  NOP   
145C:  BSF    F94.3
145E:  BTFSS  F82.3
1460:  BRA    145E
1462:  NOP   
1464:  BRA    1466
1466:  NOP   
1468:  BSF    F94.4
146A:  NOP   
146C:  GOTO   182E (RETURN)
.................... } 
....................   
....................  U8 TLV493D_init() 
*
0986:  CLRF   xBF
0988:  CLRF   xBE
098A:  CLRF   xC1
098C:  CLRF   xC0
098E:  CLRF   xC3
0990:  CLRF   xC2
.................... { 
.................... //!      // после вкл. питания требуется считать значения регистров 7, 8, 9 датчика 
.................... //!      // для дальнейшей записи этих значений в конфигурационные регистры. 
.................... //! 
....................        S16 reg7data = 0;    // переменные для сохр. заводских настроек датчика 
....................        S16 reg8data = 0; 
....................        S16 reg9data = 0; 
....................  
.................... //!      //------- 1 этап - чтение заводской конфигурации датчика -------//  
....................        
....................        i2c_start (); 
0992:  BSF    F94.4
0994:  NOP   
0996:  BSF    F94.3
0998:  NOP   
099A:  BCF    F8B.4
099C:  BCF    F94.4
099E:  NOP   
09A0:  BCF    F8B.3
09A2:  BCF    F94.3
09A4:  CLRF   16
09A6:  BTFSC  FF2.7
09A8:  BSF    16.7
09AA:  BCF    FF2.7
....................        i2c_write (TLV493D_rd_addr); // чтение регистров 
09AC:  MOVLW  BD
09AE:  MOVWF  xE1
09B0:  CALL   0196
09B4:  BTFSC  16.7
09B6:  BSF    FF2.7
....................        i2c_read();           // Bx (0H) 
09B8:  MOVLW  01
09BA:  MOVWF  00
09BC:  CLRF   16
09BE:  BTFSC  FF2.7
09C0:  BSF    16.7
09C2:  BCF    FF2.7
09C4:  RCALL  01DE
09C6:  BTFSC  16.7
09C8:  BSF    FF2.7
....................        i2c_read();           // By (1H) 
09CA:  MOVLW  01
09CC:  MOVWF  00
09CE:  CLRF   16
09D0:  BTFSC  FF2.7
09D2:  BSF    16.7
09D4:  BCF    FF2.7
09D6:  RCALL  01DE
09D8:  BTFSC  16.7
09DA:  BSF    FF2.7
....................        i2c_read();           // Bz (2H) 
09DC:  MOVLW  01
09DE:  MOVWF  00
09E0:  CLRF   16
09E2:  BTFSC  FF2.7
09E4:  BSF    16.7
09E6:  BCF    FF2.7
09E8:  CALL   01DE
09EC:  BTFSC  16.7
09EE:  BSF    FF2.7
....................         
....................        i2c_read();           // Temp (3H) Temp. (11…8) FRM CH 
09F0:  MOVLW  01
09F2:  MOVWF  00
09F4:  CLRF   16
09F6:  BTFSC  FF2.7
09F8:  BSF    16.7
09FA:  BCF    FF2.7
09FC:  CALL   01DE
0A00:  BTFSC  16.7
0A02:  BSF    FF2.7
....................        i2c_read();           // Bx2 (4H)  Bx (3…0) By (3…0) 
0A04:  MOVLW  01
0A06:  MOVWF  00
0A08:  CLRF   16
0A0A:  BTFSC  FF2.7
0A0C:  BSF    16.7
0A0E:  BCF    FF2.7
0A10:  CALL   01DE
0A14:  BTFSC  16.7
0A16:  BSF    FF2.7
....................        i2c_read();           // Bz2 (5H) 
0A18:  MOVLW  01
0A1A:  MOVWF  00
0A1C:  CLRF   16
0A1E:  BTFSC  FF2.7
0A20:  BSF    16.7
0A22:  BCF    FF2.7
0A24:  CALL   01DE
0A28:  BTFSC  16.7
0A2A:  BSF    FF2.7
....................         
....................        i2c_read();                      // Temp2 (6H) 
0A2C:  MOVLW  01
0A2E:  MOVWF  00
0A30:  CLRF   16
0A32:  BTFSC  FF2.7
0A34:  BSF    16.7
0A36:  BCF    FF2.7
0A38:  CALL   01DE
0A3C:  BTFSC  16.7
0A3E:  BSF    FF2.7
....................        reg7data = i2c_read();           // FactSet1 (7H) 
0A40:  MOVLW  01
0A42:  MOVWF  00
0A44:  CLRF   16
0A46:  BTFSC  FF2.7
0A48:  BSF    16.7
0A4A:  BCF    FF2.7
0A4C:  CALL   01DE
0A50:  BTFSC  16.7
0A52:  BSF    FF2.7
0A54:  MOVF   01,W
0A56:  CLRF   03
0A58:  MOVWF  xBE
0A5A:  MOVFF  03,BF
....................        reg8data = i2c_read();           // FactSet2 (8H) 
0A5E:  MOVLW  01
0A60:  MOVWF  00
0A62:  CLRF   16
0A64:  BTFSC  FF2.7
0A66:  BSF    16.7
0A68:  BCF    FF2.7
0A6A:  CALL   01DE
0A6E:  BTFSC  16.7
0A70:  BSF    FF2.7
0A72:  MOVF   01,W
0A74:  CLRF   03
0A76:  MOVWF  xC0
0A78:  MOVFF  03,C1
....................        reg9data = i2c_read();           // FactSet3 (9H) 
0A7C:  MOVLW  01
0A7E:  MOVWF  00
0A80:  CLRF   16
0A82:  BTFSC  FF2.7
0A84:  BSF    16.7
0A86:  BCF    FF2.7
0A88:  CALL   01DE
0A8C:  BTFSC  16.7
0A8E:  BSF    FF2.7
0A90:  MOVF   01,W
0A92:  CLRF   03
0A94:  MOVWF  xC2
0A96:  MOVFF  03,C3
....................        i2c_stop (); 
0A9A:  BCF    F94.4
0A9C:  NOP   
0A9E:  BSF    F94.3
0AA0:  BTFSS  F82.3
0AA2:  BRA    0AA0
0AA4:  NOP   
0AA6:  BRA    0AA8
0AA8:  NOP   
0AAA:  BSF    F94.4
0AAC:  NOP   
....................  
.................... //!      // инициализация датчика  
.................... //!      // данные магнитного поля обновляются сразу после их чтения микроконтроллером,  
.................... //!      // режим master-controlled 
.................... //!      // так, частота измерений зависит от частоты чтения показаний датчика, не более 3.3 кГц 
.................... //!     
....................        i2c_start (); 
0AAE:  BSF    F94.4
0AB0:  NOP   
0AB2:  BSF    F94.3
0AB4:  NOP   
0AB6:  BCF    F8B.4
0AB8:  BCF    F94.4
0ABA:  NOP   
0ABC:  BCF    F8B.3
0ABE:  BCF    F94.3
0AC0:  CLRF   16
0AC2:  BTFSC  FF2.7
0AC4:  BSF    16.7
0AC6:  BCF    FF2.7
....................        i2c_write (TLV493D_wr_addr); //  запись конфигурации 
0AC8:  MOVLW  BC
0ACA:  MOVWF  xE1
0ACC:  CALL   0196
0AD0:  BTFSC  16.7
0AD2:  BSF    FF2.7
0AD4:  CLRF   16
0AD6:  BTFSC  FF2.7
0AD8:  BSF    16.7
0ADA:  BCF    FF2.7
....................        i2c_write (0x00);            //  Reg 0, Reserved register, must write 0's 
0ADC:  CLRF   xE1
0ADE:  CALL   0196
0AE2:  BTFSC  16.7
0AE4:  BSF    FF2.7
....................         
....................        i2c_write( 0 << 7 |          //  Reg 1, parity disabled in Reg3 
....................                   0 << 5 |          //  define the slave address, dont use, ADDR = 1, pulled high on PCB   
....................  ((reg7data & 0x18) << 3)|          //  Bits must correspond to bits 4:3 from read register 7H 
....................                   0 << 2 |          //  If "0" INT (interrupt pulse) disabled 
....................                   1 << 1 |          //  If "1" fast mode enabled 
....................                         1);         //  If "1" - Low power mode, f = 100 Hz 
0AE6:  MOVF   xBE,W
0AE8:  ANDLW  18
0AEA:  MOVWF  xC4
0AEC:  CLRF   xC5
0AEE:  RLCF   xC4,W
0AF0:  MOVWF  02
0AF2:  RLCF   xC5,W
0AF4:  MOVWF  03
0AF6:  RLCF   02,F
0AF8:  RLCF   03,F
0AFA:  RLCF   02,F
0AFC:  RLCF   03,F
0AFE:  MOVLW  F8
0B00:  ANDWF  02,F
0B02:  MOVFF  02,C4
0B06:  MOVFF  03,C5
0B0A:  BSF    xC4.1
0B0C:  BSF    xC4.0
0B0E:  CLRF   16
0B10:  BTFSC  FF2.7
0B12:  BSF    16.7
0B14:  BCF    FF2.7
0B16:  MOVFF  C4,E1
0B1A:  CALL   0196
0B1E:  BTFSC  16.7
0B20:  BSF    FF2.7
0B22:  CLRF   16
0B24:  BTFSC  FF2.7
0B26:  BSF    16.7
0B28:  BCF    FF2.7
....................                    
....................                    
....................        i2c_write(reg8data);         //  Reg 2, Bits must correspond to bits 7:0 from read register 8H 
0B2A:  MOVFF  C0,E1
0B2E:  CALL   0196
0B32:  BTFSC  16.7
0B34:  BSF    FF2.7
....................         
....................        i2c_write( 1 << 7 |          //  Reg 3, temperature measurement disabled 
....................                   1 << 6 |          //  If '1' period is 12ms, if '0' period is 100ms      
....................                   0 << 5 |          //  If "0" parity test disabled 
....................           (reg9data & 0x1f));       //  Bits must correspond to bits 4:0 from read register 9H.         
0B36:  MOVF   xC2,W
0B38:  ANDLW  1F
0B3A:  MOVWF  00
0B3C:  CLRF   03
0B3E:  MOVF   00,W
0B40:  IORLW  C0
0B42:  MOVWF  xC4
0B44:  MOVFF  03,C5
0B48:  CLRF   16
0B4A:  BTFSC  FF2.7
0B4C:  BSF    16.7
0B4E:  BCF    FF2.7
0B50:  MOVWF  xE1
0B52:  CALL   0196
0B56:  BTFSC  16.7
0B58:  BSF    FF2.7
....................        i2c_stop (); 
0B5A:  BCF    F94.4
0B5C:  NOP   
0B5E:  BSF    F94.3
0B60:  BTFSS  F82.3
0B62:  BRA    0B60
0B64:  NOP   
0B66:  BRA    0B68
0B68:  NOP   
0B6A:  BSF    F94.4
0B6C:  NOP   
....................         
....................        if (reg8data < 0xff) return 1; 
0B6E:  BTFSC  xC1.7
0B70:  BRA    0B7C
0B72:  MOVF   xC1,F
0B74:  BNZ   0B84
0B76:  MOVF   xC0,W
0B78:  SUBLW  FE
0B7A:  BNC   0B84
0B7C:  MOVLW  01
0B7E:  MOVWF  01
0B80:  BRA    0B88
0B82:  BRA    0B88
....................        else return 0; 
0B84:  MOVLW  00
0B86:  MOVWF  01
0B88:  RETURN 0
.................... } 
....................  
....................  float TLV493D_calc_field (S16 nibble_h, S16 nibble_l) 
*
14BA:  CLRF   xC3
14BC:  CLRF   xC2
14BE:  CLRF   xC7
14C0:  CLRF   xC6
14C2:  CLRF   xC5
14C4:  CLRF   xC4
....................  { 
....................       // расчет величины магнитного поля по оси X датчика 
....................       // nibble_h - MSB, nibble_l содержит младший полубайт данных оси Х 
....................           
....................       S16 fi = 0;          // для хранения отсчетов магнитного поля 
....................       float fl = 0;        // для хранения магнитного поля в Гс 
....................        
....................       fi = (nibble_h << 4) | nibble_l; 
14C6:  RLCF   xBE,W
14C8:  MOVWF  xC8
14CA:  RLCF   xBF,W
14CC:  MOVWF  xC9
14CE:  RLCF   xC8,F
14D0:  RLCF   xC9,F
14D2:  RLCF   xC8,F
14D4:  RLCF   xC9,F
14D6:  RLCF   xC8,F
14D8:  RLCF   xC9,F
14DA:  MOVLW  F0
14DC:  ANDWF  xC8,F
14DE:  MOVF   xC8,W
14E0:  IORWF  xC0,W
14E2:  MOVWF  xC2
14E4:  MOVF   xC9,W
14E6:  IORWF  xC1,W
14E8:  MOVWF  xC3
....................       if ( fi >= 2048)   fi = fi - 4096;  // Interpret bit 12 as +/-  
14EA:  BTFSC  xC3.7
14EC:  BRA    14FC
14EE:  MOVF   xC3,W
14F0:  SUBLW  07
14F2:  BC    14FC
14F4:  MOVLW  00
14F6:  SUBWF  xC2,F
14F8:  MOVLW  10
14FA:  SUBWFB xC3,F
....................        
....................       // LSB = 0.098 mT -> 0.98 Gs 
....................       fl = fi * 0.098;    // перевод из отсчетов АЦП в mT 
14FC:  MOVFF  C3,C9
1500:  MOVFF  C2,C8
1504:  BRA    1470
1506:  MOVFF  03,CB
150A:  MOVFF  02,CA
150E:  MOVFF  01,C9
1512:  MOVFF  00,C8
1516:  MOVLW  39
1518:  MOVWF  xCF
151A:  MOVLW  B4
151C:  MOVWF  xCE
151E:  MOVLW  48
1520:  MOVWF  xCD
1522:  MOVLW  7B
1524:  MOVWF  xCC
1526:  RCALL  0EE0
1528:  MOVFF  03,C7
152C:  MOVFF  02,C6
1530:  MOVFF  01,C5
1534:  MOVFF  00,C4
....................       fl *= 10;           // перевод из mT в Гауссы 
1538:  MOVFF  C7,CB
153C:  MOVFF  C6,CA
1540:  MOVFF  C5,C9
1544:  MOVFF  C4,C8
1548:  CLRF   xCF
154A:  CLRF   xCE
154C:  MOVLW  20
154E:  MOVWF  xCD
1550:  MOVLW  82
1552:  MOVWF  xCC
1554:  RCALL  0EE0
1556:  MOVFF  03,C7
155A:  MOVFF  02,C6
155E:  MOVFF  01,C5
1562:  MOVFF  00,C4
....................        
....................       return fl; 
1566:  MOVFF  C4,00
156A:  MOVFF  C5,01
156E:  MOVFF  C6,02
1572:  MOVFF  C7,03
1576:  RETURN 0
....................  
....................   } 
....................   
....................  U8 TLV493D_rd_all(U8 coord_sys) 
*
16C8:  CLRF   xA8
16CA:  CLRF   xA7
16CC:  CLRF   xAE
16CE:  CLRF   xAD
16D0:  CLRF   xB4
16D2:  CLRF   xB3
16D4:  CLRF   xBA
16D6:  CLRF   xB9
16D8:  CLRF   xBC
16DA:  CLRF   xBB
....................  { 
....................          
....................        S16 xh, yh, zh = 0;  // ст. байты данных 
....................        S16 xl, yl, zl = 0;  // мл. полубайты 
....................        S16 bz2, bx2by2, frame_ctr = 0; // регистры датчика 
....................        S16 x, y, z = 0; 
....................        S16 coodr_buf = 0; 
....................  
....................        U8 status; // 1 - чтение ок, 0 - ошибка чтения, 2 - требуется инициализация 
....................   
....................         // чтение данных 
....................        i2c_start (); 
16DC:  BSF    F94.4
16DE:  NOP   
16E0:  BSF    F94.3
16E2:  NOP   
16E4:  BCF    F8B.4
16E6:  BCF    F94.4
16E8:  NOP   
16EA:  BCF    F8B.3
16EC:  BCF    F94.3
16EE:  CLRF   16
16F0:  BTFSC  FF2.7
16F2:  BSF    16.7
16F4:  BCF    FF2.7
....................       
....................        i2c_write (TLV493D_rd_addr);     // чтение регистров 
16F6:  MOVLW  BD
16F8:  MOVWF  xE1
16FA:  CALL   0196
16FE:  BTFSC  16.7
1700:  BSF    FF2.7
....................        xh = i2c_read();                 // Bx (0H) 
1702:  MOVLW  01
1704:  MOVWF  00
1706:  CLRF   16
1708:  BTFSC  FF2.7
170A:  BSF    16.7
170C:  BCF    FF2.7
170E:  CALL   01DE
1712:  BTFSC  16.7
1714:  BSF    FF2.7
1716:  MOVF   01,W
1718:  CLRF   03
171A:  MOVWF  xA3
171C:  MOVFF  03,A4
....................        yh = i2c_read();                 // By (1H) 
1720:  MOVLW  01
1722:  MOVWF  00
1724:  CLRF   16
1726:  BTFSC  FF2.7
1728:  BSF    16.7
172A:  BCF    FF2.7
172C:  CALL   01DE
1730:  BTFSC  16.7
1732:  BSF    FF2.7
1734:  MOVF   01,W
1736:  CLRF   03
1738:  MOVWF  xA5
173A:  MOVFF  03,A6
....................        zh = i2c_read();                 // Bz (2H) 
173E:  MOVLW  01
1740:  MOVWF  00
1742:  CLRF   16
1744:  BTFSC  FF2.7
1746:  BSF    16.7
1748:  BCF    FF2.7
174A:  CALL   01DE
174E:  BTFSC  16.7
1750:  BSF    FF2.7
1752:  MOVF   01,W
1754:  CLRF   03
1756:  MOVWF  xA7
1758:  MOVFF  03,A8
....................         
....................        frame_ctr = i2c_read();          // Temp (3H) Temp. (11…8) FRM CH 
175C:  MOVLW  01
175E:  MOVWF  00
1760:  CLRF   16
1762:  BTFSC  FF2.7
1764:  BSF    16.7
1766:  BCF    FF2.7
1768:  CALL   01DE
176C:  BTFSC  16.7
176E:  BSF    FF2.7
1770:  MOVF   01,W
1772:  CLRF   03
1774:  MOVWF  xB3
1776:  MOVFF  03,B4
....................        bx2by2 = i2c_read();             // Bx2 (4H)  Bx (3…0) By (3…0) 
177A:  MOVLW  01
177C:  MOVWF  00
177E:  CLRF   16
1780:  BTFSC  FF2.7
1782:  BSF    16.7
1784:  BCF    FF2.7
1786:  CALL   01DE
178A:  BTFSC  16.7
178C:  BSF    FF2.7
178E:  MOVF   01,W
1790:  CLRF   03
1792:  MOVWF  xB1
1794:  MOVFF  03,B2
....................        bz2 = i2c_read();                // Bz2 (5H) 
1798:  MOVLW  01
179A:  MOVWF  00
179C:  CLRF   16
179E:  BTFSC  FF2.7
17A0:  BSF    16.7
17A2:  BCF    FF2.7
17A4:  CALL   01DE
17A8:  BTFSC  16.7
17AA:  BSF    FF2.7
17AC:  MOVF   01,W
17AE:  CLRF   03
17B0:  MOVWF  xAF
17B2:  MOVFF  03,B0
....................       
....................        i2c_read();                      // вычитывать необходимо все 10 регистров 
17B6:  MOVLW  01
17B8:  MOVWF  00
17BA:  CLRF   16
17BC:  BTFSC  FF2.7
17BE:  BSF    16.7
17C0:  BCF    FF2.7
17C2:  CALL   01DE
17C6:  BTFSC  16.7
17C8:  BSF    FF2.7
....................        i2c_read();  
17CA:  MOVLW  01
17CC:  MOVWF  00
17CE:  CLRF   16
17D0:  BTFSC  FF2.7
17D2:  BSF    16.7
17D4:  BCF    FF2.7
17D6:  CALL   01DE
17DA:  BTFSC  16.7
17DC:  BSF    FF2.7
....................        i2c_read();  
17DE:  MOVLW  01
17E0:  MOVWF  00
17E2:  CLRF   16
17E4:  BTFSC  FF2.7
17E6:  BSF    16.7
17E8:  BCF    FF2.7
17EA:  CALL   01DE
17EE:  BTFSC  16.7
17F0:  BSF    FF2.7
....................        i2c_read();  
17F2:  MOVLW  01
17F4:  MOVWF  00
17F6:  CLRF   16
17F8:  BTFSC  FF2.7
17FA:  BSF    16.7
17FC:  BCF    FF2.7
17FE:  CALL   01DE
1802:  BTFSC  16.7
1804:  BSF    FF2.7
....................       
....................        i2c_stop (); 
1806:  BCF    F94.4
1808:  NOP   
180A:  BSF    F94.3
180C:  BTFSS  F82.3
180E:  BRA    180C
1810:  NOP   
1812:  BRA    1814
1814:  NOP   
1816:  BSF    F94.4
1818:  NOP   
....................         
....................        if(frame_ctr == 0xff) status = 0; // датчик не подкл 
181A:  INCFSZ xB3,W
181C:  BRA    1826
181E:  MOVF   xB4,F
1820:  BNZ   1826
1822:  CLRF   xBD
1824:  BRA    1AF6
....................         
....................        // сравнение старого значения счетчика измерений с новым 
....................        else if(TLV493D_frm_cnt == (U8)frame_ctr)  
1826:  MOVF   xB3,W
1828:  SUBWF  x88,W
182A:  BNZ   1834
....................        {// датчик заклинило 
....................          TLV493D_reset(); // сброс состояния датчика 
182C:  BRA    1434
....................          TLV493D_init();  // инициализация 
182E:  CALL   0986
....................        } 
1832:  BRA    1AF6
....................         
....................        else                                  // подключен, все ок 
....................        { 
....................          TLV493D_frm_cnt = frame_ctr;   // сохр. нового значения счетчика измерений 
1834:  MOVFF  B3,88
....................           
....................          xl = bx2by2 >> 4;      // получение мл. полубайта значений по оси Х  
1838:  RRCF   xB2,W
183A:  MOVWF  03
183C:  RRCF   xB1,W
183E:  MOVWF  02
1840:  RRCF   03,F
1842:  RRCF   02,F
1844:  RRCF   03,F
1846:  RRCF   02,F
1848:  RRCF   03,F
184A:  RRCF   02,F
184C:  MOVLW  0F
184E:  ANDWF  03,F
1850:  MOVFF  02,A9
1854:  MOVFF  03,AA
....................          yl = bx2by2 & 0x0f;    // получение мл. полубайта значений по оси Y  
1858:  MOVF   xB1,W
185A:  ANDLW  0F
185C:  MOVWF  xAB
185E:  CLRF   xAC
....................          zl = bz2 & 0x0f;       // получение мл. полубайта значений по оси Z   
1860:  MOVF   xAF,W
1862:  ANDLW  0F
1864:  MOVWF  xAD
1866:  CLRF   xAE
....................         
....................          x = (S16)(kx * TLV493D_calc_field(xh, xl));    // передача в функцию ст. и мл. байт для расчета поля по X 
1868:  MOVFF  A4,BF
186C:  MOVFF  A3,BE
1870:  MOVFF  AA,C1
1874:  MOVFF  A9,C0
1878:  RCALL  14BA
187A:  MOVFF  4F,CB
187E:  MOVFF  4E,CA
1882:  MOVFF  4D,C9
1886:  MOVFF  4C,C8
188A:  MOVFF  03,CF
188E:  MOVFF  02,CE
1892:  MOVFF  01,CD
1896:  MOVFF  00,CC
189A:  CALL   0EE0
189E:  MOVFF  03,C1
18A2:  MOVFF  02,C0
18A6:  MOVFF  01,BF
18AA:  MOVFF  00,BE
18AE:  RCALL  1578
18B0:  MOVFF  02,B6
18B4:  MOVFF  01,B5
....................          y = (S16)(ky * TLV493D_calc_field(yh, yl));    // передача в функцию ст. и мл. байт для расчета поля по Y 
18B8:  MOVFF  A6,BF
18BC:  MOVFF  A5,BE
18C0:  MOVFF  AC,C1
18C4:  MOVFF  AB,C0
18C8:  RCALL  14BA
18CA:  MOVFF  53,CB
18CE:  MOVFF  52,CA
18D2:  MOVFF  51,C9
18D6:  MOVFF  50,C8
18DA:  MOVFF  03,CF
18DE:  MOVFF  02,CE
18E2:  MOVFF  01,CD
18E6:  MOVFF  00,CC
18EA:  CALL   0EE0
18EE:  MOVFF  03,C1
18F2:  MOVFF  02,C0
18F6:  MOVFF  01,BF
18FA:  MOVFF  00,BE
18FE:  RCALL  1578
1900:  MOVFF  02,B8
1904:  MOVFF  01,B7
....................          z = (S16)(kz * TLV493D_calc_field(zh, zl));    // передача в функцию ст. и мл. байт для расчета поля по Z 
1908:  MOVFF  A8,BF
190C:  MOVFF  A7,BE
1910:  MOVFF  AE,C1
1914:  MOVFF  AD,C0
1918:  RCALL  14BA
191A:  MOVFF  57,CB
191E:  MOVFF  56,CA
1922:  MOVFF  55,C9
1926:  MOVFF  54,C8
192A:  MOVFF  03,CF
192E:  MOVFF  02,CE
1932:  MOVFF  01,CD
1936:  MOVFF  00,CC
193A:  CALL   0EE0
193E:  MOVFF  03,C1
1942:  MOVFF  02,C0
1946:  MOVFF  01,BF
194A:  MOVFF  00,BE
194E:  RCALL  1578
1950:  MOVFF  02,BA
1954:  MOVFF  01,B9
....................           
....................          switch(coord_sys)       // анализ выбраной системы координат 
1958:  MOVF   xA2,W
195A:  BZ    1966
195C:  XORLW  01
195E:  BZ    1968
1960:  XORLW  03
1962:  BZ    1982
1964:  BRA    199C
....................          { 
....................             case 0: break;       // по умолчанию, ничего не меняем 
1966:  BRA    199C
....................             //===== 
....................             case 1:              // 1 вариант изменения системы координат 
....................                coodr_buf = x;    // поворот правой тройки вниз 
1968:  MOVFF  B6,BC
196C:  MOVFF  B5,BB
....................                x = z; 
1970:  MOVFF  BA,B6
1974:  MOVFF  B9,B5
....................                z = coodr_buf; 
1978:  MOVFF  BC,BA
197C:  MOVFF  BB,B9
....................                break;        
1980:  BRA    199C
....................             //===== 
....................             case 2:              // 2 вариант изменения системы координат 
....................                coodr_buf = y;    // поворот правой тройки влево 
1982:  MOVFF  B8,BC
1986:  MOVFF  B7,BB
....................                y = z; 
198A:  MOVFF  BA,B8
198E:  MOVFF  B9,B7
....................                z = coodr_buf; 
1992:  MOVFF  BC,BA
1996:  MOVFF  BB,B9
....................                break;        
199A:  BRA    199C
....................             //===== 
....................             default: break; 
....................           
....................          } 
....................           
....................          if (set_zero_fl) 
199C:  BTFSS  1A.2
199E:  BRA    19E0
....................          { 
....................            // утс. 0 
....................        
....................           LCDClear (); 
19A0:  CALL   06A0
....................           Lcdsetcursor (0); 
19A4:  CLRF   xBE
19A6:  CALL   0694
....................           LcdMsg (" Установка нуля "); 
19AA:  MOVLW  5A
19AC:  MOVWF  FF6
19AE:  MOVLW  01
19B0:  MOVWF  FF7
19B2:  CALL   0674
....................           SUMX0 = x;  // сохр. текущего значения магнитного поля 
19B6:  MOVFF  B6,26
19BA:  MOVFF  B5,25
....................           SUMY0 = y; 
19BE:  MOVFF  B8,28
19C2:  MOVFF  B7,27
....................           SUMZ0 = z; 
19C6:  MOVFF  BA,2A
19CA:  MOVFF  B9,29
....................           delay_ms (1000); 
19CE:  MOVLW  04
19D0:  MOVWF  xBE
19D2:  MOVLW  FA
19D4:  MOVWF  xBF
19D6:  CALL   050E
19DA:  DECFSZ xBE,F
19DC:  BRA    19D2
....................           set_zero_fl = 0; 
19DE:  BCF    1A.2
....................          } 
....................           
....................          x = x - SUMX0; // вычет смещение поля 
19E0:  MOVF   25,W
19E2:  SUBWF  xB5,F
19E4:  MOVF   26,W
19E6:  SUBWFB xB6,F
....................          y = y - SUMY0; 
19E8:  MOVF   27,W
19EA:  SUBWF  xB7,F
19EC:  MOVF   28,W
19EE:  SUBWFB xB8,F
....................          z = z - SUMZ0; 
19F0:  MOVF   29,W
19F2:  SUBWF  xB9,F
19F4:  MOVF   2A,W
19F6:  SUBWFB xBA,F
....................           
....................         // отправка на ПК значений поля в Гс 
....................          Printf ("x%05Ldt\n", x);  
19F8:  MOVLW  78
19FA:  BTFSS  F9E.4
19FC:  BRA    19FA
19FE:  MOVWF  FAD
1A00:  MOVLW  09
1A02:  MOVWF  FE9
1A04:  MOVFF  B6,BF
1A08:  MOVFF  B5,BE
1A0C:  RCALL  15B0
1A0E:  MOVLW  74
1A10:  BTFSS  F9E.4
1A12:  BRA    1A10
1A14:  MOVWF  FAD
1A16:  MOVLW  0A
1A18:  BTFSS  F9E.4
1A1A:  BRA    1A18
1A1C:  MOVWF  FAD
....................          Printf ("y%05Ldt\n", y); 
1A1E:  MOVLW  79
1A20:  BTFSS  F9E.4
1A22:  BRA    1A20
1A24:  MOVWF  FAD
1A26:  MOVLW  09
1A28:  MOVWF  FE9
1A2A:  MOVFF  B8,BF
1A2E:  MOVFF  B7,BE
1A32:  RCALL  15B0
1A34:  MOVLW  74
1A36:  BTFSS  F9E.4
1A38:  BRA    1A36
1A3A:  MOVWF  FAD
1A3C:  MOVLW  0A
1A3E:  BTFSS  F9E.4
1A40:  BRA    1A3E
1A42:  MOVWF  FAD
....................          Printf ("z%05Ldt\n", z); 
1A44:  MOVLW  7A
1A46:  BTFSS  F9E.4
1A48:  BRA    1A46
1A4A:  MOVWF  FAD
1A4C:  MOVLW  09
1A4E:  MOVWF  FE9
1A50:  MOVFF  BA,BF
1A54:  MOVFF  B9,BE
1A58:  RCALL  15B0
1A5A:  MOVLW  74
1A5C:  BTFSS  F9E.4
1A5E:  BRA    1A5C
1A60:  MOVWF  FAD
1A62:  MOVLW  0A
1A64:  BTFSS  F9E.4
1A66:  BRA    1A64
1A68:  MOVWF  FAD
....................  
....................          LcdSetCursor (one); 
1A6A:  CLRF   xBE
1A6C:  CALL   0694
....................          LcdMsg (" Bx = "); LCDPutS16n (x, 4); LcdMsg (" Гс. "); 
1A70:  MOVLW  6C
1A72:  MOVWF  FF6
1A74:  MOVLW  01
1A76:  MOVWF  FF7
1A78:  CALL   0674
1A7C:  MOVFF  B6,BF
1A80:  MOVFF  B5,BE
1A84:  MOVLW  04
1A86:  MOVWF  xC0
1A88:  RCALL  1694
1A8A:  MOVLW  74
1A8C:  MOVWF  FF6
1A8E:  MOVLW  01
1A90:  MOVWF  FF7
1A92:  CALL   0674
....................          LcdSetCursor (two);  
1A96:  MOVLW  40
1A98:  MOVWF  xBE
1A9A:  CALL   0694
....................          LcdMsg (" By = "); LCDPutS16n (y, 4); LcdMsg (" Гс. "); 
1A9E:  MOVLW  7A
1AA0:  MOVWF  FF6
1AA2:  MOVLW  01
1AA4:  MOVWF  FF7
1AA6:  CALL   0674
1AAA:  MOVFF  B8,BF
1AAE:  MOVFF  B7,BE
1AB2:  MOVLW  04
1AB4:  MOVWF  xC0
1AB6:  RCALL  1694
1AB8:  MOVLW  82
1ABA:  MOVWF  FF6
1ABC:  MOVLW  01
1ABE:  MOVWF  FF7
1AC0:  CALL   0674
....................          LcdSetCursor (three); 
1AC4:  MOVLW  10
1AC6:  MOVWF  xBE
1AC8:  CALL   0694
....................          LcdMsg (" Bz = "); LCDPutS16n (z, 4); LcdMsg (" Гс. "); 
1ACC:  MOVLW  88
1ACE:  MOVWF  FF6
1AD0:  MOVLW  01
1AD2:  MOVWF  FF7
1AD4:  CALL   0674
1AD8:  MOVFF  BA,BF
1ADC:  MOVFF  B9,BE
1AE0:  MOVLW  04
1AE2:  MOVWF  xC0
1AE4:  RCALL  1694
1AE6:  MOVLW  90
1AE8:  MOVWF  FF6
1AEA:  MOVLW  01
1AEC:  MOVWF  FF7
1AEE:  CALL   0674
....................           
....................          status = 1; 
1AF2:  MOVLW  01
1AF4:  MOVWF  xBD
....................        } 
....................  
....................        return status; 
1AF6:  MOVFF  BD,01
1AFA:  GOTO   287E (RETURN)
....................   
....................  } 
....................  
.................... //////////////////// Sensor 2 funcs //////////////////////////////////// 
....................  
....................  
.................... //------------------ EEPROM funcs -------------------------------------- 
....................  U16 CRC16 (U8 * data_p, U8 length) 
*
084A:  SETF   xAF
084C:  SETF   xAE
....................  { 
....................     // расчет контрольной суммы 
....................     // взят из интернета 
....................      
....................     U8 x; 
....................     U16 crc = 0xFFFF; 
....................  
....................     while (length--) 
084E:  MOVF   xAC,W
0850:  DECF   xAC,F
0852:  XORLW  00
0854:  BZ    08AE
....................     { 
....................        x = crc >> 8 ^ * data_p++; 
0856:  MOVFF  AB,03
085A:  MOVF   xAA,W
085C:  INCF   xAA,F
085E:  BTFSC  FD8.2
0860:  INCF   xAB,F
0862:  MOVWF  FE9
0864:  MOVFF  03,FEA
0868:  MOVF   FEF,W
086A:  XORWF  xAF,W
086C:  MOVWF  xAD
....................        x ^= x>>4; 
086E:  SWAPF  xAD,W
0870:  MOVWF  00
0872:  MOVLW  0F
0874:  ANDWF  00,F
0876:  MOVF   00,W
0878:  XORWF  xAD,F
....................        crc = (crc << 8) ^ ((U16) (x << 12)) ^ ((U16) (x <<5)) ^ ( (U16) x) ; 
087A:  MOVFF  AE,B1
087E:  CLRF   xB0
0880:  MOVLW  00
0882:  CLRF   03
0884:  XORWF  xB0,F
0886:  MOVF   03,W
0888:  XORWF  xB1,F
088A:  SWAPF  xAD,W
088C:  MOVWF  00
088E:  RLCF   00,F
0890:  MOVLW  E0
0892:  ANDWF  00,F
0894:  MOVF   00,W
0896:  CLRF   03
0898:  XORWF  xB0,F
089A:  MOVF   03,W
089C:  XORWF  xB1,F
089E:  CLRF   03
08A0:  MOVF   xAD,W
08A2:  XORWF  xB0,W
08A4:  MOVWF  xAE
08A6:  MOVF   03,W
08A8:  XORWF  xB1,W
08AA:  MOVWF  xAF
08AC:  BRA    084E
....................     } 
....................  
....................     return crc; 
08AE:  MOVFF  AE,01
08B2:  MOVFF  AF,02
08B6:  RETURN 0
....................  } 
....................  
....................  void rom_wr_byte (U16 addr, U8 dataByte) 
*
252C:  CLRF   xB2
252E:  CLRF   xB3
....................  { 
....................     /// записывает байт данных по 16 - бит. адресу 
....................      
....................     U8 addr_MSB = 0; 
....................     U8 addr_LSB = 0; 
....................      
....................     addr_MSB = (addr >> 8); 
2530:  MOVFF  B0,B2
....................     addr_LSB = addr; 
2534:  MOVFF  AF,B3
....................      
....................     i2c_start (); 
2538:  BSF    F94.4
253A:  NOP   
253C:  BSF    F94.3
253E:  NOP   
2540:  BCF    F8B.4
2542:  BCF    F94.4
2544:  NOP   
2546:  BCF    F8B.3
2548:  BCF    F94.3
....................     i2c_write (EEprom_adr|0); // запись 
254A:  MOVFF  1E,B4
254E:  CLRF   16
2550:  BTFSC  FF2.7
2552:  BSF    16.7
2554:  BCF    FF2.7
2556:  MOVFF  1E,E1
255A:  CALL   0196
255E:  BTFSC  16.7
2560:  BSF    FF2.7
2562:  CLRF   16
2564:  BTFSC  FF2.7
2566:  BSF    16.7
2568:  BCF    FF2.7
....................     // A read operation is initiated if this bit is high 
....................     // and a write operation is initiated if this bit is low. 
....................      
....................     i2c_write (addr_MSB); 
256A:  MOVFF  B2,E1
256E:  CALL   0196
2572:  BTFSC  16.7
2574:  BSF    FF2.7
2576:  CLRF   16
2578:  BTFSC  FF2.7
257A:  BSF    16.7
257C:  BCF    FF2.7
....................     i2c_write (addr_LSB); 
257E:  MOVFF  B3,E1
2582:  CALL   0196
2586:  BTFSC  16.7
2588:  BSF    FF2.7
258A:  CLRF   16
258C:  BTFSC  FF2.7
258E:  BSF    16.7
2590:  BCF    FF2.7
....................     i2c_write (dataByte); 
2592:  MOVFF  B1,E1
2596:  CALL   0196
259A:  BTFSC  16.7
259C:  BSF    FF2.7
....................     i2c_stop (); 
259E:  BCF    F94.4
25A0:  NOP   
25A2:  BSF    F94.3
25A4:  BTFSS  F82.3
25A6:  BRA    25A4
25A8:  NOP   
25AA:  BRA    25AC
25AC:  NOP   
25AE:  BSF    F94.4
25B0:  NOP   
....................     delay_ms (15); // t записи в rom - 10 мс 
25B2:  MOVLW  0F
25B4:  MOVWF  xBF
25B6:  CALL   050E
....................     crc_buf_wr[crc_wr_index] = dataByte; 
25BA:  CLRF   03
25BC:  MOVF   x78,W
25BE:  ADDLW  58
25C0:  MOVWF  FE9
25C2:  MOVLW  00
25C4:  ADDWFC 03,W
25C6:  MOVWF  FEA
25C8:  MOVFF  B1,FEF
....................     crc_wr_index++; 
25CC:  INCF   x78,F
25CE:  RETURN 0
....................  } 
....................  
....................  U8 rom_rd_byte (U16 addr) 
*
0700:  CLRF   xAF
0702:  CLRF   xB0
0704:  CLRF   xB1
....................  { 
....................     /// чтение байта данных по 16 - бит. адресу 
....................      
....................     U8 rd_data_byte = 0; 
....................     U8 addr_MSB = 0; // старший байт адреса 
....................     U8 addr_LSB = 0; // младший байт адреса 
....................      
....................     addr_MSB = (addr >> 8); // заполнение ст. байта из 2 - байт. адреса 
0706:  MOVFF  AE,B0
....................     addr_LSB = addr; // заполнение мл. байта из 2 - байт. адреса 
070A:  MOVFF  AD,B1
....................      
....................     i2c_start (); 
070E:  BSF    F94.4
0710:  NOP   
0712:  BSF    F94.3
0714:  NOP   
0716:  BCF    F8B.4
0718:  BCF    F94.4
071A:  NOP   
071C:  BCF    F8B.3
071E:  BCF    F94.3
....................     i2c_write (EEprom_adr|0); // команда чтения 
0720:  MOVFF  1E,B2
0724:  CLRF   16
0726:  BTFSC  FF2.7
0728:  BSF    16.7
072A:  BCF    FF2.7
072C:  MOVFF  1E,E1
0730:  RCALL  0196
0732:  BTFSC  16.7
0734:  BSF    FF2.7
0736:  CLRF   16
0738:  BTFSC  FF2.7
073A:  BSF    16.7
073C:  BCF    FF2.7
....................     // A read operation is initiated if this bit is high 
....................     // and a write operation is initiated if this bit is low. 
....................      
....................     i2c_write (addr_MSB); // выдача на линию ст. байта адреса 
073E:  MOVFF  B0,E1
0742:  RCALL  0196
0744:  BTFSC  16.7
0746:  BSF    FF2.7
0748:  CLRF   16
074A:  BTFSC  FF2.7
074C:  BSF    16.7
074E:  BCF    FF2.7
....................     i2c_write (addr_LSB); // выдача на линию мл. байта адреса 
0750:  MOVFF  B1,E1
0754:  RCALL  0196
0756:  BTFSC  16.7
0758:  BSF    FF2.7
....................     i2c_start (); 
075A:  BSF    F94.4
075C:  NOP   
075E:  BSF    F94.3
0760:  NOP   
0762:  BTFSS  F82.3
0764:  BRA    0762
0766:  BCF    F8B.4
0768:  BCF    F94.4
076A:  NOP   
076C:  BCF    F8B.3
076E:  BCF    F94.3
....................     i2c_write (EEprom_adr|1); // чтение 
0770:  MOVF   1E,W
0772:  IORLW  01
0774:  MOVWF  xB2
0776:  CLRF   16
0778:  BTFSC  FF2.7
077A:  BSF    16.7
077C:  BCF    FF2.7
077E:  MOVWF  xE1
0780:  RCALL  0196
0782:  BTFSC  16.7
0784:  BSF    FF2.7
....................     rd_data_byte = i2c_read (); 
0786:  MOVLW  01
0788:  MOVWF  00
078A:  CLRF   16
078C:  BTFSC  FF2.7
078E:  BSF    16.7
0790:  BCF    FF2.7
0792:  RCALL  01DE
0794:  BTFSC  16.7
0796:  BSF    FF2.7
0798:  MOVFF  01,AF
079C:  CLRF   16
079E:  BTFSC  FF2.7
07A0:  BSF    16.7
07A2:  BCF    FF2.7
....................     i2c_write (0xff); // без этого не работает 0_0 
07A4:  SETF   xE1
07A6:  RCALL  0196
07A8:  BTFSC  16.7
07AA:  BSF    FF2.7
....................     i2c_stop (); 
07AC:  BCF    F94.4
07AE:  NOP   
07B0:  BSF    F94.3
07B2:  BTFSS  F82.3
07B4:  BRA    07B2
07B6:  NOP   
07B8:  BRA    07BA
07BA:  NOP   
07BC:  BSF    F94.4
07BE:  NOP   
....................     crc_buf_rd[crc_rd_index] = rd_data_byte; 
07C0:  CLRF   03
07C2:  MOVF   x79,W
07C4:  ADDLW  68
07C6:  MOVWF  FE9
07C8:  MOVLW  00
07CA:  ADDWFC 03,W
07CC:  MOVWF  FEA
07CE:  MOVFF  AF,FEF
....................     crc_rd_index++; 
07D2:  INCF   x79,F
....................      
....................     return rd_data_byte; 
07D4:  MOVFF  AF,01
07D8:  RETURN 0
....................  } 
....................  
....................  void rom_rd_float (U16 ee_addr, void * float_data_ptr) 
07DA:  MOVFF  A7,AA
07DE:  MOVFF  A6,A9
07E2:  CLRF   xAB
07E4:  MOVLW  04
07E6:  MOVWF  xAC
....................  { 
....................     /// чтение 4 - байт. переменной типа float из rom 
....................      
....................     // передается указатель на заранее инициализир. перемен. 
....................     // типа float, происходит побайтное считывание из rom и наполнение 
....................     // ими адреса переданного через указатель 
....................      
....................     U8 buf; 
....................     U8 * dataByte_ptr = float_data_ptr; // сохраняем указатель (адрес) 
....................     // переменной для чтения 
....................     U8 k = 0; 
....................     U8 i = sizeof (float); 
....................      
....................     while (k < i) 
07E8:  MOVF   xAC,W
07EA:  SUBWF  xAB,W
07EC:  BC    0818
....................     { 
....................        buf = rom_rd_byte (ee_addr); // чтение байта из памяти 
07EE:  MOVFF  A5,AE
07F2:  MOVFF  A4,AD
07F6:  RCALL  0700
07F8:  MOVFF  01,A8
....................        * dataByte_ptr = buf; // сох. этого байта по адресу конкретной переменной 
07FC:  MOVFF  A9,FE9
0800:  MOVFF  AA,FEA
0804:  MOVFF  A8,FEF
....................        dataByte_ptr++; // инкремент адреса байта переменной 
0808:  INCF   xA9,F
080A:  BTFSC  FD8.2
080C:  INCF   xAA,F
....................        ee_addr++; // инкремент адреса rom 
080E:  INCF   xA4,F
0810:  BTFSC  FD8.2
0812:  INCF   xA5,F
....................        k++; // инкремент итератора цикла чтения 
0814:  INCF   xAB,F
0816:  BRA    07E8
....................     } 
0818:  RETURN 0
....................  
....................     //LCDMsg ("adr = "); 
....................     //LcdPutU16 ( (U32) ee_addr * 1000, 4) ; 
....................     //delay_ms (1000); 
....................     //Lcdsetcursor (0x40); 
....................      
....................      
....................     //LCDMsg ("CRC_rd = "); 
....................     //LcdPutU16 ( (U32) CRC_rd, 5) ; 
....................     //Lcdsetcursor (0x50); 
....................     //LCDMsg ("CRC_LSB = "); 
....................     //LcdPutU16 ( (U32) CRC_rd_LSB * 100, 5) ; 
....................  } 
....................  
....................  void rom_wr_float (U16 ee_addr, void * float_data_ptr) 
*
25D0:  MOVFF  A9,AB
25D4:  MOVFF  A8,AA
25D8:  CLRF   xAC
25DA:  MOVLW  04
25DC:  MOVWF  xAD
....................  { 
....................     /// запись 4 - байт. переменной типа float в rom 
....................      
....................     // передается указатель на перемен. типа float для ее сохранения. 
....................     // происходит побайтная запись этой переменной в rom 
....................      
....................     U8 * dataByte_ptr = float_data_ptr; // сохраняем указатель (адрес) 
....................     // переменной для записи 
....................     U8 k = 0; 
....................     U8 i = sizeof (float); // сохранение размера float в байтах - 4 
....................     //Lcdsetcursor (0); 
....................     //lcdPutCh ('a'); 
....................      
....................     while (k < i) 
25DE:  MOVF   xAD,W
25E0:  SUBWF  xAC,W
25E2:  BC    2612
....................     { 
....................        //my_arr[k] = *dataByte_ptr; 
....................        //LcdPutU16 (my_arr[k], 3) ; 
....................        //lcdPutCh ('_'); 
....................        rom_wr_byte (ee_addr, * dataByte_ptr); // запись байта с конкретн. адресу в rom 
25E4:  MOVFF  AB,03
25E8:  MOVFF  AA,FE9
25EC:  MOVFF  AB,FEA
25F0:  MOVFF  FEF,AE
25F4:  MOVFF  A7,B0
25F8:  MOVFF  A6,AF
25FC:  MOVFF  AE,B1
2600:  RCALL  252C
....................        dataByte_ptr++; // инкремент адреса байта переменной 
2602:  INCF   xAA,F
2604:  BTFSC  FD8.2
2606:  INCF   xAB,F
....................        ee_addr++; // инкремент адреса rom 
2608:  INCF   xA6,F
260A:  BTFSC  FD8.2
260C:  INCF   xA7,F
....................        k++;  // инкремент итератора цикла записи 
260E:  INCF   xAC,F
2610:  BRA    25DE
....................     } 
2612:  RETURN 0
....................  
....................     //Lcdsetcursor (0x00); 
....................     //LCDMsg ("CRC_wr = "); 
....................     //LcdPutU16 ( (U32) CRC_Wr, 5); 
....................  } 
....................  
....................  U16 rom_wr_CRC16 (ee_addr, U8 crc_buf) 
....................  { 
....................     U16 CRC_Wr; 
....................      
....................     CRC_Wr = CRC16 (crc_buf, 14); // расчет CRC16 
2614:  CLRF   xAB
2616:  MOVFF  A7,AA
261A:  MOVLW  0E
261C:  MOVWF  xAC
261E:  CALL   084A
2622:  MOVFF  02,A9
2626:  MOVFF  01,A8
....................      
....................     rom_wr_byte (ee_addr, (CRC_Wr >> 8)); // запись ст. байта CRC в rom 
262A:  MOVFF  A9,AA
262E:  CLRF   xAB
2630:  CLRF   xB0
2632:  MOVFF  A6,AF
2636:  MOVFF  A9,B1
263A:  RCALL  252C
....................     ee_addr++;  // инкремент адреса 
263C:  INCF   xA6,F
....................     rom_wr_byte (ee_addr, (U8) CRC_Wr); // запись мл. байта CRC в rom 
263E:  CLRF   xB0
2640:  MOVFF  A6,AF
2644:  MOVFF  A8,B1
2648:  RCALL  252C
....................      
....................     return CRC_Wr; 
264A:  MOVFF  A8,01
264E:  MOVFF  A9,02
2652:  GOTO   26EC (RETURN)
....................  } 
....................  
....................  U16 rom_rd_CRC16 (ee_addr) 
....................  { 
....................     U8 CRC_rd_MSB; // ст. байт CRC для записи 
....................     U8 CRC_rd_LSB; // мл. байт CRC для записи 
....................     U16 CRC_rd; // 16 - бит. CRC 
....................      
....................     CRC_rd_MSB = rom_rd_byte (ee_addr); // чтение ст. байта CRC из rom 
*
081A:  CLRF   xAE
081C:  MOVFF  A4,AD
0820:  RCALL  0700
0822:  MOVFF  01,A5
....................     ee_addr++; 
0826:  INCF   xA4,F
....................     CRC_rd_LSB = rom_rd_byte (ee_addr); // чтение мл. байта CRC из rom 
0828:  CLRF   xAE
082A:  MOVFF  A4,AD
082E:  RCALL  0700
0830:  MOVFF  01,A6
....................     CRC_rd = CRC_rd_MSB << 8; // восстановление CRC 
0834:  MOVFF  A5,A8
0838:  CLRF   xA7
....................     CRC_rd |= CRC_rd_LSB; // из прочитанных байт 
083A:  MOVF   xA6,W
083C:  IORWF  xA7,F
....................      
....................     return CRC_rd; 
083E:  MOVFF  A7,01
0842:  MOVFF  A8,02
0846:  GOTO   094A (RETURN)
....................  } 
....................  
....................  int1 rom_rd_sens_data (void) 
*
08B8:  BCF    xA3.0
....................  { 
....................     int1 _rom_rd_status = 0; 
....................  
....................     sens_type = rom_rd_byte (ROM_Adr); // тип датчика 0 
08BA:  MOVFF  81,AE
08BE:  MOVFF  80,AD
08C2:  RCALL  0700
08C4:  CLRF   x7D
08C6:  MOVFF  01,7C
....................     ROM_Adr++; 
08CA:  INCF   x80,F
08CC:  BTFSC  FD8.2
08CE:  INCF   x81,F
....................     sens_num = rom_rd_byte (ROM_Adr);  // № датчика 1 
08D0:  MOVFF  81,AE
08D4:  MOVFF  80,AD
08D8:  RCALL  0700
08DA:  CLRF   x7F
08DC:  MOVFF  01,7E
....................     ROM_Adr++; 
08E0:  INCF   x80,F
08E2:  BTFSC  FD8.2
08E4:  INCF   x81,F
....................     coord_sys = rom_rd_byte (ROM_Adr); // система координат 2 
08E6:  MOVFF  81,AE
08EA:  MOVFF  80,AD
08EE:  RCALL  0700
08F0:  CLRF   x7B
08F2:  MOVFF  01,7A
....................     ROM_Adr++; 
08F6:  INCF   x80,F
08F8:  BTFSC  FD8.2
08FA:  INCF   x81,F
....................     rom_rd_float (ROM_Adr,&kx); // Kx 3 - 6 
08FC:  MOVFF  81,A5
0900:  MOVFF  80,A4
0904:  CLRF   xA7
0906:  MOVLW  4C
0908:  MOVWF  xA6
090A:  RCALL  07DA
....................     ROM_adr += 4; 
090C:  MOVLW  04
090E:  ADDWF  x80,F
0910:  MOVLW  00
0912:  ADDWFC x81,F
....................     rom_rd_float (ROM_Adr,&ky); // Ky 7 - 10 
0914:  MOVFF  81,A5
0918:  MOVFF  80,A4
091C:  CLRF   xA7
091E:  MOVLW  50
0920:  MOVWF  xA6
0922:  RCALL  07DA
....................     ROM_adr += 4; 
0924:  MOVLW  04
0926:  ADDWF  x80,F
0928:  MOVLW  00
092A:  ADDWFC x81,F
....................     rom_rd_float (ROM_Adr,&kz); // Kz 11 - 14 
092C:  MOVFF  81,A5
0930:  MOVFF  80,A4
0934:  CLRF   xA7
0936:  MOVLW  54
0938:  MOVWF  xA6
093A:  RCALL  07DA
....................      
....................     ROM_adr += 4; 
093C:  MOVLW  04
093E:  ADDWF  x80,F
0940:  MOVLW  00
0942:  ADDWFC x81,F
....................     CRC1 = rom_rd_CRC16 (ROM_adr); // чтение сохраненной CRC 
0944:  MOVFF  80,A4
0948:  BRA    081A
094A:  MOVFF  02,85
094E:  MOVFF  01,84
....................     CRC2 = CRC16 (crc_buf_rd, 14); // расчет CRC по считанным данным 
0952:  CLRF   xAB
0954:  MOVLW  68
0956:  MOVWF  xAA
0958:  MOVLW  0E
095A:  MOVWF  xAC
095C:  RCALL  084A
095E:  MOVFF  02,87
0962:  MOVFF  01,86
....................     crc_rd_index = 0; 
0966:  CLRF   x79
....................     ROM_adr = 0x0000; 
0968:  CLRF   x81
096A:  CLRF   x80
....................  
....................     if (CRC1 == CRC2) 
096C:  MOVF   x86,W
096E:  SUBWF  x84,W
0970:  BNZ   097A
0972:  MOVF   x87,W
0974:  SUBWF  x85,W
0976:  BNZ   097A
....................     { 
....................        _rom_rd_status = 1; 
0978:  BSF    xA3.0
....................     } 
....................  
....................     return _rom_rd_status; 
097A:  MOVLW  00
097C:  BTFSC  xA3.0
097E:  MOVLW  01
0980:  MOVWF  01
0982:  GOTO   0B8E (RETURN)
....................  } 
....................  
.................... void update_rom_data(void) 
*
2656:  CLRF   xA3
2658:  CLRF   xA2
265A:  CLRF   xA5
265C:  CLRF   xA4
.................... { 
....................    U16 ROM_Adr = 0x0000; 
....................   // U16 CRC_Wr; 
....................    U16 CRC1 = 0; 
....................   // U16 CRC2 = 0;  
....................  
....................    rom_wr_byte(ROM_Adr,sens_type);     // тип датчика   0 
265E:  MOVFF  A3,B0
2662:  MOVFF  A2,AF
2666:  MOVFF  7C,B1
266A:  RCALL  252C
....................    rom_wr_byte (++ROM_Adr, sens_num);  // № датчика     1 
266C:  INCF   xA2,F
266E:  BTFSC  FD8.2
2670:  INCF   xA3,F
2672:  MOVFF  A3,B0
2676:  MOVFF  A2,AF
267A:  MOVFF  7E,B1
267E:  RCALL  252C
....................    rom_wr_byte (++ROM_Adr, coord_sys); // сис.координат 2 
2680:  INCF   xA2,F
2682:  BTFSC  FD8.2
2684:  INCF   xA3,F
2686:  MOVFF  A3,B0
268A:  MOVFF  A2,AF
268E:  MOVFF  7A,B1
2692:  RCALL  252C
....................    rom_wr_float(++ROM_Adr,&kx);        // Kx            3-6  
2694:  INCF   xA2,F
2696:  BTFSC  FD8.2
2698:  INCF   xA3,F
269A:  MOVFF  A3,A7
269E:  MOVFF  A2,A6
26A2:  CLRF   xA9
26A4:  MOVLW  4C
26A6:  MOVWF  xA8
26A8:  RCALL  25D0
....................    ROM_adr += 4; 
26AA:  MOVLW  04
26AC:  ADDWF  xA2,F
26AE:  MOVLW  00
26B0:  ADDWFC xA3,F
....................    rom_wr_float(ROM_Adr,&ky);          // Ky            7-10 
26B2:  MOVFF  A3,A7
26B6:  MOVFF  A2,A6
26BA:  CLRF   xA9
26BC:  MOVLW  50
26BE:  MOVWF  xA8
26C0:  RCALL  25D0
....................    ROM_adr += 4; 
26C2:  MOVLW  04
26C4:  ADDWF  xA2,F
26C6:  MOVLW  00
26C8:  ADDWFC xA3,F
....................    rom_wr_float(ROM_Adr,&kz);          // Kz            11-14 
26CA:  MOVFF  A3,A7
26CE:  MOVFF  A2,A6
26D2:  CLRF   xA9
26D4:  MOVLW  54
26D6:  MOVWF  xA8
26D8:  RCALL  25D0
....................     
....................    ROM_Adr += 4; 
26DA:  MOVLW  04
26DC:  ADDWF  xA2,F
26DE:  MOVLW  00
26E0:  ADDWFC xA3,F
....................    CRC1 = rom_wr_CRC16(ROM_Adr,crc_buf_wr); 
26E2:  MOVFF  A2,A6
26E6:  MOVLW  58
26E8:  MOVWF  xA7
26EA:  BRA    2614
26EC:  MOVFF  02,A5
26F0:  MOVFF  01,A4
....................    crc_wr_index = 0;    
26F4:  CLRF   x78
26F6:  RETURN 0
.................... } 
....................  
.................... //------------------ EEPROM funcs -------------------------------------- 
....................   
.................... //= == == = == == == == = == = Interrupts = == = == == == == == == == 
....................  #int_EXT 
....................  void int0 (void) 
*
027E:  CLRF   xDE
0280:  CLRF   xDD
....................  { 
....................     signed int16 coodr_buf = 0; 
....................      
....................     if (SensErr) 
0282:  BTFSS  1A.1
0284:  BRA    028C
....................     { 
....................  
....................        sens_type = 0; 
0286:  CLRF   x7D
0288:  CLRF   x7C
....................     } 
028A:  BRA    03AE
....................  
....................      
....................     else 
....................     { 
....................         
....................        i2c_start (); 
028C:  BSF    F94.4
028E:  NOP   
0290:  BSF    F94.3
0292:  NOP   
0294:  BCF    F8B.4
0296:  BCF    F94.4
0298:  NOP   
029A:  BCF    F8B.3
029C:  BCF    F94.3
....................        i2c_write (0x3C); // The default (factory) HMC5883 7 - bit slave address 
029E:  MOVLW  3C
02A0:  MOVWF  xE1
02A2:  RCALL  0196
....................        // is 0x3C for write operations, or 0x3D for read operations. 
....................        i2c_write (0x03); // pointer 
02A4:  MOVLW  03
02A6:  MOVWF  xE1
02A8:  RCALL  0196
....................        i2c_stop (); 
02AA:  BCF    F94.4
02AC:  NOP   
02AE:  BSF    F94.3
02B0:  BTFSS  F82.3
02B2:  BRA    02B0
02B4:  NOP   
02B6:  BRA    02B8
02B8:  NOP   
02BA:  BSF    F94.4
02BC:  NOP   
....................         
....................        i2c_start (); 
02BE:  BSF    F94.4
02C0:  NOP   
02C2:  BSF    F94.3
02C4:  NOP   
02C6:  BCF    F8B.4
02C8:  BCF    F94.4
02CA:  NOP   
02CC:  BCF    F8B.3
02CE:  BCF    F94.3
....................        i2c_write (0x3D); //i2c Read 
02D0:  MOVLW  3D
02D2:  MOVWF  xE1
02D4:  RCALL  0196
....................         
....................        Xh = i2c_read (); // X MSB 
02D6:  MOVLW  01
02D8:  MOVWF  00
02DA:  RCALL  01DE
02DC:  CLRF   38
02DE:  MOVFF  01,37
....................        Xl = i2c_read (); // X LSB 
02E2:  MOVLW  01
02E4:  MOVWF  00
02E6:  RCALL  01DE
02E8:  MOVFF  01,39
....................        SumX = (Xh<<8)|Xl; //?????????????? ???????? ????????. ??? ? 
02EC:  CLRF   xDF
02EE:  MOVF   xDF,W
02F0:  IORWF  39,W
02F2:  MOVWF  1F
02F4:  MOVFF  37,20
....................        Yh = i2c_read (); // Y MSB 
02F8:  MOVLW  01
02FA:  MOVWF  00
02FC:  RCALL  01DE
02FE:  CLRF   3B
0300:  MOVFF  01,3A
....................        Yl = i2c_read (); // Y LSB 
0304:  MOVLW  01
0306:  MOVWF  00
0308:  RCALL  01DE
030A:  MOVFF  01,3C
....................        SumY = (Yh<<8)|Yl; //?????????????? ???????? ????????. ??? Y 
030E:  CLRF   xDF
0310:  MOVF   xDF,W
0312:  IORWF  3C,W
0314:  MOVWF  21
0316:  MOVFF  3A,22
....................        Zh = i2c_read (); // Z MSB 
031A:  MOVLW  01
031C:  MOVWF  00
031E:  RCALL  01DE
0320:  CLRF   3E
0322:  MOVFF  01,3D
....................        Zl = i2c_read (); // Z LSB 
0326:  MOVLW  01
0328:  MOVWF  00
032A:  RCALL  01DE
032C:  MOVFF  01,3F
....................        SumZ = (Zh<<8)|Zl; //?????????????? ???????? ????????. ??? Z 
0330:  CLRF   xDF
0332:  MOVF   xDF,W
0334:  IORWF  3F,W
0336:  MOVWF  23
0338:  MOVFF  3D,24
....................        i2c_stop (); 
033C:  BCF    F94.4
033E:  NOP   
0340:  BSF    F94.3
0342:  BTFSS  F82.3
0344:  BRA    0342
0346:  NOP   
0348:  BRA    034A
034A:  NOP   
034C:  BSF    F94.4
034E:  NOP   
....................         
....................       // average_X += SumX; 
....................        //average_Y += SumY; 
....................        //average_Z += SumZ; 
....................        //aver_count ++; 
....................         
....................        //if (aver_count == 5) 
....................        //{ 
....................           int_fl = true; 
0350:  BSF    1A.0
....................        //   aver_count = 0; 
....................            
....................        //   average_Xg = average_X; 
....................       //    average_Yg = average_Y; 
....................        //   average_Zg = average_Z; 
....................     
....................           switch(coord_sys)       // анализ выбраной системы координат 
0352:  MOVFF  7A,00
0356:  MOVF   x7B,W
0358:  MOVWF  03
035A:  BNZ   0360
035C:  MOVF   00,F
035E:  BZ    0376
0360:  MOVF   03,W
0362:  BNZ   036A
0364:  MOVLW  01
0366:  SUBWF  00,W
0368:  BZ    0378
036A:  MOVF   03,W
036C:  BNZ   0374
036E:  MOVLW  02
0370:  SUBWF  00,W
0372:  BZ    0392
0374:  BRA    03AC
....................          { 
....................             case 0: break;       // по умолчанию, ничего не меняем 
0376:  BRA    03AC
....................             //===== 
....................             case 1:              // 1 вариант изменения системы координат 
....................                coodr_buf = SumX;    // поворот правой тройки вниз 
0378:  MOVFF  20,DE
037C:  MOVFF  1F,DD
....................                SumX = SumZ; 
0380:  MOVFF  24,20
0384:  MOVFF  23,1F
....................                SumZ = coodr_buf; 
0388:  MOVFF  DE,24
038C:  MOVFF  DD,23
....................                break;        
0390:  BRA    03AC
....................                            //===== 
....................             case 2:              // 2 вариант изменения системы координат 
....................                coodr_buf = SumY;    // поворот правой тройки влево 
0392:  MOVFF  22,DE
0396:  MOVFF  21,DD
....................                SumY = SumZ; 
039A:  MOVFF  24,22
039E:  MOVFF  23,21
....................                SumZ = coodr_buf; 
03A2:  MOVFF  DE,24
03A6:  MOVFF  DD,23
....................                break;        
03AA:  BRA    03AC
....................             //===== 
....................             default: break; 
....................           
....................          } 
....................            
....................           //average_X = 0; 
....................           //average_Y = 0; 
....................           //average_Z = 0; 
....................        //} 
....................  
....................        HMC5883l_Init(); 
03AC:  RCALL  0260
....................        //SensWrData (ConfigRegB, 0xE0); // range = + / - 8.1 Gs 
....................        //SensWrData (ModeReg, 0x00);    // continuous measurment 
....................     } 
....................  
....................     SET_TIMER0 (55770); 
03AE:  MOVLW  D9
03B0:  MOVWF  FD7
03B2:  MOVLW  DA
03B4:  MOVWF  FD6
....................     clear_interrupt (int_EXT); 
03B6:  BCF    FF2.1
....................  } 
....................  
03B8:  BCF    FF2.1
03BA:  GOTO   0060
....................  #int_RDA 
....................  void UART_RXd_isr (void) 
....................  { 
....................      
....................      
....................     wr_ptr++;                    // инкремент счетчика запис. байт 
03BE:  INCF   x89,F
....................     rx_buf[wr_ptr & 0x0f]  = RCREG;     // сохр. байта от ПК 
03C0:  MOVF   x89,W
03C2:  ANDLW  0F
03C4:  CLRF   03
03C6:  ADDLW  8B
03C8:  MOVWF  FE9
03CA:  MOVLW  00
03CC:  ADDWFC 03,W
03CE:  MOVWF  FEA
03D0:  MOVFF  FAE,FEF
....................    
....................     clear_interrupt (int_RDA);         // сброс флага прерывания 
03D4:  BCF    F9E.5
03D6:  GOTO   0060
....................  } 
....................  
.................... //= == == = == == == == = == = Interrupts = == = == == == == == == == 
....................  
.................... void LCDsensInfoMsg() 
.................... { 
....................        LCDclear (); 
*
1256:  CALL   06A0
....................        LCDSetCursor (one); 
125A:  CLRF   xBE
125C:  CALL   0694
....................        LCDMsg ("ОБНАРУЖЕН ДАТЧИК"); 
1260:  MOVLW  DA
1262:  MOVWF  FF6
1264:  MOVLW  03
1266:  MOVWF  FF7
1268:  CALL   0674
....................        LCDSetCursor (two); 
126C:  MOVLW  40
126E:  MOVWF  xBE
1270:  CALL   0694
....................        LCDMsg ("      Тип:      "); 
1274:  MOVLW  EC
1276:  MOVWF  FF6
1278:  MOVLW  03
127A:  MOVWF  FF7
127C:  CALL   0674
....................        LCDSetCursor (three); 
1280:  MOVLW  10
1282:  MOVWF  xBE
1284:  CALL   0694
....................         
....................        if (sens_type == TLV493D)   
1288:  MOVF   x7C,W
128A:  SUBLW  25
128C:  BNZ   12A0
128E:  MOVF   x7D,F
1290:  BNZ   12A0
....................        { 
....................          LCDMsg ("  Bmax = 1.3 kGS   "); 
1292:  MOVLW  FE
1294:  MOVWF  FF6
1296:  MOVLW  03
1298:  MOVWF  FF7
129A:  CALL   0674
....................        } 
129E:  BRA    12C4
....................         else if (sens_type == HMC5883l)  
12A0:  MOVF   x7C,W
12A2:  SUBLW  1E
12A4:  BNZ   12B8
12A6:  MOVF   x7D,F
12A8:  BNZ   12B8
....................        { 
....................          LCDMsg (" Bmax = 8.1 GS    "); 
12AA:  MOVLW  12
12AC:  MOVWF  FF6
12AE:  MOVLW  04
12B0:  MOVWF  FF7
12B2:  CALL   0674
....................        } 
12B6:  BRA    12C4
....................         
....................        else LCDMsg ("   Ошибка ID    "); 
12B8:  MOVLW  26
12BA:  MOVWF  FF6
12BC:  MOVLW  04
12BE:  MOVWF  FF7
12C0:  CALL   0674
....................         
....................        LCDSetCursor (four); 
12C4:  MOVLW  50
12C6:  MOVWF  xBE
12C8:  CALL   0694
....................          LCDMsg ("Датчик N:  "); 
12CC:  MOVLW  38
12CE:  MOVWF  FF6
12D0:  MOVLW  04
12D2:  MOVWF  FF7
12D4:  CALL   0674
....................        LCDPutU16n ( (U16) sens_num, 3) ; 
12D8:  CLRF   xC5
12DA:  CLRF   xC4
12DC:  MOVFF  7F,C3
12E0:  MOVFF  7E,C2
12E4:  MOVLW  03
12E6:  MOVWF  xC6
12E8:  RCALL  0CDA
....................        delay_ms(2000); 
12EA:  MOVLW  08
12EC:  MOVWF  xA2
12EE:  MOVLW  FA
12F0:  MOVWF  xBF
12F2:  CALL   050E
12F6:  DECFSZ xA2,F
12F8:  BRA    12EE
....................         
....................        LCDClear(); 
12FA:  CALL   06A0
....................        Lcdsetcursor (one); 
12FE:  CLRF   xBE
1300:  CALL   0694
....................        LCDMsg ("Коэффициенты:"); 
1304:  MOVLW  44
1306:  MOVWF  FF6
1308:  MOVLW  04
130A:  MOVWF  FF7
130C:  CALL   0674
....................        Lcdsetcursor (0x40); 
1310:  MOVLW  40
1312:  MOVWF  xBE
1314:  CALL   0694
....................        LCDMsg ("Kx = "); 
1318:  MOVLW  52
131A:  MOVWF  FF6
131C:  MOVLW  04
131E:  MOVWF  FF7
1320:  CALL   0674
....................        LcdPutS16 ( (S32) (kx * 1000), 5); 
1324:  MOVFF  4F,CB
1328:  MOVFF  4E,CA
132C:  MOVFF  4D,C9
1330:  MOVFF  4C,C8
1334:  CLRF   xCF
1336:  CLRF   xCE
1338:  MOVLW  7A
133A:  MOVWF  xCD
133C:  MOVLW  88
133E:  MOVWF  xCC
1340:  RCALL  0EE0
1342:  MOVFF  03,A5
1346:  MOVFF  02,A4
134A:  MOVFF  01,A3
134E:  MOVFF  00,A2
1352:  RCALL  0FD2
1354:  MOVFF  01,A3
1358:  MOVFF  00,A2
135C:  MOVFF  01,A5
1360:  MOVFF  00,A4
1364:  MOVLW  05
1366:  MOVWF  xA6
1368:  RCALL  1224
....................        Lcdsetcursor (0x10); 
136A:  MOVLW  10
136C:  MOVWF  xBE
136E:  CALL   0694
....................        LCDMsg ("Ky = "); 
1372:  MOVLW  58
1374:  MOVWF  FF6
1376:  MOVLW  04
1378:  MOVWF  FF7
137A:  CALL   0674
....................        LcdPutS16 ( (S32) (ky * 1000), 5); 
137E:  MOVFF  53,CB
1382:  MOVFF  52,CA
1386:  MOVFF  51,C9
138A:  MOVFF  50,C8
138E:  CLRF   xCF
1390:  CLRF   xCE
1392:  MOVLW  7A
1394:  MOVWF  xCD
1396:  MOVLW  88
1398:  MOVWF  xCC
139A:  RCALL  0EE0
139C:  MOVFF  03,A5
13A0:  MOVFF  02,A4
13A4:  MOVFF  01,A3
13A8:  MOVFF  00,A2
13AC:  RCALL  0FD2
13AE:  MOVFF  01,A3
13B2:  MOVFF  00,A2
13B6:  MOVFF  01,A5
13BA:  MOVFF  00,A4
13BE:  MOVLW  05
13C0:  MOVWF  xA6
13C2:  RCALL  1224
....................        Lcdsetcursor (0x50); 
13C4:  MOVLW  50
13C6:  MOVWF  xBE
13C8:  CALL   0694
....................        LCDMsg ("Kz = "); 
13CC:  MOVLW  5E
13CE:  MOVWF  FF6
13D0:  MOVLW  04
13D2:  MOVWF  FF7
13D4:  CALL   0674
....................        LcdPutS16 ( (S32) (kz * 1000), 5); 
13D8:  MOVFF  57,CB
13DC:  MOVFF  56,CA
13E0:  MOVFF  55,C9
13E4:  MOVFF  54,C8
13E8:  CLRF   xCF
13EA:  CLRF   xCE
13EC:  MOVLW  7A
13EE:  MOVWF  xCD
13F0:  MOVLW  88
13F2:  MOVWF  xCC
13F4:  RCALL  0EE0
13F6:  MOVFF  03,A5
13FA:  MOVFF  02,A4
13FE:  MOVFF  01,A3
1402:  MOVFF  00,A2
1406:  RCALL  0FD2
1408:  MOVFF  01,A3
140C:  MOVFF  00,A2
1410:  MOVFF  01,A5
1414:  MOVFF  00,A4
1418:  MOVLW  05
141A:  MOVWF  xA6
141C:  RCALL  1224
....................         
....................        delay_ms (2000); 
141E:  MOVLW  08
1420:  MOVWF  xA2
1422:  MOVLW  FA
1424:  MOVWF  xBF
1426:  CALL   050E
142A:  DECFSZ xA2,F
142C:  BRA    1422
....................        LCDclear (); 
142E:  CALL   06A0
1432:  RETURN 0
....................  
.................... }  
....................  
.................... U8 detect_sensors() 
*
0B8A:  CLRF   xA2
.................... { 
....................        U8 status = 0; 
....................         
....................        rom_rd_status = rom_rd_sens_data ();  
0B8C:  BRA    08B8
0B8E:  BCF    1A.3
0B90:  BTFSC  01.0
0B92:  BSF    1A.3
....................        delay_ms (500); 
0B94:  MOVLW  02
0B96:  MOVWF  xA3
0B98:  MOVLW  FA
0B9A:  MOVWF  xBF
0B9C:  RCALL  050E
0B9E:  DECFSZ xA3,F
0BA0:  BRA    0B98
....................         
....................        if      (sens_type == HMC5883l)  
0BA2:  MOVF   x7C,W
0BA4:  SUBLW  1E
0BA6:  BNZ   0BC6
0BA8:  MOVF   x7D,F
0BAA:  BNZ   0BC6
....................        { 
....................          EXT_int_EDGE (L_TO_H); 
0BAC:  BSF    FF1.6
....................          enable_interrupts (int_EXT); 
0BAE:  BSF    FF2.4
....................          //SETUP_TIMER_0 (T0_INTERNAL|T0_DIV_128); 
....................          //SET_TIMER0 (55770); 
....................          //enable_interrupts (int_TIMER0); 
....................          status = 30;                   // return sensor id if sucess 
0BB0:  MOVLW  1E
0BB2:  MOVWF  xA2
0BB4:  CLRF   16
0BB6:  BTFSC  FF2.7
0BB8:  BSF    16.7
0BBA:  BCF    FF2.7
....................          HMC5883l_Init(); 
0BBC:  CALL   0260
0BC0:  BTFSC  16.7
0BC2:  BSF    FF2.7
....................        } 
0BC4:  BRA    0BF2
....................         
....................        else if (sens_type == TLV493D) status = TLV493D_init(); 
0BC6:  MOVF   x7C,W
0BC8:  SUBLW  25
0BCA:  BNZ   0BD8
0BCC:  MOVF   x7D,F
0BCE:  BNZ   0BD8
0BD0:  RCALL  0986
0BD2:  MOVFF  01,A2
0BD6:  BRA    0BF2
....................    
....................        else 
....................       { 
....................          kx = 1.0; 
0BD8:  CLRF   4F
0BDA:  CLRF   4E
0BDC:  CLRF   4D
0BDE:  MOVLW  7F
0BE0:  MOVWF  4C
....................          ky = 1.0; 
0BE2:  CLRF   53
0BE4:  CLRF   52
0BE6:  CLRF   51
0BE8:  MOVWF  50
....................          kz = 1.0; 
0BEA:  CLRF   57
0BEC:  CLRF   56
0BEE:  CLRF   55
0BF0:  MOVWF  54
....................       } 
....................      
....................     return status; 
0BF2:  MOVFF  A2,01
0BF6:  RETURN 0
.................... } 
....................  
.................... U8 ch_to_int(char ch) 
*
2298:  SETF   xA3
.................... { 
.................... // преобразование сивмола в цифру 
.................... U8 dg=-1;                                                                         
....................   
....................  switch (ch) 
229A:  MOVF   xA2,W
229C:  XORLW  30
229E:  BZ    22C6
22A0:  XORLW  01
22A2:  BZ    22CA
22A4:  XORLW  03
22A6:  BZ    22D0
22A8:  XORLW  01
22AA:  BZ    22D6
22AC:  XORLW  07
22AE:  BZ    22DC
22B0:  XORLW  01
22B2:  BZ    22E2
22B4:  XORLW  03
22B6:  BZ    22E8
22B8:  XORLW  01
22BA:  BZ    22EE
22BC:  XORLW  0F
22BE:  BZ    22F4
22C0:  XORLW  01
22C2:  BZ    22FA
22C4:  BRA    2300
....................    { 
....................       case '0' : dg=0; break; 
22C6:  CLRF   xA3
22C8:  BRA    2302
....................       case '1' : dg=1; break; 
22CA:  MOVLW  01
22CC:  MOVWF  xA3
22CE:  BRA    2302
....................       case '2' : dg=2; break; 
22D0:  MOVLW  02
22D2:  MOVWF  xA3
22D4:  BRA    2302
....................       case '3' : dg=3; break; 
22D6:  MOVLW  03
22D8:  MOVWF  xA3
22DA:  BRA    2302
....................       case '4' : dg=4; break; 
22DC:  MOVLW  04
22DE:  MOVWF  xA3
22E0:  BRA    2302
....................       case '5' : dg=5; break; 
22E2:  MOVLW  05
22E4:  MOVWF  xA3
22E6:  BRA    2302
....................       case '6' : dg=6; break; 
22E8:  MOVLW  06
22EA:  MOVWF  xA3
22EC:  BRA    2302
....................       case '7' : dg=7; break; 
22EE:  MOVLW  07
22F0:  MOVWF  xA3
22F2:  BRA    2302
....................       case '8' : dg=8; break; 
22F4:  MOVLW  08
22F6:  MOVWF  xA3
22F8:  BRA    2302
....................       case '9' : dg=9; break; 
22FA:  MOVLW  09
22FC:  MOVWF  xA3
22FE:  BRA    2302
....................       default: dg = -1; 
2300:  SETF   xA3
....................    } 
....................  
....................    return dg; 
2302:  MOVFF  A3,01
2306:  RETURN 0
.................... } 
....................  
.................... char get_rx_ch (void) 
.................... {                                                      
.................... // Get RX char 
.................... char rch; 
....................  
....................    if (rd_ptr < wr_ptr) // буфер не пуст 
*
218C:  MOVF   x89,W
218E:  SUBWF  x8A,W
2190:  BC    21AA
....................    { 
....................       rd_ptr++;                    // инкремент счетчика считаных байт 
2192:  INCF   x8A,F
....................       rch = rx_buf[rd_ptr & 0x0F]; // сохр. элемента по индексу 
2194:  MOVF   x8A,W
2196:  ANDLW  0F
2198:  CLRF   03
219A:  ADDLW  8B
219C:  MOVWF  FE9
219E:  MOVLW  00
21A0:  ADDWFC 03,W
21A2:  MOVWF  FEA
21A4:  MOVFF  FEF,A2
....................    } 
21A8:  BRA    21AE
....................    else rch = 'x';    
21AA:  MOVLW  78
21AC:  MOVWF  xA2
....................     
....................    // запрет прерываний по UART на время сравнение указателей   
....................    // на счит. и запис. элементы массива 
....................    disable_interrupts(INT_RDA);     
21AE:  BCF    F9D.5
....................             
....................    if ((wr_ptr==rd_ptr) && (wr_ptr > 15)) // если буфер заполнен                                             
21B0:  MOVF   x8A,W
21B2:  SUBWF  x89,W
21B4:  BNZ   21C0
21B6:  MOVF   x89,W
21B8:  SUBLW  0F
21BA:  BC    21C0
....................    {   
....................       wr_ptr=0;                                                                    
21BC:  CLRF   x89
....................       rd_ptr=0;                                                        
21BE:  CLRF   x8A
....................    }  
....................  
.................... enable_interrupts(INT_RDA);         // разрешение прерываний 
21C0:  BSF    F9D.5
....................  
.................... return rch; 
21C2:  MOVFF  A2,01
21C6:  GOTO   2936 (RETURN)
.................... } 
....................  
.................... void main  () 
*
26F8:  CLRF   FF8
26FA:  BCF    FD0.7
26FC:  BSF    07.7
26FE:  BCF    FA7.3
2700:  MOVLW  40
2702:  MOVWF  FAF
2704:  MOVLW  A6
2706:  MOVWF  FAC
2708:  MOVLW  90
270A:  MOVWF  FAB
270C:  BCF    1A.0
270E:  BCF    1A.1
2710:  BCF    1A.2
2712:  CLRF   1B
2714:  MOVLW  01
2716:  MOVWF  1C
2718:  MOVLW  02
271A:  MOVWF  1D
271C:  MOVLW  A0
271E:  MOVWF  1E
2720:  CLRF   20
2722:  CLRF   1F
2724:  CLRF   22
2726:  CLRF   21
2728:  CLRF   24
272A:  CLRF   23
272C:  CLRF   26
272E:  CLRF   25
2730:  CLRF   28
2732:  CLRF   27
2734:  CLRF   2A
2736:  CLRF   29
2738:  CLRF   2E
273A:  CLRF   2D
273C:  CLRF   2C
273E:  CLRF   2B
2740:  CLRF   32
2742:  CLRF   31
2744:  CLRF   30
2746:  CLRF   2F
2748:  CLRF   36
274A:  CLRF   35
274C:  CLRF   34
274E:  CLRF   33
2750:  CLRF   38
2752:  CLRF   37
2754:  CLRF   39
2756:  CLRF   3B
2758:  CLRF   3A
275A:  CLRF   3C
275C:  CLRF   3E
275E:  CLRF   3D
2760:  CLRF   3F
2762:  CLRF   43
2764:  CLRF   42
2766:  CLRF   41
2768:  CLRF   40
276A:  CLRF   47
276C:  CLRF   46
276E:  CLRF   45
2770:  CLRF   44
2772:  CLRF   4B
2774:  CLRF   4A
2776:  CLRF   49
2778:  CLRF   48
277A:  CLRF   4F
277C:  CLRF   4E
277E:  CLRF   4D
2780:  MOVLW  7F
2782:  MOVWF  4C
2784:  CLRF   53
2786:  CLRF   52
2788:  CLRF   51
278A:  MOVWF  50
278C:  CLRF   57
278E:  CLRF   56
2790:  CLRF   55
2792:  MOVWF  54
2794:  CLRF   x78
2796:  CLRF   x79
2798:  CLRF   x7B
279A:  CLRF   x7A
279C:  CLRF   x81
279E:  CLRF   x80
27A0:  BCF    1A.3
27A2:  CLRF   x85
27A4:  CLRF   x84
27A6:  CLRF   x87
27A8:  CLRF   x86
27AA:  CLRF   x88
27AC:  CLRF   x89
27AE:  CLRF   x8A
27B0:  MOVLB  F
27B2:  MOVF   x5C,W
27B4:  ANDLW  80
27B6:  MOVWF  x5C
27B8:  MOVLW  00
27BA:  MOVWF  x5D
27BC:  BCF    FC1.3
27BE:  BCF    FC1.4
27C0:  BCF    FC1.5
27C2:  CLRF   x5E
27C4:  CLRF   x5F
27C6:  BRA    27D8
27C8:  DATA 03,00
27CA:  DATA 17,00
27CC:  DATA 00,00
27CE:  DATA 20,40
27D0:  DATA 58,00
27D2:  DATA 10,40
27D4:  DATA 8B,00
27D6:  DATA 00,00
27D8:  MOVLW  00
27DA:  MOVWF  FF8
27DC:  MOVLW  27
27DE:  MOVWF  FF7
27E0:  MOVLW  C8
27E2:  MOVWF  FF6
27E4:  TBLRD*+
27E6:  MOVF   FF5,W
27E8:  MOVWF  00
27EA:  XORLW  00
27EC:  BZ    2814
27EE:  TBLRD*+
27F0:  MOVF   FF5,W
27F2:  MOVWF  01
27F4:  BTFSC  FE8.7
27F6:  BRA    2802
27F8:  ANDLW  0F
27FA:  MOVWF  FEA
27FC:  TBLRD*+
27FE:  MOVFF  FF5,FE9
2802:  BTFSC  01.6
2804:  TBLRD*+
2806:  BTFSS  01.6
2808:  TBLRD*+
280A:  MOVFF  FF5,FEE
280E:  DCFSNZ 00,F
2810:  BRA    27E4
2812:  BRA    2806
2814:  CLRF   FF8
2816:  MOVLB  0
2818:  CLRF   x9B
281A:  CLRF   x9D
281C:  CLRF   x9E
281E:  CLRF   xA0
2820:  CLRF   x9F
....................  { 
.................... // режим программатора закомментирован 
....................  
....................  
.................... /* 
.................... ///////////////////////////////////////////////////////////////////////////////   
....................    /// программатор ПЗУ 
....................  
....................    //float kx = 1.058935361; // старые коэффициенты датчика № 2  
....................    //float ky = 1.20824295; 
....................    //float kz = 1.031481481; 
....................     
....................    //float kx = 1.041121495;   // старые коэффициенты датчика № 1 
....................    //float ky = 1.141393443; 
....................    //float kz = 1.023897059; 
....................     
....................    //float kx = 1.092291928;   // коэффициенты датчика № 1 21.04 
....................    //float ky = 1.170930426; 
....................    //float kz = 1.042684161; 
....................       
....................    float kx = 1;   // без коэффициентов 
....................    float ky = 1; 
....................    float kz = 1; 
....................        
....................    //float kx = 1.0778792;   // коэффициенты датчика № 2 кал. вечер 21.04 
....................    //float ky = 1.19226638; 
....................    //float kz = 1.06812933; 
....................     
....................    //float kx = 1.07537299;   // коэффициенты датчика № 1 кал. вечер 21.04 
....................    //float ky = 1.173361522; 
....................    //float kz = 1.061591431; 
....................     
....................    //float kx = 1.0517;     // коэффициенты датчика № 2 кал. 28.12.16 
....................    //float ky = 1.2266; 
....................    //float kz = 1.0406; 
....................     
....................    //float kx = 1.0747;     // коэффициенты датчика № 1 кал. 28.12.16 
....................    //float ky = 1.1824; 
....................    //float kz = 1.0650; 
....................     
....................       
....................    U16 sens_type = HMC5883l; //TLV493D; 
....................    U16 sens_num = 18; 
....................  
....................    U16 ROM_Adr = 0x0000; 
....................    U16 CRC_Wr; 
....................    U16 CRC1 = 0; 
....................    U16 CRC2 = 0;  
....................  
....................    TRB0 = 1;   // DRDY 
....................     
....................    TRB3 = 0;  
....................    TRB4 = 0; 
....................    TRB5 = 0; 
....................    TRC0 = 0; 
....................    TRC1 = 0; 
....................    TRC2 = 0; 
....................    TRC5 = 0; 
....................   
....................    TRC3 = 1; 
....................    TRC4 = 1; 
....................    TRC6 = 0;                  // UART1 - TX 
....................    TRC7 = 1;                  // UART1 - RX 
....................     
....................    EXT_INT_EDGE(L_TO_H); 
....................    enable_interrupts(INT_RDA); 
....................    enable_interrupts(INT_EXT); 
....................    //enable_interrupts(GLOBAL); 
....................  
....................    LCDInit(); 
....................    LcdWelcome(); 
....................    LCDSetCursor(two); 
....................    LCDMsg(" Запись в ПЗУ..."); 
.................... //-----------------------------------------------------------------------------        
....................    rom_wr_byte(ROM_Adr,sens_type);     // тип датчика   0 
....................    rom_wr_byte (++ROM_Adr, sens_num);  // № датчика     1 
....................    rom_wr_byte (++ROM_Adr, coord_sys); // сис.координат 2 
....................    rom_wr_float(++ROM_Adr,&kx);        // Kx            3-6  
....................    ROM_adr += 4; 
....................    rom_wr_float(ROM_Adr,&ky);          // Ky            7-10 
....................    ROM_adr += 4; 
....................    rom_wr_float(ROM_Adr,&kz);          // Kz            11-14 
....................     
....................    ROM_Adr += 4; 
....................    CRC1 = rom_wr_CRC16(ROM_Adr,crc_buf_wr); 
....................    crc_wr_index = 0;    
....................  //-----------------------------------------------------------------------------      
....................    sens_type = 0; 
....................    sens_num  = 0; 
....................     
....................    LCDclear(); 
....................     
....................    while(true){ 
....................     
....................    ROM_Adr = 0x0000; 
....................     
....................    kx = 0; 
....................    ky = 0; 
....................    kz = 0; 
....................     
....................     sens_type = rom_rd_byte (ROM_Adr); // тип датчика 0 
....................     ROM_Adr++; 
....................     sens_num = rom_rd_byte (ROM_Adr);  // № датчика 1 
....................     ROM_Adr++; 
....................     coord_sys = rom_rd_byte (ROM_Adr); // система координат 2 
....................     ROM_Adr++; 
....................     rom_rd_float (ROM_Adr,&kx); // Kx 3 - 6 
....................     ROM_adr += 4; 
....................     rom_rd_float (ROM_Adr,&ky); // Ky 7 - 10 
....................     ROM_adr += 4; 
....................     rom_rd_float (ROM_Adr,&kz); // Kz 11 - 14 
....................      
....................     ROM_adr += 4; 
....................     CRC1 = rom_rd_CRC16 (ROM_adr); // чтение сохраненной CRC 
....................     CRC2 = CRC16 (crc_buf_rd, 14); // расчет CRC по считанным данным 
....................     
....................    Lcdsetcursor(0x00); 
....................    LCDMsg("kx="); 
....................    LcdPutS16((S32)(kx*1000),5); 
....................    Lcdsetcursor(0x40); 
....................    LCDMsg("ky="); 
....................    LcdPutS16((S32)(ky*1000),5); 
....................    Lcdsetcursor(0x10); 
....................    LCDMsg("kz="); 
....................    LcdPutS16((S32)(kz*1000),5); 
....................     
....................    //Printf("CRC1=%LX\n",CRC1); 
....................    //Printf("CRC2=%LX\n",CRC2); 
....................     
....................    for(U8 i =0; i < sizeof(crc_buf_wr); i++) 
....................    { 
....................       //Printf("CRC_buf_wr =%LX CRC_buf_rd=%LX\n",crc_buf_wr[i], crc_buf_rd[i]); 
....................       Printf("__"); 
....................       Printf("CRC_buf_wr =%LX\n",crc_buf_wr[i]); 
....................        
....................       delay_ms(500); 
....................    } 
....................    Printf("\n\r"); 
....................    Printf("\n\r"); 
....................    //Printf("CRC1=%LX\n",CRC1); 
....................    crc_rd_index = 0; 
....................     
....................    delay_ms(500); 
....................     
....................    } // while 
....................  } // main 
.................... ///////////////////////////////////////////////////////////////////////////////   
.................... */ 
....................  
.................... //============================================================================= 
....................  
....................    /// режим измерений 
....................     
....................     U8 TLV493D_status = 0; 
....................     char rx_byte;       // байт принятый с ПК 
....................     U8 rd_state = 0;    // машина состояний 
....................     char coef_id = 0;   // идентификатор канала численного параметра с ПК 
....................     U16 num_param = 0;  // численный параметр полученый с ПК 
....................      
....................     TRB0 = 1; // DRDY 
2822:  BSF    F93.0
....................     TRB1 = 0; 
2824:  BCF    F93.1
....................      
....................     TRB3 = 0; 
2826:  BCF    F93.3
....................     TRB4 = 0; 
2828:  BCF    F93.4
....................     TRB5 = 0; 
282A:  BCF    F93.5
....................     TRC0 = 0; 
282C:  BCF    F94.0
....................     TRC1 = 0; 
282E:  BCF    F94.1
....................     TRC2 = 0; 
2830:  BCF    F94.2
....................     TRC5 = 0; 
2832:  BCF    F94.5
....................     TRC3 = 1; 
2834:  BSF    F94.3
....................     TRC4 = 1; 
2836:  BSF    F94.4
....................     TRC6 = 0; // UART1 - TX 
2838:  BCF    F94.6
....................     TRC7 = 1; // UART1 - RX 
283A:  BSF    F94.7
....................  
....................     LED = 1; 
283C:  BSF    F8A.1
....................      
....................     LCDInit (); 
283E:  GOTO   05C2
....................     LCDWelcome (); 
2842:  GOTO   06B2
....................     if(detect_sensors() != 0) LCDsensInfoMsg(); 
2846:  CALL   0B8A
284A:  MOVF   01,F
284C:  BTFSS  FD8.2
284E:  CALL   1256
....................  
....................     enable_interrupts (int_RDA); 
2852:  BSF    F9D.5
....................     enable_interrupts (GLOBAL); 
2854:  MOVLW  C0
2856:  IORWF  FF2,F
.................... //-----------------------------------------------------------------------------    
....................     while (true) 
....................     {  
....................        restart_wdt();  
2858:  CLRWDT
.................... //-----------------------------------------------------------------------------    
....................        switch(sens_type) // анализ типа текущего датчика 
285A:  MOVFF  7C,00
285E:  MOVF   x7D,W
2860:  MOVWF  03
2862:  BNZ   286A
2864:  MOVLW  25
2866:  SUBWF  00,W
2868:  BZ    2876
286A:  MOVF   03,W
286C:  BNZ   2874
286E:  MOVLW  1E
2870:  SUBWF  00,W
2872:  BZ    28C2
2874:  BRA    2906
....................        { 
....................         case TLV493D:    // тип - 1.3 kGs 
....................              TLV493D_status = TLV493D_rd_all(coord_sys); // режим штатного чтения 
2876:  MOVFF  7A,A2
287A:  GOTO   16C8
287E:  MOVFF  01,9B
....................              
....................              if (TLV493D_status == 1)                    // датчик подключен, чтение успешно               
2882:  DECFSZ x9B,W
2884:  BRA    28BC
....................              { 
....................                LCDSetCursor(four); 
2886:  MOVLW  50
2888:  MOVWF  xBE
288A:  CALL   0694
....................                LCDMsg(" r"); LCDPutU16(coord_sys, 1);    // вывод на дисплей системы координат 
288E:  MOVLW  64
2890:  MOVWF  FF6
2892:  MOVLW  04
2894:  MOVWF  FF7
2896:  CALL   0674
289A:  CLRF   xAB
289C:  CLRF   xAA
289E:  MOVFF  7B,A9
28A2:  MOVFF  7A,A8
28A6:  MOVLW  01
28A8:  MOVWF  xAC
28AA:  CALL   1010
....................                LCDMsg("  1,3 kGs  ");                    // и типа датчика 
28AE:  MOVLW  68
28B0:  MOVWF  FF6
28B2:  MOVLW  04
28B4:  MOVWF  FF7
28B6:  CALL   0674
....................              } 
28BA:  BRA    28C0
....................              else sens_type = 0;      // сброс режима датчика, требуется новая инициализация 
28BC:  CLRF   x7D
28BE:  CLRF   x7C
....................               
....................         break; 
28C0:  BRA    2926
....................         //===========    
....................         case HMC5883l:  // тип - 8 Gs 
....................          
....................             if (int_fl) // если был взведен флаг в прерывании от датчика 
28C2:  BTFSS  1A.0
28C4:  BRA    2900
....................              {     
....................                SensRdAll(); // режим штатного чтения 
28C6:  GOTO   1C50
....................                LCDSetCursor(four); 
28CA:  MOVLW  50
28CC:  MOVWF  xBE
28CE:  CALL   0694
....................                LCDMsg(" r"); LCDPutU16(coord_sys, 1); // вывод на дисплей системы координат 
28D2:  MOVLW  74
28D4:  MOVWF  FF6
28D6:  MOVLW  04
28D8:  MOVWF  FF7
28DA:  CALL   0674
28DE:  CLRF   xAB
28E0:  CLRF   xAA
28E2:  MOVFF  7B,A9
28E6:  MOVFF  7A,A8
28EA:  MOVLW  01
28EC:  MOVWF  xAC
28EE:  CALL   1010
....................                LCDMsg("   8,1 Gs ");                  // и типа датчика 
28F2:  MOVLW  78
28F4:  MOVWF  FF6
28F6:  MOVLW  04
28F8:  MOVWF  FF7
28FA:  CALL   0674
....................              } 
28FE:  BRA    2904
....................              else sens_type = 0;                      // сброс режима датчика, требуется новая инициализация 
2900:  CLRF   x7D
2902:  CLRF   x7C
....................         //===========    
....................         break; 
2904:  BRA    2926
....................         //===========               
....................         default:  
....................                if(detect_sensors() == 0)  
2906:  CALL   0B8A
290A:  MOVF   01,F
290C:  BNZ   2922
....................                {  
....................                   NC_LCDMsg(); 
290E:  BRA    213A
....................                   delay_ms(1000); 
2910:  MOVLW  04
2912:  MOVWF  xA2
2914:  MOVLW  FA
2916:  MOVWF  xBF
2918:  CALL   050E
291C:  DECFSZ xA2,F
291E:  BRA    2914
....................                } 
2920:  BRA    2926
....................                else LCDsensInfoMsg(); 
2922:  CALL   1256
....................                break;  
....................        } 
.................... //-----------------------------------------------------------------------------    
....................        if (!SB2) set_zero_fl = 1; // проверка нажатия УСТ. 0 
2926:  BTFSC  F80.3
2928:  BRA    292C
292A:  BSF    1A.2
.................... //-----------------------------------------------------------------------------  
.................... // обработка команд 
....................  
....................        while(rd_ptr < wr_ptr) // буфер не пуст, получен байт  
292C:  MOVF   x89,W
292E:  SUBWF  x8A,W
2930:  BTFSC  FD8.0
2932:  BRA    2ED4
....................         { 
....................               U8 temp_buf;                                          
....................               rx_byte = get_rx_ch();   
2934:  BRA    218C
2936:  MOVFF  01,9C
....................                
....................               // вывод символа получения команды с ПК 
....................               LCDSetCursor(four); 
293A:  MOVLW  50
293C:  MOVWF  xBE
293E:  CALL   0694
....................               LCDMsg("             *"); 
2942:  MOVLW  84
2944:  MOVWF  FF6
2946:  MOVLW  04
2948:  MOVWF  FF7
294A:  CALL   0674
....................  
....................                switch(rd_state)  // конечный автомат состояний чтения команд 
294E:  MOVF   x9D,W
2950:  BZ    2972
2952:  XORLW  01
2954:  BTFSC  FD8.2
2956:  BRA    2B3E
2958:  XORLW  03
295A:  BTFSC  FD8.2
295C:  BRA    2B8C
295E:  XORLW  01
2960:  BTFSC  FD8.2
2962:  BRA    2BD4
2964:  XORLW  07
2966:  BTFSC  FD8.2
2968:  BRA    2C1C
296A:  XORLW  01
296C:  BTFSC  FD8.2
296E:  BRA    2E1A
2970:  BRA    2EB6
....................                { 
....................                //----- 
....................                   case 0:        // обработка однобайтных команд 
....................                      switch(rx_byte) 
2972:  MOVF   x9C,W
2974:  XORLW  7A
2976:  BZ    2998
2978:  XORLW  09
297A:  BZ    29A8
297C:  XORLW  01
297E:  BZ    29FC
2980:  XORLW  19
2982:  BZ    2A02
2984:  XORLW  0A
2986:  BTFSC  FD8.2
2988:  BRA    2B12
298A:  XORLW  03
298C:  BTFSC  FD8.2
298E:  BRA    2B1C
2990:  XORLW  01
2992:  BTFSC  FD8.2
2994:  BRA    2B26
2996:  BRA    2B30
....................                      { 
....................                         case 'z':            // получена команда уст. 0 
....................                            set_zero_fl = 1;  // выставляем флаг уст. 0 
2998:  BSF    1A.2
....................                            printf("ok\n\r"); // отсылка ответа на ПК 
299A:  MOVLW  94
299C:  MOVWF  FF6
299E:  MOVLW  04
29A0:  MOVWF  FF7
29A2:  RCALL  21CA
....................                            rd_state = 0;     // возврат в состояние анализа заголовка команды 
29A4:  CLRF   x9D
....................                            break; 
29A6:  BRA    2B3C
....................                            //===== 
....................                         case 's':            // получена команда запроса id и системы координат 
....................                            printf("r=");  printf("%01lu,",coord_sys);   // отсылка системы координат 
29A8:  MOVLW  72
29AA:  BTFSS  F9E.4
29AC:  BRA    29AA
29AE:  MOVWF  FAD
29B0:  MOVLW  3D
29B2:  BTFSS  F9E.4
29B4:  BRA    29B2
29B6:  MOVWF  FAD
29B8:  MOVLW  0C
29BA:  MOVWF  FE9
29BC:  MOVFF  7B,A5
29C0:  MOVFF  7A,A4
29C4:  RCALL  21EC
29C6:  MOVLW  2C
29C8:  BTFSS  F9E.4
29CA:  BRA    29C8
29CC:  MOVWF  FAD
....................                            printf("id="); printf("%02lu\n\r",sens_type); // отсылка id 
29CE:  MOVLW  9A
29D0:  MOVWF  FF6
29D2:  MOVLW  04
29D4:  MOVWF  FF7
29D6:  CALL   21CA
29DA:  MOVLW  0B
29DC:  MOVWF  FE9
29DE:  MOVFF  7D,A5
29E2:  MOVFF  7C,A4
29E6:  RCALL  21EC
29E8:  MOVLW  0A
29EA:  BTFSS  F9E.4
29EC:  BRA    29EA
29EE:  MOVWF  FAD
29F0:  MOVLW  0D
29F2:  BTFSS  F9E.4
29F4:  BRA    29F2
29F6:  MOVWF  FAD
....................                            rd_state = 0;     // возврат в состояние анализа заголовка команды 
29F8:  CLRF   x9D
....................                            break; 
29FA:  BRA    2B3C
....................                            //===== 
....................                         case 'r':            // получена команда уст. системы координат 
....................                            rd_state = 5;     // переход в состояние анализа команды  
29FC:  MOVLW  05
29FE:  MOVWF  x9D
....................                            break; 
2A00:  BRA    2B3C
....................                            //=====                            
....................                         case 'k':            // получена команда запроса коэффициентов 
....................                            printf("a"); printf("%04lu",(U16)(kx*1000));  // отсылка коэфф. 
2A02:  MOVLW  61
2A04:  BTFSS  F9E.4
2A06:  BRA    2A04
2A08:  MOVWF  FAD
2A0A:  MOVFF  4F,CB
2A0E:  MOVFF  4E,CA
2A12:  MOVFF  4D,C9
2A16:  MOVFF  4C,C8
2A1A:  CLRF   xCF
2A1C:  CLRF   xCE
2A1E:  MOVLW  7A
2A20:  MOVWF  xCD
2A22:  MOVLW  88
2A24:  MOVWF  xCC
2A26:  CALL   0EE0
2A2A:  MOVFF  03,C1
2A2E:  MOVFF  02,C0
2A32:  MOVFF  01,BF
2A36:  MOVFF  00,BE
2A3A:  CALL   1578
2A3E:  MOVFF  02,A3
2A42:  MOVFF  01,A2
2A46:  MOVLW  09
2A48:  MOVWF  FE9
2A4A:  MOVFF  02,A5
2A4E:  MOVFF  01,A4
2A52:  CALL   21EC
....................                            printf("b"); printf("%04lu",(U16)(ky*1000)); 
2A56:  MOVLW  62
2A58:  BTFSS  F9E.4
2A5A:  BRA    2A58
2A5C:  MOVWF  FAD
2A5E:  MOVFF  53,CB
2A62:  MOVFF  52,CA
2A66:  MOVFF  51,C9
2A6A:  MOVFF  50,C8
2A6E:  CLRF   xCF
2A70:  CLRF   xCE
2A72:  MOVLW  7A
2A74:  MOVWF  xCD
2A76:  MOVLW  88
2A78:  MOVWF  xCC
2A7A:  CALL   0EE0
2A7E:  MOVFF  03,C1
2A82:  MOVFF  02,C0
2A86:  MOVFF  01,BF
2A8A:  MOVFF  00,BE
2A8E:  CALL   1578
2A92:  MOVFF  02,A3
2A96:  MOVFF  01,A2
2A9A:  MOVLW  09
2A9C:  MOVWF  FE9
2A9E:  MOVFF  02,A5
2AA2:  MOVFF  01,A4
2AA6:  CALL   21EC
....................                            printf("c"); printf("%04lu\n\r",(U16)(kz*1000)); 
2AAA:  MOVLW  63
2AAC:  BTFSS  F9E.4
2AAE:  BRA    2AAC
2AB0:  MOVWF  FAD
2AB2:  MOVFF  57,CB
2AB6:  MOVFF  56,CA
2ABA:  MOVFF  55,C9
2ABE:  MOVFF  54,C8
2AC2:  CLRF   xCF
2AC4:  CLRF   xCE
2AC6:  MOVLW  7A
2AC8:  MOVWF  xCD
2ACA:  MOVLW  88
2ACC:  MOVWF  xCC
2ACE:  CALL   0EE0
2AD2:  MOVFF  03,C1
2AD6:  MOVFF  02,C0
2ADA:  MOVFF  01,BF
2ADE:  MOVFF  00,BE
2AE2:  CALL   1578
2AE6:  MOVFF  02,A3
2AEA:  MOVFF  01,A2
2AEE:  MOVLW  09
2AF0:  MOVWF  FE9
2AF2:  MOVFF  02,A5
2AF6:  MOVFF  01,A4
2AFA:  CALL   21EC
2AFE:  MOVLW  0A
2B00:  BTFSS  F9E.4
2B02:  BRA    2B00
2B04:  MOVWF  FAD
2B06:  MOVLW  0D
2B08:  BTFSS  F9E.4
2B0A:  BRA    2B08
2B0C:  MOVWF  FAD
....................                            rd_state = 0;     // возврат в состояние анализа заголовка команды 
2B0E:  CLRF   x9D
....................                            break; 
2B10:  BRA    2B3C
....................                            //===== 
....................                         case 'a':            // получена команда уст. коэфф. а 
....................                            rd_state = 1;     // переход в состояние чтения первого байта команды 
2B12:  MOVLW  01
2B14:  MOVWF  x9D
....................                            coef_id = 'a';    // сохранение идентификатора параметра 
2B16:  MOVLW  61
2B18:  MOVWF  x9E
....................                            break; 
2B1A:  BRA    2B3C
....................                            //===== 
....................                         case 'b':            // получена команда уст. коэфф. b 
....................                            rd_state = 1;     // переход в состояние чтения первого байта команды 
2B1C:  MOVLW  01
2B1E:  MOVWF  x9D
....................                            coef_id = 'b';    // сохранение идентификатора параметра 
2B20:  MOVLW  62
2B22:  MOVWF  x9E
....................                            break; 
2B24:  BRA    2B3C
....................                            //===== 
....................                         case 'c':            // получена команда уст. коэфф. c 
....................                            rd_state = 1;     // переход в состояние чтения первого байта команды 
2B26:  MOVLW  01
2B28:  MOVWF  x9D
....................                            coef_id = 'c';    // сохранение идентификатора параметра 
2B2A:  MOVLW  63
2B2C:  MOVWF  x9E
....................                            break; 
2B2E:  BRA    2B3C
....................                            //=====                            
....................                             
....................                         default:  
....................                            printf("cmd error\n\r");  
2B30:  MOVLW  9E
2B32:  MOVWF  FF6
2B34:  MOVLW  04
2B36:  MOVWF  FF7
2B38:  CALL   21CA
....................                            break; 
....................                      } 
....................                   break; 
2B3C:  BRA    2EB6
....................                //----- 
....................                // анализ цифр переданных с параметром 
....................                case 1:  
....................                   temp_buf = ch_to_int(rx_byte); 
2B3E:  MOVFF  9C,A2
2B42:  CALL   2298
2B46:  MOVFF  01,A1
....................                   if(temp_buf == -1)   // проверка адекватности параметра                                                            
2B4A:  MOVF   xA1,W
2B4C:  SUBLW  FF
2B4E:  BNZ   2B60
....................                   {         
....................                    rd_state = 0;                                                 
2B50:  CLRF   x9D
....................                    printf("err p1\n\r");                                             
2B52:  MOVLW  AA
2B54:  MOVWF  FF6
2B56:  MOVLW  04
2B58:  MOVWF  FF7
2B5A:  CALL   21CA
....................                    break; 
2B5E:  BRA    2EB6
....................                   } 
....................                                                                          
....................                   num_param = 0;                                                                  
2B60:  CLRF   xA0
2B62:  CLRF   x9F
....................                   num_param += (U16) temp_buf*1000;                                                       
2B64:  CLRF   xA3
2B66:  MOVFF  A1,A2
2B6A:  MOVFF  A3,A5
2B6E:  MOVFF  A1,A4
2B72:  MOVLW  03
2B74:  MOVWF  xA7
2B76:  MOVLW  E8
2B78:  MOVWF  xA6
2B7A:  CALL   2308
2B7E:  MOVF   01,W
2B80:  ADDWF  x9F,F
2B82:  MOVF   02,W
2B84:  ADDWFC xA0,F
....................                   rd_state = 2;                                                              
2B86:  MOVLW  02
2B88:  MOVWF  x9D
....................                break; 
2B8A:  BRA    2EB6
....................                //----- 
....................                case 2:  
....................                   temp_buf = ch_to_int(rx_byte); 
2B8C:  MOVFF  9C,A2
2B90:  CALL   2298
2B94:  MOVFF  01,A1
....................                   if(temp_buf == -1)   // проверка адекватности параметра                                                               
2B98:  MOVF   xA1,W
2B9A:  SUBLW  FF
2B9C:  BNZ   2BAE
....................                   {         
....................                    rd_state = 0;                                                 
2B9E:  CLRF   x9D
....................                    printf("err p2\n\r");                                             
2BA0:  MOVLW  B4
2BA2:  MOVWF  FF6
2BA4:  MOVLW  04
2BA6:  MOVWF  FF7
2BA8:  CALL   21CA
....................                    break; 
2BAC:  BRA    2EB6
....................                   }                                                                                               
....................                   num_param += (U16) temp_buf*100;                                                       
2BAE:  CLRF   xA3
2BB0:  MOVFF  A1,A2
2BB4:  MOVFF  A3,A5
2BB8:  MOVFF  A1,A4
2BBC:  CLRF   xA7
2BBE:  MOVLW  64
2BC0:  MOVWF  xA6
2BC2:  CALL   2308
2BC6:  MOVF   01,W
2BC8:  ADDWF  x9F,F
2BCA:  MOVF   02,W
2BCC:  ADDWFC xA0,F
....................                   rd_state = 3;                                                              
2BCE:  MOVLW  03
2BD0:  MOVWF  x9D
....................                break; 
2BD2:  BRA    2EB6
....................                //----- 
....................                case 3:  
....................                   temp_buf = ch_to_int(rx_byte); 
2BD4:  MOVFF  9C,A2
2BD8:  CALL   2298
2BDC:  MOVFF  01,A1
....................                   if(temp_buf == -1)   // проверка адекватности параметра                                                       
2BE0:  MOVF   xA1,W
2BE2:  SUBLW  FF
2BE4:  BNZ   2BF6
....................                   {         
....................                    rd_state = 0;                                                 
2BE6:  CLRF   x9D
....................                    printf("err p3\n\r");                                             
2BE8:  MOVLW  BE
2BEA:  MOVWF  FF6
2BEC:  MOVLW  04
2BEE:  MOVWF  FF7
2BF0:  CALL   21CA
....................                    break; 
2BF4:  BRA    2EB6
....................                   } 
....................                   num_param += (U16) temp_buf*10;                                                       
2BF6:  CLRF   xA3
2BF8:  MOVFF  A1,A2
2BFC:  MOVFF  A3,A5
2C00:  MOVFF  A1,A4
2C04:  CLRF   xA7
2C06:  MOVLW  0A
2C08:  MOVWF  xA6
2C0A:  CALL   2308
2C0E:  MOVF   01,W
2C10:  ADDWF  x9F,F
2C12:  MOVF   02,W
2C14:  ADDWFC xA0,F
....................                   rd_state = 4;                                                              
2C16:  MOVLW  04
2C18:  MOVWF  x9D
....................                break; 
2C1A:  BRA    2EB6
....................                //----- 
....................                 case 4:  
....................                   temp_buf = ch_to_int(rx_byte); 
2C1C:  MOVFF  9C,A2
2C20:  CALL   2298
2C24:  MOVFF  01,A1
....................                   if(temp_buf == -1)   // проверка адекватности параметра                                                            
2C28:  MOVF   xA1,W
2C2A:  SUBLW  FF
2C2C:  BNZ   2C3E
....................                   {         
....................                    rd_state = 0;                                                 
2C2E:  CLRF   x9D
....................                    printf("err p4\n\r");                                             
2C30:  MOVLW  C8
2C32:  MOVWF  FF6
2C34:  MOVLW  04
2C36:  MOVWF  FF7
2C38:  CALL   21CA
....................                    break; 
2C3C:  BRA    2EB6
....................                   } 
....................                   num_param += (U16) temp_buf;     
2C3E:  CLRF   03
2C40:  MOVF   xA1,W
2C42:  ADDWF  x9F,F
2C44:  MOVF   03,W
2C46:  ADDWFC xA0,F
....................                    
....................                   // все 4 цифры параметра получены успешно 
....................                   switch(coef_id) // сохраняем полученный коэф. в переменную 
2C48:  MOVF   x9E,W
2C4A:  XORLW  61
2C4C:  BZ    2C5A
2C4E:  XORLW  03
2C50:  BZ    2CD8
2C52:  XORLW  01
2C54:  BTFSC  FD8.2
2C56:  BRA    2D56
2C58:  BRA    2DD4
....................                   { 
....................                      case 'a':  
....................                         kx = (float) num_param / 1000.0;  
2C5A:  MOVFF  A0,A3
2C5E:  MOVFF  9F,A2
2C62:  CALL   2326
2C66:  MOVFF  03,A5
2C6A:  MOVFF  02,A4
2C6E:  MOVFF  01,A3
2C72:  MOVFF  00,A2
2C76:  MOVFF  03,A9
2C7A:  MOVFF  02,A8
2C7E:  MOVFF  01,A7
2C82:  MOVFF  00,A6
2C86:  CLRF   xAD
2C88:  CLRF   xAC
2C8A:  MOVLW  7A
2C8C:  MOVWF  xAB
2C8E:  MOVLW  88
2C90:  MOVWF  xAA
2C92:  CALL   235C
2C96:  MOVFF  03,4F
2C9A:  MOVFF  02,4E
2C9E:  MOVFF  01,4D
2CA2:  MOVFF  00,4C
....................                         if(kx == 0)  { kx = 1.0; num_param += 1000; } // защита от уст. коэф. = 0 
2CA6:  MOVFF  4F,A5
2CAA:  MOVFF  4E,A4
2CAE:  MOVFF  4D,A3
2CB2:  MOVFF  4C,A2
2CB6:  CLRF   xA9
2CB8:  CLRF   xA8
2CBA:  CLRF   xA7
2CBC:  CLRF   xA6
2CBE:  CALL   24B6
2CC2:  BNZ   2CD6
2CC4:  CLRF   4F
2CC6:  CLRF   4E
2CC8:  CLRF   4D
2CCA:  MOVLW  7F
2CCC:  MOVWF  4C
2CCE:  MOVLW  E8
2CD0:  ADDWF  x9F,F
2CD2:  MOVLW  03
2CD4:  ADDWFC xA0,F
....................                         break; 
2CD6:  BRA    2DD4
....................                      case 'b':  
....................                         ky = (float) num_param / 1000.0;  
2CD8:  MOVFF  A0,A3
2CDC:  MOVFF  9F,A2
2CE0:  CALL   2326
2CE4:  MOVFF  03,A5
2CE8:  MOVFF  02,A4
2CEC:  MOVFF  01,A3
2CF0:  MOVFF  00,A2
2CF4:  MOVFF  03,A9
2CF8:  MOVFF  02,A8
2CFC:  MOVFF  01,A7
2D00:  MOVFF  00,A6
2D04:  CLRF   xAD
2D06:  CLRF   xAC
2D08:  MOVLW  7A
2D0A:  MOVWF  xAB
2D0C:  MOVLW  88
2D0E:  MOVWF  xAA
2D10:  CALL   235C
2D14:  MOVFF  03,53
2D18:  MOVFF  02,52
2D1C:  MOVFF  01,51
2D20:  MOVFF  00,50
....................                         if(ky == 0) { ky = 1.0; num_param += 1000; }  // защита от уст. коэф. = 0 
2D24:  MOVFF  53,A5
2D28:  MOVFF  52,A4
2D2C:  MOVFF  51,A3
2D30:  MOVFF  50,A2
2D34:  CLRF   xA9
2D36:  CLRF   xA8
2D38:  CLRF   xA7
2D3A:  CLRF   xA6
2D3C:  CALL   24B6
2D40:  BNZ   2D54
2D42:  CLRF   53
2D44:  CLRF   52
2D46:  CLRF   51
2D48:  MOVLW  7F
2D4A:  MOVWF  50
2D4C:  MOVLW  E8
2D4E:  ADDWF  x9F,F
2D50:  MOVLW  03
2D52:  ADDWFC xA0,F
....................                         break; 
2D54:  BRA    2DD4
....................                      case 'c':  
....................                         kz = (float) num_param / 1000.0;  
2D56:  MOVFF  A0,A3
2D5A:  MOVFF  9F,A2
2D5E:  CALL   2326
2D62:  MOVFF  03,A5
2D66:  MOVFF  02,A4
2D6A:  MOVFF  01,A3
2D6E:  MOVFF  00,A2
2D72:  MOVFF  03,A9
2D76:  MOVFF  02,A8
2D7A:  MOVFF  01,A7
2D7E:  MOVFF  00,A6
2D82:  CLRF   xAD
2D84:  CLRF   xAC
2D86:  MOVLW  7A
2D88:  MOVWF  xAB
2D8A:  MOVLW  88
2D8C:  MOVWF  xAA
2D8E:  CALL   235C
2D92:  MOVFF  03,57
2D96:  MOVFF  02,56
2D9A:  MOVFF  01,55
2D9E:  MOVFF  00,54
....................                         if(kz == 0) { kz = 1.0; num_param += 1000; }// защита от уст. коэф. = 0 
2DA2:  MOVFF  57,A5
2DA6:  MOVFF  56,A4
2DAA:  MOVFF  55,A3
2DAE:  MOVFF  54,A2
2DB2:  CLRF   xA9
2DB4:  CLRF   xA8
2DB6:  CLRF   xA7
2DB8:  CLRF   xA6
2DBA:  CALL   24B6
2DBE:  BNZ   2DD2
2DC0:  CLRF   57
2DC2:  CLRF   56
2DC4:  CLRF   55
2DC6:  MOVLW  7F
2DC8:  MOVWF  54
2DCA:  MOVLW  E8
2DCC:  ADDWF  x9F,F
2DCE:  MOVLW  03
2DD0:  ADDWFC xA0,F
....................                         break; 
2DD2:  BRA    2DD4
....................                      default: break; 
....................                   } 
....................                   Printf("%c", coef_id);           // отправка id коэффициента 
2DD4:  MOVF   x9E,W
2DD6:  BTFSS  F9E.4
2DD8:  BRA    2DD6
2DDA:  MOVWF  FAD
....................                   printf("%04lu\n\r",num_param);   // отправка коэффициента 
2DDC:  MOVLW  09
2DDE:  MOVWF  FE9
2DE0:  MOVFF  A0,A5
2DE4:  MOVFF  9F,A4
2DE8:  CALL   21EC
2DEC:  MOVLW  0A
2DEE:  BTFSS  F9E.4
2DF0:  BRA    2DEE
2DF2:  MOVWF  FAD
2DF4:  MOVLW  0D
2DF6:  BTFSS  F9E.4
2DF8:  BRA    2DF6
2DFA:  MOVWF  FAD
....................                    
....................                   // вывод сообщения о записи в пзу 
....................                   LCDclear(); 
2DFC:  CALL   06A0
....................                   LCDSetCursor(two); 
2E00:  MOVLW  40
2E02:  MOVWF  xBE
2E04:  CALL   0694
....................                   LCDMsg(" Запись в ПЗУ..."); 
2E08:  MOVLW  D2
2E0A:  MOVWF  FF6
2E0C:  MOVLW  04
2E0E:  MOVWF  FF7
2E10:  CALL   0674
....................                   update_rom_data();         // запись в пзу 
2E14:  RCALL  2656
....................                   rd_state = 0;              // возврат в состояние анализа заголовка команды                                                             
2E16:  CLRF   x9D
....................                break;  
2E18:  BRA    2EB6
....................                //----- 
....................                case 5:  
....................                   temp_buf = ch_to_int(rx_byte); 
2E1A:  MOVFF  9C,A2
2E1E:  CALL   2298
2E22:  MOVFF  01,A1
....................                   if((temp_buf == -1) | (temp_buf > 2))  // проверка адекватности параметра                                                          
2E26:  MOVF   xA1,W
2E28:  SUBLW  FF
2E2A:  BZ    2E30
2E2C:  MOVLW  00
2E2E:  BRA    2E32
2E30:  MOVLW  01
2E32:  MOVWF  xA2
2E34:  MOVF   xA1,W
2E36:  SUBLW  02
2E38:  BNC   2E3E
2E3A:  MOVLW  00
2E3C:  BRA    2E40
2E3E:  MOVLW  01
2E40:  IORWF  xA2,W
2E42:  BZ    2E54
....................                   {         
....................                    rd_state = 0;             // возврат в состояние анализа заголовка команды                                                
2E44:  CLRF   x9D
....................                    printf("err p\n\r");                               
2E46:  MOVLW  E4
2E48:  MOVWF  FF6
2E4A:  MOVLW  04
2E4C:  MOVWF  FF7
2E4E:  CALL   21CA
....................                    break; 
2E52:  BRA    2EB6
....................                   } 
....................                   SUMX0 = 0; // сброс коэфф. уст. 0 
2E54:  CLRF   26
2E56:  CLRF   25
....................                   SUMY0 = 0; 
2E58:  CLRF   28
2E5A:  CLRF   27
....................                   SUMZ0 = 0;  
2E5C:  CLRF   2A
2E5E:  CLRF   29
....................                   coord_sys = (U16)temp_buf;      // обновление системы координат   
2E60:  CLRF   x7B
2E62:  MOVFF  A1,7A
....................                   printf("r="); 
2E66:  MOVLW  72
2E68:  BTFSS  F9E.4
2E6A:  BRA    2E68
2E6C:  MOVWF  FAD
2E6E:  MOVLW  3D
2E70:  BTFSS  F9E.4
2E72:  BRA    2E70
2E74:  MOVWF  FAD
....................                   printf("%01ld\n\r",coord_sys);   // отправка нового значения системы координат 
2E76:  MOVLW  0D
2E78:  MOVWF  FE9
2E7A:  MOVFF  7B,BF
2E7E:  MOVFF  7A,BE
2E82:  CALL   15B0
2E86:  MOVLW  0A
2E88:  BTFSS  F9E.4
2E8A:  BRA    2E88
2E8C:  MOVWF  FAD
2E8E:  MOVLW  0D
2E90:  BTFSS  F9E.4
2E92:  BRA    2E90
2E94:  MOVWF  FAD
....................                   // вывод сообщения о записи в пзу 
....................                   LCDclear(); 
2E96:  CALL   06A0
....................                   LCDSetCursor(two); 
2E9A:  MOVLW  40
2E9C:  MOVWF  xBE
2E9E:  CALL   0694
....................                   LCDMsg(" Запись в ПЗУ..."); 
2EA2:  MOVLW  EC
2EA4:  MOVWF  FF6
2EA6:  MOVLW  04
2EA8:  MOVWF  FF7
2EAA:  CALL   0674
....................                   update_rom_data();              // запись в пзу 
2EAE:  CALL   2656
....................                   rd_state = 0;                   // возврат в состояние анализа заголовка команды 
2EB2:  CLRF   x9D
....................                   break; 
2EB4:  BRA    2EB6
....................                //----- 
....................                default: break; 
....................                 
....................                } // switch 
....................                 
....................                // очистка символа получения команды с ПК 
....................               LCDSetCursor(four); 
2EB6:  MOVLW  50
2EB8:  MOVWF  xBE
2EBA:  CALL   0694
....................               delay_ms(75); 
2EBE:  MOVLW  4B
2EC0:  MOVWF  xBF
2EC2:  CALL   050E
....................               LCDMsg("              "); 
2EC6:  MOVLW  FE
2EC8:  MOVWF  FF6
2ECA:  MOVLW  04
2ECC:  MOVWF  FF7
2ECE:  CALL   0674
2ED2:  BRA    292C
....................             }  // while 
2ED4:  BRA    2858
....................              
....................     } // while 
....................  }  // main 
.................... //============================================================================= 
2ED6:  SLEEP 

Configuration Fuses:
   Word  1: C315   VREGSLEEP INTRC_HP SOSC_DIG NOXINST HSM NOPLLEN FCMEN IESO
   Word  2: 3378   PUT NOBROWNOUT BORV18 ZPBORM WDT WDT4096
   Word  3: 8900   CANB MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
