CCS PCH C Compiler, Version 5.049, 5967               20-июл-18 14:19

               Filename:   F:\Mega\ponkin-prjs\PICC\my prj\XYZ magnitometer\Актуальная Версия 2.1_5.019\V2.1.lst

               ROM used:   2374 bytes (7%)
                           Largest free fragment is 30390
               RAM used:   166 (5%) at main() level
                           180 (5%) worst case
               Stack used: 11 locations (7 in main + 4 for interrupts)
               Stack size: 31

*
0000:  GOTO   07E2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.4
0056:  GOTO   0060
005A:  BTFSC  FF2.1
005C:  GOTO   0298
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   03D8
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... /******************************************************/ 
.................... /* Software V2.3 for magnetic induction's tester V2.1 */ 
.................... /******************************************************/ 
.................... // последние изменения 15.03.17 
....................  
.................... #include <V2.1.h> 
.................... #include <18F25K80.h> 
.................... //////////// Standard Header file for the PIC18F25K80 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F25K80 
00BA:  DATA 20,20
00BC:  DATA 20,C8
00BE:  DATA E7,EC
00C0:  DATA E5,F0
00C2:  DATA E8,F2
00C4:  DATA E5,EB
00C6:  DATA FC,00
00C8:  DATA 20,20
00CA:  DATA 20,EC
00CC:  DATA E0,E3
00CE:  DATA ED,E8
00D0:  DATA F2,ED
00D2:  DATA EE,E9
00D4:  DATA 00,00
00D6:  DATA 20,E8
00D8:  DATA ED,E4
00DA:  DATA F3,EA
00DC:  DATA F6,E8
00DE:  DATA E8,2E
00E0:  DATA 20,76
00E2:  DATA 32,2E
00E4:  DATA 34,20
00E6:  DATA 00,00
00E8:  DATA 20,20
00EA:  DATA 20,20
00EC:  DATA 20,20
00EE:  DATA 20,20
00F0:  DATA 20,20
00F2:  DATA 20,20
00F4:  DATA 20,20
00F6:  DATA 20,20
00F8:  DATA 00,00
00FA:  DATA 20,20
00FC:  DATA 20,20
00FE:  DATA C4,C0
0100:  DATA D2,D7
0102:  DATA C8,CA
0104:  DATA 20,20
0106:  DATA 20,20
0108:  DATA 20,00
010A:  DATA 20,20
010C:  DATA 20,20
010E:  DATA 20,20
0110:  DATA CD,C5
0112:  DATA 20,20
0114:  DATA 20,20
0116:  DATA 20,20
0118:  DATA 20,00
011A:  DATA 20,20
011C:  DATA 20,CF
011E:  DATA CE,C4
0120:  DATA CA,CB
0122:  DATA DE,D7
0124:  DATA C5,CD
0126:  DATA 21,20
0128:  DATA 20,00
012A:  DATA 20,20
012C:  DATA 20,20
012E:  DATA 20,20
0130:  DATA 20,20
0132:  DATA 20,20
0134:  DATA 20,20
0136:  DATA 20,20
0138:  DATA 20,20
013A:  DATA 00,00
013C:  DATA 20,D3
013E:  DATA F1,F2
0140:  DATA E0,ED
0142:  DATA EE,E2
0144:  DATA EA,E0
0146:  DATA 20,ED
0148:  DATA F3,EB
014A:  DATA FF,20
014C:  DATA 00,00
014E:  DATA 42,78
0150:  DATA 20,3D
0152:  DATA 20,00
0154:  DATA 20,C3
0156:  DATA F1,2E
0158:  DATA 20,00
015A:  DATA 42,79
015C:  DATA 20,3D
015E:  DATA 20,00
0160:  DATA 20,C3
0162:  DATA F1,2E
0164:  DATA 20,00
0166:  DATA 42,7A
0168:  DATA 20,3D
016A:  DATA 20,00
016C:  DATA 20,C3
016E:  DATA F1,2E
0170:  DATA 20,00
0172:  DATA 20,D3
0174:  DATA F1,F2
0176:  DATA E0,ED
0178:  DATA EE,E2
017A:  DATA EA,E0
017C:  DATA 20,ED
017E:  DATA F3,EB
0180:  DATA FF,20
0182:  DATA 00,00
0184:  DATA 20,42
0186:  DATA 78,20
0188:  DATA 3D,20
018A:  DATA 00,00
018C:  DATA 20,C3
018E:  DATA F1,2E
0190:  DATA 20,00
0192:  DATA 20,42
0194:  DATA 79,20
0196:  DATA 3D,20
0198:  DATA 00,00
019A:  DATA 20,C3
019C:  DATA F1,2E
019E:  DATA 20,00
01A0:  DATA 20,42
01A2:  DATA 7A,20
01A4:  DATA 3D,20
01A6:  DATA 00,00
01A8:  DATA 20,C3
01AA:  DATA F1,2E
01AC:  DATA 20,00
*
03F6:  DATA CE,C1
03F8:  DATA CD,C0
03FA:  DATA D0,D3
03FC:  DATA C6,C5
03FE:  DATA CD,20
0400:  DATA C4,C0
0402:  DATA D2,D7
0404:  DATA C8,CA
0406:  DATA 00,00
0408:  DATA 20,20
040A:  DATA 20,20
040C:  DATA 20,20
040E:  DATA D2,E8
0410:  DATA EF,3A
0412:  DATA 20,20
0414:  DATA 20,20
0416:  DATA 20,20
0418:  DATA 00,00
041A:  DATA 20,20
041C:  DATA 42,6D
041E:  DATA 61,78
0420:  DATA 20,3D
0422:  DATA 20,31
0424:  DATA 2E,33
0426:  DATA 20,6B
0428:  DATA 47,53
042A:  DATA 20,20
042C:  DATA 20,00
042E:  DATA 20,42
0430:  DATA 6D,61
0432:  DATA 78,20
0434:  DATA 3D,20
0436:  DATA 38,2E
0438:  DATA 31,20
043A:  DATA 47,53
043C:  DATA 20,20
043E:  DATA 20,20
0440:  DATA 00,00
0442:  DATA 20,20
0444:  DATA 20,CE
0446:  DATA F8,E8
0448:  DATA E1,EA
044A:  DATA E0,20
044C:  DATA 49,44
044E:  DATA 20,20
0450:  DATA 20,20
0452:  DATA 00,00
0454:  DATA C4,E0
0456:  DATA F2,F7
0458:  DATA E8,EA
045A:  DATA 20,4E
045C:  DATA 3A,20
045E:  DATA 20,00
0460:  DATA CA,EE
0462:  DATA FD,F4
0464:  DATA F4,E8
0466:  DATA F6,E8
0468:  DATA E5,ED
046A:  DATA F2,FB
046C:  DATA 3A,00
046E:  DATA 4B,78
0470:  DATA 20,3D
0472:  DATA 20,00
0474:  DATA 4B,79
0476:  DATA 20,3D
0478:  DATA 20,00
047A:  DATA 4B,7A
047C:  DATA 20,3D
047E:  DATA 20,00
*
05D4:  TBLRD*+
05D6:  MOVF   FF5,F
05D8:  BZ    05F2
05DA:  MOVFF  FF6,A6
05DE:  MOVFF  FF7,A7
05E2:  MOVFF  FF5,A8
05E6:  BRA    05CA
05E8:  MOVFF  A6,FF6
05EC:  MOVFF  A7,FF7
05F0:  BRA    05D4
05F2:  RETURN 0
....................  
.................... #list 
....................  
.................... //#device ADC=16 
....................  
....................  
.................... #FUSES WDT                       //Watch Dog Timer 
.................... #FUSES WDT4096                  //Watch Dog Timer PreScalar 1:32 
....................  
.................... #FUSES SOSC_DIG                 //Digital mode, I/O port functionality of RC0 and RC1 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #fuses HSM                       //High speed Osc, medium power 4MHz-16MHz 
.................... #fuses NOPLLEN                     //HW PLL disabled, PLL enabled in software 
....................  
.................... #use delay(clock=10MHz,crystal=10MHz) 
*
0480:  CLRF   FEA
0482:  MOVLW  AC
0484:  MOVWF  FE9
0486:  MOVF   FEF,W
0488:  BZ    04A6
048A:  MOVLW  03
048C:  MOVWF  01
048E:  CLRF   00
0490:  DECFSZ 00,F
0492:  BRA    0490
0494:  DECFSZ 01,F
0496:  BRA    048E
0498:  MOVLW  3C
049A:  MOVWF  00
049C:  DECFSZ 00,F
049E:  BRA    049C
04A0:  BRA    04A2
04A2:  DECFSZ FEF,F
04A4:  BRA    048A
04A6:  RETURN 0
04A8:  MOVLW  07
04AA:  SUBWF  xAE,F
04AC:  BNC   04C4
04AE:  CLRF   FEA
04B0:  MOVLW  AE
04B2:  MOVWF  FE9
04B4:  BCF    FD8.0
04B6:  RRCF   FEF,F
04B8:  MOVF   FEF,W
04BA:  BZ    04C4
04BC:  BRA    04C0
04BE:  BRA    04C0
04C0:  DECFSZ FEF,F
04C2:  BRA    04BE
04C4:  RETURN 0
....................  
.................... #BYTE TRISA = 0xF92 
.................... #BYTE TRISB = 0xF93 
.................... #BYTE TRISC = 0xF94 
.................... #BYTE PORTA = 0xF80 
.................... #BYTE PORTB = 0xF81 
.................... #BYTE PORTC = 0xF82  
.................... #BYTE LATB = 0xF8A 
.................... #BYTE LATC = 0xF8B 
.................... #BYTE RCREG = 0xFAE  
....................  
.................... #BYTE INTCON = 0xFF2    // ???????? ???????????? ?????????? 
.................... #BYTE INTCON2= 0xFF1 
....................   
.................... #BIT TRC7 = TRISC.7 
....................  
.................... /****** TEST ******/ 
.................... #BIT TRC6 = TRISC.6 
.................... //#BIT TEST_PIN = LATC.6 
.................... /******************/ 
....................  
.................... /****** SWITCHS ******/ 
.................... #BIT TRA0 = TRISA.0 
.................... #BIT TRA3 = TRISA.3 
.................... #BIT TRA5 = TRISA.5 
.................... #BIT TRB2 = TRISB.2 
.................... #BIT SB1 = PORTA.0 
.................... #BIT SB2 = PORTA.3 
.................... #BIT SB3 = PORTB.2 
.................... #BIT SB4 = PORTA.5 
.................... /*********************/ 
....................  
.................... /****** LCD ******/ 
.................... #BIT TRB1 = TRISB.1 
.................... #BIT TRB3 = TRISB.3 
.................... #BIT TRB4 = TRISB.4 
.................... #BIT TRB5 = TRISB.5 
.................... #BIT TRC0 = TRISC.0 
.................... #BIT TRC1 = TRISC.1 
.................... #BIT TRC2 = TRISC.2 
.................... #BIT TRC5 = TRISC.5 
.................... #BIT DB4 = LATC.5 
.................... #BIT DB5 = LATC.2 
.................... #BIT DB6 = LATC.1 
.................... #BIT DB7 = LATC.0 
.................... #BIT LCD_RS = LATB.5  
.................... #BIT LCD_RW = LATB.4 
.................... #BIT LCD_E = LATB.3 
.................... #BIT LED = LATB.1 
.................... /*****************/ 
....................  
.................... /****** SENSOR ******/ 
.................... #BIT TRB0 = TRISB.0 
.................... #BIT DRDY = PORTB.0 
.................... #BIT TRC3 = TRISC.3 
.................... #BIT TRC4 = TRISC.4 
.................... #use i2c(Master, sda = PIN_C4, scl = PIN_C3, Fast = 400000) 
*
01AE:  MOVLW  08
01B0:  MOVWF  01
01B2:  NOP   
01B4:  BCF    F8B.3
01B6:  BCF    F94.3
01B8:  NOP   
01BA:  RLCF   xB3,F
01BC:  BCF    F8B.4
01BE:  BTFSC  FD8.0
01C0:  BSF    F94.4
01C2:  BTFSS  FD8.0
01C4:  BCF    F94.4
01C6:  BSF    F94.3
01C8:  BTFSS  F82.3
01CA:  BRA    01C8
01CC:  DECFSZ 01,F
01CE:  BRA    01B2
01D0:  NOP   
01D2:  BCF    F8B.3
01D4:  BCF    F94.3
01D6:  NOP   
01D8:  BSF    F94.4
01DA:  NOP   
01DC:  NOP   
01DE:  BSF    F94.3
01E0:  BTFSS  F82.3
01E2:  BRA    01E0
01E4:  CLRF   01
01E6:  NOP   
01E8:  BTFSC  F82.4
01EA:  BSF    01.0
01EC:  BCF    F8B.3
01EE:  BCF    F94.3
01F0:  BCF    F8B.4
01F2:  BCF    F94.4
01F4:  RETURN 0
01F6:  MOVLW  08
01F8:  MOVWF  xB2
01FA:  MOVFF  00,B3
01FE:  BSF    F94.4
0200:  NOP   
0202:  BSF    F94.3
0204:  BTFSS  F82.3
0206:  BRA    0204
0208:  BTFSC  F82.4
020A:  BSF    FD8.0
020C:  BTFSS  F82.4
020E:  BCF    FD8.0
0210:  RLCF   01,F
0212:  NOP   
0214:  BCF    F94.3
0216:  BCF    F8B.3
0218:  DECFSZ xB2,F
021A:  BRA    01FE
021C:  BSF    F94.4
021E:  NOP   
0220:  BCF    F8B.4
0222:  MOVF   xB3,W
0224:  BTFSS  FD8.2
0226:  BCF    F94.4
0228:  NOP   
022A:  BSF    F94.3
022C:  BTFSS  F82.3
022E:  BRA    022C
0230:  NOP   
0232:  BCF    F8B.3
0234:  BCF    F94.3
0236:  NOP   
0238:  BCF    F8B.4
023A:  BCF    F94.4
023C:  RETURN 0
.................... /********************/ 
....................  
.................... #use rs232(uart1,baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... #define DELAY 200 
....................  
.................... #define one   0x00 
.................... #define two   0x40 
.................... #define three 0x10 
.................... #define four  0x50 
....................  
.................... typedef unsigned int32 U32; 
.................... typedef int16 U16; 
.................... typedef signed int16 S16; 
.................... typedef int8 U8; 
.................... typedef signed int8 S8; 
.................... typedef signed int32 S32; 
....................  
.................... static U8 buf; 
....................  
.................... #BIT buf4 = buf.4 
.................... #BIT buf5 = buf.5 
.................... #BIT buf6 = buf.6 
.................... #BIT buf7 = buf.7 
....................  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <LCD for V2.1.c> 
.................... /***************** LCD functions *****************/ 
....................  
.................... void LCDWriteNibble(unsigned char uc) // RS must be set/reset before calling  
.................... {                                            
....................    uc=uc << 4; // Align with bits 7-4 
*
04C6:  SWAPF  xAC,F
04C8:  MOVLW  F0
04CA:  ANDWF  xAC,F
....................    LCD_RW=0; 
04CC:  BCF    F8A.4
....................    buf = uc; 
04CE:  MOVFF  AC,1A
....................     DB4 = buf4; 
04D2:  BCF    F8B.5
04D4:  BTFSC  1A.4
04D6:  BSF    F8B.5
....................     DB5 = buf5; 
04D8:  BCF    F8B.2
04DA:  BTFSC  1A.5
04DC:  BSF    F8B.2
....................     DB6 = buf6; 
04DE:  BCF    F8B.1
04E0:  BTFSC  1A.6
04E2:  BSF    F8B.1
....................     DB7 = buf7; 
04E4:  BCF    F8B.0
04E6:  BTFSC  1A.7
04E8:  BSF    F8B.0
....................    delay_us(500); 
04EA:  MOVLW  02
04EC:  MOVWF  xAD
04EE:  MOVLW  F9
04F0:  MOVWF  xAE
04F2:  RCALL  04A8
04F4:  DECFSZ xAD,F
04F6:  BRA    04EE
....................    LCD_E = 1; 
04F8:  BSF    F8A.3
....................    delay_us(2); 
04FA:  BRA    04FC
04FC:  BRA    04FE
04FE:  NOP   
....................    LCD_E = 0; 
0500:  BCF    F8A.3
....................    delay_us(50); 
0502:  MOVLW  29
0504:  MOVWF  00
0506:  DECFSZ 00,F
0508:  BRA    0506
050A:  NOP   
050C:  RETURN 0
.................... } 
....................  
.................... void LCDWriteData(unsigned char uc) 
.................... {     
....................    LCD_RS = 0; 
*
0594:  BCF    F8A.5
....................     delay_us(500); 
0596:  MOVLW  02
0598:  MOVWF  xAB
059A:  MOVLW  F9
059C:  MOVWF  xAE
059E:  RCALL  04A8
05A0:  DECFSZ xAB,F
05A2:  BRA    059A
....................     LCD_RS = 1; 
05A4:  BSF    F8A.5
....................     LCD_RW = 1;// Р’РѕСЃСЃС‚Р°РЅРѕРІР»РµРЅРёРµ Р±Р°Р№С‚РѕРІРѕР№ СЃРёРЅС…СЂРѕРЅРёР·Р°С†РёРё 
05A6:  BSF    F8A.4
....................     LCDWriteNibble(uc>>4);//РґРІРёРі СЂР°Р·СЂСЏРґРѕРІ СЃС‚Р°СЂС€РёС… 
05A8:  SWAPF  xAA,W
05AA:  MOVWF  xAB
05AC:  MOVLW  0F
05AE:  ANDWF  xAB,F
05B0:  MOVFF  AB,AC
05B4:  RCALL  04C6
....................     LCDWriteNibble(uc); 
05B6:  MOVFF  AA,AC
05BA:  RCALL  04C6
05BC:  GOTO   05C6 (RETURN)
.................... } 
....................  
.................... void LCDCommand(unsigned char uc) 
.................... { 
....................     LCD_RS = 0; // Instruction mode 
*
050E:  BCF    F8A.5
....................     delay_us(250); 
0510:  MOVLW  D0
0512:  MOVWF  00
0514:  DECFSZ 00,F
0516:  BRA    0514
....................     LCD_RW = 1;// Р’РѕСЃСЃС‚Р°РЅРѕРІР»РµРЅРёРµ Р±Р°Р№С‚РѕРІРѕР№ СЃРёРЅС…СЂРѕРЅРёР·Р°С†РёРё 
0518:  BSF    F8A.4
....................     LCDWriteNibble(uc>>4); 
051A:  SWAPF  xA8,W
051C:  MOVWF  xA9
051E:  MOVLW  0F
0520:  ANDWF  xA9,F
0522:  MOVFF  A9,AC
0526:  RCALL  04C6
....................     LCDWriteNibble(uc);   
0528:  MOVFF  A8,AC
052C:  RCALL  04C6
052E:  RETURN 0
.................... } 
....................  
.................... void LCDSetCursor(unsigned char ucPos) 
.................... { 
....................   LCDCommand(0x80 | ucPos); 
*
05F4:  MOVF   xA6,W
05F6:  IORLW  80
05F8:  MOVWF  xA7
05FA:  MOVWF  xA8
05FC:  RCALL  050E
05FE:  RETURN 0
.................... } 
....................  
.................... void LCDClear(void) 
.................... { 
....................    LCDCommand(0x1); 
0600:  MOVLW  01
0602:  MOVWF  xA8
0604:  RCALL  050E
....................    delay_us(200); 
0606:  MOVLW  A6
0608:  MOVWF  00
060A:  DECFSZ 00,F
060C:  BRA    060A
060E:  NOP   
0610:  GOTO   065E (RETURN)
.................... } 
....................  
.................... void LCDinit(void) 
.................... { 
....................   LCD_E=0; 
*
0530:  BCF    F8A.3
....................   LCD_RS=0; 
0532:  BCF    F8A.5
....................     
....................   Delay_ms(20); 
0534:  MOVLW  14
0536:  MOVWF  xAC
0538:  RCALL  0480
....................    
....................   LCDWriteNibble(3); 
053A:  MOVLW  03
053C:  MOVWF  xAC
053E:  RCALL  04C6
....................   Delay_us(40); 
0540:  MOVLW  21
0542:  MOVWF  00
0544:  DECFSZ 00,F
0546:  BRA    0544
....................   LCDWriteNibble(3); 
0548:  MOVLW  03
054A:  MOVWF  xAC
054C:  RCALL  04C6
....................   Delay_us(40); 
054E:  MOVLW  21
0550:  MOVWF  00
0552:  DECFSZ 00,F
0554:  BRA    0552
....................   LCDWriteNibble(3); 
0556:  MOVLW  03
0558:  MOVWF  xAC
055A:  RCALL  04C6
....................   Delay_us(40); 
055C:  MOVLW  21
055E:  MOVWF  00
0560:  DECFSZ 00,F
0562:  BRA    0560
....................   LCDWriteNibble(2); 
0564:  MOVLW  02
0566:  MOVWF  xAC
0568:  RCALL  04C6
....................   Delay_us(40); 
056A:  MOVLW  21
056C:  MOVWF  00
056E:  DECFSZ 00,F
0570:  BRA    056E
....................   
....................   LCDCommand(0x2A);//???????? 1 WIN CP1261 ??????? ?????   
0572:  MOVLW  2A
0574:  MOVWF  xA8
0576:  RCALL  050E
....................   LCDCommand(0x08);// ????????? ???????, ????????? ??????, ????????? ???????? ??????? 
0578:  MOVLW  08
057A:  MOVWF  xA8
057C:  RCALL  050E
....................   LCDCommand(0x1);// ??????? ?????? ? ??????????? ??????? ? ?????? ???????  
057E:  MOVLW  01
0580:  MOVWF  xA8
0582:  RCALL  050E
....................   LCDCommand(0x06);// ?????? ????? ????????? ?????? ??? ?????? ??????  
0584:  MOVLW  06
0586:  MOVWF  xA8
0588:  RCALL  050E
....................   LCDCommand(0b00001111); 
058A:  MOVLW  0F
058C:  MOVWF  xA8
058E:  RCALL  050E
0590:  GOTO   092E (RETURN)
....................  
....................  } 
....................  
.................... void LCDPutCh(char c) 
.................... { 
....................   LCDWriteData(c); 
*
05C0:  MOVFF  A9,AA
05C4:  BRA    0594
05C6:  GOTO   05D0 (RETURN)
.................... } 
....................  
.................... void LCDPutU16(U32 _u16,U8 u8NumDigs) 
.................... {   
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000; 
....................    u16b=u16a*10000; 
....................  
....................     if (u8NumDigs>=5) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/1000; 
....................     u16b=u16a*1000; 
....................      
....................     if (u8NumDigs>=4) 
....................     { 
....................       LCDPutCh((U8)u16a +'0'); 
....................       LCDPutCh('.'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/100; 
....................     u16b=u16a*100; 
....................      
....................     if (u8NumDigs>=3) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/10; 
....................     u16b=u16a*10; 
....................    if (u8NumDigs>=2) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     if (u8NumDigs>=1) 
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
....................     } 
....................    
.................... } 
....................  
.................... void LCDPutU16n(U32 _u16,U8 u8NumDigs) 
.................... {   
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000; 
....................    u16b=u16a*10000; 
....................  
....................     if (u8NumDigs>=5) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/1000; 
....................     u16b=u16a*1000; 
....................      
....................     if (u8NumDigs>=4) 
....................     { 
....................       LCDPutCh((U8)u16a +'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/100; 
....................     u16b=u16a*100; 
....................      
....................     if (u8NumDigs>=3) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/10; 
....................     u16b=u16a*10; 
....................    if (u8NumDigs>=2) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     if (u8NumDigs>=1) 
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
....................     } 
....................    
.................... } 
....................  
.................... void LCDPutS16(S16 s16a,U8 u8NumDigs) 
.................... { 
....................    char c='+'; 
....................  
....................    if (s16a<0) 
....................    { 
....................       s16a=-s16a; 
....................       c='-'; 
....................    } 
....................    LCDPutCh(c); 
....................    LCDPutU16((U16)s16a, u8NumDigs); 
.................... } 
....................  
.................... void LCDPutS16n(S16 s16a,U8 u8NumDigs) 
.................... { 
....................    char c='+'; 
....................  
....................    if (s16a<0) 
....................    { 
....................       s16a=-s16a; 
....................       c='-'; 
....................    } 
....................    LCDPutCh(c); 
....................    LCDPutU16n((U16)s16a, u8NumDigs); 
.................... } 
....................  
.................... void LCDMsg(char c) 
.................... { 
....................     LCDPutCh(c); 
05CA:  MOVFF  A8,A9
05CE:  BRA    05C0
05D0:  GOTO   05E8 (RETURN)
.................... } 
....................  
.................... void LCDWelcome(void){ 
....................    LCDMsg("   Измеритель"); 
*
0614:  MOVLW  BA
0616:  MOVWF  FF6
0618:  MOVLW  00
061A:  MOVWF  FF7
061C:  RCALL  05D4
....................    LCDSetCursor(two); 
061E:  MOVLW  40
0620:  MOVWF  xA6
0622:  RCALL  05F4
....................    LCDMsg("   магнитной"); 
0624:  MOVLW  C8
0626:  MOVWF  FF6
0628:  MOVLW  00
062A:  MOVWF  FF7
062C:  RCALL  05D4
....................    LCDSetCursor(three); 
062E:  MOVLW  10
0630:  MOVWF  xA6
0632:  RCALL  05F4
....................    LCDMsg(" индукции. v2.4 "); 
0634:  MOVLW  D6
0636:  MOVWF  FF6
0638:  MOVLW  00
063A:  MOVWF  FF7
063C:  RCALL  05D4
....................    LCDSetCursor(four); 
063E:  MOVLW  50
0640:  MOVWF  xA6
0642:  RCALL  05F4
....................    LCDMsg("                "); 
0644:  MOVLW  E8
0646:  MOVWF  FF6
0648:  MOVLW  00
064A:  MOVWF  FF7
064C:  RCALL  05D4
....................    Delay_ms(1000); 
064E:  MOVLW  04
0650:  MOVWF  xA6
0652:  MOVLW  FA
0654:  MOVWF  xAC
0656:  RCALL  0480
0658:  DECFSZ xA6,F
065A:  BRA    0652
....................    LCDClear();   
065C:  BRA    0600
065E:  GOTO   0930 (RETURN)
.................... } 
....................  
.................... void NC_LCDMsg() 
.................... { 
....................  
....................     LCDSetCursor (one); 
....................     LCDMsg ("    ДАТЧИК     "); 
....................     LCDSetCursor (two); 
....................     LCDMsg ("      НЕ       "); 
....................     LCDSetCursor (three); 
....................     LCDMsg ("   ПОДКЛЮЧЕН!  "); 
....................     LCDSetCursor (four); 
....................     LCDMsg ("                "); 
.................... } 
....................  
....................  
.................... #define TLV493D_rd_addr 0xbd     // i2c адрес датчика при чтении  
.................... #define TLV493D_wr_addr 0xbc     // i2c адрес датчика при записи 
....................  
.................... #define TLV493D        37        // ID датчика Bmax = 1,3 kGs 
.................... #define HMC5883l       30        // ID датчика Bmax = 8,1 Gs 
....................  
.................... unsigned int1 int_fl = 0; 
.................... unsigned int1 SensErr = 0; 
.................... unsigned int1 set_zero_fl = 0; 
....................  
....................  
.................... char  ConfigRegA = 0x00, ConfigRegB = 0x01, ModeReg = 0x02, EEprom_adr = 0xA0; 
.................... signed int16 SumX=0;  
.................... signed int16 SumY=0;  
.................... signed int16 SumZ=0; 
....................         
.................... signed int16 SumX0=0;  
.................... signed int16 SumY0=0; 
.................... signed int16 SumZ0=0; 
....................  
.................... signed int32 average_Xg=0;  
.................... signed int32 average_Yg=0; 
.................... signed int32 average_Zg=0; 
....................               
.................... unsigned int16 Xh =0;    
.................... unsigned int8 Xl = 0; 
.................... unsigned int16 Yh =0; 
.................... unsigned int8 Yl = 0; 
.................... unsigned int16 Zh =0; 
.................... unsigned int8 Zl = 0; 
....................  
.................... float Xd = 0; 
.................... float Yd = 0; 
.................... float Zd = 0; 
.................... float kx = 1.0;   // калибровочные коэффициенты 
.................... float ky = 1.0; 
.................... float kz = 1.0; 
....................  
.................... U8 crc_buf_wr[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... U8 crc_buf_rd[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... U8 crc_wr_index = 0; 
.................... U8 crc_rd_index = 0; 
....................  
.................... U16 coord_sys = 0;      // переменная выбора системы координат измерений 
.................... U16 sens_type;          // тип датчика => 37 - TLV493D, 30 - HMC5883l         
.................... U16 sens_num;           // № датчика в базе Диалтек 
.................... U16 ROM_Adr = 0x0000; 
.................... int1 rom_rd_status = 0; // флаг статуса прочтения ПЗУ 
....................  
.................... U16 CRC_Wr; 
.................... U16 CRC1 = 0; 
.................... U16 CRC2 = 0;  
....................  
.................... U8 TLV493D_frm_cnt = 0; // переменная счета итераций измерения датчика TLV493D 
.................... U8 wr_ptr = 0, rd_ptr = 0;                         // счетчики чтения и записи в массив UART 
.................... U8 rx_buf[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // буфер для сохр. принятных команд 
....................  
.................... //****************** Sensor 1 funcs ************************************ 
.................... void SensWrData(unsigned int8 Adr, Data) 
.................... { 
....................     
....................    i2c_start (); 
*
023E:  BSF    F94.4
0240:  NOP   
0242:  BSF    F94.3
0244:  NOP   
0246:  BCF    F8B.4
0248:  BCF    F94.4
024A:  NOP   
024C:  BCF    F8B.3
024E:  BCF    F94.3
....................    i2c_write (0x3C); 
0250:  MOVLW  3C
0252:  MOVWF  xB3
0254:  RCALL  01AE
....................  
....................    // The default (factory) HMC5883 7 - bit slave address 
....................    // is 0x3C for write operations, or 0x3D for read operations. 
....................    i2c_write (Adr); 
0256:  MOVFF  B1,B3
025A:  RCALL  01AE
....................    i2c_write (Data); 
025C:  MOVFF  B2,B3
0260:  RCALL  01AE
....................    i2c_stop (); 
0262:  BCF    F94.4
0264:  NOP   
0266:  BSF    F94.3
0268:  BTFSS  F82.3
026A:  BRA    0268
026C:  NOP   
026E:  BRA    0270
0270:  NOP   
0272:  BSF    F94.4
0274:  NOP   
0276:  RETURN 0
.................... } 
....................   
.................... char SensRdData(char Adr) 
.................... { 
....................     
....................    char Data = 0; 
....................     
....................    i2c_start (); 
....................    i2c_write (0x3C); // The default (factory) HMC5883 7 - bit slave address 
....................    // is 0x3C for write operations, or 0x3D for read operations. 
....................    i2c_write (Adr); // pointer 
....................    i2c_stop (); 
....................    delay_us (10); 
....................    i2c_start (); 
....................    i2c_write (0x3D); //i2c Read 
....................    delay_us (10); 
....................    Data = i2c_read (); 
....................    delay_us (10); 
....................    Data = i2c_read (); 
....................    delay_us (10); 
....................    i2c_stop (); 
....................     
....................    return Data; 
.................... } 
....................      
.................... void HMC5883l_Init () 
.................... { 
....................     
....................    //SensWrData (ConfigRegA, 0x14); // F = 30 Hz / 1 
....................    SensWrData (ConfigRegA, 0x18); // F = 75 Hz / 1 
0278:  MOVFF  20,B1
027C:  MOVLW  18
027E:  MOVWF  xB2
0280:  RCALL  023E
....................    SensWrData (ConfigRegB, 0xE0); // range = + / - 8.1 Ga 
0282:  MOVFF  21,B1
0286:  MOVLW  E0
0288:  MOVWF  xB2
028A:  RCALL  023E
....................    SensWrData (ModeReg, 0x00); // continuous measurment mode 
028C:  MOVFF  22,B1
0290:  CLRF   xB2
0292:  RCALL  023E
0294:  GOTO   03C8 (RETURN)
....................    //SensWrData (ModeReg, 0x01); // single measurment mode 
.................... } 
....................  
.................... signed int16 SelfCal() 
.................... { 
....................     
....................    unsigned int16 Xh = 0; 
....................    unsigned int8 Xl = 0; 
....................    unsigned int16 Yh = 0; 
....................    unsigned int8 Yl = 0; 
....................    unsigned int16 Zh = 0; 
....................    unsigned int8 Zl = 0; 
....................     
....................    HMC5883l_Init(); 
....................    delay_us (10); 
....................  
....................    if (int_fl) 
....................    { 
....................       i2c_start (); 
....................       i2c_write (0x3C); // The default (factory) HMC5883 7 - bit slave address 
....................       // is 0x3C for write operations, or 0x3D for read operations. 
....................       i2c_write (0x03); // pointer 
....................       i2c_stop (); 
....................       delay_us (10); 
....................        
....................       i2c_start (); 
....................       i2c_write (0x3D); //i2c Read 
....................       Xh = i2c_read (); // X MSB 
....................       Xl = i2c_read (); // X LSB 
....................       SumX = (Xh<<8)|Xl; //?????????????? ???????? ????????. ??? ? 
....................       Yh = i2c_read (); // Y MSB 
....................       Yl = i2c_read (); // Y LSB 
....................       SumY = (Yh<<8)|Yl; //?????????????? ???????? ????????. ??? Y 
....................       Zh = i2c_read (); // Z MSB 
....................       Zl = i2c_read (); // Z LSB 
....................       SumZ = (Zh<<8)|Zl; //?????????????? ???????? ????????. ??? Z 
....................       i2c_read (); //if adress pointer = 08, adress pointer = 03 
....................       i2c_stop (); 
....................    } 
....................  
....................     
....................    delay_us (10); 
....................    return 1; 
.................... } 
....................  
.................... void SensRdAll() 
.................... { 
....................     
....................    if (set_zero_fl) 
....................    { 
....................       // утс. 0 
....................        
....................       LCDClear (); 
....................       Lcdsetcursor (0); 
....................       LcdMsg (" Установка нуля "); 
....................       SumX0 = SumX; 
....................       SumY0 = SumY; 
....................       SumZ0 = SumZ; 
....................       delay_ms (1000); 
....................       set_zero_fl = 0; 
....................    } 
....................  
....................     
....................    average_Zg = SumZ - SumZ0; //(average_Zg / 10) - SumZ0; 
....................    average_Yg = SumY - SumY0; 
....................    average_Xg = SumX - SumX0; 
....................     
....................    //y = (8.1 * x) / 2048; 8.1 / 2048 = 0.0039550781252 
....................     
....................    Xd = average_Xg * 0.0039550781252; 
....................    Xd *= kx; // умножение на поправочный коэффициент из ПЗУ 
....................    Yd = average_Yg * 0.0039550781252; 
....................    Yd *= ky; // умножение на поправочный коэффициент из ПЗУ 
....................    Zd = average_Zg * 0.0039550781252; 
....................    Zd *= -kz; // умножение на поправочный коэффициент из ПЗУ 
....................    // вручную изменили направление оси Z для приведения систем координат 
....................    // обоих датчиков к единой 
....................  
....................     
....................    // Значения поля Bx, By, Bz выводятся согласно пожеланию заказчика // 
....................  
....................    Printf ("x%05Ldh\n", ( (S32) (Xd * 1000))); // Zd отправка на ПК значений поля в Гс 
....................    Printf ("y%05Ldh\n", ( (S32) (Yd * 1000))); //  
....................    Printf ("z%05Ldh\n", ( (S32) (Zd * 1000))); // Zd 
....................    LcdSetCursor (one); 
....................    LcdMsg ("Bx = "); 
....................    LcdPutS16 (Xd * 1000, 4); // zd 
....................    LcdMsg (" Гс. "); 
....................    LcdSetCursor (two); 
....................    LcdMsg ("By = "); 
....................    LcdPutS16 (Yd * 1000, 4); 
....................    LcdMsg (" Гс. "); 
....................    LcdSetCursor (three); 
....................    LcdMsg ("Bz = "); 
....................    LcdPutS16 (Zd * 1000, 4); // Xd 
....................    LcdMsg (" Гс. "); 
....................    int_fl = false; 
.................... } 
....................  
.................... //****************** Sensor 1 funcs ************************************ 
....................  
.................... //////////////////// Sensor 2 funcs ////////////////////////////////////   
....................  void TLV493D_reset() 
.................... { 
....................     i2c_start(); 
....................     i2c_write (0x00);  
....................     i2c_stop(); 
.................... } 
....................   
....................  U8 TLV493D_init() 
.................... { 
.................... //!      // после вкл. питания требуется считать значения регистров 7, 8, 9 датчика 
.................... //!      // для дальнейшей записи этих значений в конфигурационные регистры. 
.................... //! 
....................        S16 reg7data = 0;    // переменные для сохр. заводских настроек датчика 
....................        S16 reg8data = 0; 
....................        S16 reg9data = 0; 
....................  
.................... //!      //------- 1 этап - чтение заводской конфигурации датчика -------//  
....................        
....................        i2c_start (); 
....................        i2c_write (TLV493D_rd_addr); // чтение регистров 
....................        i2c_read();           // Bx (0H) 
....................        i2c_read();           // By (1H) 
....................        i2c_read();           // Bz (2H) 
....................         
....................        i2c_read();           // Temp (3H) Temp. (11…8) FRM CH 
....................        i2c_read();           // Bx2 (4H)  Bx (3…0) By (3…0) 
....................        i2c_read();           // Bz2 (5H) 
....................         
....................        i2c_read();                      // Temp2 (6H) 
....................        reg7data = i2c_read();           // FactSet1 (7H) 
....................        reg8data = i2c_read();           // FactSet2 (8H) 
....................        reg9data = i2c_read();           // FactSet3 (9H) 
....................        i2c_stop (); 
....................  
.................... //!      // инициализация датчика  
.................... //!      // данные магнитного поля обновляются сразу после их чтения микроконтроллером,  
.................... //!      // режим master-controlled 
.................... //!      // так, частота измерений зависит от частоты чтения показаний датчика, не более 3.3 кГц 
.................... //!     
....................        i2c_start (); 
....................        i2c_write (TLV493D_wr_addr); //  запись конфигурации 
....................        i2c_write (0x00);            //  Reg 0, Reserved register, must write 0's 
....................         
....................        i2c_write( 0 << 7 |          //  Reg 1, parity disabled in Reg3 
....................                   0 << 5 |          //  define the slave address, dont use, ADDR = 1, pulled high on PCB   
....................  ((reg7data & 0x18) << 3)|          //  Bits must correspond to bits 4:3 from read register 7H 
....................                   0 << 2 |          //  If "0" INT (interrupt pulse) disabled 
....................                   1 << 1 |          //  If "1" fast mode enabled 
....................                         1);         //  If "1" - Low power mode, f = 100 Hz 
....................                    
....................                    
....................        i2c_write(reg8data);         //  Reg 2, Bits must correspond to bits 7:0 from read register 8H 
....................         
....................        i2c_write( 1 << 7 |          //  Reg 3, temperature measurement disabled 
....................                   1 << 6 |          //  If '1' period is 12ms, if '0' period is 100ms      
....................                   0 << 5 |          //  If "0" parity test disabled 
....................           (reg9data & 0x1f));       //  Bits must correspond to bits 4:0 from read register 9H.         
....................        i2c_stop (); 
....................         
....................        if (reg8data < 0xff) return 1; 
....................        else return 0; 
.................... } 
....................  
....................  float TLV493D_calc_field (S16 nibble_h, S16 nibble_l) 
....................  { 
....................       // расчет величины магнитного поля по оси X датчика 
....................       // nibble_h - MSB, nibble_l содержит младший полубайт данных оси Х 
....................           
....................       S16 fi = 0;          // для хранения отсчетов магнитного поля 
....................       float fl = 0;        // для хранения магнитного поля в Гс 
....................        
....................       fi = (nibble_h << 4) | nibble_l; 
....................       if ( fi >= 2048)   fi = fi - 4096;  // Interpret bit 12 as +/-  
....................        
....................       // LSB = 0.098 mT -> 0.98 Gs 
....................       fl = fi * 0.098;    // перевод из отсчетов АЦП в mT 
....................       fl *= 10;           // перевод из mT в Гауссы 
....................        
....................       return fl; 
....................  
....................   } 
....................   
....................  U8 TLV493D_rd_all(U8 coord_sys) 
....................  { 
....................          
....................        S16 xh, yh, zh = 0;  // ст. байты данных 
....................        S16 xl, yl, zl = 0;  // мл. полубайты 
....................        S16 bz2, bx2by2, frame_ctr = 0; // регистры датчика 
....................        S16 x, y, z = 0; 
....................        S16 coodr_buf = 0; 
....................  
....................        U8 status; // 1 - чтение ок, 0 - ошибка чтения, 2 - требуется инициализация 
....................   
....................         // чтение данных 
....................        i2c_start (); 
....................       
....................        i2c_write (TLV493D_rd_addr);     // чтение регистров 
....................        xh = i2c_read();                 // Bx (0H) 
....................        yh = i2c_read();                 // By (1H) 
....................        zh = i2c_read();                 // Bz (2H) 
....................         
....................        frame_ctr = i2c_read();          // Temp (3H) Temp. (11…8) FRM CH 
....................        bx2by2 = i2c_read();             // Bx2 (4H)  Bx (3…0) By (3…0) 
....................        bz2 = i2c_read();                // Bz2 (5H) 
....................       
....................        i2c_read();                      // вычитывать необходимо все 10 регистров 
....................        i2c_read();  
....................        i2c_read();  
....................        i2c_read();  
....................       
....................        i2c_stop (); 
....................         
....................        if(frame_ctr == 0xff) status = 0; // датчик не подкл 
....................         
....................        // сравнение старого значения счетчика измерений с новым 
....................        else if(TLV493D_frm_cnt == (U8)frame_ctr)  
....................        {// датчик заклинило 
....................          TLV493D_reset(); // сброс состояния датчика 
....................          TLV493D_init();  // инициализация 
....................        } 
....................         
....................        else                                  // подключен, все ок 
....................        { 
....................          TLV493D_frm_cnt = frame_ctr;   // сохр. нового значения счетчика измерений 
....................           
....................          xl = bx2by2 >> 4;      // получение мл. полубайта значений по оси Х  
....................          yl = bx2by2 & 0x0f;    // получение мл. полубайта значений по оси Y  
....................          zl = bz2 & 0x0f;       // получение мл. полубайта значений по оси Z   
....................         
....................          x = (S16)(kx * TLV493D_calc_field(xh, xl));    // передача в функцию ст. и мл. байт для расчета поля по X 
....................          y = (S16)(ky * TLV493D_calc_field(yh, yl));    // передача в функцию ст. и мл. байт для расчета поля по Y 
....................          z = (S16)(kz * TLV493D_calc_field(zh, zl));    // передача в функцию ст. и мл. байт для расчета поля по Z 
....................           
....................          switch(coord_sys)       // анализ выбраной системы координат 
....................          { 
....................             case 0: break;       // по умолчанию, ничего не меняем 
....................             //===== 
....................             case 1:              // 1 вариант изменения системы координат 
....................                coodr_buf = x;    // поворот правой тройки вниз 
....................                x = z; 
....................                z = coodr_buf; 
....................                break;        
....................             //===== 
....................             case 2:              // 2 вариант изменения системы координат 
....................                coodr_buf = y;    // поворот правой тройки влево 
....................                y = z; 
....................                z = coodr_buf; 
....................                break;        
....................             //===== 
....................             default: break; 
....................           
....................          } 
....................           
....................          if (set_zero_fl) 
....................          { 
....................            // утс. 0 
....................        
....................           LCDClear (); 
....................           Lcdsetcursor (0); 
....................           LcdMsg (" Установка нуля "); 
....................           SUMX0 = x;  // сохр. текущего значения магнитного поля 
....................           SUMY0 = y; 
....................           SUMZ0 = z; 
....................           delay_ms (1000); 
....................           set_zero_fl = 0; 
....................          } 
....................           
....................          x = x - SUMX0; // вычет смещение поля 
....................          y = y - SUMY0; 
....................          z = z - SUMZ0; 
....................           
....................         // отправка на ПК значений поля в Гс 
....................          Printf ("x%05Ldt\n", x);  
....................          Printf ("y%05Ldt\n", y); 
....................          Printf ("z%05Ldt\n", z); 
....................  
....................          LcdSetCursor (one); 
....................          LcdMsg (" Bx = "); LCDPutS16n (x, 4); LcdMsg (" Гс. "); 
....................          LcdSetCursor (two);  
....................          LcdMsg (" By = "); LCDPutS16n (y, 4); LcdMsg (" Гс. "); 
....................          LcdSetCursor (three); 
....................          LcdMsg (" Bz = "); LCDPutS16n (z, 4); LcdMsg (" Гс. "); 
....................           
....................          status = 1; 
....................        } 
....................  
....................        return status; 
....................   
....................  } 
....................  
.................... //////////////////// Sensor 2 funcs //////////////////////////////////// 
....................  
....................  
.................... //------------------ EEPROM funcs -------------------------------------- 
....................  U16 CRC16 (U8 * data_p, U8 length) 
....................  { 
....................     // расчет контрольной суммы 
....................     // взят из интернета 
....................      
....................     U8 x; 
....................     U16 crc = 0xFFFF; 
....................  
....................     while (length--) 
....................     { 
....................        x = crc >> 8 ^ * data_p++; 
....................        x ^= x>>4; 
....................        crc = (crc << 8) ^ ((U16) (x << 12)) ^ ((U16) (x <<5)) ^ ( (U16) x) ; 
....................     } 
....................  
....................     return crc; 
....................  } 
....................  
....................  void rom_wr_byte (U16 addr, U8 dataByte) 
*
0662:  CLRF   xA9
0664:  CLRF   xAA
....................  { 
....................     /// записывает байт данных по 16 - бит. адресу 
....................      
....................     U8 addr_MSB = 0; 
....................     U8 addr_LSB = 0; 
....................      
....................     addr_MSB = (addr >> 8); 
0666:  MOVFF  A7,A9
....................     addr_LSB = addr; 
066A:  MOVFF  A6,AA
....................      
....................     i2c_start (); 
066E:  BSF    F94.4
0670:  NOP   
0672:  BSF    F94.3
0674:  NOP   
0676:  BCF    F8B.4
0678:  BCF    F94.4
067A:  NOP   
067C:  BCF    F8B.3
067E:  BCF    F94.3
....................     i2c_write (EEprom_adr|0); // запись 
0680:  MOVFF  23,AC
0684:  CLRF   19
0686:  BTFSC  FF2.7
0688:  BSF    19.7
068A:  BCF    FF2.7
068C:  MOVFF  23,B3
0690:  RCALL  01AE
0692:  BTFSC  19.7
0694:  BSF    FF2.7
0696:  CLRF   19
0698:  BTFSC  FF2.7
069A:  BSF    19.7
069C:  BCF    FF2.7
....................     // A read operation is initiated if this bit is high 
....................     // and a write operation is initiated if this bit is low. 
....................      
....................     i2c_write (addr_MSB); 
069E:  MOVFF  A9,B3
06A2:  RCALL  01AE
06A4:  BTFSC  19.7
06A6:  BSF    FF2.7
06A8:  CLRF   19
06AA:  BTFSC  FF2.7
06AC:  BSF    19.7
06AE:  BCF    FF2.7
....................     i2c_write (addr_LSB); 
06B0:  MOVFF  AA,B3
06B4:  RCALL  01AE
06B6:  BTFSC  19.7
06B8:  BSF    FF2.7
....................    for(unsigned char i =0; i < 64; i++) 
06BA:  CLRF   xAB
06BC:  MOVF   xAB,W
06BE:  SUBLW  3F
06C0:  BNC   06D8
06C2:  CLRF   19
06C4:  BTFSC  FF2.7
06C6:  BSF    19.7
06C8:  BCF    FF2.7
....................   { 
....................       i2c_write (i); 
06CA:  MOVFF  AB,B3
06CE:  RCALL  01AE
06D0:  BTFSC  19.7
06D2:  BSF    FF2.7
06D4:  INCF   xAB,F
06D6:  BRA    06BC
....................   } 
....................      
....................     i2c_stop (); 
06D8:  BCF    F94.4
06DA:  NOP   
06DC:  BSF    F94.3
06DE:  BTFSS  F82.3
06E0:  BRA    06DE
06E2:  NOP   
06E4:  BRA    06E6
06E6:  NOP   
06E8:  BSF    F94.4
06EA:  NOP   
....................     delay_ms (15); // t записи в rom - 10 мс 
06EC:  MOVLW  0F
06EE:  MOVWF  xAC
06F0:  RCALL  0480
....................     crc_buf_wr[crc_wr_index] = dataByte; 
06F2:  CLRF   03
06F4:  MOVF   x7D,W
06F6:  ADDLW  5D
06F8:  MOVWF  FE9
06FA:  MOVLW  00
06FC:  ADDWFC 03,W
06FE:  MOVWF  FEA
0700:  MOVFF  A8,FEF
....................     crc_wr_index++; 
0704:  INCF   x7D,F
0706:  GOTO   0938 (RETURN)
....................  } 
....................  
....................  U8 rom_rd_byte (U16 addr) 
070A:  CLRF   xA8
070C:  CLRF   xA9
070E:  CLRF   xAA
....................  { 
....................     /// чтение байта данных по 16 - бит. адресу 
....................      
....................     U8 rd_data_byte = 0; 
....................     U8 addr_MSB = 0; // старший байт адреса 
....................     U8 addr_LSB = 0; // младший байт адреса 
....................      
....................     addr_MSB = (addr >> 8); // заполнение ст. байта из 2 - байт. адреса 
0710:  MOVFF  A7,A9
....................     addr_LSB = addr; // заполнение мл. байта из 2 - байт. адреса 
0714:  MOVFF  A6,AA
....................      
....................     i2c_start (); 
0718:  BSF    F94.4
071A:  NOP   
071C:  BSF    F94.3
071E:  NOP   
0720:  BCF    F8B.4
0722:  BCF    F94.4
0724:  NOP   
0726:  BCF    F8B.3
0728:  BCF    F94.3
....................     i2c_write (EEprom_adr|0); // команда чтения 
072A:  MOVFF  23,AC
072E:  CLRF   19
0730:  BTFSC  FF2.7
0732:  BSF    19.7
0734:  BCF    FF2.7
0736:  MOVFF  23,B3
073A:  RCALL  01AE
073C:  BTFSC  19.7
073E:  BSF    FF2.7
0740:  CLRF   19
0742:  BTFSC  FF2.7
0744:  BSF    19.7
0746:  BCF    FF2.7
....................     // A read operation is initiated if this bit is high 
....................     // and a write operation is initiated if this bit is low. 
....................      
....................     i2c_write (addr_MSB); // выдача на линию ст. байта адреса 
0748:  MOVFF  A9,B3
074C:  RCALL  01AE
074E:  BTFSC  19.7
0750:  BSF    FF2.7
0752:  CLRF   19
0754:  BTFSC  FF2.7
0756:  BSF    19.7
0758:  BCF    FF2.7
....................     i2c_write (addr_LSB); // выдача на линию мл. байта адреса 
075A:  MOVFF  AA,B3
075E:  RCALL  01AE
0760:  BTFSC  19.7
0762:  BSF    FF2.7
....................     i2c_start (); 
0764:  BSF    F94.4
0766:  NOP   
0768:  BSF    F94.3
076A:  NOP   
076C:  BTFSS  F82.3
076E:  BRA    076C
0770:  BCF    F8B.4
0772:  BCF    F94.4
0774:  NOP   
0776:  BCF    F8B.3
0778:  BCF    F94.3
....................     i2c_write (EEprom_adr|1); // чтение 
077A:  MOVF   23,W
077C:  IORLW  01
077E:  MOVWF  xAC
0780:  CLRF   19
0782:  BTFSC  FF2.7
0784:  BSF    19.7
0786:  BCF    FF2.7
0788:  MOVWF  xB3
078A:  RCALL  01AE
078C:  BTFSC  19.7
078E:  BSF    FF2.7
....................     for(U8 i = 0; i < 64; i++ ) 
0790:  CLRF   xAB
0792:  MOVF   xAB,W
0794:  SUBLW  3F
0796:  BNC   07B2
....................       rd_data_byte = i2c_read (); 
0798:  MOVLW  01
079A:  MOVWF  00
079C:  CLRF   19
079E:  BTFSC  FF2.7
07A0:  BSF    19.7
07A2:  BCF    FF2.7
07A4:  RCALL  01F6
07A6:  BTFSC  19.7
07A8:  BSF    FF2.7
07AA:  MOVFF  01,A8
07AE:  INCF   xAB,F
07B0:  BRA    0792
....................     //i2c_write (0xff); // без этого не работает 0_0 
....................     i2c_stop (); 
07B2:  BCF    F94.4
07B4:  NOP   
07B6:  BSF    F94.3
07B8:  BTFSS  F82.3
07BA:  BRA    07B8
07BC:  NOP   
07BE:  BRA    07C0
07C0:  NOP   
07C2:  BSF    F94.4
07C4:  NOP   
....................     crc_buf_rd[crc_rd_index] = rd_data_byte; 
07C6:  CLRF   03
07C8:  MOVF   x7E,W
07CA:  ADDLW  6D
07CC:  MOVWF  FE9
07CE:  MOVLW  00
07D0:  ADDWFC 03,W
07D2:  MOVWF  FEA
07D4:  MOVFF  A8,FEF
....................     crc_rd_index++; 
07D8:  INCF   x7E,F
....................      
....................     return rd_data_byte; 
07DA:  MOVFF  A8,01
07DE:  GOTO   0940 (RETURN)
....................  } 
....................  
....................  void rom_rd_float (U16 ee_addr, void * float_data_ptr) 
....................  { 
....................     /// чтение 4 - байт. переменной типа float из rom 
....................      
....................     // передается указатель на заранее инициализир. перемен. 
....................     // типа float, происходит побайтное считывание из rom и наполнение 
....................     // ими адреса переданного через указатель 
....................      
....................     U8 buf; 
....................     U8 * dataByte_ptr = float_data_ptr; // сохраняем указатель (адрес) 
....................     // переменной для чтения 
....................     U8 k = 0; 
....................     U8 i = sizeof (float); 
....................      
....................     while (k < i) 
....................     { 
....................        buf = rom_rd_byte (ee_addr); // чтение байта из памяти 
....................        * dataByte_ptr = buf; // сох. этого байта по адресу конкретной переменной 
....................        dataByte_ptr++; // инкремент адреса байта переменной 
....................        ee_addr++; // инкремент адреса rom 
....................        k++; // инкремент итератора цикла чтения 
....................     } 
....................  
....................     //LCDMsg ("adr = "); 
....................     //LcdPutU16 ( (U32) ee_addr * 1000, 4) ; 
....................     //delay_ms (1000); 
....................     //Lcdsetcursor (0x40); 
....................      
....................      
....................     //LCDMsg ("CRC_rd = "); 
....................     //LcdPutU16 ( (U32) CRC_rd, 5) ; 
....................     //Lcdsetcursor (0x50); 
....................     //LCDMsg ("CRC_LSB = "); 
....................     //LcdPutU16 ( (U32) CRC_rd_LSB * 100, 5) ; 
....................  } 
....................  
....................  void rom_wr_float (U16 ee_addr, void * float_data_ptr) 
....................  { 
....................     /// запись 4 - байт. переменной типа float в rom 
....................      
....................     // передается указатель на перемен. типа float для ее сохранения. 
....................     // происходит побайтная запись этой переменной в rom 
....................      
....................     U8 * dataByte_ptr = float_data_ptr; // сохраняем указатель (адрес) 
....................     // переменной для записи 
....................     U8 k = 0; 
....................     U8 i = sizeof (float); // сохранение размера float в байтах - 4 
....................     //Lcdsetcursor (0); 
....................     //lcdPutCh ('a'); 
....................      
....................     while (k < i) 
....................     { 
....................        //my_arr[k] = *dataByte_ptr; 
....................        //LcdPutU16 (my_arr[k], 3) ; 
....................        //lcdPutCh ('_'); 
....................        rom_wr_byte (ee_addr, * dataByte_ptr); // запись байта с конкретн. адресу в rom 
....................        dataByte_ptr++; // инкремент адреса байта переменной 
....................        ee_addr++; // инкремент адреса rom 
....................        k++;  // инкремент итератора цикла записи 
....................     } 
....................  
....................     //Lcdsetcursor (0x00); 
....................     //LCDMsg ("CRC_wr = "); 
....................     //LcdPutU16 ( (U32) CRC_Wr, 5); 
....................  } 
....................  
....................  U16 rom_wr_CRC16 (ee_addr, U8 crc_buf) 
....................  { 
....................     U16 CRC_Wr; 
....................      
....................     CRC_Wr = CRC16 (crc_buf, 14); // расчет CRC16 
....................      
....................     rom_wr_byte (ee_addr, (CRC_Wr >> 8)); // запись ст. байта CRC в rom 
....................     ee_addr++;  // инкремент адреса 
....................     rom_wr_byte (ee_addr, (U8) CRC_Wr); // запись мл. байта CRC в rom 
....................      
....................     return CRC_Wr; 
....................  } 
....................  
....................  U16 rom_rd_CRC16 (ee_addr) 
....................  { 
....................     U8 CRC_rd_MSB; // ст. байт CRC для записи 
....................     U8 CRC_rd_LSB; // мл. байт CRC для записи 
....................     U16 CRC_rd; // 16 - бит. CRC 
....................      
....................     CRC_rd_MSB = rom_rd_byte (ee_addr); // чтение ст. байта CRC из rom 
....................     ee_addr++; 
....................     CRC_rd_LSB = rom_rd_byte (ee_addr); // чтение мл. байта CRC из rom 
....................     CRC_rd = CRC_rd_MSB << 8; // восстановление CRC 
....................     CRC_rd |= CRC_rd_LSB; // из прочитанных байт 
....................      
....................     return CRC_rd; 
....................  } 
....................  
....................  int1 rom_rd_sens_data (void) 
....................  { 
....................     int1 _rom_rd_status = 0; 
....................  
....................     sens_type = rom_rd_byte (ROM_Adr); // тип датчика 0 
....................     ROM_Adr++; 
....................     sens_num = rom_rd_byte (ROM_Adr);  // № датчика 1 
....................     ROM_Adr++; 
....................     coord_sys = rom_rd_byte (ROM_Adr); // система координат 2 
....................     ROM_Adr++; 
....................     rom_rd_float (ROM_Adr,&kx); // Kx 3 - 6 
....................     ROM_adr += 4; 
....................     rom_rd_float (ROM_Adr,&ky); // Ky 7 - 10 
....................     ROM_adr += 4; 
....................     rom_rd_float (ROM_Adr,&kz); // Kz 11 - 14 
....................      
....................     ROM_adr += 4; 
....................     CRC1 = rom_rd_CRC16 (ROM_adr); // чтение сохраненной CRC 
....................     CRC2 = CRC16 (crc_buf_rd, 14); // расчет CRC по считанным данным 
....................     crc_rd_index = 0; 
....................     ROM_adr = 0x0000; 
....................  
....................     if (CRC1 == CRC2) 
....................     { 
....................        _rom_rd_status = 1; 
....................     } 
....................  
....................     return _rom_rd_status; 
....................  } 
....................  
.................... void update_rom_data(void) 
.................... { 
....................    U16 ROM_Adr = 0x0000; 
....................   // U16 CRC_Wr; 
....................    U16 CRC1 = 0; 
....................   // U16 CRC2 = 0;  
....................  
....................    rom_wr_byte(ROM_Adr,sens_type);     // тип датчика   0 
....................    rom_wr_byte (++ROM_Adr, sens_num);  // № датчика     1 
....................    rom_wr_byte (++ROM_Adr, coord_sys); // сис.координат 2 
....................    rom_wr_float(++ROM_Adr,&kx);        // Kx            3-6  
....................    ROM_adr += 4; 
....................    rom_wr_float(ROM_Adr,&ky);          // Ky            7-10 
....................    ROM_adr += 4; 
....................    rom_wr_float(ROM_Adr,&kz);          // Kz            11-14 
....................     
....................    ROM_Adr += 4; 
....................    CRC1 = rom_wr_CRC16(ROM_Adr,crc_buf_wr); 
....................    crc_wr_index = 0;    
.................... } 
....................  
.................... //------------------ EEPROM funcs -------------------------------------- 
....................   
.................... //= == == = == == == == = == = Interrupts = == = == == == == == == == 
....................  #int_EXT 
....................  void int0 (void) 
*
0298:  CLRF   xB0
029A:  CLRF   xAF
....................  { 
....................     signed int16 coodr_buf = 0; 
....................      
....................     if (SensErr) 
029C:  BTFSS  1F.1
029E:  BRA    02A6
....................     { 
....................  
....................        sens_type = 0; 
02A0:  CLRF   x82
02A2:  CLRF   x81
....................     } 
02A4:  BRA    03C8
....................  
....................      
....................     else 
....................     { 
....................         
....................        i2c_start (); 
02A6:  BSF    F94.4
02A8:  NOP   
02AA:  BSF    F94.3
02AC:  NOP   
02AE:  BCF    F8B.4
02B0:  BCF    F94.4
02B2:  NOP   
02B4:  BCF    F8B.3
02B6:  BCF    F94.3
....................        i2c_write (0x3C); // The default (factory) HMC5883 7 - bit slave address 
02B8:  MOVLW  3C
02BA:  MOVWF  xB3
02BC:  RCALL  01AE
....................        // is 0x3C for write operations, or 0x3D for read operations. 
....................        i2c_write (0x03); // pointer 
02BE:  MOVLW  03
02C0:  MOVWF  xB3
02C2:  RCALL  01AE
....................        i2c_stop (); 
02C4:  BCF    F94.4
02C6:  NOP   
02C8:  BSF    F94.3
02CA:  BTFSS  F82.3
02CC:  BRA    02CA
02CE:  NOP   
02D0:  BRA    02D2
02D2:  NOP   
02D4:  BSF    F94.4
02D6:  NOP   
....................         
....................        i2c_start (); 
02D8:  BSF    F94.4
02DA:  NOP   
02DC:  BSF    F94.3
02DE:  NOP   
02E0:  BCF    F8B.4
02E2:  BCF    F94.4
02E4:  NOP   
02E6:  BCF    F8B.3
02E8:  BCF    F94.3
....................        i2c_write (0x3D); //i2c Read 
02EA:  MOVLW  3D
02EC:  MOVWF  xB3
02EE:  RCALL  01AE
....................         
....................        Xh = i2c_read (); // X MSB 
02F0:  MOVLW  01
02F2:  MOVWF  00
02F4:  RCALL  01F6
02F6:  CLRF   3D
02F8:  MOVFF  01,3C
....................        Xl = i2c_read (); // X LSB 
02FC:  MOVLW  01
02FE:  MOVWF  00
0300:  RCALL  01F6
0302:  MOVFF  01,3E
....................        SumX = (Xh<<8)|Xl; //?????????????? ???????? ????????. ??? ? 
0306:  CLRF   xB1
0308:  MOVF   xB1,W
030A:  IORWF  3E,W
030C:  MOVWF  24
030E:  MOVFF  3C,25
....................        Yh = i2c_read (); // Y MSB 
0312:  MOVLW  01
0314:  MOVWF  00
0316:  RCALL  01F6
0318:  CLRF   40
031A:  MOVFF  01,3F
....................        Yl = i2c_read (); // Y LSB 
031E:  MOVLW  01
0320:  MOVWF  00
0322:  RCALL  01F6
0324:  MOVFF  01,41
....................        SumY = (Yh<<8)|Yl; //?????????????? ???????? ????????. ??? Y 
0328:  CLRF   xB1
032A:  MOVF   xB1,W
032C:  IORWF  41,W
032E:  MOVWF  26
0330:  MOVFF  3F,27
....................        Zh = i2c_read (); // Z MSB 
0334:  MOVLW  01
0336:  MOVWF  00
0338:  RCALL  01F6
033A:  CLRF   43
033C:  MOVFF  01,42
....................        Zl = i2c_read (); // Z LSB 
0340:  MOVLW  01
0342:  MOVWF  00
0344:  RCALL  01F6
0346:  MOVFF  01,44
....................        SumZ = (Zh<<8)|Zl; //?????????????? ???????? ????????. ??? Z 
034A:  CLRF   xB1
034C:  MOVF   xB1,W
034E:  IORWF  44,W
0350:  MOVWF  28
0352:  MOVFF  42,29
....................        i2c_stop (); 
0356:  BCF    F94.4
0358:  NOP   
035A:  BSF    F94.3
035C:  BTFSS  F82.3
035E:  BRA    035C
0360:  NOP   
0362:  BRA    0364
0364:  NOP   
0366:  BSF    F94.4
0368:  NOP   
....................         
....................       // average_X += SumX; 
....................        //average_Y += SumY; 
....................        //average_Z += SumZ; 
....................        //aver_count ++; 
....................         
....................        //if (aver_count == 5) 
....................        //{ 
....................           int_fl = true; 
036A:  BSF    1F.0
....................        //   aver_count = 0; 
....................            
....................        //   average_Xg = average_X; 
....................       //    average_Yg = average_Y; 
....................        //   average_Zg = average_Z; 
....................     
....................           switch(coord_sys)       // анализ выбраной системы координат 
036C:  MOVFF  7F,00
0370:  MOVF   x80,W
0372:  MOVWF  03
0374:  BNZ   037A
0376:  MOVF   00,F
0378:  BZ    0390
037A:  MOVF   03,W
037C:  BNZ   0384
037E:  MOVLW  01
0380:  SUBWF  00,W
0382:  BZ    0392
0384:  MOVF   03,W
0386:  BNZ   038E
0388:  MOVLW  02
038A:  SUBWF  00,W
038C:  BZ    03AC
038E:  BRA    03C6
....................          { 
....................             case 0: break;       // по умолчанию, ничего не меняем 
0390:  BRA    03C6
....................             //===== 
....................             case 1:              // 1 вариант изменения системы координат 
....................                coodr_buf = SumX;    // поворот правой тройки вниз 
0392:  MOVFF  25,B0
0396:  MOVFF  24,AF
....................                SumX = SumZ; 
039A:  MOVFF  29,25
039E:  MOVFF  28,24
....................                SumZ = coodr_buf; 
03A2:  MOVFF  B0,29
03A6:  MOVFF  AF,28
....................                break;        
03AA:  BRA    03C6
....................                            //===== 
....................             case 2:              // 2 вариант изменения системы координат 
....................                coodr_buf = SumY;    // поворот правой тройки влево 
03AC:  MOVFF  27,B0
03B0:  MOVFF  26,AF
....................                SumY = SumZ; 
03B4:  MOVFF  29,27
03B8:  MOVFF  28,26
....................                SumZ = coodr_buf; 
03BC:  MOVFF  B0,29
03C0:  MOVFF  AF,28
....................                break;        
03C4:  BRA    03C6
....................             //===== 
....................             default: break; 
....................           
....................          } 
....................            
....................           //average_X = 0; 
....................           //average_Y = 0; 
....................           //average_Z = 0; 
....................        //} 
....................  
....................        HMC5883l_Init(); 
03C6:  BRA    0278
....................        //SensWrData (ConfigRegB, 0xE0); // range = + / - 8.1 Gs 
....................        //SensWrData (ModeReg, 0x00);    // continuous measurment 
....................     } 
....................  
....................     SET_TIMER0 (55770); 
03C8:  MOVLW  D9
03CA:  MOVWF  FD7
03CC:  MOVLW  DA
03CE:  MOVWF  FD6
....................     clear_interrupt (int_EXT); 
03D0:  BCF    FF2.1
....................  } 
....................  
03D2:  BCF    FF2.1
03D4:  GOTO   006C
....................  #int_RDA 
....................  void UART_RXd_isr (void) 
....................  { 
....................      
....................      
....................     wr_ptr++;                    // инкремент счетчика запис. байт 
03D8:  INCF   x8E,F
....................     rx_buf[wr_ptr & 0x0f]  = RCREG;     // сохр. байта от ПК 
03DA:  MOVF   x8E,W
03DC:  ANDLW  0F
03DE:  CLRF   03
03E0:  ADDLW  90
03E2:  MOVWF  FE9
03E4:  MOVLW  00
03E6:  ADDWFC 03,W
03E8:  MOVWF  FEA
03EA:  MOVFF  FAE,FEF
....................    
....................     clear_interrupt (int_RDA);         // сброс флага прерывания 
03EE:  MOVF   FAE,W
03F0:  BCF    F9E.5
03F2:  GOTO   006C
....................  } 
....................  
.................... //= == == = == == == == = == = Interrupts = == = == == == == == == == 
....................  
.................... void LCDsensInfoMsg() 
.................... { 
....................        LCDclear (); 
....................        LCDSetCursor (one); 
....................        LCDMsg ("ОБНАРУЖЕН ДАТЧИК"); 
....................        LCDSetCursor (two); 
....................        LCDMsg ("      Тип:      "); 
....................        LCDSetCursor (three); 
....................         
....................        if (sens_type == TLV493D)   
....................        { 
....................          LCDMsg ("  Bmax = 1.3 kGS   "); 
....................        } 
....................         else if (sens_type == HMC5883l)  
....................        { 
....................          LCDMsg (" Bmax = 8.1 GS    "); 
....................        } 
....................         
....................        else LCDMsg ("   Ошибка ID    "); 
....................         
....................        LCDSetCursor (four); 
....................          LCDMsg ("Датчик N:  "); 
....................        LCDPutU16n ( (U16) sens_num, 3) ; 
....................        delay_ms(2000); 
....................         
....................        LCDClear(); 
....................        Lcdsetcursor (one); 
....................        LCDMsg ("Коэффициенты:"); 
....................        Lcdsetcursor (0x40); 
....................        LCDMsg ("Kx = "); 
....................        LcdPutS16 ( (S32) (kx * 1000), 5); 
....................        Lcdsetcursor (0x10); 
....................        LCDMsg ("Ky = "); 
....................        LcdPutS16 ( (S32) (ky * 1000), 5); 
....................        Lcdsetcursor (0x50); 
....................        LCDMsg ("Kz = "); 
....................        LcdPutS16 ( (S32) (kz * 1000), 5); 
....................         
....................        delay_ms (2000); 
....................        LCDclear (); 
....................  
.................... }  
....................  
.................... U8 detect_sensors() 
.................... { 
....................        U8 status = 0; 
....................         
....................        rom_rd_status = rom_rd_sens_data ();  
....................        delay_ms (500); 
....................         
....................        if      (sens_type == HMC5883l)  
....................        { 
....................          EXT_int_EDGE (L_TO_H); 
....................          enable_interrupts (int_EXT); 
....................          //SETUP_TIMER_0 (T0_INTERNAL|T0_DIV_128); 
....................          //SET_TIMER0 (55770); 
....................          //enable_interrupts (int_TIMER0); 
....................          status = 30;                   // return sensor id if sucess 
....................          HMC5883l_Init(); 
....................        } 
....................         
....................        else if (sens_type == TLV493D) status = TLV493D_init(); 
....................    
....................        else 
....................       { 
....................          kx = 1.0; 
....................          ky = 1.0; 
....................          kz = 1.0; 
....................       } 
....................      
....................     return status; 
.................... } 
....................  
.................... U8 ch_to_int(char ch) 
.................... { 
.................... // преобразование сивмола в цифру 
.................... U8 dg=-1;                                                                         
....................   
....................  switch (ch) 
....................    { 
....................       case '0' : dg=0; break; 
....................       case '1' : dg=1; break; 
....................       case '2' : dg=2; break; 
....................       case '3' : dg=3; break; 
....................       case '4' : dg=4; break; 
....................       case '5' : dg=5; break; 
....................       case '6' : dg=6; break; 
....................       case '7' : dg=7; break; 
....................       case '8' : dg=8; break; 
....................       case '9' : dg=9; break; 
....................       default: dg = -1; 
....................    } 
....................  
....................    return dg; 
.................... } 
....................  
.................... char get_rx_ch (void) 
.................... {                                                      
.................... // Get RX char 
.................... char rch; 
....................  
....................    if (rd_ptr < wr_ptr) // буфер не пуст 
....................    { 
....................       rd_ptr++;                    // инкремент счетчика считаных байт 
....................       rch = rx_buf[rd_ptr & 0x0F]; // сохр. элемента по индексу 
....................    } 
....................    else rch = 'x';    
....................     
....................    // запрет прерываний по UART на время сравнение указателей   
....................    // на счит. и запис. элементы массива 
....................    disable_interrupts(INT_RDA);     
....................             
....................    if ((wr_ptr==rd_ptr) && (wr_ptr > 15)) // если буфер заполнен                                             
....................    {   
....................       wr_ptr=0;                                                                    
....................       rd_ptr=0;                                                        
....................    }  
....................  
.................... enable_interrupts(INT_RDA);         // разрешение прерываний 
....................  
.................... return rch; 
.................... } 
....................  
.................... void main  () 
*
07E2:  CLRF   FF8
07E4:  BCF    FD0.7
07E6:  BSF    07.7
07E8:  BCF    FA7.3
07EA:  MOVLW  40
07EC:  MOVWF  FAF
07EE:  MOVLW  A6
07F0:  MOVWF  FAC
07F2:  MOVLW  90
07F4:  MOVWF  FAB
07F6:  CLRF   1E
07F8:  CLRF   1D
07FA:  BCF    1F.0
07FC:  BCF    1F.1
07FE:  BCF    1F.2
0800:  CLRF   20
0802:  MOVLW  01
0804:  MOVWF  21
0806:  MOVLW  02
0808:  MOVWF  22
080A:  MOVLW  A0
080C:  MOVWF  23
080E:  CLRF   25
0810:  CLRF   24
0812:  CLRF   27
0814:  CLRF   26
0816:  CLRF   29
0818:  CLRF   28
081A:  CLRF   2B
081C:  CLRF   2A
081E:  CLRF   2D
0820:  CLRF   2C
0822:  CLRF   2F
0824:  CLRF   2E
0826:  CLRF   33
0828:  CLRF   32
082A:  CLRF   31
082C:  CLRF   30
082E:  CLRF   37
0830:  CLRF   36
0832:  CLRF   35
0834:  CLRF   34
0836:  CLRF   3B
0838:  CLRF   3A
083A:  CLRF   39
083C:  CLRF   38
083E:  CLRF   3D
0840:  CLRF   3C
0842:  CLRF   3E
0844:  CLRF   40
0846:  CLRF   3F
0848:  CLRF   41
084A:  CLRF   43
084C:  CLRF   42
084E:  CLRF   44
0850:  CLRF   48
0852:  CLRF   47
0854:  CLRF   46
0856:  CLRF   45
0858:  CLRF   4C
085A:  CLRF   4B
085C:  CLRF   4A
085E:  CLRF   49
0860:  CLRF   50
0862:  CLRF   4F
0864:  CLRF   4E
0866:  CLRF   4D
0868:  CLRF   54
086A:  CLRF   53
086C:  CLRF   52
086E:  MOVLW  7F
0870:  MOVWF  51
0872:  CLRF   58
0874:  CLRF   57
0876:  CLRF   56
0878:  MOVWF  55
087A:  CLRF   5C
087C:  CLRF   5B
087E:  CLRF   5A
0880:  MOVWF  59
0882:  CLRF   x7D
0884:  CLRF   x7E
0886:  CLRF   x80
0888:  CLRF   x7F
088A:  CLRF   x86
088C:  CLRF   x85
088E:  BCF    1F.3
0890:  CLRF   x8A
0892:  CLRF   x89
0894:  CLRF   x8C
0896:  CLRF   x8B
0898:  CLRF   x8D
089A:  CLRF   x8E
089C:  CLRF   x8F
089E:  MOVLB  F
08A0:  MOVF   x5C,W
08A2:  ANDLW  80
08A4:  MOVWF  x5C
08A6:  MOVLW  00
08A8:  MOVWF  x5D
08AA:  BCF    FC1.3
08AC:  BCF    FC1.4
08AE:  BCF    FC1.5
08B0:  CLRF   x5E
08B2:  CLRF   x5F
08B4:  BRA    08C6
08B6:  DATA 03,00
08B8:  DATA 1A,00
08BA:  DATA 00,00
08BC:  DATA 20,40
08BE:  DATA 5D,00
08C0:  DATA 10,40
08C2:  DATA 90,00
08C4:  DATA 00,00
08C6:  MOVLW  00
08C8:  MOVWF  FF8
08CA:  MOVLW  08
08CC:  MOVWF  FF7
08CE:  MOVLW  B6
08D0:  MOVWF  FF6
08D2:  TBLRD*+
08D4:  MOVF   FF5,W
08D6:  MOVWF  00
08D8:  XORLW  00
08DA:  BZ    0902
08DC:  TBLRD*+
08DE:  MOVF   FF5,W
08E0:  MOVWF  01
08E2:  BTFSC  FE8.7
08E4:  BRA    08F0
08E6:  ANDLW  0F
08E8:  MOVWF  FEA
08EA:  TBLRD*+
08EC:  MOVFF  FF5,FE9
08F0:  BTFSC  01.6
08F2:  TBLRD*+
08F4:  BTFSS  01.6
08F6:  TBLRD*+
08F8:  MOVFF  FF5,FEE
08FC:  DCFSNZ 00,F
08FE:  BRA    08D2
0900:  BRA    08F4
0902:  CLRF   FF8
0904:  MOVLB  0
0906:  CLRF   xA0
0908:  CLRF   xA2
090A:  CLRF   xA3
090C:  CLRF   xA5
090E:  CLRF   xA4
....................  { 
.................... // режим программатора закомментирован 
....................  
....................  
.................... /* 
.................... ///////////////////////////////////////////////////////////////////////////////   
....................    /// программатор ПЗУ 
....................  
....................    //float kx = 1.058935361; // старые коэффициенты датчика № 2  
....................    //float ky = 1.20824295; 
....................    //float kz = 1.031481481; 
....................     
....................    //float kx = 1.041121495;   // старые коэффициенты датчика № 1 
....................    //float ky = 1.141393443; 
....................    //float kz = 1.023897059; 
....................     
....................    //float kx = 1.092291928;   // коэффициенты датчика № 1 21.04 
....................    //float ky = 1.170930426; 
....................    //float kz = 1.042684161; 
....................       
....................    float kx = 1;   // без коэффициентов 
....................    float ky = 1; 
....................    float kz = 1; 
....................        
....................    //float kx = 1.0778792;   // коэффициенты датчика № 2 кал. вечер 21.04 
....................    //float ky = 1.19226638; 
....................    //float kz = 1.06812933; 
....................     
....................    //float kx = 1.07537299;   // коэффициенты датчика № 1 кал. вечер 21.04 
....................    //float ky = 1.173361522; 
....................    //float kz = 1.061591431; 
....................     
....................    //float kx = 1.0517;     // коэффициенты датчика № 2 кал. 28.12.16 
....................    //float ky = 1.2266; 
....................    //float kz = 1.0406; 
....................     
....................    //float kx = 1.0747;     // коэффициенты датчика № 1 кал. 28.12.16 
....................    //float ky = 1.1824; 
....................    //float kz = 1.0650; 
....................     
....................       
....................    U16 sens_type = HMC5883l; //TLV493D; 
....................    U16 sens_num = 18; 
....................  
....................    U16 ROM_Adr = 0x0000; 
....................    U16 CRC_Wr; 
....................    U16 CRC1 = 0; 
....................    U16 CRC2 = 0;  
....................  
....................    TRB0 = 1;   // DRDY 
....................     
....................    TRB3 = 0;  
....................    TRB4 = 0; 
....................    TRB5 = 0; 
....................    TRC0 = 0; 
....................    TRC1 = 0; 
....................    TRC2 = 0; 
....................    TRC5 = 0; 
....................   
....................    TRC3 = 1; 
....................    TRC4 = 1; 
....................    TRC6 = 0;                  // UART1 - TX 
....................    TRC7 = 1;                  // UART1 - RX 
....................     
....................    EXT_INT_EDGE(L_TO_H); 
....................    enable_interrupts(INT_RDA); 
....................    enable_interrupts(INT_EXT); 
....................    //enable_interrupts(GLOBAL); 
....................  
....................    LCDInit(); 
....................    LcdWelcome(); 
....................    LCDSetCursor(two); 
....................    LCDMsg(" Запись в ПЗУ..."); 
.................... //-----------------------------------------------------------------------------        
....................    rom_wr_byte(ROM_Adr,sens_type);     // тип датчика   0 
....................    rom_wr_byte (++ROM_Adr, sens_num);  // № датчика     1 
....................    rom_wr_byte (++ROM_Adr, coord_sys); // сис.координат 2 
....................    rom_wr_float(++ROM_Adr,&kx);        // Kx            3-6  
....................    ROM_adr += 4; 
....................    rom_wr_float(ROM_Adr,&ky);          // Ky            7-10 
....................    ROM_adr += 4; 
....................    rom_wr_float(ROM_Adr,&kz);          // Kz            11-14 
....................     
....................    ROM_Adr += 4; 
....................    CRC1 = rom_wr_CRC16(ROM_Adr,crc_buf_wr); 
....................    crc_wr_index = 0;    
....................  //-----------------------------------------------------------------------------      
....................    sens_type = 0; 
....................    sens_num  = 0; 
....................     
....................    LCDclear(); 
....................     
....................    while(true){ 
....................     
....................    ROM_Adr = 0x0000; 
....................     
....................    kx = 0; 
....................    ky = 0; 
....................    kz = 0; 
....................     
....................     sens_type = rom_rd_byte (ROM_Adr); // тип датчика 0 
....................     ROM_Adr++; 
....................     sens_num = rom_rd_byte (ROM_Adr);  // № датчика 1 
....................     ROM_Adr++; 
....................     coord_sys = rom_rd_byte (ROM_Adr); // система координат 2 
....................     ROM_Adr++; 
....................     rom_rd_float (ROM_Adr,&kx); // Kx 3 - 6 
....................     ROM_adr += 4; 
....................     rom_rd_float (ROM_Adr,&ky); // Ky 7 - 10 
....................     ROM_adr += 4; 
....................     rom_rd_float (ROM_Adr,&kz); // Kz 11 - 14 
....................      
....................     ROM_adr += 4; 
....................     CRC1 = rom_rd_CRC16 (ROM_adr); // чтение сохраненной CRC 
....................     CRC2 = CRC16 (crc_buf_rd, 14); // расчет CRC по считанным данным 
....................     
....................    Lcdsetcursor(0x00); 
....................    LCDMsg("kx="); 
....................    LcdPutS16((S32)(kx*1000),5); 
....................    Lcdsetcursor(0x40); 
....................    LCDMsg("ky="); 
....................    LcdPutS16((S32)(ky*1000),5); 
....................    Lcdsetcursor(0x10); 
....................    LCDMsg("kz="); 
....................    LcdPutS16((S32)(kz*1000),5); 
....................     
....................    //Printf("CRC1=%LX\n",CRC1); 
....................    //Printf("CRC2=%LX\n",CRC2); 
....................     
....................    for(U8 i =0; i < sizeof(crc_buf_wr); i++) 
....................    { 
....................       //Printf("CRC_buf_wr =%LX CRC_buf_rd=%LX\n",crc_buf_wr[i], crc_buf_rd[i]); 
....................       Printf("__"); 
....................       Printf("CRC_buf_wr =%LX\n",crc_buf_wr[i]); 
....................        
....................       delay_ms(500); 
....................    } 
....................    Printf("\n\r"); 
....................    Printf("\n\r"); 
....................    //Printf("CRC1=%LX\n",CRC1); 
....................    crc_rd_index = 0; 
....................     
....................    delay_ms(500); 
....................     
....................    } // while 
....................  } // main 
.................... ///////////////////////////////////////////////////////////////////////////////   
.................... */ 
....................  
.................... //============================================================================= 
....................  
....................    /// режим измерений 
....................     
....................     U8 TLV493D_status = 0; 
....................     char rx_byte;       // байт принятый с ПК 
....................     U8 rd_state = 0;    // машина состояний 
....................     char coef_id = 0;   // идентификатор канала численного параметра с ПК 
....................     U16 num_param = 0;  // численный параметр полученый с ПК 
....................      
....................     TRB0 = 1; // DRDY 
0910:  BSF    F93.0
....................     TRB1 = 0; 
0912:  BCF    F93.1
....................      
....................     TRB3 = 0; 
0914:  BCF    F93.3
....................     TRB4 = 0; 
0916:  BCF    F93.4
....................     TRB5 = 0; 
0918:  BCF    F93.5
....................     TRC0 = 0; 
091A:  BCF    F94.0
....................     TRC1 = 0; 
091C:  BCF    F94.1
....................     TRC2 = 0; 
091E:  BCF    F94.2
....................     TRC5 = 0; 
0920:  BCF    F94.5
....................     TRC3 = 1; 
0922:  BSF    F94.3
....................     TRC4 = 1; 
0924:  BSF    F94.4
....................     TRC6 = 0; // UART1 - TX 
0926:  BCF    F94.6
....................     TRC7 = 1; // UART1 - RX 
0928:  BSF    F94.7
....................  
....................     LED = 1; 
092A:  BSF    F8A.1
....................      
....................     LCDInit (); 
092C:  BRA    0530
....................     LCDWelcome (); 
092E:  BRA    0614
....................     //if(detect_sensors() != 0) LCDsensInfoMsg(); 
....................  
....................     //enable_interrupts (int_RDA); 
....................     //enable_interrupts (GLOBAL); 
....................      
....................     rom_wr_byte(0,0); 
0930:  CLRF   xA7
0932:  CLRF   xA6
0934:  CLRF   xA8
0936:  BRA    0662
....................      
.................... //-----------------------------------------------------------------------------    
....................     while (true) 
....................     {  
....................        restart_wdt();  
0938:  CLRWDT
....................       // rom_wr_byte(0x0000,0x82); 
....................         
....................        //LcdPutU16(rom_rd_byte(0x0000), 3); 
....................        rom_rd_byte(0x0000); 
093A:  CLRF   xA7
093C:  CLRF   xA6
093E:  BRA    070A
....................        delay_ms(100); 
0940:  MOVLW  64
0942:  MOVWF  xAC
0944:  RCALL  0480
0946:  BRA    0938
.................... //-----------------------------------------------------------------------------    
.................... /* 
....................        switch(sens_type) // анализ типа текущего датчика 
....................        { 
....................         case TLV493D:    // тип - 1.3 kGs 
....................              TLV493D_status = TLV493D_rd_all(coord_sys); // режим штатного чтения 
....................              
....................              if (TLV493D_status == 1)                    // датчик подключен, чтение успешно               
....................              { 
....................                LCDSetCursor(four); 
....................                LCDMsg(" r"); LCDPutU16(coord_sys, 1);    // вывод на дисплей системы координат 
....................                LCDMsg("  1,3 kGs  ");                    // и типа датчика 
....................              } 
....................              else sens_type = 0;      // сброс режима датчика, требуется новая инициализация 
....................               
....................         break; 
....................         //===========    
....................         case HMC5883l:  // тип - 8 Gs 
....................          
....................             if (int_fl) // если был взведен флаг в прерывании от датчика 
....................              {     
....................                SensRdAll(); // режим штатного чтения 
....................                LCDSetCursor(four); 
....................                LCDMsg(" r"); LCDPutU16(coord_sys, 1); // вывод на дисплей системы координат 
....................                LCDMsg("   8,1 Gs ");                  // и типа датчика 
....................              } 
....................              else sens_type = 0;                      // сброс режима датчика, требуется новая инициализация 
....................         //===========    
....................         break; 
....................         //===========               
....................         default:  
....................                if(detect_sensors() == 0)  
....................                {  
....................                   NC_LCDMsg(); 
....................                   delay_ms(1000); 
....................                } 
....................                else LCDsensInfoMsg(); 
....................                break;  
....................        } 
.................... //-----------------------------------------------------------------------------    
....................        if (!SB2) set_zero_fl = 1; // проверка нажатия УСТ. 0 
.................... //-----------------------------------------------------------------------------  
.................... // обработка команд 
....................  
....................        while(rd_ptr < wr_ptr) // буфер не пуст, получен байт  
....................         { 
....................               U8 temp_buf;                                          
....................               rx_byte = get_rx_ch();   
....................                
....................               // вывод символа получения команды с ПК 
....................               LCDSetCursor(four); 
....................               LCDMsg("             *"); 
....................  
....................                switch(rd_state)  // конечный автомат состояний чтения команд 
....................                { 
....................                //----- 
....................                   case 0:        // обработка однобайтных команд 
....................                      switch(rx_byte) 
....................                      { 
....................                         case 'z':            // получена команда уст. 0 
....................                            set_zero_fl = 1;  // выставляем флаг уст. 0 
....................                            printf("ok\n\r"); // отсылка ответа на ПК 
....................                            rd_state = 0;     // возврат в состояние анализа заголовка команды 
....................                            break; 
....................                            //===== 
....................                         case 's':            // получена команда запроса id и системы координат 
....................                            printf("r=");  printf("%01lu,",coord_sys);   // отсылка системы координат 
....................                            printf("id="); printf("%02lu\n\r",sens_type); // отсылка id 
....................                            rd_state = 0;     // возврат в состояние анализа заголовка команды 
....................                            break; 
....................                            //===== 
....................                         case 'r':            // получена команда уст. системы координат 
....................                            rd_state = 5;     // переход в состояние анализа команды  
....................                            break; 
....................                            //=====                            
....................                         case 'k':            // получена команда запроса коэффициентов 
....................                            printf("a"); printf("%04lu",(U16)(kx*1000));  // отсылка коэфф. 
....................                            printf("b"); printf("%04lu",(U16)(ky*1000)); 
....................                            printf("c"); printf("%04lu\n\r",(U16)(kz*1000)); 
....................                            rd_state = 0;     // возврат в состояние анализа заголовка команды 
....................                            break; 
....................                            //===== 
....................                         case 'a':            // получена команда уст. коэфф. а 
....................                            rd_state = 1;     // переход в состояние чтения первого байта команды 
....................                            coef_id = 'a';    // сохранение идентификатора параметра 
....................                            break; 
....................                            //===== 
....................                         case 'b':            // получена команда уст. коэфф. b 
....................                            rd_state = 1;     // переход в состояние чтения первого байта команды 
....................                            coef_id = 'b';    // сохранение идентификатора параметра 
....................                            break; 
....................                            //===== 
....................                         case 'c':            // получена команда уст. коэфф. c 
....................                            rd_state = 1;     // переход в состояние чтения первого байта команды 
....................                            coef_id = 'c';    // сохранение идентификатора параметра 
....................                            break; 
....................                            //=====                            
....................                             
....................                         default:  
....................                            printf("cmd error\n\r");  
....................                            break; 
....................                      } 
....................                   break; 
....................                //----- 
....................                // анализ цифр переданных с параметром 
....................                case 1:  
....................                   temp_buf = ch_to_int(rx_byte); 
....................                   if(temp_buf == -1)   // проверка адекватности параметра                                                            
....................                   {         
....................                    rd_state = 0;                                                 
....................                    printf("err p1\n\r");                                             
....................                    break; 
....................                   } 
....................                                                                          
....................                   num_param = 0;                                                                  
....................                   num_param += (U16) temp_buf*1000;                                                       
....................                   rd_state = 2;                                                              
....................                break; 
....................                //----- 
....................                case 2:  
....................                   temp_buf = ch_to_int(rx_byte); 
....................                   if(temp_buf == -1)   // проверка адекватности параметра                                                               
....................                   {         
....................                    rd_state = 0;                                                 
....................                    printf("err p2\n\r");                                             
....................                    break; 
....................                   }                                                                                               
....................                   num_param += (U16) temp_buf*100;                                                       
....................                   rd_state = 3;                                                              
....................                break; 
....................                //----- 
....................                case 3:  
....................                   temp_buf = ch_to_int(rx_byte); 
....................                   if(temp_buf == -1)   // проверка адекватности параметра                                                       
....................                   {         
....................                    rd_state = 0;                                                 
....................                    printf("err p3\n\r");                                             
....................                    break; 
....................                   } 
....................                   num_param += (U16) temp_buf*10;                                                       
....................                   rd_state = 4;                                                              
....................                break; 
....................                //----- 
....................                 case 4:  
....................                   temp_buf = ch_to_int(rx_byte); 
....................                   if(temp_buf == -1)   // проверка адекватности параметра                                                            
....................                   {         
....................                    rd_state = 0;                                                 
....................                    printf("err p4\n\r");                                             
....................                    break; 
....................                   } 
....................                   num_param += (U16) temp_buf;     
....................                    
....................                   // все 4 цифры параметра получены успешно 
....................                   switch(coef_id) // сохраняем полученный коэф. в переменную 
....................                   { 
....................                      case 'a':  
....................                         kx = (float) num_param / 1000.0;  
....................                         if(kx == 0)  { kx = 1.0; num_param += 1000; } // защита от уст. коэф. = 0 
....................                         break; 
....................                      case 'b':  
....................                         ky = (float) num_param / 1000.0;  
....................                         if(ky == 0) { ky = 1.0; num_param += 1000; }  // защита от уст. коэф. = 0 
....................                         break; 
....................                      case 'c':  
....................                         kz = (float) num_param / 1000.0;  
....................                         if(kz == 0) { kz = 1.0; num_param += 1000; }// защита от уст. коэф. = 0 
....................                         break; 
....................                      default: break; 
....................                   } 
....................                   Printf("%c", coef_id);           // отправка id коэффициента 
....................                   printf("%04lu\n\r",num_param);   // отправка коэффициента 
....................                    
....................                   // вывод сообщения о записи в пзу 
....................                   LCDclear(); 
....................                   LCDSetCursor(two); 
....................                   LCDMsg(" Запись в ПЗУ..."); 
....................                   update_rom_data();         // запись в пзу 
....................                   rd_state = 0;              // возврат в состояние анализа заголовка команды                                                             
....................                break;  
....................                //----- 
....................                case 5:  
....................                   temp_buf = ch_to_int(rx_byte); 
....................                   if((temp_buf == -1) | (temp_buf > 2))  // проверка адекватности параметра                                                          
....................                   {         
....................                    rd_state = 0;             // возврат в состояние анализа заголовка команды                                                
....................                    printf("err p\n\r");                               
....................                    break; 
....................                   } 
....................                   SUMX0 = 0; // сброс коэфф. уст. 0 
....................                   SUMY0 = 0; 
....................                   SUMZ0 = 0;  
....................                   coord_sys = (U16)temp_buf;      // обновление системы координат   
....................                   printf("r="); 
....................                   printf("%01ld\n\r",coord_sys);   // отправка нового значения системы координат 
....................                   // вывод сообщения о записи в пзу 
....................                   LCDclear(); 
....................                   LCDSetCursor(two); 
....................                   LCDMsg(" Запись в ПЗУ..."); 
....................                   update_rom_data();              // запись в пзу 
....................                   rd_state = 0;                   // возврат в состояние анализа заголовка команды 
....................                   break; 
....................                //----- 
....................                default: break; 
....................                 
....................                } // switch 
....................                 
....................                // очистка символа получения команды с ПК 
....................               LCDSetCursor(four); 
....................               delay_ms(75); 
....................               LCDMsg("              "); 
....................             }  // while 
....................             */ 
....................     } // while 
....................  }  // main 
.................... //============================================================================= 
0948:  SLEEP 

Configuration Fuses:
   Word  1: C315   VREGSLEEP INTRC_HP SOSC_DIG NOXINST HSM NOPLLEN FCMEN IESO
   Word  2: 3378   PUT NOBROWNOUT BORV18 ZPBORM WDT WDT4096
   Word  3: 8900   CANB MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
