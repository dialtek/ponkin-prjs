
/******************************************************/
/* Software V2.3 for magnetic induction's tester V2.1 */
/******************************************************/
// последние изменения 02.03.17

#include <V2.1.h>
#include <stdio.h>
#include <LCD for V2.1.c>

#define TLV493D_rd_addr 0xbd     // i2c адрес датчика при чтении 
#define TLV493D_wr_addr 0xbc     // i2c адрес датчика при записи

#define TLV493D        37        // ID датчика Bmax = 1,3 kGs
#define HMC5883l       30        // ID датчика Bmax = 8,1 Gs

unsigned int1 int_fl = 0;
unsigned int1 SensErr = 0;
unsigned int1 ReInit_flag = 0;
static U8 ff1=0;
unsigned int1 set_zero_fl = 0;
static U8 TMR0fl=0;                 


char  ConfigRegA = 0x00, ConfigRegB = 0x01, ModeReg = 0x02, xMSB = 0x03, xLSB = 0x04, // ?????? ????????? ??????? ??
      zMSB = 0x05, zLSB = 0x06, yMSB = 0x07, yLSB = 0x08, StatReg = 0x09, idRegA = 0x10,
      idRegB = 0x11, idRegC = 0x12, EEprom_adr = 0xA0;
      
signed int16 SumX=0; 
signed int16 SumY=0; 
signed int16 SumZ=0;
       
signed int16 SumX0=0; 
signed int16 SumY0=0;
signed int16 SumZ0=0;

signed int32 average_Xg=0; 
signed int32 average_Yg=0;
signed int32 average_Zg=0;
             
unsigned int16 Xh =0;   
unsigned int8 Xl = 0;
unsigned int16 Yh =0;
unsigned int8 Yl = 0;
unsigned int16 Zh =0;
unsigned int8 Zl = 0;

float Xd = 0;
float Yd = 0;
float Zd = 0;
float kx = 1.0;   // калибровочные коэффициенты
float ky = 1.0;
float kz = 1.0;

U8 crc_buf_wr[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
U8 crc_buf_rd[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
U8 crc_wr_index = 0;
U8 crc_rd_index = 0;
U8 aver_count = 0;

U16 coord_sys = 0;      // переменная выбора системы координат измерений
U16 sens_type;          // тип датчика => 37 - TLV493D, 30 - HMC5883l        
U16 sens_num;           // № датчика в базе Диалтек
U16 ROM_Adr = 0x0000;
int1 rom_rd_status = 0; // флаг статуса прочтения ПЗУ

U16 CRC_Wr;
U16 CRC1 = 0;
U16 CRC2 = 0; 

S32 average_X, average_Y, average_Z;

U8 TLV493D_frm_cnt = 0; // переменная счета итераций измерения датчика TLV493D
U8 wr_ptr = 0, rd_ptr = 0;                         // счетчики чтения и записи в массив UART
U8 rx_buf[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // буфер для сохр. принятных команд

//****************** Sensor 1 funcs ************************************
void SensWrData(unsigned int8 Adr, Data)
{
   
   i2c_start ();
   i2c_write (0x3C);

   // The default (factory) HMC5883 7 - bit slave address
   // is 0x3C for write operations, or 0x3D for read operations.
   i2c_write (Adr);
   i2c_write (Data);
   i2c_stop ();
}
 
char SensRdData(char Adr)
{
   
   char Data = 0;
   
   i2c_start ();
   i2c_write (0x3C); // The default (factory) HMC5883 7 - bit slave address
   // is 0x3C for write operations, or 0x3D for read operations.
   i2c_write (Adr); // pointer
   i2c_stop ();
   delay_us (10);
   i2c_start ();
   i2c_write (0x3D); //i2c Read
   delay_us (10);
   Data = i2c_read ();
   delay_us (10);
   Data = i2c_read ();
   delay_us (10);
   i2c_stop ();
   
   return Data;
}
    
void HMC5883l_Init ()
{
   
   //SensWrData (ConfigRegA, 0x14); // F = 30 Hz / 1
   SensWrData (ConfigRegA, 0x18); // F = 75 Hz / 1
   SensWrData (ConfigRegB, 0xE0); // range = + / - 8.1 Ga
   SensWrData (ModeReg, 0x00); // continuous measurment mode
   //SensWrData (ModeReg, 0x01); // single measurment mode
}

signed int16 SelfCal()
{
   
   unsigned int16 Xh = 0;
   unsigned int8 Xl = 0;
   unsigned int16 Yh = 0;
   unsigned int8 Yl = 0;
   unsigned int16 Zh = 0;
   unsigned int8 Zl = 0;
   
   HMC5883l_Init();
   delay_us (10);

   if (int_fl)
   {
      i2c_start ();
      i2c_write (0x3C); // The default (factory) HMC5883 7 - bit slave address
      // is 0x3C for write operations, or 0x3D for read operations.
      i2c_write (0x03); // pointer
      i2c_stop ();
      delay_us (10);
      
      i2c_start ();
      i2c_write (0x3D); //i2c Read
      Xh = i2c_read (); // X MSB
      Xl = i2c_read (); // X LSB
      SumX = (Xh<<8)|Xl; //?????????????? ???????? ????????. ??? ?
      Yh = i2c_read (); // Y MSB
      Yl = i2c_read (); // Y LSB
      SumY = (Yh<<8)|Yl; //?????????????? ???????? ????????. ??? Y
      Zh = i2c_read (); // Z MSB
      Zl = i2c_read (); // Z LSB
      SumZ = (Zh<<8)|Zl; //?????????????? ???????? ????????. ??? Z
      i2c_read (); //if adress pointer = 08, adress pointer = 03
      i2c_stop ();
   }

   
   delay_us (10);
   return 1;
}

void SensRdAll()
{
   if (set_zero_fl)
   {
      // утс. 0
      
      LCDClear ();
      Lcdsetcursor (0);
      LcdMsg (" Установка нуля ");
      SumX0 = SumX;
      SumY0 = SumY;
      SumZ0 = SumZ;
      delay_ms (1000);
      set_zero_fl = 0;
   }

   
   average_Zg = (average_Zg / 10) - SumZ0;
   average_Yg = (average_Yg / 10) - SumY0;
   average_Xg = (average_Xg / 10) - SumX0;
   
   //y = (8.1 * x) / 2048; 8.1 / 2048 = 0.0039550781252
   
   Xd = average_Xg * 0.0039550781252;
   Xd *= kx; // умножение на поправочный коэффициент из ПЗУ
   Yd = average_Yg * 0.0039550781252;
   Yd *= ky; // умножение на поправочный коэффициент из ПЗУ
   Zd = average_Zg * 0.0039550781252;
   Zd *= kz; // умножение на поправочный коэффициент из ПЗУ
   
   // Значения поля Bx, By, Bz выводятся согласно пожеланию заказчика //

   Printf ("x%05Ld\n", ( (S32) (Zd * 1000))); // отправка на ПК значений поля в Гс
   Printf ("y%05Ld\n", ( (S32) (Yd * 1000)));
   Printf ("z%05Ld\n", ( (S32) (Xd * 1000)));
   LcdSetCursor (one);
   LcdMsg ("Bx = ");
   LcdPutS16 (Zd * 1000, 4);
   LcdMsg (" Гс. ");
   LcdSetCursor (two);
   LcdMsg ("By = ");
   LcdPutS16 (Yd * 1000, 4);
   LcdMsg (" Гс. ");
   LcdSetCursor (three);
   LcdMsg ("Bz = ");
   LcdPutS16 (Xd * 1000, 4);
   LcdMsg (" Гс. ");
   int_fl = false;
}

//****************** Sensor 1 funcs ************************************

//////////////////// Sensor 2 funcs ////////////////////////////////////  
 void TLV493D_reset()
{
    i2c_start();
    i2c_write (0x00); 
    i2c_stop();
}
 
 U8 TLV493D_init()
{
//!      // после вкл. питания требуется считать значения регистров 7, 8, 9 датчика
//!      // для дальнейшей записи этих значений в конфигурационные регистры.
//!
       S16 reg7data = 0;    // переменные для сохр. заводских настроек датчика
       S16 reg8data = 0;
       S16 reg9data = 0;

//!      //------- 1 этап - чтение заводской конфигурации датчика -------// 
      
       i2c_start ();
       i2c_write (TLV493D_rd_addr); // чтение регистров
       i2c_read();           // Bx (0H)
       i2c_read();           // By (1H)
       i2c_read();           // Bz (2H)
       
       i2c_read();           // Temp (3H) Temp. (11…8) FRM CH
       i2c_read();           // Bx2 (4H)  Bx (3…0) By (3…0)
       i2c_read();           // Bz2 (5H)
       
       i2c_read();                      // Temp2 (6H)
       reg7data = i2c_read();           // FactSet1 (7H)
       reg8data = i2c_read();           // FactSet2 (8H)
       reg9data = i2c_read();           // FactSet3 (9H)
       i2c_stop ();

//!      // инициализация датчика 
//!      // данные магнитного поля обновляются сразу после их чтения микроконтроллером, 
//!      // режим master-controlled
//!      // так, частота измерений зависит от частоты чтения показаний датчика, не более 3.3 кГц
//!    
       i2c_start ();
       i2c_write (TLV493D_wr_addr); //  запись конфигурации
       i2c_write (0x00);            //  Reg 0, Reserved register, must write 0's
       
       i2c_write( 0 << 7 |          //  Reg 1, parity disabled in Reg3
                  0 << 5 |          //  define the slave address, dont use, ADDR = 1, pulled high on PCB  
 ((reg7data & 0x18) << 3)|          //  Bits must correspond to bits 4:3 from read register 7H
                  0 << 2 |          //  If "0" INT (interrupt pulse) disabled
                  1 << 1 |          //  If "1" fast mode enabled
                        1);         //  If "1" - Low power mode, f = 100 Hz
                  
                  
       i2c_write(reg8data);         //  Reg 2, Bits must correspond to bits 7:0 from read register 8H
       
       i2c_write( 1 << 7 |          //  Reg 3, temperature measurement disabled
                  1 << 6 |          //  If '1' period is 12ms, if '0' period is 100ms     
                  0 << 5 |          //  If "0" parity test disabled
          (reg9data & 0x1f));       //  Bits must correspond to bits 4:0 from read register 9H.        
       i2c_stop ();
       
       if (reg8data < 0xff) return 1;
       else return 0;
}

 float TLV493D_calc_field (S16 nibble_h, S16 nibble_l)
 {
      // расчет величины магнитного поля по оси X датчика
      // nibble_h - MSB, nibble_l содержит младший полубайт данных оси Х
         
      S16 fi = 0;          // для хранения отсчетов магнитного поля
      float fl = 0;        // для хранения магнитного поля в Гс
      
      fi = (nibble_h << 4) | nibble_l;
      if ( fi >= 2048)   fi = fi - 4096;  // Interpret bit 12 as +/- 
      
      // LSB = 0.098 mT -> 0.98 Gs
      fl = fi * 0.098;    // перевод из отсчетов АЦП в mT
      fl *= 10;           // перевод из mT в Гауссы
      
      return fl;

  }
 
 U8 TLV493D_rd_all(U8 coord_sys)
 {
        
       S16 xh, yh, zh = 0;  // ст. байты данных
       S16 xl, yl, zl = 0;  // мл. полубайты
       S16 bz2, bx2by2, frame_ctr = 0; // регистры датчика
       S16 x, y, z = 0;
       S16 coodr_buf = 0;

       U8 status; // 1 - чтение ок, 0 - ошибка чтения, 2 - требуется инициализация
 
        // чтение данных
       i2c_start ();
     
       i2c_write (TLV493D_rd_addr);     // чтение регистров
       xh = i2c_read();                 // Bx (0H)
       yh = i2c_read();                 // By (1H)
       zh = i2c_read();                 // Bz (2H)
       
       frame_ctr = i2c_read();          // Temp (3H) Temp. (11…8) FRM CH
       bx2by2 = i2c_read();             // Bx2 (4H)  Bx (3…0) By (3…0)
       bz2 = i2c_read();                // Bz2 (5H)
     
       i2c_read();                      // вычитывать необходимо все 10 регистров
       i2c_read(); 
       i2c_read(); 
       i2c_read(); 
     
       i2c_stop ();
       
       if(frame_ctr == 0xff) status = 0; // датчик не подкл
       
       // сравнение старого значения счетчика измерений с новым
       else if(TLV493D_frm_cnt == (U8)frame_ctr) 
       {// датчик заклинило
         TLV493D_reset(); // сброс состояния датчика
         TLV493D_init();  // инициализация
       }
       
       else                                  // подключен, все ок
       {
         TLV493D_frm_cnt = frame_ctr;   // сохр. нового значения счетчика измерений
         
         xl = bx2by2 >> 4;      // получение мл. полубайта значений по оси Х 
         yl = bx2by2 & 0x0f;    // получение мл. полубайта значений по оси Y 
         zl = bz2 & 0x0f;       // получение мл. полубайта значений по оси Z  
       
         x = (S16)(kx * TLV493D_calc_field(xh, xl));    // передача в функцию ст. и мл. байт для расчета поля по X
         y = (S16)(ky * TLV493D_calc_field(yh, yl));    // передача в функцию ст. и мл. байт для расчета поля по Y
         z = (S16)(kz * TLV493D_calc_field(zh, zl));    // передача в функцию ст. и мл. байт для расчета поля по Z
         
         switch(coord_sys)       // анализ выбраной системы координат
         {
            case 0: break;       // по умолчанию, ничего не меняем
            //=====
            case 1:              // 1 вариант изменения системы координат
               coodr_buf = x;    // поворот правой тройки вниз
               x = z;
               z = coodr_buf;
               break;       
                           //=====
            case 2:              // 2 вариант изменения системы координат
               coodr_buf = y;    // поворот правой тройки влево
               y = z;
               z = coodr_buf;
               break;       
            //=====
            default: break;
         
         }
         
         if (set_zero_fl)
         {
           // утс. 0
      
          LCDClear ();
          Lcdsetcursor (0);
          LcdMsg (" Установка нуля ");
          SUMX0 = x;  // сохр. текущего значения магнитного поля
          SUMY0 = y;
          SUMZ0 = z;
          delay_ms (1000);
          set_zero_fl = 0;
         }
         
         x = x - SUMX0; // вычет смещение поля
         y = y - SUMY0;
         z = z - SUMZ0;
         
        // отправка на ПК значений поля в Гс
         Printf ("x%05Ld\n", x); 
         Printf ("y%05Ld\n", y);
         Printf ("z%05Ld\n", z);

         LcdSetCursor (one);
         LcdMsg (" Bx = "); LCDPutS16n (x, 4); LcdMsg (" Гс. ");
         LcdSetCursor (two); 
         LcdMsg (" By = "); LCDPutS16n (y, 4); LcdMsg (" Гс. ");
         LcdSetCursor (three);
         LcdMsg (" Bz = "); LCDPutS16n (z, 4); LcdMsg (" Гс. ");
         
         status = 1;
       }
       
       if((ReInit_flag == 1) & (status==1)) status = 2;
       
       return status;
 
 }

//////////////////// Sensor 2 funcs ////////////////////////////////////


//------------------ EEPROM funcs --------------------------------------
 U16 CRC16 (U8 * data_p, U8 length)
 {
    // расчет контрольной суммы
    // взят из интернета
    
    U8 x;
    U16 crc = 0xFFFF;

    while (length--)
    {
       x = crc >> 8 ^ * data_p++;
       x ^= x>>4;
       crc = (crc << 8) ^ ((U16) (x << 12)) ^ ((U16) (x <<5)) ^ ( (U16) x) ;
    }

    return crc;
 }

 void rom_wr_byte (U16 addr, U8 dataByte)
 {
    /// записывает байт данных по 16 - бит. адресу
    
    U8 addr_MSB = 0;
    U8 addr_LSB = 0;
    
    addr_MSB = (addr >> 8);
    addr_LSB = addr;
    
    i2c_start ();
    i2c_write (EEprom_adr|0); // запись
    // A read operation is initiated if this bit is high
    // and a write operation is initiated if this bit is low.
    
    i2c_write (addr_MSB);
    i2c_write (addr_LSB);
    i2c_write (dataByte);
    i2c_stop ();
    delay_ms (15); // t записи в rom - 10 мс
    crc_buf_wr[crc_wr_index] = dataByte;
    crc_wr_index++;
 }

 U8 rom_rd_byte (U16 addr)
 {
    /// чтение байта данных по 16 - бит. адресу
    
    U8 rd_data_byte = 0;
    U8 addr_MSB = 0; // старший байт адреса
    U8 addr_LSB = 0; // младший байт адреса
    
    addr_MSB = (addr >> 8); // заполнение ст. байта из 2 - байт. адреса
    addr_LSB = addr; // заполнение мл. байта из 2 - байт. адреса
    
    i2c_start ();
    i2c_write (EEprom_adr|0); // команда чтения
    // A read operation is initiated if this bit is high
    // and a write operation is initiated if this bit is low.
    
    i2c_write (addr_MSB); // выдача на линию ст. байта адреса
    i2c_write (addr_LSB); // выдача на линию мл. байта адреса
    i2c_start ();
    i2c_write (EEprom_adr|1); // чтение
    rd_data_byte = i2c_read ();
    i2c_write (0xff); // без этого не работает 0_0
    i2c_stop ();
    crc_buf_rd[crc_rd_index] = rd_data_byte;
    crc_rd_index++;
    
    return rd_data_byte;
 }

 void rom_rd_float (U16 ee_addr, void * float_data_ptr)
 {
    /// чтение 4 - байт. переменной типа float из rom
    
    // передается указатель на заранее инициализир. перемен.
    // типа float, происходит побайтное считывание из rom и наполнение
    // ими адреса переданного через указатель
    
    U8 buf;
    U8 * dataByte_ptr = float_data_ptr; // сохраняем указатель (адрес)
    // переменной для чтения
    U8 k = 0;
    U8 i = sizeof (float);
    
    while (k < i)
    {
       buf = rom_rd_byte (ee_addr); // чтение байта из памяти
       * dataByte_ptr = buf; // сох. этого байта по адресу конкретной переменной
       dataByte_ptr++; // инкремент адреса байта переменной
       ee_addr++; // инкремент адреса rom
       k++; // инкремент итератора цикла чтения
    }

    //LCDMsg ("adr = ");
    //LcdPutU16 ( (U32) ee_addr * 1000, 4) ;
    //delay_ms (1000);
    //Lcdsetcursor (0x40);
    
    
    //LCDMsg ("CRC_rd = ");
    //LcdPutU16 ( (U32) CRC_rd, 5) ;
    //Lcdsetcursor (0x50);
    //LCDMsg ("CRC_LSB = ");
    //LcdPutU16 ( (U32) CRC_rd_LSB * 100, 5) ;
 }

 void rom_wr_float (U16 ee_addr, void * float_data_ptr)
 {
    /// запись 4 - байт. переменной типа float в rom
    
    // передается указатель на перемен. типа float для ее сохранения.
    // происходит побайтная запись этой переменной в rom
    
    U8 * dataByte_ptr = float_data_ptr; // сохраняем указатель (адрес)
    // переменной для записи
    U8 k = 0;
    U8 i = sizeof (float); // сохранение размера float в байтах - 4
    //Lcdsetcursor (0);
    //lcdPutCh ('a');
    
    while (k < i)
    {
       //my_arr[k] = *dataByte_ptr;
       //LcdPutU16 (my_arr[k], 3) ;
       //lcdPutCh ('_');
       rom_wr_byte (ee_addr, * dataByte_ptr); // запись байта с конкретн. адресу в rom
       dataByte_ptr++; // инкремент адреса байта переменной
       ee_addr++; // инкремент адреса rom
       k++;  // инкремент итератора цикла записи
    }

    //Lcdsetcursor (0x00);
    //LCDMsg ("CRC_wr = ");
    //LcdPutU16 ( (U32) CRC_Wr, 5);
 }

 U16 rom_wr_CRC16 (ee_addr, U8 crc_buf)
 {
    U16 CRC_Wr;
    
    CRC_Wr = CRC16 (crc_buf, 14); // расчет CRC16
    
    rom_wr_byte (ee_addr, (CRC_Wr >> 8)); // запись ст. байта CRC в rom
    ee_addr++;  // инкремент адреса
    rom_wr_byte (ee_addr, (U8) CRC_Wr); // запись мл. байта CRC в rom
    
    return CRC_Wr;
 }

 U16 rom_rd_CRC16 (ee_addr)
 {
    U8 CRC_rd_MSB; // ст. байт CRC для записи
    U8 CRC_rd_LSB; // мл. байт CRC для записи
    U16 CRC_rd; // 16 - бит. CRC
    
    CRC_rd_MSB = rom_rd_byte (ee_addr); // чтение ст. байта CRC из rom
    ee_addr++;
    CRC_rd_LSB = rom_rd_byte (ee_addr); // чтение мл. байта CRC из rom
    CRC_rd = CRC_rd_MSB << 8; // восстановление CRC
    CRC_rd |= CRC_rd_LSB; // из прочитанных байт
    
    return CRC_rd;
 }

 int1 rom_rd_sens_data (void)
 {
    int1 _rom_rd_status = 0;

    sens_type = rom_rd_byte (ROM_Adr); // тип датчика 0
    ROM_Adr++;
    sens_num = rom_rd_byte (ROM_Adr);  // № датчика 1
    ROM_Adr++;
    coord_sys = rom_rd_byte (ROM_Adr); // система координат 2
    ROM_Adr++;
    rom_rd_float (ROM_Adr,&kx); // Kx 3 - 6
    ROM_adr += 4;
    rom_rd_float (ROM_Adr,&ky); // Ky 7 - 10
    ROM_adr += 4;
    rom_rd_float (ROM_Adr,&kz); // Kz 11 - 14
    
    ROM_adr += 4;
    CRC1 = rom_rd_CRC16 (ROM_adr); // чтение сохраненной CRC
    CRC2 = CRC16 (crc_buf_rd, 14); // расчет CRC по считанным данным
    crc_rd_index = 0;
    ROM_adr = 0x0000;

    if (CRC1 == CRC2)
    {
       _rom_rd_status = 1;
    }

    return _rom_rd_status;
 }

void update_rom_data(void)
{
   U16 ROM_Adr = 0x0000;
  // U16 CRC_Wr;
   U16 CRC1 = 0;
  // U16 CRC2 = 0; 

   rom_wr_byte(ROM_Adr,sens_type);     // тип датчика   0
   rom_wr_byte (++ROM_Adr, sens_num);  // № датчика     1
   rom_wr_byte (++ROM_Adr, coord_sys); // сис.координат 2
   rom_wr_float(++ROM_Adr,&kx);        // Kx            3-6 
   ROM_adr += 4;
   rom_wr_float(ROM_Adr,&ky);          // Ky            7-10
   ROM_adr += 4;
   rom_wr_float(ROM_Adr,&kz);          // Kz            11-14
   
   ROM_Adr += 4;
   CRC1 = rom_wr_CRC16(ROM_Adr,crc_buf_wr);
   crc_wr_index = 0;   
}

//------------------ EEPROM funcs --------------------------------------
 
//= == == = == == == == = == = Interrupts = == = == == == == == == ==
 #int_EXT
 void int0 (void)
 {
    if (SensErr)
    {
       SensErr = 0;
       ReInit_flag = 1;
    }

    
    else
    {
       
       i2c_start ();
       i2c_write (0x3C); // The default (factory) HMC5883 7 - bit slave address
       // is 0x3C for write operations, or 0x3D for read operations.
       i2c_write (0x03); // pointer
       i2c_stop ();
       
       i2c_start ();
       i2c_write (0x3D); //i2c Read
       
       Xh = i2c_read (); // X MSB
       Xl = i2c_read (); // X LSB
       SumX = (Xh<<8)|Xl; //?????????????? ???????? ????????. ??? ?
       Yh = i2c_read (); // Y MSB
       Yl = i2c_read (); // Y LSB
       SumY = (Yh<<8)|Yl; //?????????????? ???????? ????????. ??? Y
       Zh = i2c_read (); // Z MSB
       Zl = i2c_read (); // Z LSB
       SumZ = (Zh<<8)|Zl; //?????????????? ???????? ????????. ??? Z
       i2c_stop ();
       
       average_X += SumX;
       average_Y += SumY;
       average_Z += SumZ;
       aver_count ++;
       
       if (aver_count == 10)
       {
          int_fl = true;
          aver_count = 0;
          
          average_Xg = average_X;
          average_Yg = average_Y;
          average_Zg = average_Z;
          
          average_X = 0;
          average_Y = 0;
          average_Z = 0;
       }

       
       SensWrData (ConfigRegB, 0xE0); // range = + / - 8.1 Gs
       SensWrData (ModeReg, 0x00); // continuous measurment
    }

    SET_TIMER0 (55770);
    clear_interrupt (int_EXT);
 }

 #int_RDA
 void UART_RXd_isr (void)
 {
    
    
    wr_ptr++;                    // инкремент счетчика запис. байт
    rx_buf[wr_ptr & 0x0f]  = RCREG;     // сохр. байта от ПК
  
    clear_interrupt (int_RDA);         // сброс флага прерывания
 }

 #int_TIMER0
 void INT_TIMER0_isr (void)
 {
    SET_TIMER0 (55770);
    clear_interrupt (int_TIMER0);
    SensErr = 1;
 }

//= == == = == == == == = == = Interrupts = == = == == == == == == ==

U8 detect_sensors()
{
    U8 status = 0;
    for (U8 i = 0; i < 10; i++)
    {  // чтение пзу датчика
       rom_rd_status = rom_rd_sens_data (); 
       if (rom_rd_status) break; 
       delay_ms (100);
    }

    if (rom_rd_status)
    {
       LCDclear ();
       LCDSetCursor (two);
       LCDMsg (" Чтение ПЗУ...");
       LCDSetCursor (three);
       LCDMsg ("       OK!      ");
       delay_ms (1000);
       LCDclear ();
       
       LCDSetCursor (0x00);
       LCDMsg ("  Тип датчика:  ");
       LCDSetCursor (0x40);

       if      (sens_type == HMC5883l) 
       {
           EXT_int_EDGE (L_TO_H);
           enable_interrupts (int_EXT);
           SETUP_TIMER_0 (T0_INTERNAL|T0_DIV_128);
           SET_TIMER0 (55770);
           enable_interrupts (int_TIMER0);
           
           HMC5883l_Init();

           LCDMsg ("   Bmax = 8.1 GS    ");
       }
       
       else if (sens_type == TLV493D)  
       {
         LCDMsg ("   Bmax = 1.3 kGS   ");
         TLV493D_reset();
         status = TLV493D_init();
       }
      
       else    LCDMsg ("   Ошибка ID    ");

       LCDSetCursor (0x50);
       LCDMsg ("Датчик N: ");
       LCDPutU16n ( (U16) sens_num, 3) ;
       
       delay_ms (2000);
       LCDclear ();
       
       Lcdsetcursor (0x00);
       LCDMsg ("Коэффициенты:");
       Lcdsetcursor (0x40);
       LCDMsg ("Kx = ");
       LcdPutS16 ( (S32) (kx * 1000), 5);
       Lcdsetcursor (0x10);
       LCDMsg ("Ky = ");
       LcdPutS16 ( (S32) (ky * 1000), 5);
       Lcdsetcursor (0x50);
       LCDMsg ("Kz = ");
       LcdPutS16 ( (S32) (kz * 1000), 5);
       
       delay_ms (2000);
       LCDclear ();
    }
    else
    {
       LCDMsg ("    Ошибка..    ");
       delay_ms (1000);
       kx = 1.0;
       ky = 1.0;
       kz = 1.0;
       LCDSetCursor (four);
       LCDMsg ("Не калиброван");
    }
    
    return status;
}

U8 silent_detect_sensors()
{
    U8 status = 0;
    for (U8 i = 0; i < 10; i++)
    {  // чтение пзу датчика
       rom_rd_status = rom_rd_sens_data (); 
       if (rom_rd_status) break; 
       delay_ms (100);
    }
   

       if      (sens_type == HMC5883l) 
       {
           EXT_int_EDGE (L_TO_H);
           enable_interrupts (int_EXT);
           SETUP_TIMER_0 (T0_INTERNAL|T0_DIV_128);
           SET_TIMER0 (55770);
           enable_interrupts (int_TIMER0);
           
           HMC5883l_Init();
       }
       
       else if (sens_type == TLV493D)  
       {
         TLV493D_reset();
         status = TLV493D_init();
       }
  
    else
    {

       kx = 1.0;
       ky = 1.0;
       kz = 1.0;
    }
    
    return status;
}

U8 ch_to_int(char ch)
{
// преобразование сивмола в цифру
U8 dg=-1;                                                                        
 
 switch (ch)
   {
      case '0' : dg=0; break;
      case '1' : dg=1; break;
      case '2' : dg=2; break;
      case '3' : dg=3; break;
      case '4' : dg=4; break;
      case '5' : dg=5; break;
      case '6' : dg=6; break;
      case '7' : dg=7; break;
      case '8' : dg=8; break;
      case '9' : dg=9; break;
      default: dg = -1;
   }

   return dg;
}

char get_rx_ch (void)
{                                                     
// Get RX char
char rch;

   if (rd_ptr < wr_ptr) // буфер не пуст
   {
      rd_ptr++;                    // инкремент счетчика считаных байт
      rch = rx_buf[rd_ptr & 0x0F]; // сохр. элемента по индексу
   }
   else rch = 'x';   
   
   // запрет прерываний по UART на время сравнение указателей  
   // на счит. и запис. элементы массива
   disable_interrupts(INT_RDA);    
           
   if ((wr_ptr==rd_ptr) && (wr_ptr > 15)) // если буфер заполнен                                            
   {  
      wr_ptr=0;                                                                   
      rd_ptr=0;                                                       
   } 

enable_interrupts(INT_RDA);         // разрешение прерываний

return rch;
}

void main  ()
 {
// режим программатора закомментирован

///////////////////////////////////////////////////////////////////////////////  
   /// программатор ПЗУ

   //float kx = 1.058935361; // старые коэффициенты датчика № 2 
   //float ky = 1.20824295;
   //float kz = 1.031481481;
   
   //float kx = 1.041121495;   // старые коэффициенты датчика № 1
   //float ky = 1.141393443;
   //float kz = 1.023897059;
   
   //float kx = 1.092291928;   // коэффициенты датчика № 1 21.04
   //float ky = 1.170930426;
   //float kz = 1.042684161;
     
   float kx = 1;   // без коэффициентов
   float ky = 1;
   float kz = 1;
      
   //float kx = 1.0778792;   // коэффициенты датчика № 2 кал. вечер 21.04
   //float ky = 1.19226638;
   //float kz = 1.06812933;
   
   //float kx = 1.07537299;   // коэффициенты датчика № 1 кал. вечер 21.04
   //float ky = 1.173361522;
   //float kz = 1.061591431;
   
   //float kx = 1.0517;     // коэффициенты датчика № 2 кал. 28.12.16
   //float ky = 1.2266;
   //float kz = 1.0406;
   
   //float kx = 1.0747;     // коэффициенты датчика № 1 кал. 28.12.16
   //float ky = 1.1824;
   //float kz = 1.0650;
   
     
   U16 sens_type = TLV493D;
   U16 sens_num = 13;

   U16 ROM_Adr = 0x0000;
   U16 CRC_Wr;
   U16 CRC1 = 0;
   U16 CRC2 = 0; 

   TRB0 = 1;   // DRDY
   
   TRB3 = 0; 
   TRB4 = 0;
   TRB5 = 0;
   TRC0 = 0;
   TRC1 = 0;
   TRC2 = 0;
   TRC5 = 0;
 
   TRC3 = 1;
   TRC4 = 1;
   TRC6 = 0;                  // UART1 - TX
   TRC7 = 1;                  // UART1 - RX
   
   EXT_INT_EDGE(L_TO_H);
   enable_interrupts(INT_RDA);
   enable_interrupts(INT_EXT);
   //enable_interrupts(GLOBAL);

   LCDInit();
   LcdWelcome();
   LCDSetCursor(two);
   LCDMsg(" Запись в ПЗУ...");
//-----------------------------------------------------------------------------       
   rom_wr_byte(ROM_Adr,sens_type);     // тип датчика   0
   rom_wr_byte (++ROM_Adr, sens_num);  // № датчика     1
   rom_wr_byte (++ROM_Adr, coord_sys); // сис.координат 2
   rom_wr_float(++ROM_Adr,&kx);        // Kx            3-6 
   ROM_adr += 4;
   rom_wr_float(ROM_Adr,&ky);          // Ky            7-10
   ROM_adr += 4;
   rom_wr_float(ROM_Adr,&kz);          // Kz            11-14
   
   ROM_Adr += 4;
   CRC1 = rom_wr_CRC16(ROM_Adr,crc_buf_wr);
   crc_wr_index = 0;   
 //-----------------------------------------------------------------------------     
   sens_type = 0;
   sens_num  = 0;
   
   LCDclear();
   
   while(true){
   
   ROM_Adr = 0x0000;
   
   kx = 0;
   ky = 0;
   kz = 0;
   
    sens_type = rom_rd_byte (ROM_Adr); // тип датчика 0
    ROM_Adr++;
    sens_num = rom_rd_byte (ROM_Adr);  // № датчика 1
    ROM_Adr++;
    coord_sys = rom_rd_byte (ROM_Adr); // система координат 2
    ROM_Adr++;
    rom_rd_float (ROM_Adr,&kx); // Kx 3 - 6
    ROM_adr += 4;
    rom_rd_float (ROM_Adr,&ky); // Ky 7 - 10
    ROM_adr += 4;
    rom_rd_float (ROM_Adr,&kz); // Kz 11 - 14
    
    ROM_adr += 4;
    CRC1 = rom_rd_CRC16 (ROM_adr); // чтение сохраненной CRC
    CRC2 = CRC16 (crc_buf_rd, 14); // расчет CRC по считанным данным
   
   Lcdsetcursor(0x00);
   LCDMsg("kx=");
   LcdPutS16((S32)(kx*1000),5);
   Lcdsetcursor(0x40);
   LCDMsg("ky=");
   LcdPutS16((S32)(ky*1000),5);
   Lcdsetcursor(0x10);
   LCDMsg("kz=");
   LcdPutS16((S32)(kz*1000),5);
   
   //Printf("CRC1=%LX\n",CRC1);
   //Printf("CRC2=%LX\n",CRC2);
   
   for(U8 i =0; i < sizeof(crc_buf_wr); i++)
   {
      //Printf("CRC_buf_wr =%LX CRC_buf_rd=%LX\n",crc_buf_wr[i], crc_buf_rd[i]);
      Printf("__");
      Printf("CRC_buf_wr =%LX\n",crc_buf_wr[i]);
      
      delay_ms(500);
   }
   Printf("\n\r");
   Printf("\n\r");
   //Printf("CRC1=%LX\n",CRC1);
   crc_rd_index = 0;
   
   delay_ms(500);
   
   } // while
 } // main
///////////////////////////////////////////////////////////////////////////////  

/*
//=============================================================================

   /// режим измерений
   
    U8 TLV493D_status = 0;
    char rx_byte;       // байт принятый с ПК
    U8 rd_state = 0;    // машина состояний
    char coef_id = 0;   // идентификатор канала численного параметра с ПК
    U16 num_param = 0;  // численный параметр полученый с ПК
    
    TRB0 = 1; // DRDY
    TRB1 = 0;
    
    TRB3 = 0;
    TRB4 = 0;
    TRB5 = 0;
    TRC0 = 0;
    TRC1 = 0;
    TRC2 = 0;
    TRC5 = 0;
    TRC3 = 1;
    TRC4 = 1;
    TRC6 = 0; // UART1 - TX
    TRC7 = 1; // UART1 - RX

    LED = 1;
    
    LCDInit ();
    LCDWelcome ();
    detect_sensors();

    enable_interrupts (int_RDA);
    enable_interrupts (GLOBAL);
//-----------------------------------------------------------------------------   
    while (true)
    { 
       restart_wdt(); 
//-----------------------------------------------------------------------------   
       switch(sens_type) // анализ типа текущего датчика
       {
        case TLV493D:    // тип - 1.3 kGs
             TLV493D_status = TLV493D_rd_all(coord_sys); // режим штатного чтения
            
             if (TLV493D_status == 1)                    // датчик подключен, чтение успешно              
             {
               LCDSetCursor(four);
               LCDMsg(" r"); LCDPutU16(coord_sys, 1); // вывод на дисплей системы координат
               delay_ms(10);
             }
             
             else if    (TLV493D_status == 0)  // если статус не был прочитан 
             {
               NC_LCDMsg();
               ReInit_flag = 1;
             }
             
             else if(TLV493D_status == 2) // датчик появился после откл, инициализируем
             {
               while ( TLV493D_status == 2 ) TLV493D_status = detect_sensors(); 
               ReInit_flag = 0;
             }

        break;
        //===========   
        case HMC5883l:  // тип - 8 Gs
        
            if (int_fl)
             {    
                SensRdAll(); // режим штатного чтения
             }
     
            if (SensErr)
             {  // датчик не обнаружен
               NC_LCDMsg();
             }
 
            if (ReInit_flag)
             {  // событие переподключение датчика
                // при подкл. датчика выполняем инициализацию
                // для восстановления скорости измерений
                SensErr = 0;
                disable_interrupts (int_TIMER0);
                delay_ms (300);
                detect_sensors(); 
          
                ReInit_flag = 0;
                HMC5883l_Init();
                HMC5883l_Init();
                delay_ms (100);
                enable_interrupts (int_TIMER0);
            }
        //===========   
        break;
        //===========              
        default: NC_LCDMsg(); silent_detect_sensors(); break;
       }
//-----------------------------------------------------------------------------   
       if (!SB2) set_zero_fl = 1; // проверка нажатия УСТ. 0
//----------------------------------------------------------------------------- 
// обработка команд

       while(rd_ptr < wr_ptr) // буфер не пуст, получен байт 
        {
              U8 temp_buf;                                         
              rx_byte = get_rx_ch();  
              
              // вывод символа получения команды с ПК
              LCDSetCursor(four);
              LCDMsg("             *");

               switch(rd_state)  // конечный автомат состояний чтения команд
               {
               //-----
                  case 0:        // обработка однобайтных команд
                     switch(rx_byte)
                     {
                        case 'z':            // получена команда уст. 0
                           set_zero_fl = 1;  // выставляем флаг уст. 0
                           printf("ok\n\r"); // отсылка ответа на ПК
                           rd_state = 0;     // возврат в состояние анализа заголовка команды
                           break;
                           //=====
                        case 's':            // получена команда запроса id и системы координат
                           printf("r=");  printf("%01lu,",coord_sys);   // отсылка системы координат
                           printf("id="); printf("%02lu\n\r",sens_type); // отсылка id
                           rd_state = 0;     // возврат в состояние анализа заголовка команды
                           break;
                           //=====
                        case 'r':            // получена команда уст. системы координат
                           rd_state = 5;     // переход в состояние анализа команды 
                           break;
                           //=====                           
                        case 'k':            // получена команда запроса коэффициентов
                           printf("a"); printf("%04lu",(U16)(kx*1000));  // отсылка коэфф.
                           printf("b"); printf("%04lu",(U16)(ky*1000));
                           printf("c"); printf("%04lu\n\r",(U16)(kz*1000));
                           rd_state = 0;     // возврат в состояние анализа заголовка команды
                           break;
                           //=====
                        case 'a':            // получена команда уст. коэфф. а
                           rd_state = 1;     // переход в состояние чтения первого байта команды
                           coef_id = 'a';    // сохранение идентификатора параметра
                           break;
                           //=====
                        case 'b':            // получена команда уст. коэфф. b
                           rd_state = 1;     // переход в состояние чтения первого байта команды
                           coef_id = 'b';    // сохранение идентификатора параметра
                           break;
                           //=====
                        case 'c':            // получена команда уст. коэфф. c
                           rd_state = 1;     // переход в состояние чтения первого байта команды
                           coef_id = 'c';    // сохранение идентификатора параметра
                           break;
                           //=====                           
                           
                        default: 
                           printf("cmd error\n\r"); 
                           break;
                     }
                  break;
               //-----
               // анализ цифр переданных с параметром
               case 1: 
                  temp_buf = ch_to_int(rx_byte);
                  if(temp_buf == -1)   // проверка адекватности параметра                                                           
                  {        
                   rd_state = 0;                                                
                   printf("err p1\n\r");                                            
                   break;
                  }
                                                                        
                  num_param = 0;                                                                 
                  num_param += (U16) temp_buf*1000;                                                      
                  rd_state = 2;                                                             
               break;
               //-----
               case 2: 
                  temp_buf = ch_to_int(rx_byte);
                  if(temp_buf == -1)   // проверка адекватности параметра                                                              
                  {        
                   rd_state = 0;                                                
                   printf("err p2\n\r");                                            
                   break;
                  }                                                                                              
                  num_param += (U16) temp_buf*100;                                                      
                  rd_state = 3;                                                             
               break;
               //-----
               case 3: 
                  temp_buf = ch_to_int(rx_byte);
                  if(temp_buf == -1)   // проверка адекватности параметра                                                      
                  {        
                   rd_state = 0;                                                
                   printf("err p3\n\r");                                            
                   break;
                  }
                  num_param += (U16) temp_buf*10;                                                      
                  rd_state = 4;                                                             
               break;
               //-----
                case 4: 
                  temp_buf = ch_to_int(rx_byte);
                  if(temp_buf == -1)   // проверка адекватности параметра                                                           
                  {        
                   rd_state = 0;                                                
                   printf("err p4\n\r");                                            
                   break;
                  }
                  num_param += (U16) temp_buf;    
                  
                  // все 4 цифры параметра получены успешно
                  switch(coef_id) // сохраняем полученный коэф. в переменную
                  {
                     case 'a': 
                        kx = (float) num_param / 1000.0; 
                        if(kx == 0)  { kx = 1.0; num_param += 1000; } // защита от уст. коэф. = 0
                        break;
                     case 'b': 
                        ky = (float) num_param / 1000.0; 
                        if(ky == 0) { ky = 1.0; num_param += 1000; }  // защита от уст. коэф. = 0
                        break;
                     case 'c': 
                        kz = (float) num_param / 1000.0; 
                        if(kz == 0) { kz = 1.0; num_param += 1000; }// защита от уст. коэф. = 0
                        break;
                     default: break;
                  }
                  Printf("%c", coef_id);           // отправка id коэффициента
                  printf("%04lu\n\r",num_param);   // отправка коэффициента
                  
                  // вывод сообщения о записи в пзу
                  LCDclear();
                  LCDSetCursor(two);
                  LCDMsg(" Запись в ПЗУ...");
                  update_rom_data();         // запись в пзу
                  rd_state = 0;              // возврат в состояние анализа заголовка команды                                                            
               break; 
               //-----
               case 5: 
                  temp_buf = ch_to_int(rx_byte);
                  if((temp_buf == -1) | (temp_buf > 2))  // проверка адекватности параметра                                                         
                  {        
                   rd_state = 0;             // возврат в состояние анализа заголовка команды                                               
                   printf("err p\n\r");                              
                   break;
                  }
                  coord_sys = (U16)temp_buf;      // обновление системы координат  
                  printf("r=");
                  printf("%01ld\n\r",coord_sys);   // отправка нового значения системы координат
                  // вывод сообщения о записи в пзу
                  LCDclear();
                  LCDSetCursor(two);
                  LCDMsg(" Запись в ПЗУ...");
                  update_rom_data();              // запись в пзу
                  rd_state = 0;                   // возврат в состояние анализа заголовка команды
                  break;
               //-----
               default: break;
               
               } // switch
               
               // очистка символа получения команды с ПК
              LCDSetCursor(four);
              delay_ms(75);
              LCDMsg("              ");
            }  // while
            
    } // while
 }  // main
//=============================================================================

*/
