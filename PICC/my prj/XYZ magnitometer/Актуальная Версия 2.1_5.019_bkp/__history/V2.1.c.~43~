/******************************************************/
/* Software V2.3 for magnetic induction's tester V2.1 */
/******************************************************/

#include <V2.1.h>
#include <stdio.h>
#include <LCD for V2.1.c>

unsigned int1 int_fl = 0,zero_set1=0, LCDClear_Fl = 0;
unsigned int1 SensErr = 0;
unsigned int1 ReInit_flag = 0;
static U8 ff1=0;
unsigned int1 fl2=0, menufl1 =0, menufl2 =0, menufl3 =0, menufl4 =1; //????? ??????? ??????
static U8 TMR0fl=0, MenuItemNum=0;                  
static U8 RXd_buf=0;

char  ConfigRegA = 0x00, ConfigRegB = 0x01, ModeReg = 0x02, xMSB = 0x03, xLSB = 0x04, // ?????? ????????? ??????? ??
      zMSB = 0x05, zLSB = 0x06,yMSB = 0x07,yLSB = 0x08,StatReg = 0x09, idRegA = 0x10,
      idRegB = 0x11, idRegC = 0x12, EEprom_adr = 0xA0;
      
signed int16 SumX=0; 
signed int16 SumY=0; 
signed int16 SumZ=0;
       
signed int16 SumX0=0; 
signed int16 SumY0=0;
signed int16 SumZ0=0;

signed int32 average_Xg=0; 
signed int32 average_Yg=0;
signed int32 average_Zg=0;
             
unsigned int16 Xh =0;   
unsigned int8 Xl = 0;
unsigned int16 Yh =0;
unsigned int8 Yl = 0;
unsigned int16 Zh =0;
unsigned int8 Zl = 0;

float Xd = 0;
float Yd = 0;
float Zd = 0;

float kx_rd = 1.0;
float ky_rd = 1.0;
float kz_rd = 1.0;

U8 crc_buf_wr[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
U8 crc_buf_rd[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
U8 crc_wr_index = 0;
U8 crc_rd_index = 0;
U8 my_arr[4];  

U8 aver_count = 0;

U16 sens_type;
U16 sens_num;

U16 ROM_Adr = 0x0000;
   
U16 CRC_Wr;
 U16 CRC1 = 0;
U16 CRC2 = 0; 

S32 average_X, average_Y, average_Z;

//****************** Sensor func ************************************
static void SensWrData(unsigned int8 Adr, Data){  
   i2c_start();
   i2c_write(0x3C);
                        // The default (factory) HMC5883 7-bit slave address 
                        // is 0x3C for write operations, or 0x3D for read operations.
   i2c_write(Adr);
   i2c_write(Data);
   i2c_stop();
   }
   
static char SensRdData(char Adr){   
   char Data = 0;
   
   i2c_start();  
   i2c_write(0x3C); // The default (factory) HMC5883 7-bit slave address 
                    // is 0x3C for write operations, or 0x3D for read operations.
   i2c_write(Adr); // pointer 
 
   i2c_stop();
   delay_us(10);
    i2c_start();
   i2c_write(0x3D); //i2c Read
   delay_us(10);
   Data = i2c_read();
   delay_us(10);
   Data = i2c_read();
   delay_us(10);
   i2c_stop();
   
   return Data;
   }
    
static void SensInit (){  
   //SensWrData(ConfigRegA,0x14); //  F = 30 Hz/1
   SensWrData(ConfigRegA,0x18); //  F = 75 Hz/1
   SensWrData(ConfigRegB,0xE0); // range = +/- 8.1 Ga
   SensWrData(ModeReg,0x00); // continuous measurment mode
   //SensWrData(ModeReg,0x01); // single measurment mode 
   }

static signed int16 SelfCal(){  
   unsigned int16 Xh = 0;
   unsigned int8 Xl = 0;
   unsigned int16 Yh = 0;
   unsigned int8 Yl = 0;
   unsigned int16 Zh = 0;
   unsigned int8 Zl = 0;

     SensInit();
     delay_us(10);
   if (int_fl){        
      i2c_start();  
      i2c_write(0x3C); // The default (factory) HMC5883 7-bit slave address 
                    // is 0x3C for write operations, or 0x3D for read operations.
      i2c_write(0x03); // pointer 
      i2c_stop();
      delay_us(10);
   
      i2c_start();
      i2c_write(0x3D); //i2c Read
 
      Xh = i2c_read();   // X MSB
      Xl = i2c_read();   // X LSB
      SumX = (Xh<<8)|Xl;   //?????????????? ???????? ????????. ??? ?
      Yh = i2c_read();  // Y MSB
      Yl = i2c_read();  // Y LSB
      SumY = (Yh<<8)|Yl;   //?????????????? ???????? ????????. ??? Y
      Zh = i2c_read();  // Z MSB
      Zl = i2c_read();  // Z LSB
      SumZ = (Zh<<8)|Zl;  //?????????????? ???????? ????????. ??? Z
      i2c_read();    //if adress pointer = 08, adress pointer = 03
      i2c_stop();
      }
        
   delay_us(10);
  // SensWrData(ConfigRegA,0x00); // selftest end        
        //Printf("X= %Ld ",SumX);
    //Printf("Y= %Ld ",SumY);
    //Printf("Z= %Ld\n\r",SumZ);
    //restart_wdt();
   return 1;
   }

static void SensRdAll(){
   if (fl2){      // утс. 0
               
      LCDClear();
      Lcdsetcursor(0);
      LcdMsg(" ”становка нул€ ");    
      SumX0=SumX;
      SumY0=SumY;
      SumZ0=SumZ;  
      delay_ms(1000);
      fl2=0;
   }     
   
   average_Zg = (average_Zg/10)-SumZ0;
   average_Yg = (average_Yg/10)-SumY0;
   average_Xg = (average_Xg/10)-SumX0;
   
   //y = (8.1*x)/2048; 8.1/2048 = 0.0039550781252
   
   Xd = average_Xg * 0.0039550781252;
   Xd *= kx_rd;      // умножение на поправочный коэффициент из ѕ«”
   Yd = average_Yg * 0.0039550781252;
   Yd *= ky_rd;      // умножение на поправочный коэффициент из ѕ«”
   Zd = average_Zg * 0.0039550781252;
   Zd *= kz_rd;      // умножение на поправочный коэффициент из ѕ«”
   
   // «начени€ пол€ Bx, By, Bz вывод€тс€ согласно пожеланию заказчика //
   Printf("x%05Ld\n",average_Zg);
   Printf("y%05Ld\n",average_Yg);
   Printf("z%05Ld\n",average_Xg);

   LcdSetCursor(one);
   LcdMsg("Bx = ");
   LcdPutS16(Zd*1000,4);
   LcdMsg(" √с.   ");
   LcdSetCursor(two);
   LcdMsg("By = ");
   LcdPutS16(Yd*1000,4);
   LcdMsg(" √с.   ");
   LcdSetCursor(three);
   LcdMsg("Bz = ");
   LcdPutS16(Xd*1000,4);
   LcdMsg(" √с.   ");

   int_fl = false;
      
}

//****************** Sensor func ************************************


//------------------ EEPROM func ------------------------------------ 

 U16 CRC16(U8* data_p, U8 length)
 {
    // расчет контрольной суммы
    // вз€т из интернета
    
    U8 x;
    U16 crc = 0xFFFF;

    while (length--){
        x = crc >> 8 ^ *data_p++;
        x ^= x>>4;
        crc = (crc << 8) ^ ((U16)(x << 12)) ^ ((U16)(x <<5)) ^ ((U16)x);
    }
    return crc;
}

 static void rom_wr_byte(U16 addr, U8 dataByte)
   {
      /// записывает байт данных по 16-бит. адресу
      
      U8 addr_MSB = 0;
      U8 addr_LSB = 0; 
      
      addr_MSB = (addr >> 8);
      addr_LSB = addr;
      
      i2c_start();
      i2c_write(EEprom_adr | 0); // запись

   // A read operation is initiated if this bit is high 
   // and a write operation is initiated if this bit is low.
                        
      i2c_write(addr_MSB);
      i2c_write(addr_LSB);
      i2c_write(dataByte);
      i2c_stop();
      delay_ms(15); // t записи в rom - 10 мс
      crc_buf_wr[crc_wr_index] = dataByte;
      crc_wr_index++;
   }

 static U8 rom_rd_byte(U16 addr)
   {
      /// чтение байта данных по 16-бит. адресу
      
      U8 rd_data_byte = 0;
      U8 addr_MSB = 0;        // старший байт адреса
      U8 addr_LSB = 0;        // младший байт адреса
      
      addr_MSB = (addr >> 8); // заполнение ст. байта из 2-байт. адреса
      addr_LSB = addr;        // заполнение мл. байта из 2-байт. адреса
      
      i2c_start();
      i2c_write(EEprom_adr | 0); // команда чтени€
   // A read operation is initiated if this bit is high 
   // and a write operation is initiated if this bit is low.
                        
      i2c_write(addr_MSB);    // выдача на линию ст. байта адреса
      i2c_write(addr_LSB);    // выдача на линию мл. байта адреса
      i2c_start();     
      i2c_write(EEprom_adr | 1); // чтение
      rd_data_byte = i2c_read(); 
      i2c_write(0xff);        // без этого не работает 0_0
      i2c_stop();
      crc_buf_rd[crc_rd_index] = rd_data_byte;
      crc_rd_index++;
      
      return rd_data_byte;
   }
   
 void rom_rd_float(U16 ee_addr, void *float_data_ptr)
 {
     /// чтение 4-байт. переменной типа float из rom 
         
     // передаетс€ указатель на заранее инициализир. перемен.
     // типа float, происходит побайтное считывание из rom и наполнение 
     // ими адреса переданного через указатель
     
     U8 buf; 
     U8 *dataByte_ptr = float_data_ptr; // сохран€ем указатель (адрес)
                                        // переменной дл€ чтени€
     U8 k = 0;
     U8 i = sizeof(float);
       
     //Lcdsetcursor(0x50);
     //lcdPutCh('b');
     
     while( k < i) 
     {
        //*dataByte_ptr = my_arr[k];
        buf = rom_rd_byte(ee_addr); // чтение байта из пам€ти 
        *dataByte_ptr = buf;        // сох. этого байта по адресу конкретной переменной
        //LcdPutU16(buf,3);
        //lcdPutCh('_'); 
        dataByte_ptr++;             // инкремент адреса байта переменной 
        ee_addr++;                  // инкремент адреса rom
        k++;                        // инкремент итератора цикла чтени€
     }
     //LCDMsg("adr=");
     //LcdPutU16((U32)ee_addr*1000,4);
     //delay_ms(1000);
     //Lcdsetcursor(0x40);
     

     
     //LCDMsg("CRC_rd=");
     //LcdPutU16((U32)CRC_rd,5);
     //Lcdsetcursor(0x50);
     //LCDMsg("CRC_LSB=");
     //LcdPutU16((U32)CRC_rd_LSB*100,5);
 }

 void rom_wr_float(U16 ee_addr, void *float_data_ptr)
 {
     /// запись 4-байт. переменной типа float в rom 
     
     // передаетс€ указатель на перемен. типа float дл€ ее сохранени€.  
     // происходит побайтна€ запись этой переменной в rom
     
     U8 *dataByte_ptr = float_data_ptr; // сохран€ем указатель (адрес)
                                        // переменной дл€ записи
     U8 k = 0;
     U8 i = sizeof(float);              // сохранение размера float в байтах - 4

     //Lcdsetcursor(0);
     //lcdPutCh('a');
     
     while(k < i) 
     {
         //my_arr[k] = *dataByte_ptr;
         //LcdPutU16(my_arr[k],3);
         //lcdPutCh('_'); 
         rom_wr_byte(ee_addr, *dataByte_ptr);// запись байта с конкретн. адресу в rom
         dataByte_ptr++;                     // инкремент адреса байта переменной
         ee_addr++;                          // инкремент адреса rom
         k++;                                // инкремент итератора цикла записи
     }
     //Lcdsetcursor(0x00);
     //LCDMsg("CRC_wr=");
     //LcdPutU16((U32)CRC_Wr,5); 
 }
    
 static U16 rom_wr_CRC16(ee_addr, U8 crc_buf)
{
   U16 CRC_Wr;
   
   CRC_Wr = CRC16(crc_buf,14);    // расчет CRC16
     
   rom_wr_byte(ee_addr, (CRC_Wr >> 8)); // запись ст. байта CRC в rom  
   ee_addr++;                           // инкремент адреса
   rom_wr_byte(ee_addr, (U8)CRC_Wr);        // запись мл. байта CRC в rom
   
   return CRC_Wr; 
}

 static U16 rom_rd_CRC16(ee_addr)
{
     U8 CRC_rd_MSB;                     // ст. байт CRC дл€ записи
     U8 CRC_rd_LSB;                     // мл. байт CRC дл€ записи
     U16 CRC_rd;                        // 16-бит. CRC 
     
     CRC_rd_MSB = rom_rd_byte(ee_addr); // чтение ст. байта CRC из rom
     ee_addr++;
     CRC_rd_LSB = rom_rd_byte(ee_addr); // чтение мл. байта CRC из rom
     CRC_rd = CRC_rd_MSB << 8;          // восстановление CRC 
     CRC_rd |= CRC_rd_LSB;              // из прочитанных байт
   
   return CRC_rd; 
}

 static void rom_rd_sens_data(void)
{
   LCDclear();
   LCDSetCursor(two);
   LCDMsg(" „тение ѕ«”...");
   
   sens_type = rom_rd_byte(ROM_Adr);     // тип датчика   0
   ROM_Adr++;
   sens_num  = rom_rd_byte(ROM_Adr);     // є датчика     1
   ROM_Adr++;
   rom_rd_float(ROM_Adr,&kx_rd);         // Kx            2-5 
   ROM_adr += 4;
   rom_rd_float(ROM_Adr,&ky_rd);         // Ky            6-9
   ROM_adr += 4;
   rom_rd_float(ROM_Adr,&kz_rd);         // Kz            10-13
   
   ROM_adr += 4;
   CRC1 = rom_rd_CRC16(ROM_adr);         // чтение сохраненной CRC
   CRC2 = CRC16(crc_buf_rd,14);          // расчет CRC по считанным данным
   crc_rd_index = 0;
   ROM_adr = 0x0000;
   
   LCDSetCursor(0x10);
   if(CRC1 == CRC2) 
   {
      LCDMsg("      OK!");   
      delay_ms(1000);
      LCDclear();
      
      LCDSetCursor(0x00);
      LCDMsg("  “ип датчика:");
      LCDSetCursor(0x40);
      if(sens_type == 30)
          LCDMsg("   3 - осевой");
      else
          LCDMsg("   1-осевой");
          
      LCDSetCursor(0x50);
      LCDMsg("Ќомер прибора: ");
      LcdPutU16((U16)sens_num*1000,4);
      
      delay_ms(2000);
      LCDclear();
      
      Lcdsetcursor(0x00);
      LCDMsg(" оэффициенты:");
      Lcdsetcursor(0x40);
      LCDMsg("Kx = ");
      LcdPutS16((S32)(kx_rd*1000),5);
      Lcdsetcursor(0x10);
      LCDMsg("Ky = ");
      LcdPutS16((S32)(ky_rd*1000),5);
      Lcdsetcursor(0x50);
      LCDMsg("Kz = ");
      LcdPutS16((S32)(kz_rd*1000),5);
      
      delay_ms(3000);
      LCDclear();
   }
   else 
   {
      LCDMsg("   ќшибка!");
      kx_rd = 1.0;               // сброс значений по умолчанию 
      ky_rd = 1.0;                     // тк произошел сбой контр. суммы
      kz_rd = 1.0;
      delay_ms(2000);
   }
}

//------------------ EEPROM func ------------------------------------


//================== Interrupts  ====================================
#INT_EXT 
Void int0(void){

   if (SensErr)
   {
      SensErr = 0;
      ReInit_flag = 1;
   }
   
   else
   {
   
   i2c_start();  
   i2c_write(0x3C); // The default (factory) HMC5883 7-bit slave address 
                       // is 0x3C for write operations, or 0x3D for read operations.
   i2c_write(0x03); // pointer 
   i2c_stop();
      
   i2c_start();
   i2c_write(0x3D); //i2c Read
      
   Xh = i2c_read();   // X MSB
   Xl = i2c_read();   // X LSB
   SumX = (Xh<<8)|Xl;   //?????????????? ???????? ????????. ??? ?                                   
   Yh = i2c_read();  // Y MSB
   Yl = i2c_read();  // Y LSB
   SumY = (Yh<<8)|Yl;   //?????????????? ???????? ????????. ??? Y
   Zh = i2c_read();  // Z MSB
   Zl = i2c_read();  // Z LSB
   SumZ = (Zh<<8)|Zl;  //?????????????? ???????? ????????. ??? Z  
   i2c_stop();
   
   average_X += SumX;
   average_Y += SumY;
   average_Z += SumZ;
   aver_count ++;
   
   if (aver_count == 10) 
      {
        int_fl = true;
        aver_count = 0;
        
        average_Xg = average_X;
        average_Yg = average_Y;
        average_Zg = average_Z;
        
        average_X = 0;
        average_Y = 0;
        average_Z = 0;     
      }
   
   SensWrData(ConfigRegB,0xE0); // range = +/- 8.1 Gs
   SensWrData(ModeReg,0x00);  // continuous measurment
   }
   SET_TIMER0(55770);
   clear_interrupt(INT_EXT);
   }
  
#INT_RDA
void UART_RXd_isr(void){

RXd_buf = getc();          // ?????? ??????? ??????....
                           // ??? ??????, ????????? ?? ??????? ?? ???????????
if (RXd_buf == 'z')        // ???????????? ?????????? ???????? ???. 0... FTDI ???? ????? ??? ????. ????????? ??
{
menufl1 = 0;
menufl2 = 0;
menufl3 = 0;
fl2=1;

zero_set1 = 1;
}

clear_interrupt(INT_RDA);  // ????? ????? ??????????
}

#INT_TIMER0 
void INT_TIMER0_isr(void){
   SET_TIMER0(55770);
   clear_interrupt(INT_TIMER0);
   SensErr = 1;
}

//================== Interrupts  ==================================== 
void main() {

   // режим измерений
   
   TRB0 = 1;   // DRDY
   TRB1 = 0;
   
   TRB3 = 0;
   TRB4 = 0;
   TRB5 = 0;
   TRC0 = 0;
   TRC1 = 0;
   TRC2 = 0;
   TRC5 = 0;
 
   TRC3 = 1;
   TRC4 = 1;
   TRC6 = 0;                  // UART1 - TX
   TRC7 = 1;                  // UART1 - RX

   EXT_INT_EDGE(L_TO_H);
   enable_interrupts(INT_RDA);
   enable_interrupts(INT_EXT);

   SETUP_TIMER_0(T0_INTERNAL|T0_DIV_128);
   SET_TIMER0(55770);
   enable_interrupts(GLOBAL);
   LED = 1;
   LCDInit();  
   LcdWelcome();
      
   rom_rd_sens_data();
   
   /*
   LCDSetCursor(two);
   LCDMsg(" „тение ѕ«”...");
   
   sens_type = rom_rd_byte(ROM_Adr);     // тип датчика   0
   ROM_Adr++;
   sens_num  = rom_rd_byte(ROM_Adr);     // є датчика     1
   ROM_Adr++;
   rom_rd_float(ROM_Adr,&kx_rd);         // Kx            2-5 
   ROM_adr += 4;
   rom_rd_float(ROM_Adr,&ky_rd);         // Ky            6-9
   ROM_adr += 4;
   rom_rd_float(ROM_Adr,&kz_rd);         // Kz            10-13
   
   ROM_adr += 4;
   CRC1 = rom_rd_CRC16(ROM_adr);         // чтение сохраненной CRC
   CRC2 = CRC16(crc_buf_rd,14);          // расчет CRC по считанным данным
   crc_rd_index = 0;
   ROM_adr = 0x0000;
   
   LCDSetCursor(0x10);
   if(CRC1 == CRC2) 
   {
      LCDMsg("      OK!");   
      delay_ms(1000);
      LCDclear();
      
      LCDSetCursor(0x10);
      LCDMsg("“ип:");
      if(sens_type == 30)
          LCDMsg("3 - Ax.");
      else
          LCDMsg("1 - Ax.");
          
      LCDSetCursor(0x40);
      LCDMsg("N:");
      LcdPutU16((U16)sens_num*1000,4);
      
      delay_ms(2000);
      LCDclear();
      
      Lcdsetcursor(0x00);
      LCDMsg(" оэффициенты:");
      Lcdsetcursor(0x40);
      LCDMsg("kx=");
      LcdPutS16((S32)(kx_rd*1000),5);
      Lcdsetcursor(0x10);
      LCDMsg("ky=");
      LcdPutS16((S32)(ky_rd*1000),5);
      Lcdsetcursor(0x50);
      LCDMsg("kz=");
      LcdPutS16((S32)(kz_rd*1000),5);
      
      delay_ms(3000);
      LCDclear();
   }
   else 
   {
      LCDMsg("   ќшибка!");
      kx_rd = 1.0;               // сброс значений по умолчанию 
      ky_rd = 1.0;                     // тк произошел сбой контр. суммы
      kz_rd = 1.0;
      delay_ms(2000);
   }
   */
   SensInit();
   delay_ms(20);
   enable_interrupts(INT_TIMER0);
   
   
   while(true)
   {
   
      if (int_fl)
         SensRdAll();
         
      if (SensErr)
      {
         LCDSetCursor(one);
         LCDMsg("     ƒј“„»      ");
         LCDSetCursor(two);
         LCDMsg("       Ќ≈       ");
         LCDSetCursor(three);
         LCDMsg("   ѕќƒ Ћё„≈Ќ!   ");
         LCDSetCursor(four);
         LCDMsg("                ");
      }
      
      if (ReInit_flag)
      {   // при подкл. датчика выполн€ем инициализацию
          // дл€ восстановлени€ скорости измерений
      
         //Printf("e");
         
         ReInit_flag = 0;
         delay_ms(50);
         rom_rd_sens_data();
         //delay_ms(25);
         SensInit();
         
      }
      
      if (!SB2) fl2 = 1;
   }   
}


