CCS PCD C Compiler, Version 4.140, 5967               05-фев-15 15:54

               Filename:   D:\work\Projects\PICC\my prj\КЗ виток\main.lst

               ROM used:   7760 bytes (9%)
                           Largest free fragment is 57776
               RAM used:   205 (3%) at main() level
                           306 (4%) worst case
               Stack size: 128

*
00000:  GOTO    195C
*
0001A:  DATA    6E,04,00
*
0003A:  DATA    18,04,00
.................... #include <main.h> 
.................... #include <24HJ128GP506.h> 
.................... //////// Standard Header file for the PIC24HJ128GP506 device //////////////// 
.................... #device PIC24HJ128GP506 
.................... #list 
....................  
....................  
.................... //#FUSES PROTECT_HIGH            //General Segment Code Protect High Security 
.................... #FUSES WRTB                      //Boot block write protected 
.................... #FUSES CKSFSM                    //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES WDT                       //Watch Dog Timer 
.................... #FUSES WPOSTS14                  //Watch Dog Timer PreScalar 1:8192 
.................... #FUSES PR_PLL                    //Primary Oscillator with PLL 
.................... #FUSES HS                        //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOWRT                     //Program memory not write protected 
.................... #use delay(clock=80M) 
*
00522:  CP0     W0
00524:  BTSC.B  42.1
00526:  BRA     538
00528:  REPEAT  #1C3B
0052A:  NOP     
0052C:  REPEAT  #3FFE
0052E:  NOP     
00530:  REPEAT  #3FFE
00532:  NOP     
00534:  DEC     W0,W0
00536:  BRA     NZ,528
00538:  RETURN  
....................  
.................... #WORD PLLFBD=0x0746 // osc PLL div reg 
.................... #WORD U2BRG=0x0238 
.................... #WORD U2MODE=0x0230 
....................  
.................... #WORD CLKDIV=0x0744  // osc con reg 
.................... #BIT PLLPOST1=CLKDIV.7 
.................... #BIT PLLPOST0=CLKDIV.6 
.................... #BIT PLLPRE4=CLKDIV.4 
.................... #BIT PLLPRE3=CLKDIV.3 
.................... #BIT PLLPRE2=CLKDIV.2 
.................... #BIT PLLPRE1=CLKDIV.1 
.................... #BIT PLLPRE0=CLKDIV.0 
....................  
.................... #WORD LATA=0x02C4  
.................... #WORD LATB=0x02CA 
.................... #WORD LATD=0x02D6 
.................... #WORD LATF=0x02E2 
.................... #WORD LATG=0x02E8   
.................... #WORD LATC=0x02D0 
....................  
.................... #use spi(spi2, FORCE_HW) 
.................... #use standard_io(B)//(B_outputs=PIN_B1, PIN_B2) 
....................  
.................... #define STATUS 0x00     // ADC1256 Register map 
.................... #define MUX 0x01  
.................... #define ADCON 0x02 
.................... #define DRATE 0x03 
.................... #define IO 0x04 
.................... #define OFCO 0x05 
.................... #define OFC1 0x06 
.................... #define OFC2 0x07 
.................... #define FSCO 0x08 
.................... #define FSC1 0x09 
.................... #define FSC2 0x0A 
....................  
.................... #define uV 1000000 //basic 
.................... //#define uV 10000000 //basic 
.................... #define mV 1000 
....................  
.................... #WORD PORTB=0x02C8 
.................... #WORD TRISB=0x02C6 
.................... #BIT  TRB0=TRISB.0 
.................... #BIT  TRB1=TRISB.1 
.................... #BIT  CN1_TRIS=TRISB.5 
.................... #BIT  CN2_TRIS=TRISB.4 
.................... #BIT  CN4_TRIS=TRISB.3 
.................... #BIT  CN3_TRIS=TRISB.2 
.................... #BIT  CN1=PORTB.5 
.................... #BIT  CN4=PORTB.3 
.................... #BIT  CN2=PORTB.4 
.................... #BIT  CN3=PORTB.2 
.................... #BIT  XPORT_RST_n=TRISB.15 
.................... #BIT  Status_LED_TRIS=TRISB.13 
.................... #BIT  TRB14=TRISB.14 
.................... #BIT  XPORT_RST_TRIS=TRISB.15 
.................... #BIT  RB1=LATB.1 
.................... #BIT  RB0=LATB.0 
.................... #BIT  Status_LED=LATB.13 
....................  
.................... #WORD PORTC=0x02CE 
.................... #WORD TRISC=0x02CC 
.................... //#BIT RC13=LATC.13 
.................... //#BIT RC14=LATC.14 
.................... #BIT RC13=PORTC.13 
.................... #BIT RC14=PORTC.14 
.................... #BIT  TRC13=TRISC.13 
.................... #BIT  TRC14=TRISC.14 
.................... #BIT  TRC1=TRISC.1 
.................... #BIT  TRC2=TRISC.2 
.................... #BIT  TRC4=TRISC.4 
.................... //_______________________________________ 
.................... #WORD PORTD=0x02D4 
.................... #WORD TRISD=0x02D2 
.................... #WORD ODCD=0x06D2 
.................... #BIT  TRD0=TRISD.0 
.................... //#BIT  TRD1=TRISD.1 // ADC !DRDY описан ниже 
.................... //#BIT  TRD2=TRISD.2 
.................... //#BIT  TRD3=TRISD.3 
.................... #BIT  TRD4=TRISD.4 
.................... #BIT  TRD5=TRISD.5 
.................... #BIT  TRD6=TRISD.6 
.................... #BIT  TRD7=TRISD.7 
.................... #BIT  TRD8=TRISD.8 
.................... #BIT  TRD9=TRISD.9 
.................... #BIT  TRD10=TRISD.10 
.................... #BIT  TRD11=TRISD.11 
....................  
.................... #BIT  RD0=LATD.0 
.................... //#BIT  RD1=LATD.1 // ADC !DRDY описан ниже 
.................... //#BIT  RD2=LATD.2 
.................... //#BIT  RD3=LATD.3 
.................... #BIT  RD4=LATD.4 
.................... #BIT  RD5=LATD.5 
.................... #BIT  RD6=LATD.6 
.................... #BIT  RD7=LATD.7 
.................... #BIT  RD8=LATD.8 
.................... #BIT  RD9=LATD.9 
.................... #BIT  RD10=LATD.10 
.................... #BIT  RD11=LATD.11 
.................... //_________________________________________________ 
.................... #WORD PORTF=0x02E0 
.................... #WORD TRISF=0x02DE 
.................... #BIT  UART2_RX_TRIS=TRISF.4 
.................... #BIT  UART2_TX_TRIS=TRISF.5 
....................  
.................... #WORD PORTG=0x02E6 
.................... #WORD TRISG=0x02E4 
.................... #BIT RG0=LATG.0 
.................... #BIT RG1=LATG.1 
.................... #BIT LCD_RW=LATG.12 
.................... #BIT LCD_RS=LATG.13 
.................... #BIT LCD_E=LATG.14 
.................... #BIT RG15=LATG.15 
.................... #BIT SCK2=LATG.6 // SPI2 pins 
.................... #BIT SDI2=LATG.7 
.................... #BIT SDO2=LATG.8 
.................... //#BIT SS2=LATG.9 
.................... #BIT SCK2_TRIS=TRISG.6 // SPI2 tris 
.................... #BIT SDI2_TRIS=TRISG.7 
.................... #BIT SDO2_TRIS=TRISG.8 
.................... #BIT TRG0=TRISG.0 
.................... #BIT TRG1=TRISG.1 
.................... #BIT LCD_RW_TRIS=TRISG.12 
.................... #BIT LCD_RS_TRIS=TRISG.13 
.................... #BIT LCD_E_TRIS=TRISG.14 
....................  
.................... //#BIT SS2_TRIS=TRISG.9 
....................  
.................... #define ADC_Dout SDI2 //???? Din ?? 
.................... #define ADC_Din SDO2  //???? Dout ?? 
....................  
.................... #BIT  ADC_RESET_TRIS=TRISD.3 
.................... #BIT  ADC_RESET=LATD.3 
.................... #BIT  ADC_SYNC_TRIS=TRISD.2 
.................... #BIT  ADC_SYNC=LATD.2 
.................... #BIT  ADC_CS_TRIS=TRISG.9 
.................... #BIT  ADC_CS = LATG.9 
.................... #BIT  ADC_DRDY_TRIS = LATD.1 
.................... #BIT  ADC_DRDY = PORTD.1 
....................  
.................... #define FCY      40000000 
.................... #define BAUDRATE 9600                 
.................... #define BRGVAL   ((FCY/BAUDRATE)/16)-1 
....................  
.................... //#define Flash_adr1 0xAD00 // ADC sps variable location 
.................... //#define Flash_adr2 0xAE00 // average variable location 
....................  
.................... //#ORG Flash_adr1, Flash_adr2 // зарезервировал ячейки флэш для сохр. параметров 
....................  
.................... #define CK_FLASH_END       (getenv("PROGRAM_MEMORY")-1)       
.................... #define CK_FLASH_PAGE_SIZE (getenv("FLASH_ERASE_SIZE")/2)  
.................... #define CK_NUM_PAGES (CK_FLASH_END/CK_FLASH_PAGE_SIZE)  
....................  
.................... #define CK_USER_PAGE (CK_FLASH_PAGE_SIZE*(CK_NUM_PAGES-1))  
....................  
.................... #org CK_USER_PAGE,CK_FLASH_END {}  
....................  
....................  
....................  
....................    typedef unsigned int16 U16; 
....................    typedef unsigned int8 U8; 
....................    typedef unsigned int32 U32; 
....................    typedef signed int32 S32; 
....................    typedef signed int16 S16; 
....................    typedef signed int8 S8; 
....................  
....................  
.................... #use rs232(UART2,baud=9600,parity=N,bits=8) 
....................  
....................    static S32 ADC_RByte1=0; 
....................    static S32 ADC_RByte2=0; 
....................    static S32 ADC_RByte3=0; 
....................    static S32 ADC_RByte_Sum=0; 
....................    static S32 ADCresult=0; 
....................    static float Vin;                           
....................    static U8 PGA; 
....................    //static float Vref=2.5; 
....................    static U8 Sps_buf,Global_Ch_Number=0; 
....................    static S16 ADCaddCoef; 
....................    static float ADCmulCoef; 
....................    float Final_T_in_K = 0; 
....................    U8 ostatok_int_dec,ostatok_int_sot  = 0; 
....................    U8 LCD_num_symb = 1;             // по умолчанию одна цифра для вывода Т на ЛСД 
....................    U8 flash_wr_data [] = {0,0,0,0}; // заготовка массива для записи во флэш 
....................    U8 Aver_Wr = 0; 
....................    U8 Sps_Wr = 0; 
....................    U8 CRC_Wr = 0; 
....................     
....................    U8 menu_item = 0; 
....................    volatile S8 menu_sel = 0; 
....................     
....................    U8 menu_fl = 0; 
....................    int1 meas_stop_fl = 0; 
....................    int1 LCD_clear_fl = 1; 
....................    int1 reset_fl = 0;    // флаг сброса системы 
....................     
....................    U8 NumAver = 1;       // размер усреднения 
....................    U8 ADC_sps_var = 1;   // переменная усреднения данных АЦП  
....................    U8 CRC1=0xFF,CRC2=0xFF, CRC_buf;   // константы EEPROM CRC 
....................    U8 flash_rd_data[4]; // заготовка массива для чтения из флэш 
....................    U32 temp  = 0;        // промежуточный буфер для вычислений T 
....................    S32 ADC_data  = 0;    // отсчеты АЦП 
....................       
.................... static unsigned int8 buf; // lcd buf 
.................... #BIT buf4=buf.4  
.................... #BIT buf5=buf.5 
.................... #BIT buf6=buf.6 
.................... #BIT buf7=buf.7 
....................     
....................  
.................... #include <LCD_16X4_Termo3.h> 
.................... /* 
.................... #define 'Б' 0xA0 
.................... #define 'Г' 0xA1 
.................... #define 'Ё' 0xA2 
.................... #define 'Ж' 0xA3 
.................... #define 'З' 0xA4 
.................... #define 'И' 0xA5 
.................... #define 'Й' 0xA6 
.................... #define 'Л' 0xA7 
.................... #define 'П' 0xA8 
.................... #define 'У' 0xA9 
.................... #define 'Ф' 0xAA 
.................... #define 'Ч' 0xAB 
.................... #define 'Ш' 0xAC 
.................... #define 'Ъ' 0xAD 
.................... #define 'Ы' 0xAE 
.................... #define 'Э' 0xAF 
.................... */ 
....................  
....................  
.................... #define one   0x00 
.................... #define two   0x40 
.................... #define three 0x10 
.................... #define four  0x50 
....................  
....................  
.................... static void LCDWriteNibble(unsigned char uc) 
.................... {                                            
....................   uc=uc << 4; /* Align with bits 7-4*/ 
0053A:  MOV.B   866,W0L
0053C:  CLR.B   1
0053E:  SL      W0,#4,W0
00540:  MOV.B   W0L,866
....................   LCD_RW=0; 
00542:  BCLR.B  2E9.4
....................   buf=uc; 
00544:  MOV.B   866,W0L
00546:  MOV.B   W0L,844
....................   RG0=buf4; 
00548:  BCLR.B  2E8.0
0054A:  BTSC.B  844.4
0054C:  BSET.B  2E8.0
....................   RG1=buf5; 
0054E:  BCLR.B  2E8.1
00550:  BTSC.B  844.5
00552:  BSET.B  2E8.1
....................   RB1=buf6; 
00554:  BCLR.B  2CA.1
00556:  BTSC.B  844.6
00558:  BSET.B  2CA.1
....................   RB0=buf7; 
0055A:  BCLR.B  2CA.0
0055C:  BTSC.B  844.7
0055E:  BSET.B  2CA.0
....................   //delay_ms(50); 
....................   delay_ms(1); 
00560:  REPEAT  #1C3E
00562:  NOP     
00564:  REPEAT  #3FFF
00566:  NOP     
00568:  REPEAT  #3FFF
0056A:  NOP     
....................   LCD_E=1; 
0056C:  BSET.B  2E9.6
....................   //delay_us(100); 
....................   delay_us(2); 
0056E:  REPEAT  #4E
00570:  NOP     
....................   LCD_E=0; 
00572:  BCLR.B  2E9.6
....................   delay_us(100); 
00574:  REPEAT  #F9E
00576:  NOP     
....................   LCD_RW=1;    
00578:  BSET.B  2E9.4
.................... } 
0057A:  RETURN  
....................  
.................... static void LCDWriteData(unsigned char uc) 
.................... { 
*
00654:  MOV     W5,[W15++]
....................    
....................     LCD_RS=0; 
00656:  BCLR.B  2E9.5
....................     //delay_ms(50); 
....................     delay_us(500); 
00658:  REPEAT  #E1E
0065A:  NOP     
0065C:  REPEAT  #3FFF
0065E:  NOP     
....................     LCD_RS=1; 
00660:  BSET.B  2E9.5
....................     LCD_RW=1;// ?????????????? ???????? ????????????? 
00662:  BSET.B  2E9.4
....................     LCDWriteNibble(uc>>4);//???? ???????? ??????? 
00664:  MOV     862,W5
00666:  CLR.B   B
00668:  LSR     W5,#4,W5
0066A:  PUSH    866
0066C:  MOV.B   W5L,[W15-#2]
0066E:  POP     866
00670:  CALL    53A
....................     LCDWriteNibble(uc); 
00674:  MOV.B   862,W0L
00676:  MOV.B   W0L,866
00678:  CALL    53A
....................    
.................... } 
0067C:  MOV     [--W15],W5
0067E:  RETURN  
....................  
.................... static void LCDCommand(unsigned char uc) 
.................... { 
*
0057C:  MOV     W5,[W15++]
....................     LCD_RS=0; /* Instruction mode */ 
0057E:  BCLR.B  2E9.5
....................     delay_us(500); 
00580:  REPEAT  #E1E
00582:  NOP     
00584:  REPEAT  #3FFF
00586:  NOP     
....................     //delay_ms(5); 
....................     LCD_RW=1;// ?????????????? ???????? ????????????? 
00588:  BSET.B  2E9.4
....................     LCDWriteNibble(uc>>4); 
0058A:  MOV     84E,W5
0058C:  CLR.B   B
0058E:  LSR     W5,#4,W5
00590:  PUSH    866
00592:  MOV.B   W5L,[W15-#2]
00594:  POP     866
00596:  CALL    53A
....................     LCDWriteNibble(uc);   
0059A:  MOV.B   84E,W0L
0059C:  MOV.B   W0L,866
0059E:  CALL    53A
.................... } 
005A2:  MOV     [--W15],W5
005A4:  RETURN  
....................  
.................... static void LCDSetCursor(unsigned char ucPos) 
.................... { 
*
00694:  MOV     W5,[W15++]
....................   LCDCommand(0x80 | ucPos); 
00696:  MOV     84A,W5
00698:  IOR.B   #80,W5L
0069A:  PUSH    84E
0069C:  MOV.B   W5L,[W15-#2]
0069E:  POP     84E
006A0:  CALL    57C
.................... } 
006A4:  MOV     [--W15],W5
006A6:  RETURN  
....................  
.................... static void LCDClear(void) 
.................... { 
....................    LCDCommand(0x1); 
*
00646:  MOV.B   #1,W0L
00648:  MOV.B   W0L,84E
0064A:  CALL    57C
....................    Delay_us(200); 
0064E:  REPEAT  #1F3E
00650:  NOP     
....................    //delay_ms(5); 
.................... } 
00652:  RETURN  
....................  
.................... static void LCDInit(void) 
.................... { 
....................   LCD_E=0; 
*
005A6:  BCLR.B  2E9.6
....................   LCD_RS=0; 
005A8:  BCLR.B  2E9.5
....................   //Delay_ms(1000); // 
....................   delay_ms(2000); 
005AA:  MOV     #7D0,W0
005AC:  CALL    522
....................   LCDWriteNibble(3); 
005B0:  MOV.B   #3,W0L
005B2:  MOV.B   W0L,866
005B4:  CALL    53A
....................   //Delay_us(200); 
....................   Delay_ms(1); 
005B8:  REPEAT  #1C3E
005BA:  NOP     
005BC:  REPEAT  #3FFF
005BE:  NOP     
005C0:  REPEAT  #3FFF
005C2:  NOP     
....................   LCDWriteNibble(3); 
005C4:  MOV.B   #3,W0L
005C6:  MOV.B   W0L,866
005C8:  CALL    53A
....................   Delay_ms(1); 
005CC:  REPEAT  #1C3E
005CE:  NOP     
005D0:  REPEAT  #3FFF
005D2:  NOP     
005D4:  REPEAT  #3FFF
005D6:  NOP     
....................   //Delay_us(200); 
....................   LCDWriteNibble(3); 
005D8:  MOV.B   #3,W0L
005DA:  MOV.B   W0L,866
005DC:  CALL    53A
....................   Delay_ms(1); 
005E0:  REPEAT  #1C3E
005E2:  NOP     
005E4:  REPEAT  #3FFF
005E6:  NOP     
005E8:  REPEAT  #3FFF
005EA:  NOP     
....................   //Delay_us(200); 
....................   LCDWriteNibble(2); 
005EC:  MOV.B   #2,W0L
005EE:  MOV.B   W0L,866
005F0:  CALL    53A
....................   Delay_ms(1); 
005F4:  REPEAT  #1C3E
005F6:  NOP     
005F8:  REPEAT  #3FFF
005FA:  NOP     
005FC:  REPEAT  #3FFF
005FE:  NOP     
....................   //Delay_us(200); 
....................    
....................   LCDCommand(0x28);//4-?????? ?????, 2 ??????, ????? 5x8 ????? 
00600:  MOV.B   #28,W0L
00602:  MOV.B   W0L,84E
00604:  CALL    57C
....................    
....................   LCDCommand(0x08);// ????????? ???????, ????????? ??????, ????????? ???????? ??????? 
00608:  MOV.B   #8,W0L
0060A:  MOV.B   W0L,84E
0060C:  CALL    57C
....................    
....................  // LCDCommand(0x0C);// ???????? ???????, ???????? ??????, ???????? ???????? ??????? 
....................   LCDCommand(0b00001100);// ???????? ???????, ???????? ??????, ???????? ???????? ??????? 
00610:  MOV.B   #C,W0L
00612:  MOV.B   W0L,84E
00614:  CALL    57C
....................    
....................   LCDCommand(0x06);// ?????? ????? ????????? ?????? ??? ?????? ?????? 
00618:  MOV.B   #6,W0L
0061A:  MOV.B   W0L,84E
0061C:  CALL    57C
....................   LCDCommand(0x1);// ??????? ?????? ? ??????????? ??????? ? ?????? ???????  
00620:  MOV.B   #1,W0L
00622:  MOV.B   W0L,84E
00624:  CALL    57C
....................   // delay_ms(2); 
....................   Delay_ms(8); 
00628:  MOV     #8,W0
0062A:  CALL    522
....................   LCDCommand(0x06);// ?????? ????? ????????? ?????? ??? ?????? ??????  
0062E:  MOV.B   #6,W0L
00630:  MOV.B   W0L,84E
00632:  CALL    57C
....................   LCDCommand(0x40);//????????? ?????? DRAM 
00636:  MOV.B   #40,W0L
00638:  MOV.B   W0L,84E
0063A:  CALL    57C
....................   //delay_ms(10); 
....................   Delay_ms(20); 
0063E:  MOV     #14,W0
00640:  CALL    522
....................  } 
00644:  RETURN  
....................  
.................... static void LCDPutCh(char c) 
.................... { 
....................   LCDWriteData(c); 
*
00680:  MOV.B   860,W0L
00682:  MOV.B   W0L,862
00684:  CALL    654
.................... } 
00688:  RETURN  
....................  
.................... static void LCDMsg(char c) 
.................... { 
....................      
....................     LCDPutCh(c); 
0068A:  MOV.B   84E,W0L
0068C:  MOV.B   W0L,860
0068E:  CALL    680
.................... } 
00692:  RETURN  
....................  
.................... static void LCDWelcome(void) 
.................... { 
*
006A8:  MOV     W5,[W15++]
....................     LCDClear(); 
006AA:  CALL    646
....................     LCDMsg("       KZ       "); 
006AE:  MOV     #0,W5
006B0:  MOV     W5,W0
006B2:  CALL    200
006B6:  IOR.B   #0,W0L
006B8:  BTSC.B  42.1
006BA:  BRA     6C6
006BC:  INC     W5,W5
006BE:  MOV.B   W0L,84E
006C0:  CALL    68A
006C4:  BRA     6B0
....................     //Delay_ms(2000); 
....................     LCDSetCursor(0x40); 
006C6:  MOV.B   #40,W0L
006C8:  MOV.B   W0L,84A
006CA:  CALL    694
....................     LCDMsg("     Vitok"      ); 
006CE:  MOV     #0,W5
006D0:  MOV     W5,W0
006D2:  CALL    21E
006D6:  IOR.B   #0,W0L
006D8:  BTSC.B  42.1
006DA:  BRA     6E6
006DC:  INC     W5,W5
006DE:  MOV.B   W0L,84E
006E0:  CALL    68A
006E4:  BRA     6D0
....................     LCDSetCursor(0x50); 
006E6:  MOV.B   #50,W0L
006E8:  MOV.B   W0L,84A
006EA:  CALL    694
....................     LCDMsg("___LHEP_JINR____"); 
006EE:  MOV     #0,W5
006F0:  MOV     W5,W0
006F2:  CALL    236
006F6:  IOR.B   #0,W0L
006F8:  BTSC.B  42.1
006FA:  BRA     706
006FC:  INC     W5,W5
006FE:  MOV.B   W0L,84E
00700:  CALL    68A
00704:  BRA     6F0
....................     Delay_ms(1000); 
00706:  MOV     #3E8,W0
00708:  CALL    522
....................     LCDClear();    
0070C:  CALL    646
.................... } 
00710:  MOV     [--W15],W5
00712:  RETURN  
....................  
.................... static void LCDPutU16(U32 _u16,U8 u8NumDigs) 
.................... { 
*
01740:  MOV     W5,[W15++]
....................     
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000; 
01742:  BCLR.B  43.0
01744:  MOV     84A,W0
01746:  MOV     84C,W1
01748:  MOV     #2710,W2
0174A:  MOV     #0,W3
0174C:  CALL    16BC
01750:  MOV     W0,850
01752:  MOV     W1,852
....................    u16b=u16a*10000; 
01754:  MOV     850,W0
01756:  MOV     852,W1
01758:  MOV     #2710,W2
0175A:  MOV     #0,W3
0175C:  CALL    1710
01760:  MOV     W0,854
01762:  MOV     W1,856
....................  
....................     if (u8NumDigs>=5) 
01764:  MOV     84E,W4
01766:  CP.B    W4L,#5
01768:  BRA     NC,177A
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0176A:  MOV     #30,W4
0176C:  MOV     850,W3
0176E:  ADD.B   W3L,W4L,W5L
01770:  PUSH    860
01772:  MOV.B   W5L,[W15-#2]
01774:  POP     860
01776:  CALL    680
....................     } 
....................  
....................     _u16-=u16b; 
0177A:  MOV     84A,W4
0177C:  MOV     854,W3
0177E:  SUB     W4,W3,W0
01780:  MOV     W0,84A
01782:  MOV     84C,W4
01784:  MOV     856,W3
01786:  SUBB    W4,W3,W0
01788:  MOV     W0,84C
....................     u16a=_u16/1000; 
0178A:  BCLR.B  43.0
0178C:  MOV     84A,W0
0178E:  MOV     84C,W1
01790:  MOV     #3E8,W2
01792:  MOV     #0,W3
01794:  CALL    16BC
01798:  MOV     W0,850
0179A:  MOV     W1,852
....................     u16b=u16a*1000; 
0179C:  MOV     850,W0
0179E:  MOV     852,W1
017A0:  MOV     #3E8,W2
017A2:  MOV     #0,W3
017A4:  CALL    1710
017A8:  MOV     W0,854
017AA:  MOV     W1,856
....................     if (u8NumDigs>=4) 
017AC:  MOV     84E,W4
017AE:  CP.B    W4L,#4
017B0:  BRA     NC,17C2
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
017B2:  MOV     #30,W4
017B4:  MOV     850,W3
017B6:  ADD.B   W3L,W4L,W5L
017B8:  PUSH    860
017BA:  MOV.B   W5L,[W15-#2]
017BC:  POP     860
017BE:  CALL    680
....................     } 
....................  
....................     _u16-=u16b; 
017C2:  MOV     84A,W4
017C4:  MOV     854,W3
017C6:  SUB     W4,W3,W0
017C8:  MOV     W0,84A
017CA:  MOV     84C,W4
017CC:  MOV     856,W3
017CE:  SUBB    W4,W3,W0
017D0:  MOV     W0,84C
....................     u16a=_u16/100; 
017D2:  BCLR.B  43.0
017D4:  MOV     84A,W0
017D6:  MOV     84C,W1
017D8:  MOV     #64,W2
017DA:  MOV     #0,W3
017DC:  CALL    16BC
017E0:  MOV     W0,850
017E2:  MOV     W1,852
....................     u16b=u16a*100; 
017E4:  MOV     850,W0
017E6:  MOV     852,W1
017E8:  MOV     #64,W2
017EA:  MOV     #0,W3
017EC:  CALL    1710
017F0:  MOV     W0,854
017F2:  MOV     W1,856
....................     if (u8NumDigs>=3) 
017F4:  MOV     84E,W4
017F6:  CP.B    W4L,#3
017F8:  BRA     NC,180A
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
017FA:  MOV     #30,W4
017FC:  MOV     850,W3
017FE:  ADD.B   W3L,W4L,W5L
01800:  PUSH    860
01802:  MOV.B   W5L,[W15-#2]
01804:  POP     860
01806:  CALL    680
....................        
....................     } 
....................  
....................     _u16-=u16b; 
0180A:  MOV     84A,W4
0180C:  MOV     854,W3
0180E:  SUB     W4,W3,W0
01810:  MOV     W0,84A
01812:  MOV     84C,W4
01814:  MOV     856,W3
01816:  SUBB    W4,W3,W0
01818:  MOV     W0,84C
....................     u16a=_u16/10; 
0181A:  BCLR.B  43.0
0181C:  MOV     84A,W0
0181E:  MOV     84C,W1
01820:  MOV     #A,W2
01822:  MOV     #0,W3
01824:  CALL    16BC
01828:  MOV     W0,850
0182A:  MOV     W1,852
....................     u16b=u16a*10; 
0182C:  MOV     850,W0
0182E:  MOV     852,W1
01830:  MOV     #A,W2
01832:  MOV     #0,W3
01834:  CALL    1710
01838:  MOV     W0,854
0183A:  MOV     W1,856
....................    if (u8NumDigs>=2) 
0183C:  MOV     84E,W4
0183E:  CP.B    W4L,#2
01840:  BRA     NC,1852
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01842:  MOV     #30,W4
01844:  MOV     850,W3
01846:  ADD.B   W3L,W4L,W5L
01848:  PUSH    860
0184A:  MOV.B   W5L,[W15-#2]
0184C:  POP     860
0184E:  CALL    680
....................     } 
....................  
....................     _u16-=u16b; 
01852:  MOV     84A,W4
01854:  MOV     854,W3
01856:  SUB     W4,W3,W0
01858:  MOV     W0,84A
0185A:  MOV     84C,W4
0185C:  MOV     856,W3
0185E:  SUBB    W4,W3,W0
01860:  MOV     W0,84C
....................     if (u8NumDigs>=1) 
01862:  MOV     84E,W4
01864:  CP.B    W4L,#1
01866:  BRA     NC,1878
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
01868:  MOV     #30,W4
0186A:  MOV     84A,W3
0186C:  ADD.B   W3L,W4L,W5L
0186E:  PUSH    860
01870:  MOV.B   W5L,[W15-#2]
01872:  POP     860
01874:  CALL    680
....................     } 
....................    
.................... } 
01878:  MOV     [--W15],W5
0187A:  RETURN  
....................  
.................... static void LCDPutU32(U32 _u16,U8 u8NumDigs) 
.................... { 
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000000; 
....................    u16b=u16a*10000000; 
....................  
....................     if (u8NumDigs>=7) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................       _u16-=u16b; 
....................        
....................    u16a=_u16/1000000; 
....................    u16b=u16a*1000000; 
....................        
....................     if (u8NumDigs>=6) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................       _u16-=u16b; 
....................        
....................    u16a=_u16/100000; 
....................    u16b=u16a*100000; 
....................  
....................     if (u8NumDigs>=5) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/10000; 
....................     u16b=u16a*10000; 
....................     if (u8NumDigs>=4) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/1000; 
....................     u16b=u16a*1000; 
....................     if (u8NumDigs>=3) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................        
....................     } 
....................  
....................     _u16-=u16b; 
....................     u16a=_u16/100; 
....................     u16b=u16a*100; 
....................    if (u8NumDigs>=2) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................    _u16-=u16b; 
....................     u16a=_u16/10; 
....................     u16b=u16a*10; 
....................    if (u8NumDigs>=2) 
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
....................     } 
....................  
....................     _u16-=u16b; 
....................     if (u8NumDigs>=1) 
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
....................     } 
....................    
.................... } 
....................  
.................... static void LCDPutS32(S32 s32a,U8 u8NumDigs) 
.................... { 
....................   char c='+'; 
....................  
....................   if (s32a<0) 
....................   { 
....................     s32a=-s32a; 
....................     c='-'; 
....................   } 
....................   LCDPutCh(c); 
....................   LCDPutU32((U32)s32a,u8NumDigs); 
.................... } 
....................  
.................... #include <ADS1256.h> 
....................  
.................... static U8 RdReg(U8 RegName) 
.................... { 
....................    U8 RegValue = 0;  
....................    //1st Command Byte: 0001 rrrr where rrrr is the address of the first register to read. 
....................    //2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to read – 1 
....................    ADC_CS = 0; 
....................    delay_us(1); 
....................    Spi_write2(0x10+RegName); // 1st Command Byte,??????? ?????? 
....................    Spi_write2(0x00); // 1st Command Byte, ?????? ?????? ???? ???? 
....................    delay_us(8); // 50 CLK_IN PEDIODS 
....................    RegValue = Spi_read2(0); 
....................    delay_us(1); 
....................    ADC_CS =1; 
....................    delay_us(1); 
....................    Return RegValue;   
.................... } 
....................  
.................... static void WrReg(U8 RegName,CommandByte) 
.................... { 
*
007CA:  MOV     W5,[W15++]
....................    ADC_CS = 0; 
007CC:  BCLR.B  2E9.1
....................    delay_us(5); 
007CE:  REPEAT  #C6
007D0:  NOP     
....................    Spi_write2(0x50+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written. 
007D2:  MOV     #50,W0
007D4:  ADD.B   84C,W0L
007D6:  MOV.B   W0L,A
007D8:  BCLR.B  260.6
007DA:  BTSS.B  260.0
007DC:  BRA     7E2
007DE:  MOV.B   268,W0L
007E0:  BRA     7DA
007E2:  PUSH    268
007E4:  MOV.B   W5L,[W15-#2]
007E6:  POP     268
007E8:  BTSS.B  260.0
007EA:  BRA     7E8
....................    delay_us(10); 
007EC:  REPEAT  #18E
007EE:  NOP     
....................    Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1. 
007F0:  BCLR.B  260.6
007F2:  BTSS.B  260.0
007F4:  BRA     7FA
007F6:  MOV.B   268,W0L
007F8:  BRA     7F2
007FA:  CLR.B   268
007FC:  BTSS.B  260.0
007FE:  BRA     7FC
....................    delay_us(10); 
00800:  REPEAT  #18E
00802:  NOP     
....................    Spi_write2(CommandByte); 
00804:  BCLR.B  260.6
00806:  BTSS.B  260.0
00808:  BRA     80E
0080A:  MOV.B   268,W0L
0080C:  BRA     806
0080E:  MOV.B   84D,W0L
00810:  MOV.B   W0L,268
00812:  BTSS.B  260.0
00814:  BRA     812
....................    delay_us(10); 
00816:  REPEAT  #18E
00818:  NOP     
....................    ADC_CS = 1; 
0081A:  BSET.B  2E9.1
....................    delay_us(50); 
0081C:  REPEAT  #7CE
0081E:  NOP     
.................... } 
00820:  MOV     [--W15],W5
00822:  RETURN  
....................  
.................... static void ADC_Init2(U8 StartRegId,CommandByte1,CommandByte2,CommandByte3,CommandByte4) 
....................  
.................... { 
....................  
....................    ADC_CS = 0; 
....................    delay_us(1); 
....................    Spi_write2(0x50+StartRegId); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written. 
....................    Spi_write2(3);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1. 
....................    Spi_write2(CommandByte1); 
....................    Spi_write2(CommandByte2); 
....................    Spi_write2(CommandByte3); 
....................    Spi_write2(CommandByte4); 
....................    delay_us(1); 
....................    ADC_CS = 1; 
....................     
.................... } 
....................  
.................... static S32 ADC_RData(){             
....................  
....................      ADC_CS = 0; 
....................      delay_us(1); 
....................      Spi_write2(0x01); 
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      delay_us(1); 
....................      m1: 
....................      if(!ADC_DRDY){ 
....................      ADC_CS = 0; 
....................      delay_us(1); 
....................      ADC_Rbyte1 = Spi_read2(0); 
....................      ADC_Rbyte2 = Spi_read2(0); 
....................      ADC_Rbyte3 = Spi_read2(0); 
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      ADC_RByte_Sum = (ADC_Rbyte1<<16) + (ADC_Rbyte2<<8) + ADC_Rbyte3; 
....................      return ADC_RByte_Sum; 
....................      } 
....................      else goto m1; 
.................... } 
....................  
.................... static void ADC_StartRdContin(){ 
....................  
....................      ADC_CS = 0;        
*
00A6A:  BCLR.B  2E9.1
....................      delay_us(1);                                          
00A6C:  REPEAT  #26
00A6E:  NOP     
....................      Spi_write2(0x03);              
00A70:  BCLR.B  260.6
00A72:  BTSS.B  260.0
00A74:  BRA     A7A
00A76:  MOV.B   268,W0L
00A78:  BRA     A72
00A7A:  MOV.B   #3,W0L
00A7C:  MOV.B   W0L,268
00A7E:  BTSS.B  260.0
00A80:  BRA     A7E
....................      delay_us(1); 
00A82:  REPEAT  #26
00A84:  NOP     
....................      ADC_CS = 1; 
00A86:  BSET.B  2E9.1
.................... } 
00A88:  RETURN  
....................  
.................... static S32 ADC_RdataC(){                                               
*
00B08:  MOV     W5,[W15++]
00B0A:  MOV     W6,[W15++]
....................     /*   
....................      ADC_CS = 0;        
....................      delay_us(1);                                          
....................      Spi_write2(0x03);              
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      //delay_ms(1); 
....................         
....................      Switch (Sps_buf){      
....................      
....................       case 0xF0:    
....................        delay_us(220);         
....................         break;                       
....................        
....................       case 0xE0: 
....................        delay_us(255);  
....................         break; 
....................          
....................       case 0xD0: 
....................        delay_us(315);  
....................         break; 
....................          
....................       case 0xC0: 
....................        delay_us(445);  
....................         break; 
....................          
....................       case 0xB0: 
....................        delay_us(685);  
....................         break; 
....................          
....................       case 0xA1: 
....................        delay_ms(1); 
....................        delay_us(185);                
....................         break;       
....................          
....................       case 0x92: 
....................        delay_ms(5); 
....................         break; 
....................          
....................       case 0x82: 
....................        delay_ms(10); 
....................        delay_us(200); 
....................         break; 
....................                     
....................       case 0x63: 
....................        delay_ms(21);  
....................         break; 
....................          
....................       case 0x43: 
....................        delay_ms(41);  
....................         break; 
....................          
....................       case 0x23: 
....................        delay_ms(101);  
....................         break;          
....................              
....................       case 0x13: 
....................        delay_ms(201);  
....................         break;                           
....................      } 
....................      */                                                               
....................       
....................      ADC_StartRdContin();    
00B0C:  CALL    A6A
....................      While(ADC_DRDY) 
....................      delay_us(1); 
00B10:  BTSS.B  2D4.1
00B12:  BRA     B1C
00B14:  REPEAT  #26
00B16:  NOP     
00B18:  GOTO    B10
....................      ADC_CS = 0; 
00B1C:  BCLR.B  2E9.1
....................      delay_us(1); 
00B1E:  REPEAT  #26
00B20:  NOP     
....................      ADC_Rbyte1 = Spi_read2(0); 
00B22:  BCLR.B  260.6
00B24:  BTSS.B  260.0
00B26:  BRA     B2C
00B28:  MOV.B   268,W0L
00B2A:  BRA     B24
00B2C:  CLR.B   268
00B2E:  BTSS.B  260.0
00B30:  BRA     B2E
00B32:  MOV.B   268,W0L
00B34:  CLR.B   1
00B36:  MOV     #0,W1
00B38:  MOV     W0,800
00B3A:  MOV     W1,802
....................      ADC_Rbyte2 = Spi_read2(0); 
00B3C:  BCLR.B  260.6
00B3E:  BTSS.B  260.0
00B40:  BRA     B46
00B42:  MOV.B   268,W0L
00B44:  BRA     B3E
00B46:  CLR.B   268
00B48:  BTSS.B  260.0
00B4A:  BRA     B48
00B4C:  MOV.B   268,W0L
00B4E:  CLR.B   1
00B50:  MOV     #0,W1
00B52:  MOV     W0,804
00B54:  MOV     W1,806
....................      ADC_Rbyte3 = Spi_read2(0); 
00B56:  BCLR.B  260.6
00B58:  BTSS.B  260.0
00B5A:  BRA     B60
00B5C:  MOV.B   268,W0L
00B5E:  BRA     B58
00B60:  CLR.B   268
00B62:  BTSS.B  260.0
00B64:  BRA     B62
00B66:  MOV.B   268,W0L
00B68:  CLR.B   1
00B6A:  MOV     #0,W1
00B6C:  MOV     W0,808
00B6E:  MOV     W1,80A
....................      delay_us(1); 
00B70:  REPEAT  #26
00B72:  NOP     
....................      ADC_CS = 1; 
00B74:  BSET.B  2E9.1
....................      ADC_RByte_Sum = (ADC_Rbyte1<<24) + (ADC_Rbyte2<<16) + (ADC_Rbyte3<<8); 
00B76:  MOV.B   800,W0L
00B78:  MOV.B   W0L,D
00B7A:  CLR.B   W6
00B7C:  CLR.B   B
00B7E:  CLR.B   W5
00B80:  MOV     804,W1
00B82:  MOV     #0,W0
00B84:  ADD     W0,W5,W5
00B86:  ADDC    W1,W6,W6
00B88:  MOV.B   80A,W0L
00B8A:  MOV.B   W0L,3
00B8C:  MOV.B   809,W0L
00B8E:  MOV.B   W0L,W1L
00B90:  MOV.B   808,W0L
00B92:  MOV.B   W0L,1
00B94:  CLR.B   W0
00B96:  ADD     W0,W5,W0
00B98:  MOV     W0,80C
00B9A:  ADDC    W1,W6,W0
00B9C:  MOV     W0,80E
....................      return ADC_RByte_Sum/256; 
00B9E:  BCLR.B  43.0
00BA0:  MOV     80C,W0
00BA2:  MOV     80E,W1
00BA4:  MOV     #100,W2
00BA6:  MOV     #0,W3
00BA8:  CALL    A8A
00BAC:  MOV.D   W0,W0
....................      } 
00BAE:  MOV     [--W15],W6
00BB0:  MOV     [--W15],W5
00BB2:  RETURN  
....................  
.................... static void ADC_StopRd(){ 
....................     
....................    ADC_CS = 0; 
*
008BA:  BCLR.B  2E9.1
....................    delay_us(5); 
008BC:  REPEAT  #C6
008BE:  NOP     
....................    Spi_write2(0x0F);   
008C0:  BCLR.B  260.6
008C2:  BTSS.B  260.0
008C4:  BRA     8CA
008C6:  MOV.B   268,W0L
008C8:  BRA     8C2
008CA:  MOV.B   #F,W0L
008CC:  MOV.B   W0L,268
008CE:  BTSS.B  260.0
008D0:  BRA     8CE
....................    delay_us(5); 
008D2:  REPEAT  #C6
008D4:  NOP     
....................    ADC_CS = 1; 
008D6:  BSET.B  2E9.1
....................    delay_us(50); 
008D8:  REPEAT  #7CE
008DA:  NOP     
....................  
.................... } 
008DC:  RETURN  
....................  
.................... static void ADC_sps_set(U8 SPS){ 
....................  
....................    ADC_StopRd();                                                               
008DE:  CALL    8BA
....................    Sps_buf = SPS; 
008E2:  MOV.B   84A,W0L
008E4:  MOV.B   W0L,819
....................    WrReg(DRATE,SPS);  
008E6:  MOV.B   #3,W0L
008E8:  MOV.B   W0L,84C
008EA:  MOV.B   84A,W0L
008EC:  MOV.B   W0L,84D
008EE:  CALL    7CA
....................                   
....................    // ???????? ???_????? ? ??????????           
.................... }  
008F2:  RETURN  
....................  
.................... static void ADC_SelfCal(){ 
....................                       
....................    ADC_CS = 0; 
*
00990:  BCLR.B  2E9.1
....................    delay_us(1); 
00992:  REPEAT  #26
00994:  NOP     
....................    Spi_write2(0xF0); 
00996:  BCLR.B  260.6
00998:  BTSS.B  260.0
0099A:  BRA     9A0
0099C:  MOV.B   268,W0L
0099E:  BRA     998
009A0:  MOV.B   #F0,W0L
009A2:  MOV.B   W0L,268
009A4:  BTSS.B  260.0
009A6:  BRA     9A4
....................     delay_us(1); 
009A8:  REPEAT  #26
009AA:  NOP     
....................    ADC_CS = 1;   
009AC:  BSET.B  2E9.1
....................    Switch (Sps_buf) {      
009AE:  MOV.B   819,W0L
009B0:  CLR.B   1
009B2:  XOR     #F0,W0
009B4:  BRA     Z,9E4
009B6:  XOR     #10,W0
009B8:  BRA     Z,9EC
009BA:  XOR     #30,W0
009BC:  BRA     Z,9F4
009BE:  XOR     #10,W0
009C0:  BRA     Z,9FC
009C2:  XOR     #70,W0
009C4:  BRA     Z,A08
009C6:  XOR     #11,W0
009C8:  BRA     Z,A14
009CA:  XOR     #33,W0
009CC:  BRA     Z,A28
009CE:  XOR     #10,W0
009D0:  BRA     Z,A32
009D2:  XOR     #E1,W0
009D4:  BRA     Z,A40
009D6:  XOR     #20,W0
009D8:  BRA     Z,A4A
009DA:  XOR     #60,W0
009DC:  BRA     Z,A54
009DE:  XOR     #30,W0
009E0:  BRA     Z,A5E
009E2:  BRA     A68
....................      
....................       case 0xF0:    
....................        delay_us(220);         
009E4:  REPEAT  #225E
009E6:  NOP     
....................         break;                       
009E8:  GOTO    A68
....................        
....................       case 0xE0: 
....................        delay_us(255);  
009EC:  REPEAT  #27D6
009EE:  NOP     
....................         break; 
009F0:  GOTO    A68
....................          
....................       case 0xD0: 
....................        delay_us(315);  
009F4:  REPEAT  #3136
009F6:  NOP     
....................         break; 
009F8:  GOTO    A68
....................          
....................       case 0xC0: 
....................        delay_us(445);  
009FC:  REPEAT  #586
009FE:  NOP     
00A00:  REPEAT  #3FFF
00A02:  NOP     
....................         break; 
00A04:  GOTO    A68
....................          
....................       case 0xB0: 
....................        delay_us(685);  
00A08:  REPEAT  #2B06
00A0A:  NOP     
00A0C:  REPEAT  #3FFF
00A0E:  NOP     
....................         break; 
00A10:  GOTO    A68
....................          
....................       case 0xA1: 
....................        delay_ms(1); 
00A14:  REPEAT  #1C3E
00A16:  NOP     
00A18:  REPEAT  #3FFF
00A1A:  NOP     
00A1C:  REPEAT  #3FFF
00A1E:  NOP     
....................        delay_us(185);                
00A20:  REPEAT  #1CE6
00A22:  NOP     
....................         break;       
00A24:  GOTO    A68
....................          
....................       case 0x92: 
....................        delay_ms(5); 
00A28:  MOV     #5,W0
00A2A:  CALL    522
....................         break; 
00A2E:  GOTO    A68
....................          
....................       case 0x82: 
....................        delay_ms(10); 
00A32:  MOV     #A,W0
00A34:  CALL    522
....................        delay_us(200); 
00A38:  REPEAT  #1F3E
00A3A:  NOP     
....................         break; 
00A3C:  GOTO    A68
....................                     
....................       case 0x63: 
....................        delay_ms(21);  
00A40:  MOV     #15,W0
00A42:  CALL    522
....................         break; 
00A46:  GOTO    A68
....................          
....................       case 0x43: 
....................        delay_ms(41);  
00A4A:  MOV     #29,W0
00A4C:  CALL    522
....................         break; 
00A50:  GOTO    A68
....................          
....................       case 0x23: 
....................        delay_ms(101);  
00A54:  MOV     #65,W0
00A56:  CALL    522
....................         break;          
00A5A:  GOTO    A68
....................              
....................       case 0x13: 
....................        delay_ms(201);  
00A5E:  MOV     #C9,W0
00A60:  CALL    522
....................         break;                           
00A64:  GOTO    A68
....................      } 
....................       
.................... } 
00A68:  RETURN  
....................  
.................... static void ADC_setCh(U8 Ch_Number){ 
....................    ADC_StopRd(); 
*
00BB4:  CALL    8BA
....................    Global_Ch_Number = Ch_Number; 
00BB8:  MOV.B   84A,W0L
00BBA:  MOV.B   W0L,81A
....................    Switch (Ch_Number) { 
00BBC:  MOV.B   84A,W0L
00BBE:  CLR.B   1
00BC0:  XOR     #1,W0
00BC2:  BRA     Z,BD2
00BC4:  XOR     #3,W0
00BC6:  BRA     Z,BE2
00BC8:  XOR     #1,W0
00BCA:  BRA     Z,BF2
00BCC:  XOR     #7,W0
00BCE:  BRA     Z,C02
00BD0:  BRA     C12
....................  
....................     case 1:   WrReg(MUX,0x67); //7 & 6              
00BD2:  MOV.B   #1,W0L
00BD4:  MOV.B   W0L,84C
00BD6:  MOV.B   #67,W0L
00BD8:  MOV.B   W0L,84D
00BDA:  CALL    7CA
....................            break; 
00BDE:  GOTO    C12
.................... //-------------------------------- 
....................     case 2: WrReg(MUX,0x45);     
00BE2:  MOV.B   #1,W0L
00BE4:  MOV.B   W0L,84C
00BE6:  MOV.B   #45,W0L
00BE8:  MOV.B   W0L,84D
00BEA:  CALL    7CA
....................            break; 
00BEE:  GOTO    C12
.................... //--------------------------------            
....................     case 3: WrReg(MUX,0x23);         
00BF2:  MOV.B   #1,W0L
00BF4:  MOV.B   W0L,84C
00BF6:  MOV.B   #23,W0L
00BF8:  MOV.B   W0L,84D
00BFA:  CALL    7CA
....................            break; 
00BFE:  GOTO    C12
.................... //--------------------------------     
....................     case 4: WrReg(MUX,0x01);     
00C02:  MOV.B   #1,W0L
00C04:  MOV.B   W0L,84C
00C06:  MOV.B   #1,W0L
00C08:  MOV.B   W0L,84D
00C0A:  CALL    7CA
....................            break; 
00C0E:  GOTO    C12
....................     //default:printf("bad cmd");   
....................             } 
.................... // ?????????? ????????? ????????? ???. Xn ? Xn-1 
....................    ADC_SelfCal(); 
00C12:  CALL    990
....................    ADC_StartRdContin(); 
00C16:  CALL    A6A
....................    ADC_RdataC(); 
00C1A:  CALL    B08
....................    ADC_RdataC(); 
00C1E:  CALL    B08
....................    ADC_RdataC(); 
00C22:  CALL    B08
....................    ADC_RdataC(); 
00C26:  CALL    B08
....................     
....................  
.................... } 
00C2A:  RETURN  
....................  
.................... static S32 Read_ADC_vol_in(S32 k){ 
*
011B0:  MOV     W5,[W15++]
011B2:  MOV     #C,W5
011B4:  REPEAT  #4
011B6:  MOV     [W5++],[W15++]
....................     S32 VinInt; 
....................     ADCresult = ADC_RDataC(); 
011B8:  CALL    B08
011BC:  MOV     W0,810
011BE:  MOV     W1,812
....................     ADCresult=ADCresult+ADCaddCoef; // Аддитивная ошибка, ошибка смещения  
011C0:  MOV     81C,W0
011C2:  CLR     W1
011C4:  BTSC    W0.F
011C6:  SETM    W1
011C8:  ADD     810
011CA:  MOV     W1,W0
011CC:  ADDC    812,W0
011CE:  MOV     W0,812
....................     Vin = ((ADCresult*5)/(8388608.0*PGA))*ADCmulCoef; 
011D0:  MOV     810,W0
011D2:  MOV     812,W1
011D4:  MOV     #5,W2
011D6:  MOV     #0,W3
011D8:  CALL    CB6
011DC:  MOV     W0,W5
011DE:  MOV     W1,W6
011E0:  MOV     #0,W1
011E2:  MOV     #0,W2
011E4:  MOV     #0,W3
011E6:  MOV.B   818,W0L
011E8:  CLR.B   1
011EA:  CALL    CF8
011EE:  MOV     W5,[W15++]
011F0:  MOV     W6,[W15++]
011F2:  MOV     W0,W4
011F4:  MOV     W1,W5
011F6:  MOV     W2,W6
011F8:  MOV     W3,W7
011FA:  MOV     #0,W0
011FC:  MOV     #0,W1
011FE:  MOV     #0,W2
01200:  MOV     #4160,W3
01202:  CALL    D5C
01206:  MOV     [--W15],W6
01208:  MOV     [--W15],W5
0120A:  MOV     W0,W7
0120C:  MOV     W1,W8
0120E:  MOV     W2,W9
01210:  MOV     W3,W10
01212:  MOV     W5,W0
01214:  MOV     W6,W1
01216:  CLR     W3
01218:  BTSC    W1.F
0121A:  SETM    W3
0121C:  MOV     W3,W2
0121E:  CALL    E6C
01222:  MOV     W5,[W15++]
01224:  MOV     W6,[W15++]
01226:  MOV     W7,[W15++]
01228:  MOV     W7,W4
0122A:  MOV     W8,W5
0122C:  MOV     W9,W6
0122E:  MOV     W10,W7
01230:  CALL    ED0
01234:  MOV     [--W15],W7
01236:  MOV     [--W15],W6
01238:  MOV     [--W15],W5
0123A:  MOV     W0,W5
0123C:  MOV     W1,W6
0123E:  MOV     W2,W7
01240:  MOV     W3,W8
01242:  MOV     820,W2
01244:  MOV     81E,W1
01246:  MOV     #0,W0
01248:  CALL    FD8
0124C:  MOV     W5,[W15++]
0124E:  MOV     W6,[W15++]
01250:  MOV     W7,[W15++]
01252:  MOV     W0,W4
01254:  MOV     W5,W0
01256:  MOV     W1,W5
01258:  MOV     W6,W1
0125A:  MOV     W2,W6
0125C:  MOV     W7,W2
0125E:  MOV     W3,W7
01260:  MOV     W8,W3
01262:  CALL    D5C
01266:  MOV     [--W15],W7
01268:  MOV     [--W15],W6
0126A:  MOV     [--W15],W5
0126C:  CALL    101E
01270:  MOV     W1,814
01272:  MOV     W2,816
....................     VinInt = Vin*k; 
01274:  MOV     84A,W0
01276:  MOV     84C,W1
01278:  CALL    1062
0127C:  MOV     W0,W2
0127E:  MOV     W1,W3
01280:  MOV     814,W0
01282:  MOV     816,W1
01284:  CALL    10B0
01288:  CALL    1174
0128C:  MOV     W0,84E
0128E:  MOV     W1,850
....................     return VinInt; 
01290:  MOV     84E,W0
01292:  MOV     850,W1
.................... }                
01294:  MOV     #14,W5
01296:  REPEAT  #4
01298:  MOV     [--W15],[W5--]
0129A:  MOV     [--W15],W5
0129C:  RETURN  
....................  
.................... static S32 ADC_vol_average(U8 NumSamples){ 
....................     
....................    S32 A,Sum = 0;                
....................    U8 i; 
....................     
....................    for (i=0;i<NumSamples;i++){ 
....................         
....................        A = Read_ADC_vol_in(uV); 
....................        Sum = Sum + A;     
....................    } 
....................    return Sum/NumSamples; 
.................... } 
....................  
.................... static void ADC_set_PGA(u8 PGA_val){ 
....................    
....................   PGA = PGA_val; 
*
00824:  MOV.B   84A,W0L
00826:  MOV.B   W0L,818
....................  
.................... /* PGA 
.................... 000 = 1 (default) 
.................... 001 = 2 
.................... 010 = 4 
.................... 011 = 8 
.................... 100 = 16 
.................... 101 = 32 
.................... 110 = 64 
.................... 111 = 64*/ 
....................  
....................    switch (PGA_val){ 
00828:  MOV.B   84A,W0L
0082A:  CLR.B   1
0082C:  XOR     #1,W0
0082E:  BRA     Z,84A
00830:  XOR     #3,W0
00832:  BRA     Z,858
00834:  XOR     #6,W0
00836:  BRA     Z,868
00838:  XOR     #C,W0
0083A:  BRA     Z,878
0083C:  XOR     #18,W0
0083E:  BRA     Z,888
00840:  XOR     #30,W0
00842:  BRA     Z,898
00844:  XOR     #60,W0
00846:  BRA     Z,8A8
00848:  BRA     8B8
....................       case 1: 
....................        WrReg(ADCON,0); 
0084A:  MOV.B   #2,W0L
0084C:  MOV.B   W0L,84C
0084E:  CLR.B   84D
00850:  CALL    7CA
....................       break; 
00854:  GOTO    8B8
....................        
....................       case 2: 
....................        WrReg(ADCON,1); 
00858:  MOV.B   #2,W0L
0085A:  MOV.B   W0L,84C
0085C:  MOV.B   #1,W0L
0085E:  MOV.B   W0L,84D
00860:  CALL    7CA
....................       break; 
00864:  GOTO    8B8
....................        
....................       case 4: 
....................        WrReg(ADCON,2); 
00868:  MOV.B   #2,W0L
0086A:  MOV.B   W0L,84C
0086C:  MOV.B   #2,W0L
0086E:  MOV.B   W0L,84D
00870:  CALL    7CA
....................       break; 
00874:  GOTO    8B8
....................        
....................       case 8: 
....................        WrReg(ADCON,3); 
00878:  MOV.B   #2,W0L
0087A:  MOV.B   W0L,84C
0087C:  MOV.B   #3,W0L
0087E:  MOV.B   W0L,84D
00880:  CALL    7CA
....................       break; 
00884:  GOTO    8B8
....................        
....................       case 16: 
....................        WrReg(ADCON,4); 
00888:  MOV.B   #2,W0L
0088A:  MOV.B   W0L,84C
0088C:  MOV.B   #4,W0L
0088E:  MOV.B   W0L,84D
00890:  CALL    7CA
....................       break; 
00894:  GOTO    8B8
....................        
....................       case 32: 
....................        WrReg(ADCON,5); 
00898:  MOV.B   #2,W0L
0089A:  MOV.B   W0L,84C
0089C:  MOV.B   #5,W0L
0089E:  MOV.B   W0L,84D
008A0:  CALL    7CA
....................       break; 
008A4:  GOTO    8B8
....................        
....................       case 64: 
....................        WrReg(ADCON,6); 
008A8:  MOV.B   #2,W0L
008AA:  MOV.B   W0L,84C
008AC:  MOV.B   #6,W0L
008AE:  MOV.B   W0L,84D
008B0:  CALL    7CA
....................       break;  
008B4:  GOTO    8B8
....................    } 
.................... } 
008B8:  RETURN  
....................  
.................... static void ADC_wakeUp(){ 
....................  
....................    ADC_CS = 1;                          
*
007AA:  BSET.B  2E9.1
....................    ADC_RESET = 0; //When using the RESET pin, take it low to force a reset. 
007AC:  BCLR.B  2D6.3
....................    delay_us(100); 
007AE:  REPEAT  #F9E
007B0:  NOP     
....................    ADC_RESET = 1; 
007B2:  BSET.B  2D6.3
....................    ADC_SYNC =0; 
007B4:  BCLR.B  2D6.2
....................    delay_us(100); 
007B6:  REPEAT  #F9E
007B8:  NOP     
....................    ADC_SYNC = 1; //To use the SYNC/PDWN pin, take it low and then high 
007BA:  BSET.B  2D6.2
....................    delay_ms(1); 
007BC:  REPEAT  #1C3E
007BE:  NOP     
007C0:  REPEAT  #3FFF
007C2:  NOP     
007C4:  REPEAT  #3FFF
007C6:  NOP     
....................  
.................... }  
007C8:  RETURN  
....................  
.................... static void ADC_init(){ 
....................     
....................   WrReg(STATUS,2); 
*
008F4:  CLR.B   84C
008F6:  MOV.B   #2,W0L
008F8:  MOV.B   W0L,84D
008FA:  CALL    7CA
....................   ADC_set_PGA(64);    // 
008FE:  MOV.B   #40,W0L
00900:  MOV.B   W0L,84A
00902:  CALL    824
....................    if(ADC_sps_var>7)  ADC_sps_var = 7; 
00906:  MOV     834,W4
00908:  CP.B    W4L,#7
0090A:  BRA     LEU,910
0090C:  MOV.B   #7,W0L
0090E:  MOV.B   W0L,834
....................    if(ADC_sps_var==0) ADC_sps_var = 1; 
00910:  CP0.B   834
00912:  BRA     NZ,918
00914:  MOV.B   #1,W0L
00916:  MOV.B   W0L,834
....................     switch (ADC_sps_var){                // передача величины скорости измерений АЦП  
00918:  MOV.B   834,W0L
0091A:  CLR.B   1
0091C:  XOR     #1,W0
0091E:  BRA     Z,93A
00920:  XOR     #3,W0
00922:  BRA     Z,946
00924:  XOR     #1,W0
00926:  BRA     Z,952
00928:  XOR     #7,W0
0092A:  BRA     Z,95E
0092C:  XOR     #1,W0
0092E:  BRA     Z,96A
00930:  XOR     #3,W0
00932:  BRA     Z,976
00934:  XOR     #1,W0
00936:  BRA     Z,982
00938:  BRA     98E
....................       case 1: ADC_sps_set(0x23);  break; // 10   sps 
0093A:  MOV.B   #23,W0L
0093C:  MOV.B   W0L,84A
0093E:  CALL    8DE
00942:  GOTO    98E
....................       case 2: ADC_sps_set(0x43);  break; // 25   sps 
00946:  MOV.B   #43,W0L
00948:  MOV.B   W0L,84A
0094A:  CALL    8DE
0094E:  GOTO    98E
....................       case 3: ADC_sps_set(0x63);  break; // 50   sps 
00952:  MOV.B   #63,W0L
00954:  MOV.B   W0L,84A
00956:  CALL    8DE
0095A:  GOTO    98E
....................       case 4: ADC_sps_set(0x82);  break; // 100  sps 
0095E:  MOV.B   #82,W0L
00960:  MOV.B   W0L,84A
00962:  CALL    8DE
00966:  GOTO    98E
....................       case 5: ADC_sps_set(0x91);  break; // 500  sps 
0096A:  MOV.B   #91,W0L
0096C:  MOV.B   W0L,84A
0096E:  CALL    8DE
00972:  GOTO    98E
....................       case 6: ADC_sps_set(0xA1);  break; // 1000 sps 
00976:  MOV.B   #A1,W0L
00978:  MOV.B   W0L,84A
0097A:  CALL    8DE
0097E:  GOTO    98E
....................       case 7: ADC_sps_set(0xC0);  break; // 3750 sps 
00982:  MOV.B   #C0,W0L
00984:  MOV.B   W0L,84A
00986:  CALL    8DE
0098A:  GOTO    98E
....................       } 
....................  
.................... } 
0098E:  RETURN  
....................  
.................... static float power(float t, U8 k) // возведение t в степень k 
.................... { 
....................   float res = 1.0; 
....................   while (k)  
....................       { 
....................         if (k & 1)  
....................            res *= t; 
....................         t *= t; 
....................         k >>= 1; 
....................       } 
....................   return res; 
.................... } 
....................  
.................... static float ADC_vol_to_T(){ 
....................     float R = 1000.0; 
....................     float Temper,k1,k2,k3,k4,k5,k6,k7 = 0; 
....................     float p,z1,z2,z3,z4,z5,z6 = 0; 
....................     U8 Temper_int = 0; 
....................    temp = ADC_vol_average(NumAver); 
....................    p=R/(temp/10); // приводим к кОм 
....................     
....................    switch (Global_Ch_Number){ 
.................... //------------------------------------------- 
....................       case 4: // структура 
.................... k1=12.1972840491798706; 
.................... k2=-103.27107382635586; 
.................... k3=397.925821471959352; 
.................... k4=-567.703864333219826; 
.................... k5=208.592693047598004; 
.................... k6=315.492219684645534; 
.................... k7=-92.5740048021543771; 
....................       break; 
.................... //------------------------------------------- 
....................       case 3: // спаи 
.................... k1=3.06244888759101741; 
.................... k2=-30.3586341044865549; 
.................... k3=241.908977336715907; 
.................... k4=-649.756288938224316; 
.................... k5=955.307573420926928; 
.................... k6=-485.428257496096194; 
.................... k7=136.248866791371256; 
....................       break; 
....................       //------------------------------------------- 
....................       case 2: // Пер 
.................... k1=17.2566714868880808; 
.................... k2=-215.322746395599097; 
.................... k3=1219.40785944648087; 
.................... k4=-3277.70955596119165; 
.................... k5=4778.55193661898375; 
.................... k6=-3251.6292140185833; 
.................... k7=954.333331361413002; 
....................       break;  
.................... //------------------------------------------- 
....................       case 1: // соленоид 
.................... k1 = 4.005067403952125460; 
.................... k2 = -55.2455571058671922; 
.................... k3 = 448.087557092308998; 
.................... k4 = -1390.99036489240825;  
.................... k5 = 2271.71780132129788;  
.................... k6 = -1387.04864621348679;  
.................... k7 = 500.36806705314666; 
....................       break;          
.................... //------------------------------------------- 
....................    } 
....................    z1 = k1+k2*p; 
....................    z2 = k3*(power(p,2)); 
....................    z3 = k4*(power(p,3)); 
....................    z4 = k5*(power(p,4)); 
....................    z5 = k6*(power(p,5)); 
....................    z6 = k7*(power(p,6)); 
....................    Temper = (z1+z2+z3+z4+z5+z6); 
....................    Temper_int = Temper; 
....................    ostatok_int_dec = (Temper-Temper_int)*10; 
....................    ostatok_int_sot = (Temper-Temper_int)*100; 
....................    if (ostatok_int_sot > 4) ostatok_int_dec++; 
....................    if (Temper<10) { LCD_num_symb = 1;} 
....................    if (Temper>=10){ LCD_num_symb = 2;} 
....................    if (Temper>=100){LCD_num_symb = 3;} 
....................    return Temper; 
....................    } 
....................  
....................  
.................... /*############################################################################*/ 
....................  
.................... static void Rd_Flash(){ 
*
00742:  MOV     W5,[W15++]
....................  
....................   read_program_memory(CK_USER_PAGE,flash_rd_data,4); 
00744:  MOV     #4,W3
00746:  MOV     #5000,W0
00748:  MOV     #1,W1
0074A:  MOV     #838,W2
0074C:  CALL    714
....................   delay_ms(5); 
00750:  MOV     #5,W0
00752:  CALL    522
....................   NumAver = flash_rd_data[1];  
00756:  MOV.B   839,W0L
00758:  MOV.B   W0L,833
....................   ADC_sps_var = flash_rd_data[0]; 
0075A:  MOV.B   838,W0L
0075C:  MOV.B   W0L,834
....................   CRC_buf = flash_rd_data[2]; 
0075E:  MOV.B   83A,W0L
00760:  MOV.B   W0L,837
....................  
.................... } 
00762:  MOV     [--W15],W5
00764:  RETURN  
....................  
.................... static void Wr_Flash(){ 
....................  
....................   flash_wr_data[0] = Aver_Wr;  
*
01920:  MOV.B   82C,W0L
01922:  MOV.B   W0L,828
....................   flash_wr_data[1] = Sps_Wr; 
01924:  MOV.B   82D,W0L
01926:  MOV.B   W0L,829
....................   flash_wr_data[2] = CRC_Wr; 
01928:  MOV.B   82E,W0L
0192A:  MOV.B   W0L,82A
....................   //flash_wr_data[4] = 0x00; 
....................   write_program_memory(CK_USER_PAGE,flash_wr_data,4); 
0192C:  MOV     #4,W3
0192E:  MOV     #5000,W0
01930:  MOV     #1,W1
01932:  MOV     #828,W2
01934:  CALL    18A4
....................   delay_ms(2); 
01938:  MOV     #2,W0
0193A:  CALL    522
....................  
....................  //if(Rd_Flash(buf_index)==in_wr_data) return 1; else return 0; 
.................... } 
0193E:  RETURN  
....................  
.................... unsigned char Crc8(unsigned char *pcBlock, unsigned int len) 
.................... { 
*
00766:  MOV     W5,[W15++]
00768:  SETM.B  84E
....................  
....................  
....................   //Name  : CRC-8 
....................   //Poly  : 0x31    x^8 + x^5 + x^4 + 1 
....................   //Init  : 0xFF 
....................   //Revert: false 
....................   //XorOut: 0x00 
....................   //Check : 0xF7 ("123456789") 
....................   //MaxLen: 15 байт(127 бит) - обнаружение 
....................   // одинарных, двойных, тройных и всех нечетных ошибок 
....................  
....................     unsigned char crc = 0xFF; 
....................     unsigned int i; 
....................   
....................     while (len--) 
....................     { 
0076A:  MOV     84C,W0
0076C:  DEC     084C
0076E:  CP0     W0
00770:  BRA     Z,7A2
....................         crc ^= *pcBlock++; 
00772:  MOV     84A,W0
00774:  INC     084A
00776:  MOV     W0,W4
00778:  MOV.B   [W4],W0L
0077A:  XOR.B   84E
....................   
....................         for (i = 0; i < 8; i++) 
0077C:  CLR     850
0077E:  MOV     850,W4
00780:  CP      W4,#8
00782:  BRA     C,79E
....................             crc = crc & 0x80 ? (crc << 1) ^ 0x31 : crc << 1; 
00784:  BTSS.B  84E.7
00786:  BRA     792
00788:  MOV.B   84E,W0L
0078A:  SL      W0,#1,W0
0078C:  XOR.B   #31,W0L
0078E:  GOTO    796
00792:  MOV.B   84E,W0L
00794:  SL      W0,#1,W0
00796:  MOV.B   W0L,84E
00798:  INC     0850
0079A:  GOTO    77E
....................     } 
0079E:  GOTO    76A
....................   
....................     return crc; 
007A2:  MOV.B   84E,W0L
007A4:  MOV.B   W0L,0
.................... } 
007A6:  MOV     [--W15],W5
007A8:  RETURN  
....................  
.................... static void OscSetup(){ 
....................   //Fcy=Fosc/2 
....................   //Fin=10M 
....................   //Fosc=Fin(M/(N1*N2)) 
....................   //Fosc=80M 
....................   //U2BRG = 259;// BAUD Rate Setting for 9600 
....................   U2BRG = 129;// BAUD Rate Setting for 19200 
*
00492:  MOV     #81,W4
00494:  MOV     W4,238
....................   U2MODE = 0b1010101010010000; 
00496:  MOV     #AA90,W4
00498:  MOV     W4,230
....................   PLLFBD = 30; // ???. ????. ??????? PLL M = 30 
0049A:  MOV     #1E,W4
0049C:  MOV     W4,746
....................    
....................   PLLPRE4 = 0; // ???. ????. ??????? PLL N1 = 2 
0049E:  BCLR.B  744.4
....................   PLLPRE3 = 0; 
004A0:  BCLR.B  744.3
....................   PLLPRE2 = 0; 
004A2:  BCLR.B  744.2
....................   PLLPRE1 = 0; 
004A4:  BCLR.B  744.1
....................   PLLPRE0 = 0; 
004A6:  BCLR.B  744.0
....................    
....................   PLLPOST0=0; // ???. ????. ??????? PLL N2 = 2 
004A8:  BCLR.B  744.6
....................   PLLPOST1=0; 
004AA:  BCLR.B  744.7
....................      
....................    } 
004AC:  RETURN  
....................  
.................... static void EnableInt (){ 
....................   ENABLE_INTERRUPTS(INTR_GLOBAL); 
004AE:  BCLR.B  81.7
004B0:  CLR     42
004B2:  BSET.B  81.7
....................   enable_interrupts(INTR_CN_PIN|PIN_B5);  
004B4:  BSET.B  60.7
004B6:  BSET.B  96.3
....................   enable_interrupts(INTR_CN_PIN|PIN_B5); 
004B8:  BSET.B  60.7
004BA:  BSET.B  96.3
....................   enable_interrupts(INTR_CN_PIN|PIN_B4); 
004BC:  BSET.B  60.6
004BE:  BSET.B  96.3
....................   enable_interrupts(INTR_CN_PIN|PIN_B3); 
004C0:  BSET.B  60.5
004C2:  BSET.B  96.3
....................   enable_interrupts(INTR_CN_PIN|PIN_B2); 
004C4:  BSET.B  60.4
004C6:  BSET.B  96.3
....................   enable_interrupts(INT_TIMER1); 
004C8:  BSET.B  94.3
....................   EXT_INT_EDGE(L_TO_H); 
004CA:  BCLR.B  82.0
.................... } 
004CC:  RETURN  
....................  
.................... static void DisableInt (){ 
....................   DISABLE_INTERRUPTS(INTR_GLOBAL); 
*
00404:  BCLR.B  81.7
00406:  MOV     #E0,W4
00408:  MOV     W4,42
0040A:  BSET.B  81.7
....................   disable_interrupts(INTR_CN_PIN|PIN_B5);  
0040C:  BCLR.B  60.7
....................   disable_interrupts(INTR_CN_PIN|PIN_B5); 
0040E:  BCLR.B  60.7
....................   disable_interrupts(INTR_CN_PIN|PIN_B4); 
00410:  BCLR.B  60.6
....................   disable_interrupts(INTR_CN_PIN|PIN_B3); 
00412:  BCLR.B  60.5
....................   disable_interrupts(INTR_CN_PIN|PIN_B2); 
00414:  BCLR.B  60.4
.................... } 
00416:  RETURN  
....................  
.................... static void MCU_init(){ 
....................  
....................   setup_timer1(TMR_INTERNAL | TMR_DIV_BY_64); // таймер 1 сбрасывает собачий таймер 
*
004CE:  CLR     104
004D0:  SETM    102
004D2:  MOV     #8020,W4
004D4:  MOV     W4,104
....................   set_timer1(20000); //reset the timer. 
004D6:  MOV     #4E20,W4
004D8:  MOV     W4,100
....................    
....................    SETUP_SPI2(SPI_MASTER|SPI_SCK_IDLE_LOW|SPI_XMIT_H_TO_L|SPI_MODE_8B|SPI_SAMPLE_AT_END|SPI_SS_DISABLED|SPI_CLK_DIV_128); 
004DA:  BCLR.B  261.7
004DC:  BCLR.B  260.6
004DE:  MOV     #221,W4
004E0:  MOV     W4,262
004E2:  BSET.B  261.7
....................    //f SCLK SPI = 312,5 kHz 
....................    //setup_timer1(TMR_DISABLED|TMR_DIV_BY_1); 
....................    //enable_interrupts(INT_EXT0); 
....................    //enable_interrupts(INT_TIMER1); 
....................    
....................  SCK2_TRIS=0; // SPI2 tris 
004E4:  BCLR.B  2E4.6
....................  SDI2_TRIS=1; 
004E6:  BSET.B  2E4.7
....................  SDO2_TRIS=0; 
004E8:  BCLR.B  2E5.0
....................   
....................  CN1_TRIS = 1; 
004EA:  BSET.B  2C6.5
....................  CN2_TRIS = 1; 
004EC:  BSET.B  2C6.4
....................  CN3_TRIS = 1; 
004EE:  BSET.B  2C6.2
....................  CN4_TRIS = 1; 
004F0:  BSET.B  2C6.3
....................   
....................  TRG0 = 0; // lcd buf tris 
004F2:  BCLR.B  2E4.0
....................  TRG1 = 0; 
004F4:  BCLR.B  2E4.1
....................  TRB1 = 0; 
004F6:  BCLR.B  2C6.1
....................  TRB0 = 0; 
004F8:  BCLR.B  2C6.0
....................   
....................  LCD_RS_TRIS=0; 
004FA:  BCLR.B  2E5.5
....................  LCD_RW_TRIS=0; 
004FC:  BCLR.B  2E5.4
....................  LCD_E_TRIS=0; 
004FE:  BCLR.B  2E5.6
....................   
....................  ADC_CS_TRIS=0; 
00500:  BCLR.B  2E5.1
....................  ADC_RESET_TRIS=0; 
00502:  BCLR.B  2D2.3
....................  ADC_SYNC_TRIS=0; 
00504:  BCLR.B  2D2.2
....................  ADC_DRDY_TRIS=1; // опрос готовнсти данных АЦП 
00506:  BSET.B  2D6.1
....................  Status_LED_TRIS = 0; 
00508:  BCLR.B  2C7.5
....................   
....................  UART2_RX_TRIS=1; 
0050A:  BSET.B  2DE.4
....................  UART2_TX_TRIS=0; 
0050C:  BCLR.B  2DE.5
....................  XPORT_RST_TRIS=0; 
0050E:  BCLR.B  2C7.7
....................   
....................  XPORT_RST_n = 0; 
00510:  BCLR.B  2C7.7
....................  delay_us(500); 
00512:  REPEAT  #E1E
00514:  NOP     
00516:  REPEAT  #3FFF
00518:  NOP     
....................  XPORT_RST_n = 1; 
0051A:  BSET.B  2C7.7
....................  EnableInt(); 
0051C:  CALL    4AE
.................... } 
00520:  RETURN  
....................  
.................... static void Bpush_delay(){ 
*
013F6:  CLR     84A
....................     
....................    U16 counter = 0; 
....................     
....................    do {counter++;}  
013F8:  INC     084A
....................    while (counter<2000);    
013FA:  MOV     84A,W4
013FC:  MOV     #7D0,W3
013FE:  CP      W3,W4
01400:  BRA     GTU,13F8
....................    EnableInt();  
01402:  CALL    4AE
.................... } 
01406:  RETURN  
....................  
.................... static void LCD_print_menu(){ 
01408:  MOV     W5,[W15++]
.................... LCDsetCursor(one); 
0140A:  CLR.B   84A
0140C:  CALL    694
.................... LCDMsg("ADC sps set  "); 
01410:  MOV     #0,W5
01412:  MOV     W5,W0
01414:  CALL    254
01418:  IOR.B   #0,W0L
0141A:  BTSC.B  42.1
0141C:  BRA     1428
0141E:  INC     W5,W5
01420:  MOV.B   W0L,84E
01422:  CALL    68A
01426:  BRA     1412
.................... LCDsetCursor(two); 
01428:  MOV.B   #40,W0L
0142A:  MOV.B   W0L,84A
0142C:  CALL    694
.................... LCDMsg("Average set  "); 
01430:  MOV     #0,W5
01432:  MOV     W5,W0
01434:  CALL    26E
01438:  IOR.B   #0,W0L
0143A:  BTSC.B  42.1
0143C:  BRA     1448
0143E:  INC     W5,W5
01440:  MOV.B   W0L,84E
01442:  CALL    68A
01446:  BRA     1432
.................... LCDsetCursor(three); 
01448:  MOV.B   #10,W0L
0144A:  MOV.B   W0L,84A
0144C:  CALL    694
.................... LCDMsg("Reset device "); 
01450:  MOV     #0,W5
01452:  MOV     W5,W0
01454:  CALL    288
01458:  IOR.B   #0,W0L
0145A:  BTSC.B  42.1
0145C:  BRA     1468
0145E:  INC     W5,W5
01460:  MOV.B   W0L,84E
01462:  CALL    68A
01466:  BRA     1452
.................... LCDsetCursor(four); 
01468:  MOV.B   #50,W0L
0146A:  MOV.B   W0L,84A
0146C:  CALL    694
.................... LCDMsg("Return back  "); 
01470:  MOV     #0,W5
01472:  MOV     W5,W0
01474:  CALL    2A2
01478:  IOR.B   #0,W0L
0147A:  BTSC.B  42.1
0147C:  BRA     1488
0147E:  INC     W5,W5
01480:  MOV.B   W0L,84E
01482:  CALL    68A
01486:  BRA     1472
.................... } 
01488:  MOV     [--W15],W5
0148A:  RETURN  
....................  
.................... static void LCD_main_menu (void) { 
0148C:  MOV     W5,[W15++]
.................... //DisableInt(); 
.................... LCD_print_menu(); 
0148E:  CALL    1408
....................  
....................    //if(CN4){Bpush_delay(); if(CN4) menu_sel++;} 
....................    //if(CN3){Bpush_delay(); if(CN3) menu_sel--;} 
....................    switch (menu_sel){ 
01492:  MOV.B   830,W0L
01494:  CLR.B   1
01496:  XOR     #0,W0
01498:  BRA     Z,14A8
0149A:  XOR     #1,W0
0149C:  BRA     Z,152C
0149E:  XOR     #3,W0
014A0:  BRA     Z,15B0
014A2:  XOR     #1,W0
014A4:  BRA     Z,1634
014A6:  BRA     16B8
....................     case 0:  
....................        LCDsetCursor(0x0D); LCDMsg("<--"); 
014A8:  MOV.B   #D,W0L
014AA:  MOV.B   W0L,84A
014AC:  CALL    694
014B0:  MOV     #0,W5
014B2:  MOV     W5,W0
014B4:  CALL    2BC
014B8:  IOR.B   #0,W0L
014BA:  BTSC.B  42.1
014BC:  BRA     14C8
014BE:  INC     W5,W5
014C0:  MOV.B   W0L,84E
014C2:  CALL    68A
014C6:  BRA     14B2
....................        LCDsetCursor(0x4D); LCDMsg("   "); // стирание стрелки от предыдущего 
014C8:  MOV.B   #4D,W0L
014CA:  MOV.B   W0L,84A
014CC:  CALL    694
014D0:  MOV     #0,W5
014D2:  MOV     W5,W0
014D4:  CALL    2CC
014D8:  IOR.B   #0,W0L
014DA:  BTSC.B  42.1
014DC:  BRA     14E8
014DE:  INC     W5,W5
014E0:  MOV.B   W0L,84E
014E2:  CALL    68A
014E6:  BRA     14D2
....................        LCDsetCursor(0x1D); LCDMsg("   "); // элемента меню 
014E8:  MOV.B   #1D,W0L
014EA:  MOV.B   W0L,84A
014EC:  CALL    694
014F0:  MOV     #0,W5
014F2:  MOV     W5,W0
014F4:  CALL    2CC
014F8:  IOR.B   #0,W0L
014FA:  BTSC.B  42.1
014FC:  BRA     1508
014FE:  INC     W5,W5
01500:  MOV.B   W0L,84E
01502:  CALL    68A
01506:  BRA     14F2
....................        LCDsetCursor(0x5D); LCDMsg("   "); 
01508:  MOV.B   #5D,W0L
0150A:  MOV.B   W0L,84A
0150C:  CALL    694
01510:  MOV     #0,W5
01512:  MOV     W5,W0
01514:  CALL    2CC
01518:  IOR.B   #0,W0L
0151A:  BTSC.B  42.1
0151C:  BRA     1528
0151E:  INC     W5,W5
01520:  MOV.B   W0L,84E
01522:  CALL    68A
01526:  BRA     1512
....................     break; 
01528:  GOTO    16B8
....................      
....................     case 1:  
....................        LCDsetCursor(0x0D); LCDMsg("   "); 
0152C:  MOV.B   #D,W0L
0152E:  MOV.B   W0L,84A
01530:  CALL    694
01534:  MOV     #0,W5
01536:  MOV     W5,W0
01538:  CALL    2CC
0153C:  IOR.B   #0,W0L
0153E:  BTSC.B  42.1
01540:  BRA     154C
01542:  INC     W5,W5
01544:  MOV.B   W0L,84E
01546:  CALL    68A
0154A:  BRA     1536
....................        LCDsetCursor(0x4D); LCDMsg("<--"); // стирание стрелки от предыдущего 
0154C:  MOV.B   #4D,W0L
0154E:  MOV.B   W0L,84A
01550:  CALL    694
01554:  MOV     #0,W5
01556:  MOV     W5,W0
01558:  CALL    2BC
0155C:  IOR.B   #0,W0L
0155E:  BTSC.B  42.1
01560:  BRA     156C
01562:  INC     W5,W5
01564:  MOV.B   W0L,84E
01566:  CALL    68A
0156A:  BRA     1556
....................        LCDsetCursor(0x1D); LCDMsg("   "); // элемента меню 
0156C:  MOV.B   #1D,W0L
0156E:  MOV.B   W0L,84A
01570:  CALL    694
01574:  MOV     #0,W5
01576:  MOV     W5,W0
01578:  CALL    2CC
0157C:  IOR.B   #0,W0L
0157E:  BTSC.B  42.1
01580:  BRA     158C
01582:  INC     W5,W5
01584:  MOV.B   W0L,84E
01586:  CALL    68A
0158A:  BRA     1576
....................        LCDsetCursor(0x5D); LCDMsg("   "); 
0158C:  MOV.B   #5D,W0L
0158E:  MOV.B   W0L,84A
01590:  CALL    694
01594:  MOV     #0,W5
01596:  MOV     W5,W0
01598:  CALL    2CC
0159C:  IOR.B   #0,W0L
0159E:  BTSC.B  42.1
015A0:  BRA     15AC
015A2:  INC     W5,W5
015A4:  MOV.B   W0L,84E
015A6:  CALL    68A
015AA:  BRA     1596
....................     break; 
015AC:  GOTO    16B8
....................      
....................     case 2:  
....................        LCDsetCursor(0x0D); LCDMsg("   "); 
015B0:  MOV.B   #D,W0L
015B2:  MOV.B   W0L,84A
015B4:  CALL    694
015B8:  MOV     #0,W5
015BA:  MOV     W5,W0
015BC:  CALL    2CC
015C0:  IOR.B   #0,W0L
015C2:  BTSC.B  42.1
015C4:  BRA     15D0
015C6:  INC     W5,W5
015C8:  MOV.B   W0L,84E
015CA:  CALL    68A
015CE:  BRA     15BA
....................        LCDsetCursor(0x4D); LCDMsg("   "); // стирание стрелки от предыдущего 
015D0:  MOV.B   #4D,W0L
015D2:  MOV.B   W0L,84A
015D4:  CALL    694
015D8:  MOV     #0,W5
015DA:  MOV     W5,W0
015DC:  CALL    2CC
015E0:  IOR.B   #0,W0L
015E2:  BTSC.B  42.1
015E4:  BRA     15F0
015E6:  INC     W5,W5
015E8:  MOV.B   W0L,84E
015EA:  CALL    68A
015EE:  BRA     15DA
....................        LCDsetCursor(0x1D); LCDMsg("<--"); // элемента меню 
015F0:  MOV.B   #1D,W0L
015F2:  MOV.B   W0L,84A
015F4:  CALL    694
015F8:  MOV     #0,W5
015FA:  MOV     W5,W0
015FC:  CALL    2BC
01600:  IOR.B   #0,W0L
01602:  BTSC.B  42.1
01604:  BRA     1610
01606:  INC     W5,W5
01608:  MOV.B   W0L,84E
0160A:  CALL    68A
0160E:  BRA     15FA
....................        LCDsetCursor(0x5D); LCDMsg("   "); 
01610:  MOV.B   #5D,W0L
01612:  MOV.B   W0L,84A
01614:  CALL    694
01618:  MOV     #0,W5
0161A:  MOV     W5,W0
0161C:  CALL    2CC
01620:  IOR.B   #0,W0L
01622:  BTSC.B  42.1
01624:  BRA     1630
01626:  INC     W5,W5
01628:  MOV.B   W0L,84E
0162A:  CALL    68A
0162E:  BRA     161A
....................     break; 
01630:  GOTO    16B8
....................      
....................     case 3:  
....................        LCDsetCursor(0x0D); LCDMsg("   "); 
01634:  MOV.B   #D,W0L
01636:  MOV.B   W0L,84A
01638:  CALL    694
0163C:  MOV     #0,W5
0163E:  MOV     W5,W0
01640:  CALL    2CC
01644:  IOR.B   #0,W0L
01646:  BTSC.B  42.1
01648:  BRA     1654
0164A:  INC     W5,W5
0164C:  MOV.B   W0L,84E
0164E:  CALL    68A
01652:  BRA     163E
....................        LCDsetCursor(0x4D); LCDMsg("   "); // стирание стрелки от предыдущего 
01654:  MOV.B   #4D,W0L
01656:  MOV.B   W0L,84A
01658:  CALL    694
0165C:  MOV     #0,W5
0165E:  MOV     W5,W0
01660:  CALL    2CC
01664:  IOR.B   #0,W0L
01666:  BTSC.B  42.1
01668:  BRA     1674
0166A:  INC     W5,W5
0166C:  MOV.B   W0L,84E
0166E:  CALL    68A
01672:  BRA     165E
....................        LCDsetCursor(0x1D); LCDMsg("   "); // элемента меню 
01674:  MOV.B   #1D,W0L
01676:  MOV.B   W0L,84A
01678:  CALL    694
0167C:  MOV     #0,W5
0167E:  MOV     W5,W0
01680:  CALL    2CC
01684:  IOR.B   #0,W0L
01686:  BTSC.B  42.1
01688:  BRA     1694
0168A:  INC     W5,W5
0168C:  MOV.B   W0L,84E
0168E:  CALL    68A
01692:  BRA     167E
....................        LCDsetCursor(0x5D); LCDMsg("<--"); 
01694:  MOV.B   #5D,W0L
01696:  MOV.B   W0L,84A
01698:  CALL    694
0169C:  MOV     #0,W5
0169E:  MOV     W5,W0
016A0:  CALL    2BC
016A4:  IOR.B   #0,W0L
016A6:  BTSC.B  42.1
016A8:  BRA     16B4
016AA:  INC     W5,W5
016AC:  MOV.B   W0L,84E
016AE:  CALL    68A
016B2:  BRA     169E
....................     break; 
016B4:  GOTO    16B8
....................    }   
.................... } 
016B8:  MOV     [--W15],W5
016BA:  RETURN  
....................  
.................... static void Full_dev_reset(){ 
*
00C2C:  MOV     W5,[W15++]
....................   LCDClear(); 
00C2E:  CALL    646
....................   LCDsetCursor(one); 
00C32:  CLR.B   84A
00C34:  CALL    694
....................   LCDMsg("   Reset done"); 
00C38:  MOV     #0,W5
00C3A:  MOV     W5,W0
00C3C:  CALL    2DC
00C40:  IOR.B   #0,W0L
00C42:  BTSC.B  42.1
00C44:  BRA     C50
00C46:  INC     W5,W5
00C48:  MOV.B   W0L,84E
00C4A:  CALL    68A
00C4E:  BRA     C3A
....................   LCDsetCursor(three); 
00C50:  MOV.B   #10,W0L
00C52:  MOV.B   W0L,84A
00C54:  CALL    694
....................   LCDMsg("Starting device!"); 
00C58:  MOV     #0,W5
00C5A:  MOV     W5,W0
00C5C:  CALL    2F6
00C60:  IOR.B   #0,W0L
00C62:  BTSC.B  42.1
00C64:  BRA     C70
00C66:  INC     W5,W5
00C68:  MOV.B   W0L,84E
00C6A:  CALL    68A
00C6E:  BRA     C5A
....................   delay_ms(1000); 
00C70:  MOV     #3E8,W0
00C72:  CALL    522
....................   OscSetup(); 
00C76:  CALL    492
....................   MCU_init(); 
00C7A:  CALL    4CE
....................   LCDInit(); 
00C7E:  CALL    5A6
....................   reset_fl = 0; 
00C82:  BCLR.B  832.2
....................   ADC_wakeUp(); 
00C84:  CALL    7AA
....................   ADC_wakeUp();  
00C88:  CALL    7AA
....................   ADC_init(); 
00C8C:  CALL    8F4
....................   ADC_set_PGA(8); 
00C90:  MOV.B   #8,W0L
00C92:  MOV.B   W0L,84A
00C94:  CALL    824
....................   ADC_sps_set(0x23); //0x023 - 10 sps, 0x43 - 25 sps, 0x63 - 50 sps 
00C98:  MOV.B   #23,W0L
00C9A:  MOV.B   W0L,84A
00C9C:  CALL    8DE
....................                      //0x82 - 100 sps, 0x91 - 500 sps 
....................                      //0xA1 - 1000 sps, 0xC0 - 3750 sps 
....................   ADC_SelfCal(); 
00CA0:  CALL    990
....................   meas_stop_fl = 0; // вкл. режим измерений 
00CA4:  BCLR.B  832.0
....................   menu_fl = 0;      // отключение меню 
00CA6:  CLR.B   831
....................   menu_item = 0;    // сброс элемента меню 
00CA8:  CLR.B   82F
....................   NumAver = 1;      // сброс величины усреднения данных АЦП 
00CAA:  MOV.B   #1,W0L
00CAC:  MOV.B   W0L,833
....................   LCDClear();       // очистка дисплея 
00CAE:  CALL    646
....................  
.................... } 
00CB2:  MOV     [--W15],W5
00CB4:  RETURN  
....................  
.................... static void ADC_rd_and_print_ch(U8 chanel){ 
....................  
....................    switch (chanel){ 
.................... //---------------- 1 датчик --------------------------------------//      
....................  case 1:  
....................   LCDsetCursor(one); 
....................   LCDMsg("CTP"); 
....................   LCDMsg(":"); 
....................   ADCaddCoef = 22;      // смещение нуля для канала 1 
....................   ADCmulCoef = 0.99978; // мультипликат. ошибка для канала 1 
....................   ADC_setCh(4); 
....................   Final_T_in_K = ADC_vol_to_T(); 
....................   LCDPutU32(temp,4); 
....................   LCDsetCursor(0x0A); 
....................   LCDPutU16(Final_T_in_K,LCD_num_symb); 
....................   LCDMsg("."); 
....................   LCDPutU16(ostatok_int_dec,1); 
....................   if(LCD_num_symb==1){LCDMsg("K  ");} //очистка строки  
....................   if(LCD_num_symb==2){LCDMsg("K "); } 
....................   if(LCD_num_symb==3){LCDMsg("K");  } 
....................   Printf("a%05Lu\n",temp); 
....................   LCDsetCursor(0x03); 
....................   LCDMsg(" ");  
....................    
....................  break; 
.................... //---------------- 2 датчик --------------------------------------// 
....................  case 2:  
....................   LCDsetCursor(two); 
....................   LCDMsg("C"); 
....................   LCDputCH(0xA8);// П 
....................   LCDMsg(" :"); 
....................   ADCaddCoef =7;         // смещение нуля для канала 2 
....................   ADCmulCoef =0.999769;  // мультипликат. ошибка для канала 2 
....................   ADC_setCh(3); 
....................   Final_T_in_K = ADC_vol_to_T(); 
....................   LCDPutU32(temp,4); 
....................   LCDsetCursor(0x4A); 
....................   LCDPutU16(Final_T_in_K,LCD_num_symb); 
....................   LCDMsg("."); 
....................   LCDPutU16(ostatok_int_dec,1); 
....................   if(LCD_num_symb==1){LCDMsg("K  ");} //очистка строки  
....................   if(LCD_num_symb==2){LCDMsg("K "); } 
....................   if(LCD_num_symb==3){LCDMsg("K");  } 
....................   Printf("b%05Lu\n",temp); 
....................   LCDsetCursor(0x43); 
....................   LCDMsg(" "); 
....................  break; 
.................... //---------------- 3 датчик --------------------------------------//   
....................  case 3:  
....................   LCDsetCursor(three); 
....................   LCDputCH(0xA8);// П 
....................   LCDMsg('E'); 
....................   LCDMsg('P'); 
....................   LCDMsg(':'); 
....................   ADCaddCoef =30;        // смещение нуля для канала 3 
....................   ADCmulCoef =0.999795;  // мультипликат. ошибка для канала 3 
....................   ADC_setCh(2); 
....................   Final_T_in_K = ADC_vol_to_T(); 
....................   LCDPutU32(temp,4); 
....................   LCDMsg(" "); 
....................   LCDPutU16(Final_T_in_K,LCD_num_symb); 
....................   LCDMsg("."); 
....................   LCDPutU16(ostatok_int_dec,1); 
....................   if(LCD_num_symb==1){LCDMsg("K  ");} //очистка строки  
....................   if(LCD_num_symb==2){LCDMsg("K "); } 
....................   if(LCD_num_symb==3){LCDMsg("K");  } 
....................   Printf("c%05Lu\n",temp); 
....................   LCDsetCursor(0x13); 
....................   LCDMsg(" "); 
....................  break; 
.................... //---------------- 4 датчик --------------------------------------//     
....................    case 4:  
....................   LCDsetCursor(four); 
....................   LCDMsg("CO"); 
....................   LCDputCH(0xA7); // Л 
....................   LCDMsg(":"); 
....................   ADCaddCoef = 83;         // смещение нуля для канала 4 
....................   ADCmulCoef = 0.99985;         // мультипликат. ошибка для канала 4 
....................   ADC_setCh(1); 
....................   Final_T_in_K = ADC_vol_to_T(); 
....................   LCDPutU32(temp,4); 
....................   LCDMsg(" "); 
....................   LCDPutU16(Final_T_in_K,LCD_num_symb); 
....................   LCDMsg("."); 
....................   LCDPutU16(ostatok_int_dec,1); 
....................   if(LCD_num_symb==1){LCDMsg("K  ");} //очистка строки  
....................   if(LCD_num_symb==2){LCDMsg("K "); } 
....................   if(LCD_num_symb==3){LCDMsg("K");  } 
....................   Printf("d%05Lu\n",temp); 
....................   LCDsetCursor(0x53); 
....................   LCDMsg(" ");  
....................    break; 
.................... //----------------------------------------------------------------//    
....................    } 
....................  
.................... } 
....................  
.................... static void save_to_flash(){ 
....................        
....................    Sps_Wr = NumAver; 
*
01940:  MOV.B   833,W0L
01942:  MOV.B   W0L,82D
....................    Aver_Wr = ADC_sps_var; // сохранение sps значения во флеш 
01944:  MOV.B   834,W0L
01946:  MOV.B   W0L,82C
....................    CRC_Wr = CRC8(flash_wr_data,2); 
01948:  MOV     #2,W4
0194A:  MOV     W4,84C
0194C:  MOV     #828,W4
0194E:  MOV     W4,84A
01950:  CALL    766
01954:  MOV.B   W0L,82E
....................    Wr_Flash(); 
01956:  CALL    1920
....................     
....................    }  
0195A:  RETURN  
....................  
.................... #int_cni 
.................... static void cn_irq_handler(void) { 
*
00418:  PUSH    42
0041A:  PUSH    36
0041C:  MOV     W0,[W15++]
0041E:  MOV     #2,W0
00420:  REPEAT  #C
00422:  MOV     [W0++],[W15++]
....................  
....................    DisableInt();                    // отключение прерываний для обработки дребезка  
00424:  CALL    404
....................    meas_stop_fl = 1;                // взвод флага остановки измерений 
00428:  BSET.B  832.0
....................    menu_fl = 1;                     // взвод флага перехода в меню 
0042A:  MOV.B   #1,W0L
0042C:  MOV.B   W0L,831
....................     if (menu_item == 1) 
0042E:  MOV     82E,W4
00430:  LSR     W4,#8,W4
00432:  CP.B    W4L,#1
00434:  BRA     NZ,448
....................   { 
....................     if (menu_sel>3) {menu_sel=0;} 
00436:  MOV     830,W4
00438:  CP.B    W4L,#3
0043A:  BRA     LE,43E
0043C:  CLR.B   830
....................     if (menu_sel<0) {menu_sel=3;} 
0043E:  MOV     830,W4
00440:  CP.B    W4L,#0
00442:  BRA     GE,448
00444:  MOV.B   #3,W0L
00446:  MOV.B   W0L,830
....................   } 
....................    if (CN2==1) {menu_item = 1;} 
00448:  BTSS.B  2C8.4
0044A:  BRA     450
0044C:  MOV.B   #1,W0L
0044E:  MOV.B   W0L,82F
....................    if (CN3==1) {menu_sel--;} 
00450:  BTSS.B  2C8.2
00452:  BRA     456
00454:  DEC.B   0830
....................    if (CN4==1) {menu_sel++;} 
00456:  BTSS.B  2C8.3
00458:  BRA     45C
0045A:  INC.B   0830
....................    clear_interrupt(INTR_CN_PIN); 
0045C:  BCLR.B  82.7
....................  
.................... } 
....................  
0045E:  BCLR.B  86.3
00460:  MOV     #1A,W0
00462:  REPEAT  #C
00464:  MOV     [--W15],[W0--]
00466:  MOV     [--W15],W0
00468:  POP     36
0046A:  POP     42
0046C:  RETFIE  
.................... #int_timer1 
.................... static void timer1_irq_handler(void) { 
0046E:  PUSH    42
00470:  PUSH    36
00472:  MOV     W0,[W15++]
00474:  MOV     #2,W0
00476:  REPEAT  #C
00478:  MOV     [W0++],[W15++]
.................... restart_wdt();     // сбос собачего таймера 
0047A:  CLRWDT  
.................... set_timer1(20000); //reset the timer. 
0047C:  MOV     #4E20,W4
0047E:  MOV     W4,100
.................... clear_interrupt(int_timer1); 
00480:  BCLR.B  84.3
.................... } 
....................  
....................  
.................... /*############################################################################*/ 
....................  
00482:  BCLR.B  84.3
00484:  MOV     #1A,W0
00486:  REPEAT  #C
00488:  MOV     [--W15],[W0--]
0048A:  MOV     [--W15],W0
0048C:  POP     36
0048E:  POP     42
00490:  RETFIE  
.................... static void main() 
.................... {  
*
0195C:  MOV     #4444,W0
0195E:  MOV     W0,A4
01960:  MOV     #4444,W0
01962:  MOV     W0,AC
01964:  BSET.B  81.7
01966:  BCLR.B  261.7
01968:  BCLR.B  2E5.0
0196A:  BSET.B  2E4.7
0196C:  BCLR.B  2E4.6
0196E:  BCLR.B  260.6
01970:  MOV     #3B,W4
01972:  MOV     W4,262
01974:  BSET.B  261.7
01976:  MOV     #8000,W4
01978:  MOV     W4,230
0197A:  MOV     #400,W4
0197C:  MOV     W4,232
0197E:  MOV     #103,W4
01980:  MOV     W4,238
01982:  CLR     800
01984:  CLR     802
01986:  CLR     804
01988:  CLR     806
0198A:  CLR     808
0198C:  CLR     80A
0198E:  CLR     80C
01990:  CLR     80E
01992:  CLR     810
01994:  CLR     812
01996:  CLR.B   81A
01998:  CLR     822
0199A:  CLR     824
0199C:  CLR.B   826
0199E:  MOV.B   #1,W0L
019A0:  MOV.B   W0L,827
019A2:  CLR.B   82C
019A4:  CLR.B   82D
019A6:  CLR.B   82E
019A8:  CLR.B   82F
019AA:  CLR.B   830
019AC:  CLR.B   831
019AE:  BCLR.B  832.0
019B0:  BSET.B  832.1
019B2:  BCLR.B  832.2
019B4:  MOV.B   #1,W0L
019B6:  MOV.B   W0L,833
019B8:  MOV.B   #1,W0L
019BA:  MOV.B   W0L,834
019BC:  MOV.B   #FF,W0L
019BE:  MOV.B   W0L,835
019C0:  SETM.B  836
019C2:  CLR     83C
019C4:  CLR     83E
019C6:  CLR     840
019C8:  CLR     842
019CA:  SETM    32C
019CC:  SETM    32A
019CE:  MOV     #1F80,W15
019D0:  MOV     #1FFF,W0
019D2:  MOV     W0,20
019D4:  NOP     
019D6:  CLR     814
019D8:  CLR     816
019DA:  CLR.B   818
019DC:  CLR.B   819
019DE:  CLR     81C
019E0:  CLR     81E
019E2:  CLR     820
019E4:  CLR     828
019E6:  CLR     82A
019E8:  CLR.B   844
019EA:  MOV     #1F80,W15
019EC:  MOV     #1FFF,W0
019EE:  MOV     W0,20
019F0:  NOP     
019F2:  CLR     846
019F4:  CLR     848
....................   S32 ADC_voltage = 0; 
....................   OscSetup(); 
019F6:  CALL    492
....................   MCU_init();         
019FA:  CALL    4CE
....................  
....................   LCDInit(); 
019FE:  CALL    5A6
....................   lCDwelcome(); 
01A02:  CALL    6A8
....................  
....................   LCDSetCursor(one); 
01A06:  CLR.B   84A
01A08:  CALL    694
....................   LCDMsg("  Reading data"); 
01A0C:  MOV     #0,W5
01A0E:  MOV     W5,W0
01A10:  CALL    314
01A14:  IOR.B   #0,W0L
01A16:  BTSC.B  42.1
01A18:  BRA     1A24
01A1A:  INC     W5,W5
01A1C:  MOV.B   W0L,84E
01A1E:  CALL    68A
01A22:  BRA     1A0E
....................   LCDSetCursor(two); 
01A24:  MOV.B   #40,W0L
01A26:  MOV.B   W0L,84A
01A28:  CALL    694
....................   LCDMsg("   from ROM..."); 
01A2C:  MOV     #0,W5
01A2E:  MOV     W5,W0
01A30:  CALL    330
01A34:  IOR.B   #0,W0L
01A36:  BTSC.B  42.1
01A38:  BRA     1A44
01A3A:  INC     W5,W5
01A3C:  MOV.B   W0L,84E
01A3E:  CALL    68A
01A42:  BRA     1A2E
....................    
....................   Rd_Flash();                        // чтение денных из флеш для расчета контр. суммы 
01A44:  CALL    742
....................   crc1 = CRC_buf;                    // сохраненная контр. сумма     
01A48:  MOV.B   837,W0L
01A4A:  MOV.B   W0L,835
....................   crc2 = CRC8(flash_rd_data,2);      // текущая контр. сумма 
01A4C:  MOV     #2,W4
01A4E:  MOV     W4,84C
01A50:  MOV     #838,W4
01A52:  MOV     W4,84A
01A54:  CALL    766
01A58:  MOV.B   W0L,836
....................    
....................   LCDSetCursor(three); 
01A5A:  MOV.B   #10,W0L
01A5C:  MOV.B   W0L,84A
01A5E:  CALL    694
....................    
....................   if (crc1==crc2){LCDMsg("       OK!");} 
01A62:  MOV.B   835,W0L
01A64:  CP.B    836
01A66:  BRA     NZ,1A84
01A68:  MOV     #0,W5
01A6A:  MOV     W5,W0
01A6C:  CALL    34C
01A70:  IOR.B   #0,W0L
01A72:  BTSC.B  42.1
01A74:  BRA     1A80
01A76:  INC     W5,W5
01A78:  MOV.B   W0L,84E
01A7A:  CALL    68A
01A7E:  BRA     1A6A
....................   else { 
01A80:  GOTO    1AA4
....................   LCDMsg("   CRC error!"); 
01A84:  MOV     #0,W5
01A86:  MOV     W5,W0
01A88:  CALL    364
01A8C:  IOR.B   #0,W0L
01A8E:  BTSC.B  42.1
01A90:  BRA     1A9C
01A92:  INC     W5,W5
01A94:  MOV.B   W0L,84E
01A96:  CALL    68A
01A9A:  BRA     1A86
....................   ADC_sps_var = 2;   // сброс значений по умолчанию  
01A9C:  MOV.B   #2,W0L
01A9E:  MOV.B   W0L,834
....................   NumAver = 1;       // тк произошел сбой контр. суммы 
01AA0:  MOV.B   #1,W0L
01AA2:  MOV.B   W0L,833
....................    } 
....................     
....................       ADC_wakeUp();      // Сброс АЦП  
01AA4:  CALL    7AA
....................       ADC_wakeUp();      // перед инициализацией 
01AA8:  CALL    7AA
....................       ADC_init();        // Инициализация АЦП 
01AAC:  CALL    8F4
....................       ADC_SelfCal();     // Автокалибровка АЦП 
01AB0:  CALL    990
....................  
....................   delay_ms(2000); 
01AB4:  MOV     #7D0,W0
01AB6:  CALL    522
....................          
....................   LCDclear(); 
01ABA:  CALL    646
....................    
....................   ADCaddCoef = 22;      // смещение нуля для канала 1 
01ABE:  MOV     #16,W4
01AC0:  MOV     W4,81C
....................   ADCmulCoef = 0.99978; // мультипликат. ошибка для канала 1 
01AC2:  MOV     #F195,W4
01AC4:  MOV     W4,81E
01AC6:  MOV     #3F7F,W4
01AC8:  MOV     W4,820
....................   ADC_setCh(4); 
01ACA:  MOV.B   #4,W0L
01ACC:  MOV.B   W0L,84A
01ACE:  CALL    BB4
....................    
.................... /*############################################################################*/   
....................  
....................   while(true){ 
....................  
....................   if (reset_fl)     {Full_dev_reset();}        // полный сброс системы 
01AD2:  BTSS.B  832.2
01AD4:  BRA     1ADA
01AD6:  CALL    C2C
....................    
....................   if (!meas_stop_fl){// чтение АЦП 
01ADA:  BTSC.B  832.0
01ADC:  BRA     1B10
....................    
....................   ADC_voltage = Read_ADC_vol_in(uV); 
01ADE:  MOV     #4240,W4
01AE0:  MOV     W4,84A
01AE2:  MOV     #F,W4
01AE4:  MOV     W4,84C
01AE6:  CALL    11B0
01AEA:  MOV     W0,846
01AEC:  MOV     W1,848
....................   Printf("V%Ld\n\r",ADC_voltage); 
01AEE:  BTSC.B  233.1
01AF0:  BRA     1AEE
01AF2:  MOV     #56,W4
01AF4:  MOV     W4,234
01AF6:  MOV     846,W0
01AF8:  MOV     848,W1
01AFA:  MOV     #0,W4
01AFC:  CALL    12E2
01B00:  BTSC.B  233.1
01B02:  BRA     1B00
01B04:  MOV     #A,W4
01B06:  MOV     W4,234
01B08:  BTSC.B  233.1
01B0A:  BRA     1B08
01B0C:  MOV     #D,W4
01B0E:  MOV     W4,234
....................    
....................   }  
....................                                                // вывод на дисплей и UART 
....................   if (menu_fl){                                // вызов и обработка меню 
01B10:  CP0.B   831
01B12:  BRA     Z,1E4A
....................    
....................   if (LCD_clear_fl){LCD_clear_fl = 0; LCDClear();} // очистка экрана 
01B14:  BTSS.B  832.1
01B16:  BRA     1B1E
01B18:  BCLR.B  832.1
01B1A:  CALL    646
....................    
....................   Bpush_delay();                   // подавление дребезга кнопок 
01B1E:  CALL    13F6
....................   
....................   switch (menu_item){                   // древо меню 
01B22:  MOV.B   82F,W0L
01B24:  CLR.B   1
01B26:  XOR     #0,W0
01B28:  BRA     Z,1B3C
01B2A:  XOR     #1,W0
01B2C:  BRA     Z,1B42
01B2E:  XOR     #3,W0
01B30:  BRA     Z,1BD6
01B32:  XOR     #1,W0
01B34:  BRA     Z,1D58
01B36:  XOR     #7,W0
01B38:  BRA     Z,1DC6
01B3A:  BRA     1E4A
.................... /*----------------------------------------------------------------------------*/                                                            
....................   case 0: meas_stop_fl = 0; break;     // возврат в измерения 
01B3C:  BCLR.B  832.0
01B3E:  GOTO    1E4A
.................... /*----------------------------------------------------------------------------*/    
....................   case 1:  
....................           LCD_main_menu();             // ADC average set 
01B42:  CALL    148C
....................            if  (CN2 == 1){ 
01B46:  BTSS.B  2C8.4
01B48:  BRA     1BD2
....................             Bpush_delay(); 
01B4A:  CALL    13F6
....................             if ((CN2 == 1) & (menu_sel==0)){ // ADC sps set menu 
01B4E:  CLR.B   W0
01B50:  BTSC.B  2C8.4
01B52:  INC     W0,W0
01B54:  MOV.B   W0L,W6L
01B56:  CP0.B   830
01B58:  BRA     Z,1B60
01B5A:  CLR.B   W0
01B5C:  GOTO    1B62
01B60:  MOV.B   #1,W0L
01B62:  AND.B   W6L,W0L,W0L
01B64:  CP0.B   W0L
01B66:  BRA     Z,1B6E
....................                   LCD_clear_fl = 1; menu_item = 2; }    
01B68:  BSET.B  832.1
01B6A:  MOV.B   #2,W0L
01B6C:  MOV.B   W0L,82F
....................                    
....................             if ((CN2 == 1) & (menu_sel==1)){ // ADC average set 
01B6E:  CLR.B   W0
01B70:  BTSC.B  2C8.4
01B72:  INC     W0,W0
01B74:  MOV.B   W0L,W6L
01B76:  MOV     830,W4
01B78:  CP.B    W4L,#1
01B7A:  BRA     Z,1B82
01B7C:  CLR.B   W0
01B7E:  GOTO    1B84
01B82:  MOV.B   #1,W0L
01B84:  AND.B   W6L,W0L,W0L
01B86:  CP0.B   W0L
01B88:  BRA     Z,1B90
....................                   LCD_clear_fl = 1; menu_item = 3; } 
01B8A:  BSET.B  832.1
01B8C:  MOV.B   #3,W0L
01B8E:  MOV.B   W0L,82F
....................                    
....................             if ((CN2 == 1) & (menu_sel==2)){ // Reset device 
01B90:  CLR.B   W0
01B92:  BTSC.B  2C8.4
01B94:  INC     W0,W0
01B96:  MOV.B   W0L,W6L
01B98:  MOV     830,W4
01B9A:  CP.B    W4L,#2
01B9C:  BRA     Z,1BA4
01B9E:  CLR.B   W0
01BA0:  GOTO    1BA6
01BA4:  MOV.B   #1,W0L
01BA6:  AND.B   W6L,W0L,W0L
01BA8:  CP0.B   W0L
01BAA:  BRA     Z,1BB2
....................                   LCD_clear_fl = 1; menu_item = 4; }                    
01BAC:  BSET.B  832.1
01BAE:  MOV.B   #4,W0L
01BB0:  MOV.B   W0L,82F
....................    
....................             if ((CN2 == 1) & (menu_sel==3)){ // Return back 
01BB2:  CLR.B   W0
01BB4:  BTSC.B  2C8.4
01BB6:  INC     W0,W0
01BB8:  MOV.B   W0L,W6L
01BBA:  MOV     830,W4
01BBC:  CP.B    W4L,#3
01BBE:  BRA     Z,1BC6
01BC0:  CLR.B   W0
01BC2:  GOTO    1BC8
01BC6:  MOV.B   #1,W0L
01BC8:  AND.B   W6L,W0L,W0L
01BCA:  CP0.B   W0L
01BCC:  BRA     Z,1BD2
....................                   LCD_clear_fl = 1; menu_item--; }} 
01BCE:  BSET.B  832.1
01BD0:  DEC.B   082F
....................             break; 
01BD2:  GOTO    1E4A
.................... /*----------------------------------------------------------------------------*/   
....................    case 2:                               // ADC sps set menu 
....................     
....................    LCDsetCursor(one); 
01BD6:  CLR.B   84A
01BD8:  CALL    694
....................    LCDMsg("Samples per sec."); 
01BDC:  MOV     #0,W5
01BDE:  MOV     W5,W0
01BE0:  CALL    37E
01BE4:  IOR.B   #0,W0L
01BE6:  BTSC.B  42.1
01BE8:  BRA     1BF4
01BEA:  INC     W5,W5
01BEC:  MOV.B   W0L,84E
01BEE:  CALL    68A
01BF2:  BRA     1BDE
....................    LCDsetCursor(three); 
01BF4:  MOV.B   #10,W0L
01BF6:  MOV.B   W0L,84A
01BF8:  CALL    694
....................    if(CN4){Bpush_delay(); if(CN4) ADC_sps_var=ADC_sps_var-1; delay_ms(200);} 
01BFC:  BTSS.B  2C8.3
01BFE:  BRA     1C14
01C00:  CALL    13F6
01C04:  BTSS.B  2C8.3
01C06:  BRA     1C0E
01C08:  MOV     834,W4
01C0A:  SUB.B   W4L,#1,W0L
01C0C:  MOV.B   W0L,834
01C0E:  MOV     #C8,W0
01C10:  CALL    522
....................    if(CN3){Bpush_delay(); if(CN3) ADC_sps_var=ADC_sps_var+1; delay_ms(200);} 
01C14:  BTSS.B  2C8.2
01C16:  BRA     1C2E
01C18:  CALL    13F6
01C1C:  BTSS.B  2C8.2
01C1E:  BRA     1C28
01C20:  MOV     834,W4
01C22:  ADD.B   W4L,#1,W4L
01C24:  MOV.B   W4L,W0L
01C26:  MOV.B   W0L,834
01C28:  MOV     #C8,W0
01C2A:  CALL    522
....................    if(ADC_sps_var>7)  ADC_sps_var = 7; 
01C2E:  MOV     834,W4
01C30:  CP.B    W4L,#7
01C32:  BRA     LEU,1C38
01C34:  MOV.B   #7,W0L
01C36:  MOV.B   W0L,834
....................    if(ADC_sps_var==0) ADC_sps_var = 1; 
01C38:  CP0.B   834
01C3A:  BRA     NZ,1C40
01C3C:  MOV.B   #1,W0L
01C3E:  MOV.B   W0L,834
....................     switch (ADC_sps_var){                // передача величины скорости измерений АЦП  
01C40:  MOV.B   834,W0L
01C42:  CLR.B   1
01C44:  XOR     #1,W0
01C46:  BRA     Z,1C62
01C48:  XOR     #3,W0
01C4A:  BRA     Z,1C84
01C4C:  XOR     #1,W0
01C4E:  BRA     Z,1CA6
01C50:  XOR     #7,W0
01C52:  BRA     Z,1CC8
01C54:  XOR     #1,W0
01C56:  BRA     Z,1CEA
01C58:  XOR     #3,W0
01C5A:  BRA     Z,1D0C
01C5C:  XOR     #1,W0
01C5E:  BRA     Z,1D2E
01C60:  BRA     1D50
....................       case 1: ADC_sps_set(0x23); LCDsetCursor(0x16); LCDputU16(10,4);  break; // 10   sps 
01C62:  MOV.B   #23,W0L
01C64:  MOV.B   W0L,84A
01C66:  CALL    8DE
01C6A:  MOV.B   #16,W0L
01C6C:  MOV.B   W0L,84A
01C6E:  CALL    694
01C72:  MOV     #A,W4
01C74:  MOV     W4,84A
01C76:  CLR     84C
01C78:  MOV.B   #4,W0L
01C7A:  MOV.B   W0L,84E
01C7C:  CALL    1740
01C80:  GOTO    1D50
....................       case 2: ADC_sps_set(0x43); LCDsetCursor(0x16); LCDputU16(25,4);  break; // 25   sps 
01C84:  MOV.B   #43,W0L
01C86:  MOV.B   W0L,84A
01C88:  CALL    8DE
01C8C:  MOV.B   #16,W0L
01C8E:  MOV.B   W0L,84A
01C90:  CALL    694
01C94:  MOV     #19,W4
01C96:  MOV     W4,84A
01C98:  CLR     84C
01C9A:  MOV.B   #4,W0L
01C9C:  MOV.B   W0L,84E
01C9E:  CALL    1740
01CA2:  GOTO    1D50
....................       case 3: ADC_sps_set(0x63); LCDsetCursor(0x16); LCDputU16(50,4);  break; // 50   sps 
01CA6:  MOV.B   #63,W0L
01CA8:  MOV.B   W0L,84A
01CAA:  CALL    8DE
01CAE:  MOV.B   #16,W0L
01CB0:  MOV.B   W0L,84A
01CB2:  CALL    694
01CB6:  MOV     #32,W4
01CB8:  MOV     W4,84A
01CBA:  CLR     84C
01CBC:  MOV.B   #4,W0L
01CBE:  MOV.B   W0L,84E
01CC0:  CALL    1740
01CC4:  GOTO    1D50
....................       case 4: ADC_sps_set(0x82); LCDsetCursor(0x16); LCDputU16(100,4); break; // 100  sps 
01CC8:  MOV.B   #82,W0L
01CCA:  MOV.B   W0L,84A
01CCC:  CALL    8DE
01CD0:  MOV.B   #16,W0L
01CD2:  MOV.B   W0L,84A
01CD4:  CALL    694
01CD8:  MOV     #64,W4
01CDA:  MOV     W4,84A
01CDC:  CLR     84C
01CDE:  MOV.B   #4,W0L
01CE0:  MOV.B   W0L,84E
01CE2:  CALL    1740
01CE6:  GOTO    1D50
....................       case 5: ADC_sps_set(0x91); LCDsetCursor(0x16); LCDputU16(500,4); break; // 500  sps 
01CEA:  MOV.B   #91,W0L
01CEC:  MOV.B   W0L,84A
01CEE:  CALL    8DE
01CF2:  MOV.B   #16,W0L
01CF4:  MOV.B   W0L,84A
01CF6:  CALL    694
01CFA:  MOV.B   #4,W0L
01CFC:  MOV.B   W0L,84E
01CFE:  MOV     #1F4,W4
01D00:  MOV     W4,84A
01D02:  CLR     84C
01D04:  CALL    1740
01D08:  GOTO    1D50
....................       case 6: ADC_sps_set(0xA1); LCDsetCursor(0x16); LCDputU16(1000,4);break; // 1000 sps 
01D0C:  MOV.B   #A1,W0L
01D0E:  MOV.B   W0L,84A
01D10:  CALL    8DE
01D14:  MOV.B   #16,W0L
01D16:  MOV.B   W0L,84A
01D18:  CALL    694
01D1C:  MOV.B   #4,W0L
01D1E:  MOV.B   W0L,84E
01D20:  MOV     #3E8,W4
01D22:  MOV     W4,84A
01D24:  CLR     84C
01D26:  CALL    1740
01D2A:  GOTO    1D50
....................       case 7: ADC_sps_set(0xC0); LCDsetCursor(0x16); LCDputU16(3750,4);break; // 3750 sps 
01D2E:  MOV.B   #C0,W0L
01D30:  MOV.B   W0L,84A
01D32:  CALL    8DE
01D36:  MOV.B   #16,W0L
01D38:  MOV.B   W0L,84A
01D3A:  CALL    694
01D3E:  MOV.B   #4,W0L
01D40:  MOV.B   W0L,84E
01D42:  MOV     #EA6,W4
01D44:  MOV     W4,84A
01D46:  CLR     84C
01D48:  CALL    1740
01D4C:  GOTO    1D50
....................       }      
....................    save_to_flash(); 
01D50:  CALL    1940
....................    break;   
01D54:  GOTO    1E4A
.................... /*----------------------------------------------------------------------------*/ 
....................    case 3:                               // ADC average size menu 
....................     
....................    LCDsetCursor(one); 
01D58:  CLR.B   84A
01D5A:  CALL    694
....................    LCDMsg("    Average"); 
01D5E:  MOV     #0,W5
01D60:  MOV     W5,W0
01D62:  CALL    39C
01D66:  IOR.B   #0,W0L
01D68:  BTSC.B  42.1
01D6A:  BRA     1D76
01D6C:  INC     W5,W5
01D6E:  MOV.B   W0L,84E
01D70:  CALL    68A
01D74:  BRA     1D60
....................    LCDsetCursor(three); 
01D76:  MOV.B   #10,W0L
01D78:  MOV.B   W0L,84A
01D7A:  CALL    694
....................    if(CN4){Bpush_delay(); if(CN4) --NumAver; delay_ms(100);} // декремент величины усреднения 
01D7E:  BTSS.B  2C8.3
01D80:  BRA     1D92
01D82:  CALL    13F6
01D86:  BTSS.B  2C8.3
01D88:  BRA     1D8C
01D8A:  DEC.B   0833
01D8C:  MOV     #64,W0
01D8E:  CALL    522
....................    if(CN3){Bpush_delay(); if(CN3) ++NumAver; delay_ms(100);} // инкремент величины усреднения 
01D92:  BTSS.B  2C8.2
01D94:  BRA     1DA6
01D96:  CALL    13F6
01D9A:  BTSS.B  2C8.2
01D9C:  BRA     1DA0
01D9E:  INC.B   0833
01DA0:  MOV     #64,W0
01DA2:  CALL    522
....................    LCDsetCursor(0x16); 
01DA6:  MOV.B   #16,W0L
01DA8:  MOV.B   W0L,84A
01DAA:  CALL    694
....................    LCDputU16(NumAver,3); 
01DAE:  MOV.B   833,W0L
01DB0:  MOV.B   W0L,84A
01DB2:  CLR.B   84B
01DB4:  CLR     84C
01DB6:  MOV.B   #3,W0L
01DB8:  MOV.B   W0L,84E
01DBA:  CALL    1740
....................     
....................    save_to_flash(); 
01DBE:  CALL    1940
....................    break; 
01DC2:  GOTO    1E4A
.................... /*----------------------------------------------------------------------------*/   
....................    case 4:                               // Reset menu 
....................     
....................    LCDsetCursor(one); 
01DC6:  CLR.B   84A
01DC8:  CALL    694
....................    LCDMsg(" Reset device?"); 
01DCC:  MOV     #0,W5
01DCE:  MOV     W5,W0
01DD0:  CALL    3B4
01DD4:  IOR.B   #0,W0L
01DD6:  BTSC.B  42.1
01DD8:  BRA     1DE4
01DDA:  INC     W5,W5
01DDC:  MOV.B   W0L,84E
01DDE:  CALL    68A
01DE2:  BRA     1DCE
....................    LCDsetCursor(three); 
01DE4:  MOV.B   #10,W0L
01DE6:  MOV.B   W0L,84A
01DE8:  CALL    694
....................    LCDMsg("    Yes -> +"); 
01DEC:  MOV     #0,W5
01DEE:  MOV     W5,W0
01DF0:  CALL    3D0
01DF4:  IOR.B   #0,W0L
01DF6:  BTSC.B  42.1
01DF8:  BRA     1E04
01DFA:  INC     W5,W5
01DFC:  MOV.B   W0L,84E
01DFE:  CALL    68A
01E02:  BRA     1DEE
....................    LCDsetCursor(four); 
01E04:  MOV.B   #50,W0L
01E06:  MOV.B   W0L,84A
01E08:  CALL    694
....................    LCDMsg("    No  -> -"); 
01E0C:  MOV     #0,W5
01E0E:  MOV     W5,W0
01E10:  CALL    3EA
01E14:  IOR.B   #0,W0L
01E16:  BTSC.B  42.1
01E18:  BRA     1E24
01E1A:  INC     W5,W5
01E1C:  MOV.B   W0L,84E
01E1E:  CALL    68A
01E22:  BRA     1E0E
....................    if(CN3){Bpush_delay(); if(CN3) {reset_fl = 1;}}    // поднятие флага RESET для сброса всей системы 
01E24:  BTSS.B  2C8.2
01E26:  BRA     1E32
01E28:  CALL    13F6
01E2C:  BTSS.B  2C8.2
01E2E:  BRA     1E32
01E30:  BSET.B  832.2
....................    if(CN4){Bpush_delay(); if(CN4) {menu_item= 1;}}    // отмена и выход в меню 
01E32:  BTSS.B  2C8.3
01E34:  BRA     1E42
01E36:  CALL    13F6
01E3A:  BTSS.B  2C8.3
01E3C:  BRA     1E42
01E3E:  MOV.B   #1,W0L
01E40:  MOV.B   W0L,82F
....................     
....................    save_to_flash(); 
01E42:  CALL    1940
....................    break; 
01E46:  GOTO    1E4A
....................    }   
....................   }   
....................    
....................  } 
01E4A:  GOTO    1AD2
.................... } 
.................... /*############################################################################*/ 
01E4E:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 00CE   WRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0083   PR_PLL IESO
          H: FF00  
   Word  5L: 0006   HS NOOSCIO CKSFSM
          H: FF00  
   Word  6L: 00DD   WPOSTS14 WPRES128 WINDIS WDT
          H: FF00  
   Word  7L: 00E7   PUT128
          H: FF00  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: FF00  
