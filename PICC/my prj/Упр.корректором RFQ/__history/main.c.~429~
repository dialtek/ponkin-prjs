#include <main.h>
#INCLUDE <stdlib.h>
#use rs232(UART2,xmit=PIN_F5,rcv=PIN_F4,baud=115200,BRGH1OK,ERRORS,parity=N,bits=8)
 
    // коды каналов мультиплексора..
    U8 Mx_ch_code[9] = {0, 0x76, 0x54, 0x32, 0x10};

    U8 PGA;
    U8 PGA_val = 3; // PGA = 8
    U8 Sps_buf=0;
    //S16 ADCaddCoef = 1;
    //float ADCmulCoef = 1;
   
   U8 flash_wr_data [] = {0,0,0,0}; // заготовка массива для записи во флэш
   U8 Aver_Wr = 0;
   U8 Sps_Wr = 0;
   U8 CRC_Wr = 0;
   U8 ADC_select = 0; // флаг выбора АЦП: 1ый или 2ой

   int1 meas_stop_fl = 0;
   int1 reset_fl = 0;    // флаг сброса системы
   int1 stop_fl = 0;
   
   U8 NumAver = 1;       // размер усреднения
   U8 ADC_sps_var = 1;   // переменная усреднения данных АЦП 
   U8 CRC1=0xFF,CRC2=0xFF, CRC_buf;   // константы EEPROM CRC
   U8 flash_rd_data[4]; // заготовка массива для чтения из флэш

   //Ma - Moving Average
   S32 Ch_buf[8][128];  // буфер скользящего среднего для к1
   S32 Ch_buf_sum;     // сумма буфера скользящего среднего для к1

   U8 Ma_buf_index = 0; // индекс элемента скользящ. средн.
   U8 Ma_buf_size = 16;  // РАЗМЕР БУФЕРА!!!
   
   U8 RXd_buf[64]; // буфер для приема UART данных 
   U8 state;
   U16 tmp=0;
   
   static U8 wrptr=0,rdptr=0;
   static U8 RxData[16]; 
   
#include <ADS1256.h>

/*############################################################################*/

static void Rd_Flash(){

  read_program_memory(CK_USER_PAGE,flash_rd_data,4);
  delay_ms(5);
  NumAver = flash_rd_data[1]; 
  ADC_sps_var = flash_rd_data[0];
  CRC_buf = flash_rd_data[2];

}

static void Wr_Flash(){

  flash_wr_data[0] = Aver_Wr; 
  flash_wr_data[1] = Sps_Wr;
  flash_wr_data[2] = CRC_Wr;
  //flash_wr_data[4] = 0x00;
  write_program_memory(CK_USER_PAGE,flash_wr_data,4);
  delay_ms(2);

 //if(Rd_Flash(buf_index)==in_wr_data) return 1; else return 0;
}

unsigned char Crc8(unsigned char *pcBlock, unsigned int len)
{

  //Name  : CRC-8
  //Poly  : 0x31    x^8 + x^5 + x^4 + 1
  //Init  : 0xFF
  //Revert: false
  //XorOut: 0x00
  //Check : 0xF7 ("123456789")
  //MaxLen: 15 байт(127 бит) - обнаружение
  // одинарных, двойных, тройных и всех нечетных ошибок

    unsigned char crc = 0xFF;
    unsigned int i;
 
    while (len--)
    {
        crc ^= *pcBlock++;
 
        for (i = 0; i < 8; i++)
            crc = crc & 0x80 ? (crc << 1) ^ 0x31 : crc << 1;
    }
 
    return crc;
}

static void UART2_init(){

   U2MODE = (1<<15 | // UARTx is enabled
             1<<13 | // Discontinue operation when device enters Idle mode 
             0<<12 | // IrDA encoder and decoder disabled
             1<<11 | // 1 - UxRTS in Simplex mode, 0 - flow control mode
             2<<9  | // UxTX, UxRX, UxCTS and UxRTS pins are enabled and used
             1<<7  | // 1 = Wake-up enabled
             0<<6  | // 0 = Loopback mode is disabled
             0<<5  | // Auto-Baud Enable bit, disabled
             1<<4  | // Receive Polarity Inversion bit, 1 = UxRX Idle state is '0'
             0<<3  | // BRGH: High Baud Rate Select bit , 0 = Low speed
             0<<2  | // 00 = 8-bit data, no parity
             0      // 0 = One Stop bit
   );

}

static void OscSetup(){
  //Fcy=Fosc/2
  //Fin=10M
  //Fosc=Fin(M/(N1*N2))
  
  //U2BRG = 259;// BAUD Rate Setting for 9600
  //U2MODE = 0b1010101010000000; // brgh = 0
  U2BRG = 21;// BAUD Rate Setting for 115200
  U2MODE = 0b1010101010000000; // brgh = 0
  
  PLLFBD = 30; // ???. ????. ??????? PLL M = 30
  
  PLLPRE4 = 0; // ???. ????. ??????? PLL N1 = 2
  PLLPRE3 = 0;
  PLLPRE2 = 0;
  PLLPRE1 = 0;
  PLLPRE0 = 0;
  
  PLLPOST0=0; // ???. ????. ??????? PLL N2 = 2
  PLLPOST1=0;
    
   }

static void EnableInt (){

  enable_interrupts(INT_RDA); // UART Int
  enable_interrupts(INT_RDA2); // UART Int
  
  enable_interrupts(INT_TIMER1);
  EXT_INT_EDGE(L_TO_H);
  ENABLE_INTERRUPTS(INTR_GLOBAL);
}

static void MCU_init(){

  setup_timer1(TMR_INTERNAL | TMR_DIV_BY_64); // таймер 1 сбрасывает собачий таймер
  set_timer1(20000); //reset the timer.
  
   SETUP_SPI2(SPI_MASTER|SPI_SCK_IDLE_LOW|SPI_XMIT_H_TO_L|SPI_MODE_8B|SPI_SAMPLE_AT_END|SPI_SS_DISABLED|SPI_CLK_DIV_128);
   //f SCLK SPI = 312,5 kHz
   //setup_timer1(TMR_DISABLED|TMR_DIV_BY_1);
   //enable_interrupts(INT_EXT0);
   //enable_interrupts(INT_TIMER1);
  
 SCK2_TRIS=0; // SPI2 tris
 SDI2_TRIS=1;
 SDO2_TRIS=0;
 
 ADC_CS_TRIS=0;      ADC2_CS_TRIS=0;
 ADC_RESET_TRIS=0;   ADC2_RESET_TRIS=0;
 ADC_SYNC_TRIS=0;    ADC2_SYNC_TRIS=0;
 ADC_DRDY_TRIS=1;    ADC2_DRDY_TRIS=1;       // опрос готовнсти данных АЦП
 
 UART2_RX_TRIS=1;
 UART2_TX_TRIS=0;
 //XPORT_RST_TRIS=0;
 
 //XPORT_RST_n = 0;
 //delay_us(500);
 //XPORT_RST_n = 1;
 EnableInt();
}

static void Full_dev_reset(){

  OscSetup();
  MCU_init();
  reset_fl = 0;
  //ADC_wakeUp();
  //ADC_wakeUp(); 
  ADC_init();
  ADC_set_PGA(8);
  ADC_sps_set(0x23); //0x023 - 10 sps, 0x43 - 25 sps, 0x63 - 50 sps
                     //0x82 - 100 sps, 0x91 - 500 sps
                     //0xA1 - 1000 sps, 0xC0 - 3750 sps
  ADC_SelfCal();
  meas_stop_fl = 0; // вкл. режим измерений
  NumAver = 10;      // сброс величины усреднения данных АЦП

}

static void Clr_bufs(void)
{
  for (U8 i = 0; i < 8; i++)
  {
  // заполнение буферов скольз. ср. нулями
   for (U8 j = 0; j < Ma_buf_size; j++) 
      {
         Ch_buf[i][j] = 0;
      }
  }
}

static U8 ch_to_int(char ch){
U8 dg=-1;
 switch (ch){
      case '0' : dg=0;
      break;
      case '1' : dg=1;
      break;
      case '2' : dg=2;
      break;
      case '3' : dg=3;
      break;
      case '4' : dg=4;
      break;
      case '5' : dg=5;
      break;
      case '6' : dg=6;
      break;
      case '7' : dg=7;
      break;
      case '8' : dg=8;
      break;
      case '9' : dg=9;
      break;
      default: dg=-1;
 }
return dg;
}

static unsigned char getrxch (void){

unsigned char rch;

if(rdptr < wrptr){
 // есть символ, считываем
   rdptr ++;
   rch=RxData[rdptr& 0x0F];// прочитали символ
} else rch = 'x';//символов нет
   //обнуление указателей
   disable_interrupts(INT_RDA2);
  if((wrptr==rdptr) && (wrptr > 15)) 
  {
  wrptr=0;
  rdptr=0;
  } 
  enable_interrupts(INT_RDA2);
  return rch;
}

// послед. чтение двух АЦП
/*
static void ADC_Seq_rd_and_print_ch(U8 chanel){

   switch (chanel){
//---------------- АЦП 1 --------------------------------------//     
 case 1: 
 
 ADC_select(1);
 ADC_setCh(1);
 delay_us(20);
 ADC_select(0);
 
 ADC_SYNC = 0;
 delay_us(20);
 ADC_SYNC = 1;
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 ADC_select(1);
 Printf("a%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);

 break;

//---------------- 2 датчик --------------------------------------//
 case 2:
 
 ADC_select(1);
 ADC_setCh(2);
 ADC_select(0);
 
 ADC_SYNC = 0;
 delay_us(20);
 ADC_SYNC = 1;
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 ADC_select(1);
 Printf("b%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);

 break;
 
//---------------- 3 датчик --------------------------------------//  
 case 3: 

 ADC_select(1);
 ADC_setCh(3);
 delay_us(20);
 ADC_select(0);
 
 ADC_SYNC = 0;
 delay_us(20);
 ADC_SYNC = 1;
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 ADC_select(1);
 Printf("c%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);

 break;
//---------------- 4 датчик --------------------------------------//    
   case 4: 
   
 ADC_select(1);
 ADC_setCh(4);
 delay_us(20);
 ADC_select(0);
 
 ADC_SYNC = 0;
 delay_us(20);
 ADC_SYNC = 1;
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 ADC_select(1);
 Printf("d%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);
 
   break;
//----------------------------------------------------------------//

//------------------- АЦП 2 --------------------------------------//     
 case 5: 
 
 ADC_select(2);
 ADC_setCh(1);
 delay_us(20);
 ADC_select(0);
 
 ADC2_SYNC = 0;
 delay_us(20);
 ADC2_SYNC = 1;
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 1
 ADC_select(2);
 Printf("e%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);
 
 break;
 
//---------------- 2 датчик --------------------------------------//
 case 6: 
 
 ADC_select(2);
 ADC_setCh(2);
 delay_us(20);
 ADC_select(0);
 
 ADC2_SYNC = 0;
 delay_us(20);
 ADC2_SYNC = 1;
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 1
 ADC_select(2);
 Printf("f%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);
  
 break;
//---------------- 3 датчик --------------------------------------//  
 case 7: 

 ADC_select(2);
 ADC_setCh(3);
 delay_us(20);
 ADC_select(0);
 
 ADC2_SYNC = 0;
 delay_us(20);
 ADC2_SYNC = 1;
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 1
 ADC_select(2);
 Printf("g%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);
  
 break;
//---------------- 4 датчик --------------------------------------//    
   case 8: 

 ADC_select(2);
 ADC_setCh(4);
 delay_us(20);
 ADC_select(0);
 
 ADC2_SYNC = 0;
 delay_us(20);
 ADC2_SYNC = 1;
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 1
 ADC_select(2);
 Printf("h%08Lu\n",ADC_read());
 ADC_select(0);
 delay_us(20);
  
  break;
   }
   
}
*/
/**/

// || чтение двух АЦП
static void ADC_Par_rd_and_print_ch(U8 channel)
{
  char rchr;             // принятый U2 символ
  
  
   switch (channel){
//---------------- каналы 1 и 5 --------------------------------------//     
 case 1: 
 
 ADC_setCh(1,1);
 ADC_setCh(1,2);

 SYNC_ADC(1);  // синхр. измерений АЦП 1
 delay_ms(1);  
 SYNC_ADC(2);  // синхр. измерений АЦП 2
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 Printf("a%09Ld\n",ADC_read_aver(1,0));
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 2
 Printf("e%09Ld\n",ADC_read_aver(2,1));

 break;

//---------------- каналы 2 и 6 --------------------------------------//  
 case 2: 
 
 ADC_setCh(2,1);
 ADC_setCh(2,2);
 
 SYNC_ADC(1);   // синхр. измерений АЦП 1
 delay_ms(1);  
 SYNC_ADC(2);    // синхр. измерений АЦП 2
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 Printf("b%09Ld\n",ADC_read_aver(1,2));
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 2
 Printf("f%09Ld\n",ADC_read_aver(2,3));
 
 break;
 
//---------------- каналы 3 и 7 --------------------------------------//   
 case 3: 
 
 ADC_setCh(3,1);
 ADC_setCh(3,2);
 
 SYNC_ADC(1);   // синхр. измерений АЦП 1
 delay_ms(1);  
 SYNC_ADC(2);   // синхр. измерений АЦП 2
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 Printf("c%09Ld\n",ADC_read_aver(1,4));
 
 While(ADC2_DRDY) { } // ждем готовности АЦП 2
 Printf("g%09Ld\n",ADC_read_aver(2,5));
 
 break;
 
//---------------- каналы 4 и 8 --------------------------------------//   
 case 4: 
 
 ADC_setCh(4,1);
 ADC_setCh(4,2);
 
 SYNC_ADC(1);   // синхр. измерений АЦП 1
 delay_ms(1);  
 SYNC_ADC(2);    // синхр. измерений АЦП 2
 
 While(ADC_DRDY) { } // ждем готовности АЦП 1
 Printf("d%09Ld\n",ADC_read_aver(1,6));

 While(ADC2_DRDY) { } // ждем готовности АЦП 2
 Printf("h%09Ld\n",ADC_read_aver(2,7));
 
 Ma_buf_index++; // инкремент индекса
 if(Ma_buf_index > Ma_buf_size-1) Ma_buf_index = 0;   // сброс индекса буфера
 
 break;
 
//---------------- обработка команд с ПК ------------------------------//   
 case 5:
 
 while(rdptr < wrptr){
   U8 dg=0;
   U16 buf1; 
   //пока есть необработанные символы 
   rchr=getrxch();
 
   switch(state){
          case 0:
           switch (rchr){ //команды
               case 's': stop_fl = 0; // старт измерений
                         Clr_bufs();
                         ADC_init(); // инициализ .АЦП с новыми параметрами
                         state=0;
               break; 
               //----------
               case 'p': stop_fl = 1; // стоп измерений
                         printf("stopped\n\r");  
                         state=0;
               break; 
               //----------
               case 'g': state = 1; // pga_set
               if(!stop_fl) state=0; 
               break;
               //----------
               case 'v': state = 2; // sps_set
               if(!stop_fl) state=0;           
               break;
               //----------
               case 'b': state = 3; // aver_buf_size
               if(!stop_fl) state=0;           
               break;

               default : printf("err \r\n");      
         } // команды
          break;
          
         case 1: 
         // уст. PGA
            dg = ch_to_int(rchr);
            if(dg == -1){ 
              state=0;
              printf("PGA err \r\n"); 
              break;
                  }
                  
              tmp = (U16)dg;
              
            //if(stop_fl) {     
               if(tmp>=0 && tmp<=6){
                  PGA_val=tmp;
                  printf("PGA=%u \r\n",PGA_val);
               }  else printf("PGA out of range\r\n");
            //}
                  state=0;     
         break;
         
         case 2: 
         // уст. SPS
            dg = ch_to_int(rchr);
            if(dg == -1){ 
              state=0;
              printf("SPS err \r\n"); 
              break;
                  }
                  
              tmp = (U16)dg;
                  
            if(tmp>=0 && tmp<=7){
               ADC_sps_var = tmp;
               printf("SPS=%u \r\n",ADC_sps_var);
               } else printf("SPS out of range\r\n");
                  state=0;     
         break;
         
         case 3: 
         // уст. размера буфера усреднения
            dg = ch_to_int(rchr);
            if(dg == -1){ 
              state=0;
              printf("err p1 \r\n"); 
              break;
                  }
          // 1 цифра   
          tmp=0;
          tmp+=(U16)dg*100;
          state=4;
          
         break;
         
         case 4: 
         // уст. размера буфера усреднения
            dg = ch_to_int(rchr);
            if(dg == -1){ 
              state=0;
              printf("err p2 \r\n"); 
              break;
                  }
          // 2 цифра        
          tmp+=(U16)dg*10;
          state=5;
          
         break;
         
         case 5: 
         // уст. размера буфера усреднения
            dg = ch_to_int(rchr);
            if(dg == -1){ 
              state=0;
              printf("err p3 \r\n"); 
              break;
                  }
          // 3 цифра 
          tmp+=(U16)dg;
          if(tmp>=0 && tmp<=128){
                       Ma_buf_size=(U8)tmp;// прочитаны все 3 цифры без ошибок
                       printf("aver buf size=%u \r\n",Ma_buf_size);
          } else printf("aver buf out of range\r\n");
          
          state=0;
          
         break;
         
        default : state=0;   
      } // state   
   } // while
   
     break;
   } // main case
}

static void save_to_flash(){
      
   Sps_Wr = NumAver;
   Aver_Wr = ADC_sps_var; // сохранение sps значения во флеш
   CRC_Wr = CRC8(flash_wr_data,2);
   Wr_Flash();
   } 

#int_timer1
static void timer1_irq_handler(void) {
restart_wdt();     // сбос собачего таймера
set_timer1(20000); //reset the timer.
clear_interrupt(int_timer1);
}

#INT_RDA2
void UART2_RXd_isr(void){

//while(U2STA & 0x0001)
//{ //if(U2STA & 2) { U2STA = 0x0000; }
   //printf("%X", 0x00FF & U2RXREG);
//  U2TXREG = 0x00FF & U2RXREG; 
//}

while(U2STA & 0x0001)
{ // Receive buffer has data, at least one more character can be read
   wrptr++;
   RxData[wrptr & 0x0F] = (U8)(U2RXREG);
  
}
}

/*############################################################################*/

static void main()
{ 
  U8 ch = 1;             // начальная установка канала измерений АЦП

  OscSetup();
  MCU_init(); 
  //Rd_Flash();                        // чтение денных из флеш для расчета контр. суммы
  //crc1 = CRC_buf;                    // сохраненная контр. сумма    
  //crc2 = CRC8(flash_rd_data,2);      // текущая контр. сумма
  
  //Clr_bufs();
  
  ADC_sps_var = 0;   // сброс значений по умолчанию 
  NumAver = 1;       // тк произошел сбой контр. суммы
     
  ADC_RESET = 1; ADC2_RESET = 1;
  ADC_CS = 1;    ADC2_CS = 1;
  ADC_SYNC = 1;  ADC2_SYNC = 1; 
  SYNC_IN_TRIS = 1;   
  //While(ADC_DRDY | ADC2_DRDY) { }   // ждем готовности обоих АЦП перед иниц.  
  
  //ADC_init();        // Инициализация обоих АЦП 
  
/*############################################################################*/  

  while(true){
  
  //if(!SYNC_IMP) 
  printf("S\n\r");
  delay_ms(1000);

 } // while  
}  // main
/*############################################################################*/

