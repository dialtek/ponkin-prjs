CCS PCD C Compiler, Version 5.019, 5967               11-сен-14 15:16

               Filename:   C:\Users\LyuosevDmitriy\Google Drive\My project\Control Temperature\CCS PIC-C\main.lst

               ROM used:   12656 bytes (14%)
                           Largest free fragment is 52880
               RAM used:   416 (5%) at main() level
                           557 (7%) worst case
               Stack used: 94 locations (56 in main + 38 for interrupts)
               Stack size: 128

*
00000:  GOTO    28CA
*
0001A:  DATA    CC,05,00
*
00022:  DATA    F4,05,00
*
0003A:  DATA    6A,05,00
.................... #include <main.h> 
.................... #include <24HJ128GP506A.h> 
.................... //////////// Standard Header file for the PIC24HJ128GP506A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24HJ128GP506A 
*
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    20,00,00
0020E:  CLR     32
00210:  MOV     #21A,W3
00212:  ADD     W3,W0,W0
00214:  TBLRDL.B[W0],W0L
00216:  CLR.B   1
00218:  RETURN  
0021A:  DATA    C0,ED,00
0021C:  DATA    F2,E8,00
0021E:  DATA    EA,F0,00
00220:  DATA    E8,EE,00
00222:  DATA    F1,F2,00
00224:  DATA    E0,F2,00
00226:  DATA    56,31,00
00228:  DATA    2E,30,00
0022A:  DATA    00,00,00
0022C:  CLR     32
0022E:  MOV     #238,W3
00230:  ADD     W3,W0,W0
00232:  TBLRDL.B[W0],W0L
00234:  CLR.B   1
00236:  RETURN  
00238:  DATA    5F,5F,00
0023A:  DATA    5F,4A,00
0023C:  DATA    49,4E,00
0023E:  DATA    52,5F,00
00240:  DATA    4C,48,00
00242:  DATA    45,50,00
00244:  DATA    5F,5F,00
00246:  DATA    5F,5F,00
00248:  DATA    00,00,00
0024A:  CLR     32
0024C:  MOV     #AC,W3
0024E:  SUB     W0,W3,W3
00250:  BRA     C,25C
00252:  MOV     #266,W3
00254:  ADD     W3,W0,W0
00256:  TBLRDL.B[W0],W0L
00258:  CLR.B   1
0025A:  RETURN  
0025C:  MOV     #266,W0
0025E:  ADD     W3,W3,W3
00260:  ADD     W3,W0,W3
00262:  TBLRDH  [W3],W0
00264:  RETURN  
00266:  DATA    00,C1,00
00268:  DATA    81,40,C1
0026A:  DATA    01,C0,81
0026C:  DATA    80,41,40
0026E:  DATA    01,C0,01
00270:  DATA    80,41,C0
00272:  DATA    00,C1,80
00274:  DATA    81,40,41
00276:  DATA    01,C0,00
00278:  DATA    80,41,C1
0027A:  DATA    00,C1,81
0027C:  DATA    81,40,40
0027E:  DATA    00,C1,00
00280:  DATA    81,40,C1
00282:  DATA    01,C0,81
00284:  DATA    80,41,40
00286:  DATA    01,C0,01
00288:  DATA    80,41,C0
0028A:  DATA    00,C1,80
0028C:  DATA    81,40,41
0028E:  DATA    00,C1,00
00290:  DATA    81,40,C1
00292:  DATA    01,C0,81
00294:  DATA    80,41,40
00296:  DATA    00,C1,01
00298:  DATA    81,40,C0
0029A:  DATA    01,C0,80
0029C:  DATA    80,41,41
0029E:  DATA    01,C0,01
002A0:  DATA    80,41,C0
002A2:  DATA    00,C1,80
002A4:  DATA    81,40,41
002A6:  DATA    01,C0,00
002A8:  DATA    80,41,C1
002AA:  DATA    00,C1,81
002AC:  DATA    81,40,40
002AE:  DATA    00,C1,01
002B0:  DATA    81,40,C0
002B2:  DATA    01,C0,80
002B4:  DATA    80,41,41
002B6:  DATA    00,C1,00
002B8:  DATA    81,40,C1
002BA:  DATA    01,C0,81
002BC:  DATA    80,41,40
002BE:  DATA    01,C0,00
002C0:  DATA    80,41,C1
002C2:  DATA    00,C1,81
002C4:  DATA    81,40,40
002C6:  DATA    00,C1,01
002C8:  DATA    81,40,C0
002CA:  DATA    01,C0,80
002CC:  DATA    80,41,41
002CE:  DATA    01,C0,01
002D0:  DATA    80,41,C0
002D2:  DATA    00,C1,80
002D4:  DATA    81,40,41
002D6:  DATA    01,C0,00
002D8:  DATA    80,41,C1
002DA:  DATA    00,C1,81
002DC:  DATA    81,40,40
002DE:  DATA    00,C1,00
002E0:  DATA    81,40,C1
002E2:  DATA    01,C0,81
002E4:  DATA    80,41,40
002E6:  DATA    01,C0,01
002E8:  DATA    80,41,C0
002EA:  DATA    00,C1,80
002EC:  DATA    81,40,41
002EE:  DATA    00,C1,00
002F0:  DATA    81,40,C1
002F2:  DATA    01,C0,81
002F4:  DATA    80,41,40
002F6:  DATA    00,C1,01
002F8:  DATA    81,40,C0
002FA:  DATA    01,C0,80
002FC:  DATA    80,41,41
002FE:  DATA    01,C0,01
00300:  DATA    80,41,C0
00302:  DATA    00,C1,80
00304:  DATA    81,40,41
00306:  DATA    00,C1,00
00308:  DATA    81,40,C1
0030A:  DATA    01,C0,81
0030C:  DATA    80,41,40
0030E:  DATA    01,C0,00
00310:  DATA    80,41,00
00312:  CLR     32
00314:  MOV     #31E,W3
00316:  ADD     W3,W0,W0
00318:  TBLRDL.B[W0],W0L
0031A:  CLR.B   1
0031C:  RETURN  
0031E:  DATA    41,44,00
00320:  DATA    43,20,00
00322:  DATA    73,70,00
00324:  DATA    73,20,00
00326:  DATA    73,65,00
00328:  DATA    74,20,00
0032A:  DATA    20,00,00
0032C:  CLR     32
0032E:  MOV     #338,W3
00330:  ADD     W3,W0,W0
00332:  TBLRDL.B[W0],W0L
00334:  CLR.B   1
00336:  RETURN  
00338:  DATA    CA,EE,00
0033A:  DATA    FD,F4,00
0033C:  DATA    2E,20,00
0033E:  DATA    4B,31,00
00340:  DATA    20,73,00
00342:  DATA    65,74,00
00344:  DATA    20,00,00
00346:  CLR     32
00348:  MOV     #352,W3
0034A:  ADD     W3,W0,W0
0034C:  TBLRDL.B[W0],W0L
0034E:  CLR.B   1
00350:  RETURN  
00352:  DATA    CA,EE,00
00354:  DATA    FD,F4,00
00356:  DATA    2E,20,00
00358:  DATA    4B,32,00
0035A:  DATA    20,73,00
0035C:  DATA    65,74,00
0035E:  DATA    20,00,00
00360:  CLR     32
00362:  MOV     #36C,W3
00364:  ADD     W3,W0,W0
00366:  TBLRDL.B[W0],W0L
00368:  CLR.B   1
0036A:  RETURN  
0036C:  DATA    52,65,00
0036E:  DATA    73,65,00
00370:  DATA    74,20,00
00372:  DATA    64,65,00
00374:  DATA    76,69,00
00376:  DATA    63,65,00
00378:  DATA    20,00,00
0037A:  CLR     32
0037C:  MOV     #386,W3
0037E:  ADD     W3,W0,W0
00380:  TBLRDL.B[W0],W0L
00382:  CLR.B   1
00384:  RETURN  
00386:  DATA    2D,20,00
00388:  DATA    00,00,00
0038A:  CLR     32
0038C:  MOV     #396,W3
0038E:  ADD     W3,W0,W0
00390:  TBLRDL.B[W0],W0L
00392:  CLR.B   1
00394:  RETURN  
00396:  DATA    20,20,00
00398:  DATA    20,00,00
0039A:  CLR     32
0039C:  MOV     #3A6,W3
0039E:  ADD     W3,W0,W0
003A0:  TBLRDL.B[W0],W0L
003A2:  CLR.B   1
003A4:  RETURN  
003A6:  DATA    20,20,00
003A8:  DATA    20,52,00
003AA:  DATA    65,73,00
003AC:  DATA    65,74,00
003AE:  DATA    20,64,00
003B0:  DATA    6F,6E,00
003B2:  DATA    65,00,00
003B4:  CLR     32
003B6:  MOV     #3C0,W3
003B8:  ADD     W3,W0,W0
003BA:  TBLRDL.B[W0],W0L
003BC:  CLR.B   1
003BE:  RETURN  
003C0:  DATA    53,74,00
003C2:  DATA    61,72,00
003C4:  DATA    74,69,00
003C6:  DATA    6E,67,00
003C8:  DATA    20,64,00
003CA:  DATA    65,76,00
003CC:  DATA    69,63,00
003CE:  DATA    65,21,00
003D0:  DATA    00,00,00
003D2:  CLR     32
003D4:  MOV     #3DE,W3
003D6:  ADD     W3,W0,W0
003D8:  TBLRDL.B[W0],W0L
003DA:  CLR.B   1
003DC:  RETURN  
003DE:  DATA    54,3D,00
003E0:  DATA    00,00,00
003E2:  CLR     32
003E4:  MOV     #3EE,W3
003E6:  ADD     W3,W0,W0
003E8:  TBLRDL.B[W0],W0L
003EA:  CLR.B   1
003EC:  RETURN  
003EE:  DATA    2D,00,00
003F0:  CLR     32
003F2:  MOV     #3FC,W3
003F4:  ADD     W3,W0,W0
003F6:  TBLRDL.B[W0],W0L
003F8:  CLR.B   1
003FA:  RETURN  
003FC:  DATA    2E,00,00
003FE:  CLR     32
00400:  MOV     #40A,W3
00402:  ADD     W3,W0,W0
00404:  TBLRDL.B[W0],W0L
00406:  CLR.B   1
00408:  RETURN  
0040A:  DATA    43,20,00
0040C:  DATA    00,00,00
0040E:  CLR     32
00410:  MOV     #41A,W3
00412:  ADD     W3,W0,W0
00414:  TBLRDL.B[W0],W0L
00416:  CLR.B   1
00418:  RETURN  
0041A:  DATA    4B,00,00
0041C:  CLR     32
0041E:  MOV     #428,W3
00420:  ADD     W3,W0,W0
00422:  TBLRDL.B[W0],W0L
00424:  CLR.B   1
00426:  RETURN  
00428:  DATA    C8,ED,00
0042A:  DATA    F2,E5,00
0042C:  DATA    E3,F0,00
0042E:  DATA    2E,20,00
00430:  DATA    00,00,00
00432:  CLR     32
00434:  MOV     #43E,W3
00436:  ADD     W3,W0,W0
00438:  TBLRDL.B[W0],W0L
0043A:  CLR.B   1
0043C:  RETURN  
0043E:  DATA    CF,F0,00
00440:  DATA    EE,EF,00
00442:  DATA    EE,F0,00
00444:  DATA    F6,2E,00
00446:  DATA    20,00,00
00448:  CLR     32
0044A:  MOV     #454,W3
0044C:  ADD     W3,W0,W0
0044E:  TBLRDL.B[W0],W0L
00450:  CLR.B   1
00452:  RETURN  
00454:  DATA    20,20,00
00456:  DATA    52,65,00
00458:  DATA    61,64,00
0045A:  DATA    69,6E,00
0045C:  DATA    67,20,00
0045E:  DATA    64,61,00
00460:  DATA    74,61,00
00462:  DATA    00,00,00
00464:  CLR     32
00466:  MOV     #470,W3
00468:  ADD     W3,W0,W0
0046A:  TBLRDL.B[W0],W0L
0046C:  CLR.B   1
0046E:  RETURN  
00470:  DATA    20,20,00
00472:  DATA    20,66,00
00474:  DATA    72,6F,00
00476:  DATA    6D,20,00
00478:  DATA    52,4F,00
0047A:  DATA    4D,2E,00
0047C:  DATA    2E,2E,00
0047E:  DATA    00,00,00
00480:  CLR     32
00482:  MOV     #48C,W3
00484:  ADD     W3,W0,W0
00486:  TBLRDL.B[W0],W0L
00488:  CLR.B   1
0048A:  RETURN  
0048C:  DATA    20,20,00
0048E:  DATA    20,20,00
00490:  DATA    20,20,00
00492:  DATA    20,4F,00
00494:  DATA    4B,21,00
00496:  DATA    00,00,00
00498:  CLR     32
0049A:  MOV     #4A4,W3
0049C:  ADD     W3,W0,W0
0049E:  TBLRDL.B[W0],W0L
004A0:  CLR.B   1
004A2:  RETURN  
004A4:  DATA    20,20,00
004A6:  DATA    20,43,00
004A8:  DATA    52,43,00
004AA:  DATA    20,65,00
004AC:  DATA    72,72,00
004AE:  DATA    6F,72,00
004B0:  DATA    21,00,00
004B2:  CLR     32
004B4:  MOV     #4BE,W3
004B6:  ADD     W3,W0,W0
004B8:  TBLRDL.B[W0],W0L
004BA:  CLR.B   1
004BC:  RETURN  
004BE:  DATA    53,61,00
004C0:  DATA    6D,70,00
004C2:  DATA    6C,65,00
004C4:  DATA    73,20,00
004C6:  DATA    70,65,00
004C8:  DATA    72,20,00
004CA:  DATA    73,65,00
004CC:  DATA    63,2E,00
004CE:  DATA    00,00,00
004D0:  CLR     32
004D2:  MOV     #4DC,W3
004D4:  ADD     W3,W0,W0
004D6:  TBLRDL.B[W0],W0L
004D8:  CLR.B   1
004DA:  RETURN  
004DC:  DATA    20,CA,00
004DE:  DATA    EE,FD,00
004E0:  DATA    F4,F4,00
004E2:  DATA    E8,F6,00
004E4:  DATA    E8,E5,00
004E6:  DATA    ED,F2,00
004E8:  DATA    20,CA,00
004EA:  DATA    31,20,00
004EC:  DATA    00,00,00
004EE:  CLR     32
004F0:  MOV     #4FA,W3
004F2:  ADD     W3,W0,W0
004F4:  TBLRDL.B[W0],W0L
004F6:  CLR.B   1
004F8:  RETURN  
004FA:  DATA    2C,00,00
004FC:  CLR     32
004FE:  MOV     #508,W3
00500:  ADD     W3,W0,W0
00502:  TBLRDL.B[W0],W0L
00504:  CLR.B   1
00506:  RETURN  
00508:  DATA    20,CA,00
0050A:  DATA    EE,FD,00
0050C:  DATA    F4,F4,00
0050E:  DATA    E8,F6,00
00510:  DATA    E8,E5,00
00512:  DATA    ED,F2,00
00514:  DATA    20,CA,00
00516:  DATA    32,20,00
00518:  DATA    00,00,00
0051A:  CLR     32
0051C:  MOV     #526,W3
0051E:  ADD     W3,W0,W0
00520:  TBLRDL.B[W0],W0L
00522:  CLR.B   1
00524:  RETURN  
00526:  DATA    20,52,00
00528:  DATA    65,73,00
0052A:  DATA    65,74,00
0052C:  DATA    20,64,00
0052E:  DATA    65,76,00
00530:  DATA    69,63,00
00532:  DATA    65,3F,00
00534:  DATA    00,00,00
00536:  CLR     32
00538:  MOV     #542,W3
0053A:  ADD     W3,W0,W0
0053C:  TBLRDL.B[W0],W0L
0053E:  CLR.B   1
00540:  RETURN  
00542:  DATA    20,20,00
00544:  DATA    20,20,00
00546:  DATA    59,65,00
00548:  DATA    73,20,00
0054A:  DATA    2D,3E,00
0054C:  DATA    20,2B,00
0054E:  DATA    00,00,00
00550:  CLR     32
00552:  MOV     #55C,W3
00554:  ADD     W3,W0,W0
00556:  TBLRDL.B[W0],W0L
00558:  CLR.B   1
0055A:  RETURN  
0055C:  DATA    20,20,00
0055E:  DATA    20,20,00
00560:  DATA    4E,6F,00
00562:  DATA    20,20,00
00564:  DATA    2D,3E,00
00566:  DATA    20,2D,00
00568:  DATA    00,00,00
*
0087E:  MOV     W1,32
00880:  CP0     W3
00882:  BRA     Z,8AA
00884:  BTSC.B  0.0
00886:  BRA     894
00888:  TBLRDL.B[W0++],[W2++]
0088A:  DEC     W3,W3
0088C:  BRA     Z,8AA
0088E:  TBLRDL.B[W0],[W2++]
00890:  DEC     W3,W3
00892:  BRA     Z,8AA
00894:  DEC     W0,W0
00896:  TBLRDH.B[W0++],[W2++]
00898:  DEC     W3,W3
0089A:  BRA     Z,8AA
0089C:  CLR.B   [W2++]
0089E:  DEC     W3,W3
008A0:  INC     W0,W0
008A2:  CP0     W0
008A4:  BTSC.B  42.1
008A6:  INC     0032
008A8:  BRA     880
008AA:  RETURN  
008AC:  MOV     W5,[W15++]
008AE:  MOV     #C,W5
008B0:  REPEAT  #3
008B2:  MOV     [W5++],[W15++]
008B4:  MOV     W0,W4
008B6:  MOV     W1,W5
008B8:  MOV     W2,W6
008BA:  MOV     W3,W7
008BC:  CLR     W0
008BE:  CLR     W1
008C0:  CLR     W2
008C2:  CLR     W3
008C4:  BCLR    W8.0
008C6:  BTSS    W7.F
008C8:  BRA     8D4
008CA:  BSET    W8.0
008CC:  NEG     W4,W4
008CE:  COM     W5,W5
008D0:  COM     W6,W6
008D2:  COM     W7,W7
008D4:  IOR      W4,  W5,W9
008D6:  BRA     NZ,8DC
008D8:  IOR      W6,  W7,W9
008DA:  BRA     Z,906
008DC:  MOV     #473,W9
008DE:  BTSC    W3.4
008E0:  BRA     8F8
008E2:  BCLR.B  42.0
008E4:  RLC     W4,W4
008E6:  RLC     W5,W5
008E8:  RLC     W6,W6
008EA:  RLC     W7,W7
008EC:  RLC     W0,W0
008EE:  RLC     W1,W1
008F0:  RLC     W2,W2
008F2:  RLC     W3,W3
008F4:  DEC     W9,W9
008F6:  BRA     NZ,8DE
008F8:  SL      W9,#4,W9
008FA:  BCLR.B  42.0
008FC:  BCLR    W9.F
008FE:  BCLR    W3.4
00900:  XOR     W9,W3,W3
00902:  BTSC    W8.0
00904:  BSET    W3.F
00906:  MOV     #12,W5
00908:  REPEAT  #3
0090A:  MOV     [--W15],[W5--]
0090C:  MOV     [--W15],W5
0090E:  RETURN  
00910:  MOV     W8,[W15++]
00912:  MOV     #12,W8
00914:  REPEAT  #4
00916:  MOV     [W8++],[W15++]
00918:  XOR     W3,W7,W13
0091A:  MOV     W3,W8
0091C:  MOV     W7,W9
0091E:  MOV     #7FF,W10
00920:  BCLR.B  42.0
00922:  BCLR.B  42.1
00924:  ASR     W8,#4,W8
00926:  AND     W10,W8,W8
00928:  CP0     W8
0092A:  BRA     Z,A04
0092C:  BCLR.B  42.0
0092E:  BCLR.B  42.1
00930:  ASR     W9,#4,W9
00932:  AND     W10,W9,W9
00934:  CP0     W9
00936:  BRA     Z,A04
00938:  CLR     W10
0093A:  SUB     W8,W9,W12
0093C:  BRA     NC,944
0093E:  ADD     #3FF,W12
00940:  BRA     C,A04
00942:  BRA     94C
00944:  MOV     #401,W11
00946:  SUB     W12,W11,W12
00948:  BRA     NC,A04
0094A:  BRA     Z,A04
0094C:  CLR     W8
0094E:  CLR     W9
00950:  CLR     W10
00952:  CLR     W11
00954:  AND     #1F,W3
00956:  BSET    W3.4
00958:  AND     #1F,W7
0095A:  BSET    W7.4
0095C:  MOV     W12,[W15++]
0095E:  MOV     #36,W12
00960:  SUB     W0,W4,W0
00962:  SUBB    W1,W5,W1
00964:  SUBB    W2,W6,W2
00966:  SUBB    W3,W7,W3
00968:  BRA     N,96E
0096A:  BRA     C,978
0096C:  BRA     NZ,97A
0096E:  ADD     W0,W4,W0
00970:  ADDC    W1,W5,W1
00972:  ADDC    W2,W6,W2
00974:  ADDC    W3,W7,W3
00976:  BRA     97A
00978:  BSET    W8.0
0097A:  DEC     W12,W12
0097C:  BRA     Z,994
0097E:  BCLR.B  42.0
00980:  RLC     W0,W0
00982:  RLC     W1,W1
00984:  RLC     W2,W2
00986:  RLC     W3,W3
00988:  BCLR.B  42.0
0098A:  RLC     W8,W8
0098C:  RLC     W9,W9
0098E:  RLC     W10,W10
00990:  RLC     W11,W11
00992:  BRA     960
00994:  MOV     [--W15],W12
00996:  BTSC    W11.5
00998:  BRA     99C
0099A:  BRA     9A8
0099C:  BCLR.B  42.0
0099E:  RRC     W11,W11
009A0:  RRC     W10,W10
009A2:  RRC     W9,W9
009A4:  RRC     W8,W8
009A6:  BRA     9AE
009A8:  DEC     W12,W12
009AA:  BCLR.B  42.0
009AC:  BRA     Z,A04
009AE:  BTSC.B  42.0
009B0:  BRA     9C4
009B2:  RLC     W0,W0
009B4:  RLC     W1,W1
009B6:  RLC     W2,W2
009B8:  RLC     W3,W3
009BA:  SUB     W0,W4,W4
009BC:  SUBB    W1,W5,W5
009BE:  SUBB    W2,W6,W6
009C0:  SUBB    W3,W7,W7
009C2:  BRA     NC,9EE
009C4:  INC     W8,W8
009C6:  BRA     NZ,9EE
009C8:  INC     W9,W9
009CA:  BRA     NZ,9EE
009CC:  INC     W10,W10
009CE:  BRA     NZ,9EE
009D0:  INC     W11,W11
009D2:  BRA     NZ,9EE
009D4:  INC     W12,W12
009D6:  BRA     Z,A04
009D8:  BRA     9EE
009DA:  DEC     W12,W12
009DC:  BRA     Z,A04
009DE:  BTSC    W11.4
009E0:  BRA     9EE
009E2:  BCLR.B  42.0
009E4:  RLC     W8,W8
009E6:  RLC     W9,W9
009E8:  RLC     W10,W10
009EA:  RLC     W11,W11
009EC:  BRA     9DE
009EE:  SL      W12,#4,W12
009F0:  BCLR.B  42.0
009F2:  BCLR    W12.F
009F4:  BTSC    W13.F
009F6:  BSET    W12.F
009F8:  BCLR    W11.4
009FA:  XOR     W12,W11,W3
009FC:  MOV     W10,W2
009FE:  MOV     W9,W1
00A00:  MOV     W8,W0
00A02:  BRA     A0E
00A04:  MOV     #0,W0
00A06:  MOV     #0,W1
00A08:  MOV     #0,W2
00A0A:  MOV     #0,W3
00A0C:  BRA     A0E
00A0E:  MOV     #1A,W8
00A10:  REPEAT  #4
00A12:  MOV     [--W15],[W8--]
00A14:  MOV     [--W15],W8
00A16:  RETURN  
00A18:  MOV     W5,[W15++]
00A1A:  MOV     W6,[W15++]
00A1C:  MOV     W3,W4
00A1E:  MOV     W3,W6
00A20:  BCLR.B  42.0
00A22:  ASR     W4,#4,W4
00A24:  MOV     #7FF,W5
00A26:  AND     W5,W4,W4
00A28:  BRA     NZ,A30
00A2A:  MUL.UU  W0,#0,W0
00A2C:  CLR     W2
00A2E:  BRA     A56
00A30:  SUB     #380,W4
00A32:  AND     #F,W3
00A34:  MOV     #3,W7
00A36:  BCLR.B  42.0
00A38:  RLC     W0,W0
00A3A:  RLC     W1,W1
00A3C:  RLC     W2,W2
00A3E:  RLC     W3,W3
00A40:  DEC     W7,W7
00A42:  BRA     NZ,A36
00A44:  MOV     W1,W0
00A46:  MOV     W2,W1
00A48:  BCLR    W3.7
00A4A:  SWAP    W4
00A4C:  BCLR.B  42.0
00A4E:  RRC     W4,W4
00A50:  BTSC    W6.F
00A52:  BSET    W4.F
00A54:  XOR     W4,W3,W2
00A56:  MOV     [--W15],W6
00A58:  MOV     [--W15],W5
00A5A:  RETURN  
*
00E62:  MOV     W5,[W15++]
00E64:  MOV     #C,W5
00E66:  REPEAT  #3
00E68:  MOV     [W5++],[W15++]
00E6A:  MOV     #0,W9
00E6C:  BTSC.B  43.0
00E6E:  MOV     #1,W9
00E70:  MOV     W9,[W15++]
00E72:  XOR     W1,W3,W9
00E74:  BTSS    W1.F
00E76:  BRA     E7E
00E78:  COM     W1,W1
00E7A:  NEG     W0,W0
00E7C:  ADDC    W1,#0,W1
00E7E:  BTSS    W3.F
00E80:  BRA     E88
00E82:  COM     W3,W3
00E84:  NEG     W2,W2
00E86:  ADDC    W3,#0,W3
00E88:  XOR     W2,W3,W4
00E8A:  BRA     Z,EB6
00E8C:  CLR     W4
00E8E:  CLR     W5
00E90:  CLR     W6
00E92:  CLR     W7
00E94:  MOV     #20,W8
00E96:  BCLR.B  42.0
00E98:  RLC     W0,W0
00E9A:  RLC     W1,W1
00E9C:  RLC     W4,W4
00E9E:  RLC     W5,W5
00EA0:  CP      W5,W3
00EA2:  BRA     NZ,EA6
00EA4:  CPB     W4,W2
00EA6:  BRA     NC,EAE
00EA8:  SUB     W4,W2,W4
00EAA:  SUBB    W5,W3,W5
00EAC:  BSET.B  42.0
00EAE:  RLC     W6,W6
00EB0:  RLC     W7,W7
00EB2:  DEC     W8,W8
00EB4:  BRA     NZ,E96
00EB6:  BTSS    W9.F
00EB8:  BRA     EC8
00EBA:  NEG     W6,W0
00EBC:  BRA     Z,EC0
00EBE:  BRA     NZ,EC4
00EC0:  NEG     W7,W1
00EC2:  BRA     ECE
00EC4:  COM     W7,W1
00EC6:  BRA     ECE
00EC8:  MOV     W7,W1
00ECA:  MOV     W6,W0
00ECC:  BRA     ECE
00ECE:  MOV     [--W15],W9
00ED0:  CP0     W9
00ED2:  BRA     Z,ED6
00ED4:  MOV.D   W4,W0
00ED6:  MOV     #12,W5
00ED8:  REPEAT  #3
00EDA:  MOV     [--W15],[W5--]
00EDC:  MOV     [--W15],W5
00EDE:  RETURN  
*
00FDC:  MOV     W5,[W15++]
00FDE:  MOV     #C,W5
00FE0:  REPEAT  #3
00FE2:  MOV     [W5++],[W15++]
00FE4:  MUL.UU  W0,W2,W4
00FE6:  BTSS    W3.F
00FE8:  BRA     FEE
00FEA:  MUL.SS  W0,W3,W6
00FEC:  BRA     FF0
00FEE:  MUL.UU  W0,W3,W6
00FF0:  BCLR.B  42.0
00FF2:  ADD     W6,W5,W5
00FF4:  ADDC    W7,#0,W8
00FF6:  BTSS    W1.F
00FF8:  BRA     FFE
00FFA:  MUL.SS  W1,W2,W6
00FFC:  BRA     1000
00FFE:  MUL.UU  W1,W2,W6
01000:  ADDC    W6,W5,W5
01002:  ADDC    W7,W8,W8
01004:  ADDC    #0,W9
01006:  MUL.SS  W1,W3,W6
01008:  ADDC    W6,W8,W8
0100A:  ADDC    W9,W7,W7
0100C:  MOV     W7,W3
0100E:  MOV     W8,W2
01010:  MOV     W5,W1
01012:  MOV     W4,W0
01014:  MOV     #12,W5
01016:  REPEAT  #3
01018:  MOV     [--W15],[W5--]
0101A:  MOV     [--W15],W5
0101C:  RETURN  
0101E:  MOV     W8,[W15++]
01020:  MOV     #12,W8
01022:  REPEAT  #4
01024:  MOV     [W8++],[W15++]
01026:  CLR     W11
01028:  MUL.UU  W12,#0,W12
0102A:  MOV     W3,W8
0102C:  MOV     W7,W9
0102E:  MOV     #7FF,W10
01030:  BCLR.B  42.0
01032:  BCLR.B  42.1
01034:  ASR     W8,#4,W8
01036:  AND     W10,W8,W8
01038:  CP0     W8
0103A:  BRA     Z,111E
0103C:  BCLR.B  42.0
0103E:  BCLR.B  42.1
01040:  ASR     W9,#4,W9
01042:  AND     W10,W9,W9
01044:  CP0     W9
01046:  BRA     Z,111E
01048:  ADD     W9,W8,W8
0104A:  BTSC    W9.B
0104C:  BRA     1056
0104E:  SUB     #3FF,W8
01050:  BRA     Z,111E
01052:  BRA     NC,111E
01054:  BRA     105C
01056:  MOV     #401,W10
01058:  ADD.B   W10L,W5L,W5L
0105A:  BRA     C,111E
0105C:  XOR     W3,W7,W13
0105E:  BCLR.B  42.0
01060:  BCLR.B  42.1
01062:  AND     #F,W3
01064:  BSET    W3.4
01066:  AND     #F,W7
01068:  BSET    W7.4
0106A:  MOV     W8,[W15++]
0106C:  MUL.UU  W4,W1,W8
0106E:  MUL.UU  W5,W0,W10
01070:  ADD     W8,W10,W10
01072:  ADDC    W9,W11,W11
01074:  ADDC    #0,W12
01076:  MUL.UU  W4,W2,W8
01078:  ADD     W8,W11,W11
0107A:  ADDC    W9,W12,W12
0107C:  MUL.UU  W5,W1,W8
0107E:  CLR     W10
01080:  ADD     W8,W11,W11
01082:  ADDC    W9,W12,W12
01084:  ADDC    #0,W10
01086:  MUL.UU  W6,W0,W8
01088:  ADD     W8,W11,W11
0108A:  ADDC    W9,W12,W12
0108C:  ADDC    #0,W10
0108E:  CLR     W11
01090:  MUL.UU  W4,W3,W8
01092:  ADD     W8,W12,W12
01094:  ADDC    W9,W10,W10
01096:  ADDC    #0,W11
01098:  MUL.UU  W5,W2,W8
0109A:  ADD     W8,W12,W12
0109C:  ADDC    W9,W10,W10
0109E:  ADDC    #0,W11
010A0:  MUL.UU  W6,W1,W8
010A2:  ADD     W8,W12,W12
010A4:  ADDC    W9,W10,W10
010A6:  ADDC    #0,W11
010A8:  MUL.UU  W7,W0,W8
010AA:  ADD     W8,W12,W12
010AC:  ADDC    W9,W10,W10
010AE:  ADDC    #0,W11
010B0:  MOV     W12,W0
010B2:  CLR     W12
010B4:  MUL.UU  W5,W3,W8
010B6:  ADD     W8,W10,W10
010B8:  ADDC    W9,W11,W11
010BA:  ADDC    #0,W12
010BC:  MUL.UU  W6,W2,W8
010BE:  ADD     W8,W10,W10
010C0:  ADDC    W9,W11,W11
010C2:  ADDC    #0,W12
010C4:  MUL.UU  W6,W3,W8
010C6:  ADD     W8,W11,W11
010C8:  ADDC    W9,W12,W12
010CA:  MUL.UU  W7,W1,W8
010CC:  ADD     W8,W10,W10
010CE:  ADDC    W9,W11,W11
010D0:  ADDC    #0,W12
010D2:  MUL.UU  W7,W2,W8
010D4:  ADD     W8,W11,W11
010D6:  ADDC    W9,W12,W12
010D8:  MUL.UU  W7,W3,W8
010DA:  ADD     W8,W12,W12
010DC:  MOV     W10,W1
010DE:  MOV     W11,W2
010E0:  MOV     W12,W3
010E2:  MOV     #5,W4
010E4:  BCLR.B  42.0
010E6:  RRC     W3,W3
010E8:  RRC     W2,W2
010EA:  RRC     W1,W1
010EC:  RRC     W0,W0
010EE:  DEC     W4,W4
010F0:  BRA     NZ,10E4
010F2:  MOV     [--W15],W8
010F4:  INC     W8,W8
010F6:  IOR      W0,  W1,W6
010F8:  BRA     Z,10FC
010FA:  BRA     1100
010FC:  IOR      W2,  W3,W6
010FE:  BRA     Z,1110
01100:  BTSC    W3.4
01102:  BRA     1110
01104:  BCLR.B  42.0
01106:  RLC     W0,W0
01108:  RLC     W1,W1
0110A:  RLC     W2,W2
0110C:  RLC     W3,W3
0110E:  DEC     W8,W8
01110:  SL      W8,#4,W8
01112:  BCLR    W3.F
01114:  BTSC    W13.F
01116:  BSET    W3.F
01118:  BCLR    W3.4
0111A:  XOR     W8,W3,W3
0111C:  BRA     1124
0111E:  MUL.UU  W0,#0,W0
01120:  MUL.UU  W0,#0,W2
01122:  BRA     1124
01124:  MOV     #1A,W8
01126:  REPEAT  #4
01128:  MOV     [--W15],[W8--]
0112A:  MOV     [--W15],W8
0112C:  RETURN  
0112E:  MOV     W5,[W15++]
01130:  MOV     #C,W5
01132:  REPEAT  #3
01134:  MOV     [W5++],[W15++]
01136:  MOV     W0,W4
01138:  MOV     W1,W5
0113A:  MOV     W2,W6
0113C:  MOV     W3,W7
0113E:  CLR     W0
01140:  CLR     W1
01142:  CLR     W2
01144:  CLR     W3
01146:  BCLR    W8.0
01148:  BTSS    W7.F
0114A:  BRA     1156
0114C:  BSET    W8.0
0114E:  NEG     W4,W4
01150:  COM     W5,W5
01152:  COM     W6,W6
01154:  COM     W7,W7
01156:  IOR      W4,  W5,W9
01158:  BRA     NZ,115E
0115A:  IOR      W6,  W7,W9
0115C:  BRA     Z,1188
0115E:  MOV     #473,W9
01160:  BTSC    W3.4
01162:  BRA     117A
01164:  BCLR.B  42.0
01166:  RLC     W4,W4
01168:  RLC     W5,W5
0116A:  RLC     W6,W6
0116C:  RLC     W7,W7
0116E:  RLC     W0,W0
01170:  RLC     W1,W1
01172:  RLC     W2,W2
01174:  RLC     W3,W3
01176:  DEC     W9,W9
01178:  BRA     NZ,1160
0117A:  SL      W9,#4,W9
0117C:  BCLR.B  42.0
0117E:  BCLR    W9.F
01180:  BCLR    W3.4
01182:  XOR     W9,W3,W3
01184:  BTSC    W8.0
01186:  BSET    W3.F
01188:  MOV     #12,W5
0118A:  REPEAT  #3
0118C:  MOV     [--W15],[W5--]
0118E:  MOV     [--W15],W5
01190:  RETURN  
01192:  MOV     W5,[W15++]
01194:  MOV     W2,W3
01196:  MOV     W2,W5
01198:  BCLR.B  42.0
0119A:  RLC     W3,W3
0119C:  SWAP    W3
0119E:  AND     #FF,W3
011A0:  BRA     NZ,11A8
011A2:  MUL.UU  W0,#0,W0
011A4:  MUL.UU  W2,#0,W2
011A6:  BRA     11D4
011A8:  ADD     #380,W3
011AA:  AND     #7F,W2
011AC:  MOV     #3,W6
011AE:  CLR     W4
011B0:  BCLR.B  42.0
011B2:  RRC     W2,W2
011B4:  RRC     W1,W1
011B6:  RRC     W0,W0
011B8:  BTSC.B  42.0
011BA:  INC     W4,W4
011BC:  DEC     W6,W6
011BE:  BRA     NZ,11B0
011C0:  BCLR    W2.7
011C2:  SL      W3,#4,W3
011C4:  BCLR    W3.F
011C6:  BTSC    W5.F
011C8:  BSET    W3.F
011CA:  XOR     W2,W3,W3
011CC:  MOV     W1,W2
011CE:  MOV     W0,W1
011D0:  ADD     W4,W1,W1
011D2:  CLR     W0
011D4:  MOV     [--W15],W5
011D6:  RETURN  
011D8:  MOV     W5,[W15++]
011DA:  MOV     W6,[W15++]
011DC:  MOV     W0,W4
011DE:  MOV     W1,W5
011E0:  CLR     W0
011E2:  CLR     W1
011E4:  BCLR    W6.0
011E6:  BTSS    W5.F
011E8:  BRA     11F6
011EA:  BSET    W6.0
011EC:  NEG     W4,W4
011EE:  BRA     Z,11F4
011F0:  COM     W5,W5
011F2:  BRA     11F6
011F4:  NEG     W5,W5
011F6:  IOR      W4,  W5,W3
011F8:  BRA     Z,1220
011FA:  CLR     W2
011FC:  MOV     #B6,W1
011FE:  BTSC    W2.7
01200:  BRA     1210
01202:  BCLR.B  42.0
01204:  RLC     W4,W4
01206:  RLC     W5,W5
01208:  RLC     W0,W0
0120A:  RLC     W2,W2
0120C:  DEC     W1,W1
0120E:  BRA     NZ,11FE
01210:  SWAP    W1
01212:  BCLR.B  42.0
01214:  RRC     W1,W1
01216:  BCLR    W1.F
01218:  BCLR    W2.7
0121A:  XOR.B   W2L,W1L,W1L
0121C:  BTSC    W6.0
0121E:  BSET    W1.F
01220:  MOV     [--W15],W6
01222:  MOV     [--W15],W5
01224:  RETURN  
01226:  MOV     W5,[W15++]
01228:  MOV     #C,W5
0122A:  REPEAT  #4
0122C:  MOV     [W5++],[W15++]
0122E:  MOV     W0,W4
01230:  MOV     W1,W5
01232:  MOV     W3,W7
01234:  MOV     W2,W6
01236:  BCLR.B  42.0
01238:  BCLR.B  42.1
0123A:  RLC     W1,W1
0123C:  SWAP    W1
0123E:  AND     #FF,W1
01240:  CP0     W1
01242:  BRA     Z,12DA
01244:  BCLR.B  42.0
01246:  BCLR.B  42.1
01248:  RLC     W3,W3
0124A:  SWAP    W3
0124C:  AND     #FF,W3
0124E:  CP0     W3
01250:  BRA     Z,12DA
01252:  ZE      W0,W0
01254:  ADD.B   W3L,W1L,W0L
01256:  BRA     C,1260
01258:  SUB     #7F,W0
0125A:  BRA     Z,12DA
0125C:  BRA     NC,12DA
0125E:  BRA     1264
01260:  ADD.B   #81,W0L
01262:  BRA     C,12DA
01264:  XOR     W5,W7,W10
01266:  BCLR.B  42.0
01268:  BCLR.B  42.1
0126A:  AND     #FF,W5
0126C:  BSET    W5.7
0126E:  BCLR.B  42.0
01270:  AND     #FF,W7
01272:  BSET    W7.7
01274:  MUL.UU  W4,W6,W2
01276:  MUL.UU  W5,W6,W8
01278:  ADDC    W8,W3,W3
0127A:  MOV     W9,W1
0127C:  BTSC.B  42.0
0127E:  INC     W1,W1
01280:  BCLR.B  42.0
01282:  MUL.UU  W7,W4,W8
01284:  ADDC    W8,W3,W3
01286:  ADDC    W9,W1,W1
01288:  MUL.UU  W5,W7,W8
0128A:  ADDC    W8,W1,W1
0128C:  INC     W0,W0
0128E:  CP0     W1
01290:  BTSC.B  42.1
01292:  BRA     1296
01294:  BRA     129C
01296:  CP0     W3
01298:  BTSC.B  42.1
0129A:  BRA     12A6
0129C:  BTSC    W1.F
0129E:  BRA     12A6
012A0:  RLC     W3,W3
012A2:  RLC     W1,W1
012A4:  DEC     W0,W0
012A6:  MOV     W1,W2
012A8:  BCLR.B  42.0
012AA:  BTSS    W3.7
012AC:  BRA     12C0
012AE:  MOV     #FF00,W7
012B0:  AND     W3,W7,W3
012B2:  ADD     #100,W3
012B4:  ADDC    W2,#0,W2
012B6:  CP0     W2
012B8:  BRA     NZ,12C0
012BA:  CP0     W3
012BC:  BRA     NZ,12C0
012BE:  INC     W0,W0
012C0:  SWAP    W0
012C2:  BCLR.B  42.0
012C4:  BCLR.B  42.1
012C6:  RRC     W0,W1
012C8:  BTSC    W10.F
012CA:  BSET    W1.F
012CC:  BCLR    W2.F
012CE:  SWAP    W2
012D0:  XOR.B   W2L,W1L,W1L
012D2:  SWAP    W3
012D4:  MOV.B   W3L,W2L
012D6:  MOV     W2,W0
012D8:  BRA     12E0
012DA:  MOV     #0,W0
012DC:  MOV     #0,W1
012DE:  BRA     12E0
012E0:  MOV     #14,W5
012E2:  REPEAT  #4
012E4:  MOV     [--W15],[W5--]
012E6:  MOV     [--W15],W5
012E8:  RETURN  
012EA:  MOV     W5,[W15++]
012EC:  MOV     W1,W5
012EE:  MOV     W0,W2
012F0:  MOV     #B6,W4
012F2:  RLC     W1,W1
012F4:  SWAP    W1
012F6:  AND     #FF,W1
012F8:  SUB.B   W4L,W1L,W4L
012FA:  MOV.B   W5L,W3L
012FC:  BSET    W3.7
012FE:  AND     #FF,W3
01300:  CLR     W0
01302:  CLR     W1
01304:  CP      W4,#18
01306:  BRA     N,1326
01308:  BCLR.B  42.0
0130A:  RRC     W3,W3
0130C:  RRC     W2,W2
0130E:  RRC     W1,W1
01310:  RRC     W0,W0
01312:  DEC     W4,W4
01314:  BRA     NZ,1308
01316:  BTSS    W5.F
01318:  BRA     1326
0131A:  NEG     W0,W0
0131C:  BRA     Z,1322
0131E:  COM     W1,W1
01320:  BRA     1326
01322:  NEG     W1,W1
01324:  BRA     1326
01326:  MOV     [--W15],W5
01328:  RETURN  
*
01460:  MOV     W5,[W15++]
01462:  MOV     #C,W5
01464:  REPEAT  #4
01466:  MOV     [W5++],[W15++]
01468:  CLR     W9
0146A:  XOR     W1,W3,W9
0146C:  MOV     W1,W6
0146E:  MOV     W0,W5
01470:  MOV     W3,W8
01472:  MOV     W2,W7
01474:  RLC     W1,W1
01476:  SWAP    W1
01478:  ZE      W1,W1
0147A:  CP0     W1
0147C:  BRA     Z,151A
0147E:  RLC     W3,W3
01480:  SWAP    W3
01482:  ZE      W3,W3
01484:  CP0     W3
01486:  BRA     Z,151A
01488:  CLR     W0
0148A:  SUB.B   W1L,W3L,W0L
0148C:  BRA     NC,1494
0148E:  ADD.B   #7F,W0L
01490:  BRA     C,151A
01492:  BRA     149A
01494:  SUB.B   #81,W0L
01496:  BRA     NC,151A
01498:  BRA     Z,151A
0149A:  MOV     W5,W1
0149C:  MOV     W6,W2
0149E:  BSET    W2.7
014A0:  AND     #FF,W2
014A2:  AND     #FF,W8
014A4:  BSET    W8.7
014A6:  MOV     #19,W10
014A8:  CLR     W3
014AA:  CLR     W4
014AC:  SUB     W1,W7,W1
014AE:  SUBB    W2,W8,W2
014B0:  BRA     N,14B6
014B2:  BRA     C,14BC
014B4:  BRA     NZ,14BE
014B6:  ADD     W1,W7,W1
014B8:  ADDC    W2,W8,W2
014BA:  BRA     14BE
014BC:  BSET    W4.0
014BE:  DEC     W10,W10
014C0:  BRA     Z,14D0
014C2:  BCLR.B  42.0
014C4:  RLC     W1,W1
014C6:  RLC     W2,W2
014C8:  BCLR.B  42.0
014CA:  RLC     W4,W4
014CC:  RLC     W3,W3
014CE:  BRA     14AC
014D0:  CLR     W10
014D2:  BTSC    W3.8
014D4:  BRA     14D8
014D6:  BRA     14E4
014D8:  BCLR.B  42.0
014DA:  RRC     W3,W3
014DC:  BCLR    W3.7
014DE:  RRC     W4,W4
014E0:  RLC     W10,W10
014E2:  BRA     14E8
014E4:  DEC     W0,W0
014E6:  BRA     Z,151A
014E8:  BTSC    W10.F
014EA:  BRA     NC,14F6
014EC:  RLC     W1,W1
014EE:  RLC     W2,W2
014F0:  SUB     W1,W7,W1
014F2:  SUBB    W2,W8,W2
014F4:  BRA     NC,1508
014F6:  INC     W4,W4
014F8:  BRA     NZ,1508
014FA:  INC     W3,W3
014FC:  BRA     NZ,1508
014FE:  INC     W0,W0
01500:  BRA     Z,151A
01502:  BRA     1508
01504:  DEC     W0,W0
01506:  BRA     Z,151A
01508:  SWAP    W0
0150A:  RRC     W0,W1
0150C:  BSET    W1.F
0150E:  BTSS    W9.F
01510:  BCLR    W1.F
01512:  BCLR    W3.7
01514:  XOR.B   W3L,W1L,W1L
01516:  MOV     W4,W0
01518:  BRA     1520
0151A:  MOV     #0,W0
0151C:  MOV     #0,W1
0151E:  BRA     1520
01520:  MOV     #14,W5
01522:  REPEAT  #4
01524:  MOV     [--W15],[W5--]
01526:  MOV     [--W15],W5
01528:  RETURN  
0152A:  MOV     W5,[W15++]
0152C:  MOV     #C,W5
0152E:  REPEAT  #3
01530:  MOV     [W5++],[W15++]
01532:  CLR     W9
01534:  MOV     #8000,W8
01536:  BTSC.B  43.0
01538:  XOR     W8,W3,W3
0153A:  CP0     W0
0153C:  BRA     NZ,1544
0153E:  MOV     #7FFF,W10
01540:  AND     W1,W10,W10
01542:  BTSS.B  42.1
01544:  MOV     W1,W10
01546:  XOR     W3,W10,W11
01548:  MOV     W1,W6
0154A:  MOV     W3,W7
0154C:  MOV     W3,W12
0154E:  BCLR.B  42.1
01550:  BCLR.B  42.0
01552:  RLC     W6,W6
01554:  SWAP    W6
01556:  AND     #FF,W6
01558:  CP0     W6
0155A:  BRA     Z,169E
0155C:  BCLR.B  42.1
0155E:  BCLR.B  42.0
01560:  RLC     W7,W7
01562:  SWAP    W7
01564:  AND     #FF,W7
01566:  CP0     W7
01568:  BRA     Z,16A8
0156A:  BCLR.B  42.1
0156C:  BCLR.B  42.0
0156E:  CP      W7,W6
01570:  BRA     Z,16AA
01572:  BRA     N,16BA
01574:  BCLR    W9.0
01576:  BSET    W9.1
01578:  SUB     W7,W6,W8
0157A:  MOV     W7,W6
0157C:  AND     #FF,W1
0157E:  BSET    W1.7
01580:  AND     #FF,W3
01582:  BSET    W3.7
01584:  MOV     #28,W7
01586:  CP      W7,W8
01588:  BRA     N,15AC
0158A:  BCLR.B  42.1
0158C:  BCLR.B  42.0
0158E:  RRC     W1,W1
01590:  RRC     W0,W0
01592:  DEC     W8,W8
01594:  BRA     NZ,158A
01596:  BRA     15B2
01598:  MOV     #28,W7
0159A:  CP      W7,W8
0159C:  BRA     N,15B0
0159E:  BCLR.B  42.1
015A0:  BCLR.B  42.0
015A2:  RRC     W3,W3
015A4:  RRC     W2,W2
015A6:  DEC     W8,W8
015A8:  BRA     NZ,159E
015AA:  BRA     15CA
015AC:  MOV     W2,W0
015AE:  MOV     W3,W1
015B0:  BRA     1638
015B2:  BTSS    W11.F
015B4:  BRA     15D8
015B6:  BTSC    W9.4
015B8:  MOV     W12,W11
015BA:  NEG     W0,W0
015BC:  BRA     Z,15C2
015BE:  COM.B   W1L,W1L
015C0:  BRA     15C4
015C2:  NEG     W1,W1
015C4:  BTSC    W9.4
015C6:  BRA     161E
015C8:  BRA     15D8
015CA:  BTSS    W11.F
015CC:  BRA     15D8
015CE:  NEG     W2,W2
015D0:  BRA     Z,15D6
015D2:  COM.B   W3L,W3L
015D4:  BRA     15D8
015D6:  NEG     W3,W3
015D8:  AND     #FF,W5
015DA:  BCLR.B  42.1
015DC:  BCLR.B  42.0
015DE:  ADD     W0,W2,W0
015E0:  ADDC.B  W1L,W3L,W1L
015E2:  BTSC.B  42.0
015E4:  BSET    W9.3
015E6:  BTSC    W9.0
015E8:  BRA     15FC
015EA:  BTSC    W9.1
015EC:  BRA     15F0
015EE:  BRA     1606
015F0:  BTSC    W11.F
015F2:  BRA     161E
015F4:  BTSC    W9.3
015F6:  BRA     164A
015F8:  BSET    W9.6
015FA:  BRA     1638
015FC:  BTSC    W11.F
015FE:  BRA     161E
01600:  BTSC    W9.3
01602:  BRA     164A
01604:  BRA     1638
01606:  BCLR    W9.2
01608:  BTSC    W11.F
0160A:  BRA     1614
0160C:  MOV     W10,W11
0160E:  BTSC    W9.3
01610:  BRA     164A
01612:  BRA     1680
01614:  BSET    W9.4
01616:  XOR.B   #80,W1L
01618:  BTSC    W1.7
0161A:  BRA     15B6
0161C:  MOV     W10,W11
0161E:  AND     #FF,W1
01620:  IOR      W0,  W1,W7
01622:  BRA     Z,1638
01624:  BTSC    W1.7
01626:  BRA     1638
01628:  BCLR.B  42.1
0162A:  BCLR.B  42.0
0162C:  RLC     W0,W0
0162E:  RLC     W1,W1
01630:  DEC     W6,W6
01632:  BTSC.B  42.1
01634:  BRA     1698
01636:  BRA     1624
01638:  BTSC    W9.0
0163A:  MOV     W10,W11
0163C:  BTSC    W9.1
0163E:  MOV     W12,W11
01640:  BTSS    W9.5
01642:  BRA     1678
01644:  BTSC    W10.F
01646:  BSET    W0.8
01648:  BRA     1680
0164A:  BSET.B  42.0
0164C:  RRC.B   W1L,W1L
0164E:  RRC     W0,W0
01650:  BTSC.B  42.0
01652:  BSET    W9.5
01654:  INC     W6,W6
01656:  BRA     Z,1698
01658:  BTSS    W9.5
0165A:  BRA     166C
0165C:  INC     W0,W0
0165E:  BRA     NZ,166C
01660:  INC.B   W1L,W1L
01662:  BRA     NZ,166C
01664:  RRC.B   W1L,W1L
01666:  RRC     W0,W0
01668:  INC     W6,W6
0166A:  BRA     Z,1698
0166C:  BTSC    W9.0
0166E:  MOV     W10,W11
01670:  BTSC    W9.1
01672:  MOV     W12,W11
01674:  BTSC.B  42.1
01676:  BRA     1698
01678:  BTSC    W9.6
0167A:  MOV     W10,W11
0167C:  BTSC    W9.7
0167E:  MOV     W12,W11
01680:  IOR      W0,  W1,W2
01682:  BRA     Z,16CA
01684:  BCLR    W1.7
01686:  SWAP    W6
01688:  BCLR.B  42.1
0168A:  BCLR.B  42.0
0168C:  RRC     W6,W6
0168E:  XOR     W6,W1,W1
01690:  BSET    W1.F
01692:  BTSS    W11.F
01694:  BCLR    W1.F
01696:  BRA     16CA
01698:  MOV     #0,W0
0169A:  MOV     #0,W1
0169C:  BRA     16CA
0169E:  BTSC    W10.F
016A0:  XOR     W8,W3,W3
016A2:  MOV     W2,W0
016A4:  MOV     W3,W1
016A6:  BRA     16CA
016A8:  BRA     16CA
016AA:  AND     #FF,W3
016AC:  BSET    W3.7
016AE:  AND     #FF,W1
016B0:  BSET    W1.7
016B2:  BTSC    W11.F
016B4:  BCLR    W3.7
016B6:  BSET    W9.2
016B8:  BRA     15CA
016BA:  SUB     W6,W7,W8
016BC:  AND     #FF,W1
016BE:  BSET    W1.7
016C0:  AND     #FF,W3
016C2:  BSET    W3.7
016C4:  BCLR    W9.1
016C6:  BSET    W9.0
016C8:  BRA     1598
016CA:  MOV     #12,W5
016CC:  REPEAT  #3
016CE:  MOV     [--W15],[W5--]
016D0:  MOV     [--W15],W5
016D2:  RETURN  
016D4:  MOV     W5,[W15++]
016D6:  MOV     W6,[W15++]
016D8:  MOV     W7,[W15++]
016DA:  XOR     W1,W3,W4
016DC:  BTSS    W4.F
016DE:  BRA     16EC
016E0:  BCLR.B  42.0
016E2:  BCLR.B  42.1
016E4:  BTSS    W1.F
016E6:  BRA     1734
016E8:  BSET.B  42.0
016EA:  BRA     1734
016EC:  MOV     W1,W4
016EE:  MOV     W0,W5
016F0:  MOV     W3,W6
016F2:  MOV     W2,W7
016F4:  RLC     W1,W1
016F6:  SWAP    W1
016F8:  RLC     W3,W3
016FA:  SWAP    W3
016FC:  SUB.B   W3L,W1L,W1L
016FE:  BRA     Z,170A
01700:  BTSS    W4.F
01702:  BRA     1734
01704:  MOV     #1,W0
01706:  XOR.B   42
01708:  BRA     1734
0170A:  MOV.B   W4L,W1L
0170C:  MOV.B   W6L,W3L
0170E:  BCLR    W1.7
01710:  BCLR    W3.7
01712:  SUB.B   W3L,W1L,W1L
01714:  BRA     Z,1720
01716:  BTSS    W4.F
01718:  BRA     1734
0171A:  MOV     #1,W0
0171C:  XOR.B   42
0171E:  BRA     1734
01720:  SUB     W7,W5,W1
01722:  BRA     Z,172E
01724:  BTSS    W4.F
01726:  BRA     1734
01728:  MOV     #1,W0
0172A:  XOR.B   42
0172C:  BRA     1734
0172E:  BCLR.B  42.0
01730:  BRA     1734
01732:  BRA     1734
01734:  MOV     [--W15],W7
01736:  MOV     [--W15],W6
01738:  MOV     [--W15],W5
0173A:  RETURN  
*
01950:  MOV     W5,[W15++]
01952:  MOV     #C,W5
01954:  REPEAT  #5
01956:  MOV     [W5++],[W15++]
01958:  MOV     W3,W8
0195A:  MOV     W2,W7
0195C:  MOV     W1,W6
0195E:  MOV     W0,W5
01960:  MOV     W3,W9
01962:  MOV     #473,W11
01964:  ASR     W3,#4,W3
01966:  MOV     #7FF,W10
01968:  AND     W10,W3,W3
0196A:  SUB     W11,W3,W11
0196C:  AND     #1F,W8
0196E:  BSET    W8.4
01970:  CLR     W0
01972:  CLR     W1
01974:  CLR     W2
01976:  CLR     W3
01978:  BCLR.B  42.0
0197A:  RRC     W8,W8
0197C:  RRC     W7,W7
0197E:  RRC     W6,W6
01980:  RRC     W5,W5
01982:  RRC     W3,W3
01984:  RRC     W2,W2
01986:  RRC     W1,W1
01988:  RRC     W0,W0
0198A:  DEC     W11,W11
0198C:  BRA     NZ,1978
0198E:  BTSS    W9.F
01990:  BRA     199C
01992:  NEG     W0,W0
01994:  COM     W1,W1
01996:  COM     W2,W2
01998:  COM     W3,W3
0199A:  BRA     199C
0199C:  MOV     #16,W5
0199E:  REPEAT  #5
019A0:  MOV     [--W15],[W5--]
019A2:  MOV     [--W15],W5
019A4:  RETURN  
019A6:  MOV     W12,[W15++]
019A8:  MOV     W13,[W15++]
019AA:  CLR     W8
019AC:  CLR     W9
019AE:  CLR     W10
019B0:  CLR     W11
019B2:  CLR     W12
019B4:  CLR     W13
019B6:  MOV     #E,W8
019B8:  MOV     #0,W9
019BA:  LNK     #10
019BC:  MOV     W12,[W14+W8]
019BE:  DEC2    W8,W8
019C0:  BRA     NN,19BC
019C2:  XOR     W4,W5,W8
019C4:  BRA     NZ,19CA
019C6:  XOR     W6,W7,W8
019C8:  BRA     Z,1A28
019CA:  CLR     W8
019CC:  MOV     #40,W13
019CE:  MOV     #40,W13
019D0:  BCLR.B  42.0
019D2:  RLC     W0,W0
019D4:  RLC     W1,W1
019D6:  RLC     W2,W2
019D8:  RLC     W3,W3
019DA:  RLC     W8,W8
019DC:  RLC     W9,W9
019DE:  RLC     W10,W10
019E0:  RLC     W11,W11
019E2:  CP      W11,W7
019E4:  BRA     NZ,19F0
019E6:  CPB     W10,W6
019E8:  BRA     NZ,19F0
019EA:  CPB     W9,W5
019EC:  BRA     NZ,19F0
019EE:  CPB     W8,W4
019F0:  BRA     NC,19FC
019F2:  SUB     W8,W4,W8
019F4:  SUBB    W9,W5,W9
019F6:  SUBB    W10,W6,W10
019F8:  SUBB    W11,W7,W11
019FA:  BSET.B  42.0
019FC:  MOV     W8,[W14]
019FE:  MOV     W9,[W14+#2]
01A00:  MOV     W10,[W14+#4]
01A02:  MOV     W11,[W14+#6]
01A04:  MOV     [W14+#8],W8
01A06:  MOV     [W14+#A],W9
01A08:  MOV     [W14+#C],W10
01A0A:  MOV     [W14+#E],W11
01A0C:  RLC     W8,W8
01A0E:  RLC     W9,W9
01A10:  RLC     W10,W10
01A12:  RLC     W11,W11
01A14:  MOV     W8,[W14+#8]
01A16:  MOV     W9,[W14+#A]
01A18:  MOV     W10,[W14+#C]
01A1A:  MOV     W11,[W14+#E]
01A1C:  MOV     [W14],W8
01A1E:  MOV     [W14+#2],W9
01A20:  MOV     [W14+#4],W10
01A22:  MOV     [W14+#6],W11
01A24:  DEC     W13,W13
01A26:  BRA     NZ,19D0
01A28:  MOV     [W14+#8],W0
01A2A:  MOV     [W14+#A],W1
01A2C:  MOV     [W14+#C],W2
01A2E:  MOV     [W14+#E],W3
01A30:  ULNK    
01A32:  BRA     1A34
01A34:  MOV     [--W15],W13
01A36:  MOV     [--W15],W12
01A38:  RETURN  
01A3A:  MOV     W5,[W15++]
01A3C:  MOV     #C,W5
01A3E:  REPEAT  #7
01A40:  MOV     [W5++],[W15++]
01A42:  LNK     #2A
01A44:  MOV     #28,W8
01A46:  CLR     W12
01A48:  MOV     W12,[W14+W8]
01A4A:  DEC2    W8,W8
01A4C:  BRA     NN,1A48
01A4E:  CP0     W9
01A50:  BRA     Z,1A6E
01A52:  MOV     W9,[W14+#26]
01A54:  MOV     W10,[W14+#28]
01A56:  MOV     #4024,W7
01A58:  CLR     W6
01A5A:  MUL.UU  W4,#0,W4
01A5C:  MOV     W9,[W14+#24]
01A5E:  MOV     #4024,W7
01A60:  CLR     W6
01A62:  MUL.UU  W4,#0,W4
01A64:  CALL    101E
01A68:  MOV     [W14+#24],W9
01A6A:  DEC     W9,W9
01A6C:  BRA     NZ,1A5C
01A6E:  MOV     [W14+#26],W9
01A70:  MOV     #14,W8
01A72:  MOV     W8,[W14+#24]
01A74:  MOV     #41CD,W7
01A76:  MOV     #CD65,W6
01A78:  MUL.UU  W4,#0,W4
01A7A:  MOV     W0,[W14+#10]
01A7C:  MOV     W1,[W14+#12]
01A7E:  MOV     W2,[W14+#14]
01A80:  MOV     W3,[W14+#16]
01A82:  MOV     #14,W8
01A84:  MOV     W8,[W14+#20]
01A86:  MOV     #0,W4
01A88:  MOV     #89E8,W5
01A8A:  MOV     #2304,W6
01A8C:  MOV     #8AC7,W7
01A8E:  MOV     W4,[W14+#18]
01A90:  MOV     W5,[W14+#1A]
01A92:  MOV     W6,[W14+#1C]
01A94:  MOV     W7,[W14+#1E]
01A96:  BTSS    W3.F
01A98:  BRA     1AA2
01A9A:  MOV     [W14+#28],W8
01A9C:  DEC     W8,W8
01A9E:  BSET    W8.D
01AA0:  MOV     W8,[W14+#28]
01AA2:  BCLR    W3.F
01AA4:  CALL    1950
01AA8:  MOV     [W14+#28],W8
01AAA:  MOV     [W14+#26],W9
01AAC:  CP0     W9
01AAE:  BTSC.B  42.1
01AB0:  INC.B   W8L,W8L
01AB2:  MOV     W8,[W14+#28]
01AB4:  MOV     [W14+#22],W9
01AB6:  CLR     W9
01AB8:  MOV     W9,[W14+#22]
01ABA:  MOV     [W14+#18],W4
01ABC:  MOV     [W14+#1A],W5
01ABE:  MOV     [W14+#1C],W6
01AC0:  MOV     [W14+#1E],W7
01AC2:  CALL    19A6
01AC6:  MOV     [W14+#22],W13
01AC8:  BTSC    W13.0
01ACA:  BRA     1B90
01ACC:  MOV     W8,[W14+#10]
01ACE:  MOV     W9,[W14+#12]
01AD0:  MOV     W10,[W14+#14]
01AD2:  MOV     W11,[W14+#16]
01AD4:  MOV     [W14+#22],W13
01AD6:  BTG     W13.0
01AD8:  MOV     W13,[W14+#22]
01ADA:  CP0     W0
01ADC:  BRA     NZ,1B02
01ADE:  MOV     [W14+#26],W9
01AE0:  INC     W9,W9
01AE2:  MOV     [W14+#24],W10
01AE4:  SUB     W10,W9,W8
01AE6:  BRA     Z,1B02
01AE8:  MOV     [W14+#28],W11
01AEA:  CP0     W11
01AEC:  BRA     Z,1B0A
01AEE:  AND     W11,#1F,W8
01AF0:  SUB     W10,W8,W8
01AF2:  BRA     Z,1AF6
01AF4:  BRA     C,1B78
01AF6:  BTSC    W11.F
01AF8:  BRA     1B78
01AFA:  BTSC    W11.E
01AFC:  BRA     1B0A
01AFE:  MOV     #20,W0
01B00:  BRA     1B70
01B02:  MOV     [W14+#28],W11
01B04:  MOV     #2000,W12
01B06:  AND     W12,W11,W11
01B08:  MOV     W11,[W14+#28]
01B0A:  MOV     [W14+#28],W11
01B0C:  BTSS    W11.D
01B0E:  BRA     1B2E
01B10:  BCLR    W11.D
01B12:  MOV     [W14+#26],W9
01B14:  CP0     W9
01B16:  BTSS.B  42.1
01B18:  DEC     W11,W11
01B1A:  CLR     W11
01B1C:  MOV     W11,[W14+#28]
01B1E:  MOV     W0,W10
01B20:  BTSC.B  233.1
01B22:  BRA     1B20
01B24:  MOV     #2D,W4
01B26:  MOV     W4,234
01B28:  MOV     W10,W0
01B2A:  CLR     W11
01B2C:  MOV     W11,[W14+#28]
01B2E:  MOV     [W14+#26],W9
01B30:  MOV     [W14+#24],W10
01B32:  SUB     W10,W9,W8
01B34:  BRA     NZ,1B4E
01B36:  CLR     W11
01B38:  MOV     W11,[W14+#28]
01B3A:  MOV     W0,W10
01B3C:  BTSC.B  233.1
01B3E:  BRA     1B3C
01B40:  MOV     #2E,W4
01B42:  MOV     W4,234
01B44:  MOV     [W14+#28],W11
01B46:  MOV     #2000,W12
01B48:  AND     W12,W11,W11
01B4A:  MOV     W11,[W14+#28]
01B4C:  MOV     W10,W0
01B4E:  MOV     #30,W1
01B50:  MOV     [W14+#28],W11
01B52:  BTSS    W11.D
01B54:  BRA     1B70
01B56:  BCLR    W11.D
01B58:  MOV     [W14+#26],W9
01B5A:  CP0     W9
01B5C:  BTSS.B  42.1
01B5E:  DEC     W11,W11
01B60:  CLR     W11
01B62:  MOV     W11,[W14+#28]
01B64:  BTSC.B  233.1
01B66:  BRA     1B64
01B68:  MOV     #2D,W4
01B6A:  MOV     W4,234
01B6C:  CLR     W0
01B6E:  MOV     #30,W1
01B70:  ADD     W1,W0,W0
01B72:  BTSC.B  233.1
01B74:  BRA     1B72
01B76:  MOV     W0,234
01B78:  MOV     [W14+#24],W13
01B7A:  DEC     W13,W13
01B7C:  BRA     Z,1BB0
01B7E:  MOV     W13,[W14+#24]
01B80:  MOV     [W14+#18],W0
01B82:  MOV     [W14+#1A],W1
01B84:  MOV     [W14+#1C],W2
01B86:  MOV     [W14+#1E],W3
01B88:  MOV     #A,W4
01B8A:  CLR     W5
01B8C:  MUL.UU  W6,#0,W6
01B8E:  BRA     1AC2
01B90:  MOV     W0,[W14+#18]
01B92:  MOV     W1,[W14+#1A]
01B94:  MOV     W2,[W14+#1C]
01B96:  MOV     W3,[W14+#1E]
01B98:  MOV     W0,W4
01B9A:  MOV     W1,W5
01B9C:  MOV     W2,W6
01B9E:  MOV     W3,W7
01BA0:  MOV     [W14+#10],W0
01BA2:  MOV     [W14+#12],W1
01BA4:  MOV     [W14+#14],W2
01BA6:  MOV     [W14+#16],W3
01BA8:  MOV     [W14+#22],W13
01BAA:  BTG     W13.0
01BAC:  MOV     W13,[W14+#22]
01BAE:  BRA     1AC2
01BB0:  ULNK    
01BB2:  MOV     #1A,W5
01BB4:  REPEAT  #7
01BB6:  MOV     [--W15],[W5--]
01BB8:  MOV     [--W15],W5
01BBA:  RETURN  
01BBC:  MOV     W0,W2
01BBE:  MOV     W1,W3
01BC0:  MOV.B   W1L,W0L
01BC2:  SWAP    W0
01BC4:  BSET    W0.F
01BC6:  RLC     W1,W1
01BC8:  SWAP    W1
01BCA:  ZE      W1,W1
01BCC:  MOV     #8E,W4
01BCE:  SUB.B   W4L,W1L,W1L
01BD0:  BRA     Z,1BDE
01BD2:  CP0     W0
01BD4:  BRA     Z,1BDE
01BD6:  BCLR.B  42.0
01BD8:  RRC     W0,W0
01BDA:  DEC     W1,W1
01BDC:  BRA     NZ,1BD2
01BDE:  BTSS    W3.F
01BE0:  BRA     1BE6
01BE2:  NEG     W0,W0
01BE4:  BRA     1BE6
01BE6:  RETURN  
*
01C1A:  MOV     W5,[W15++]
01C1C:  MOV     #C,W5
01C1E:  REPEAT  #3
01C20:  MOV     [W5++],[W15++]
01C22:  MOV     #0,W9
01C24:  BTSC.B  43.0
01C26:  MOV     #1,W9
01C28:  MOV     W9,[W15++]
01C2A:  CLR     W4
01C2C:  CLR     W5
01C2E:  CLR     W6
01C30:  CLR     W7
01C32:  XOR     W2,W3,W8
01C34:  BRA     Z,1C58
01C36:  MOV     #20,W8
01C38:  BCLR.B  42.0
01C3A:  RLC     W0,W0
01C3C:  RLC     W1,W1
01C3E:  RLC     W4,W4
01C40:  RLC     W5,W5
01C42:  CP      W5,W3
01C44:  BRA     NZ,1C48
01C46:  CPB     W4,W2
01C48:  BRA     NC,1C50
01C4A:  SUB     W4,W2,W4
01C4C:  SUBB    W5,W3,W5
01C4E:  BSET.B  42.0
01C50:  RLC     W6,W6
01C52:  RLC     W7,W7
01C54:  DEC     W8,W8
01C56:  BRA     NZ,1C38
01C58:  MOV     W7,W1
01C5A:  MOV     W6,W0
01C5C:  MOV     [--W15],W9
01C5E:  CP0     W9
01C60:  BRA     Z,1C64
01C62:  MOV.D   W4,W0
01C64:  MOV     #12,W5
01C66:  REPEAT  #3
01C68:  MOV     [--W15],[W5--]
01C6A:  MOV     [--W15],W5
01C6C:  RETURN  
01C6E:  MOV     W5,[W15++]
01C70:  MOV     #C,W5
01C72:  REPEAT  #3
01C74:  MOV     [W5++],[W15++]
01C76:  MUL.UU  W0,W2,W4
01C78:  MUL.UU  W0,W3,W6
01C7A:  BCLR.B  42.0
01C7C:  ADD     W6,W5,W5
01C7E:  ADDC    W7,#0,W8
01C80:  MUL.UU  W1,W2,W6
01C82:  ADDC    W6,W5,W5
01C84:  ADDC    W7,W8,W8
01C86:  MUL.UU  W1,W3,W6
01C88:  ADD     W6,W8,W8
01C8A:  ADDC    #0,W7
01C8C:  MOV     W7,W3
01C8E:  MOV     W8,W2
01C90:  MOV     W5,W1
01C92:  MOV     W4,W0
01C94:  MOV     #12,W5
01C96:  REPEAT  #3
01C98:  MOV     [--W15],[W5--]
01C9A:  MOV     [--W15],W5
01C9C:  RETURN  
*
01DDA:  MOV     W5,[W15++]
01DDC:  MOV     W6,[W15++]
01DDE:  MOV     #8E,W1
01DE0:  CP0     W0
01DE2:  BRA     Z,1E08
01DE4:  BTSC    W0.F
01DE6:  BRA     1DF0
01DE8:  BCLR.B  42.0
01DEA:  RLC     W0,W0
01DEC:  DEC     W1,W1
01DEE:  BRA     1DE4
01DF0:  SWAP    W1
01DF2:  BCLR.B  42.0
01DF4:  RRC     W1,W1
01DF6:  BCLR    W0.F
01DF8:  SWAP    W0
01DFA:  XOR.B   W0L,W1L,W1L
01DFC:  AND.B   #0,W0L
01DFE:  BRA     1E0E
01E00:  MOV.B   W1L,W0L
01E02:  BSET    W1.7
01E04:  AND.B   #0,W1L
01E06:  BRA     1E0E
01E08:  CLR     W0
01E0A:  CLR     W1
01E0C:  BRA     1E0E
01E0E:  MOV     [--W15],W6
01E10:  MOV     [--W15],W5
01E12:  RETURN  
*
02782:  PUSH    42
02784:  MOV     W0,[W15++]
02786:  BCLR.B  81.7
02788:  MOV     42,W4
0278A:  IOR     #E0,W4
0278C:  MOV     W4,42
0278E:  BSET.B  81.7
02790:  MOV     W1,760
02792:  MOV     #55,W4
02794:  MOV     W4,766
02796:  MOV     #AA,W4
02798:  MOV     W4,766
0279A:  BSET.B  761.7
0279C:  NOP     
0279E:  NOP     
027A0:  MOV     [--W15],W0
027A2:  BCLR.B  81.7
027A4:  POP     42
027A6:  BSET.B  81.7
027A8:  RETURN  
027AA:  MOV     W5,[W15++]
027AC:  MOV     #C,W5
027AE:  REPEAT  #3
027B0:  MOV     [W5++],[W15++]
027B2:  BCLR    W3.0
027B4:  BCLR    W3.1
027B6:  CP0     W3
027B8:  BRA     Z,2822
027BA:  BCLR    W0.0
027BC:  BCLR    W2.0
027BE:  MOV     W1,32
027C0:  MOV     W0,W1
027C2:  MOV     #FFFF,W4
027C4:  MOV     #7F,W0
027C6:  AND     W0,W1,W0
027C8:  BRA     Z,27DA
027CA:  MOV     W1,[W15++]
027CC:  LSR     W1,#7,W1
027CE:  SL      W1,#7,W1
027D0:  TBLWTL  W4,[W1]
027D2:  TBLWTH  W4,[W1++]
027D4:  SUB     W0,#2,W0
027D6:  BRA     NZ,27D0
027D8:  MOV     [--W15],W1
027DA:  MOV     #3FF,W0
027DC:  AND     W0,W1,W0
027DE:  BRA     NZ,27EC
027E0:  TBLWTL  W0,[W1]
027E2:  MOV     W1,[W15++]
027E4:  MOV     #4042,W1
027E6:  CALL    2782
027EA:  MOV     [--W15],W1
027EC:  TBLWTL  [W2++],[W1]
027EE:  TBLWTH  [W2++],[W1++]
027F0:  CP0     W1
027F2:  BTSC.B  42.1
027F4:  INC     0032
027F6:  MOV     #7F,W0
027F8:  AND     W1,W0,W0
027FA:  BRA     NZ,2806
027FC:  MOV     W1,[W15++]
027FE:  MOV     #4001,W1
02800:  CALL    2782
02804:  MOV     [--W15],W1
02806:  SUB     W3,#4,W3
02808:  BRA     NZ,27DA
0280A:  MOV     #7F,W0
0280C:  AND     W1,W0,W0
0280E:  BRA     Z,2822
02810:  MOV     #FFFF,W4
02812:  TBLWTL  W4,[W1]
02814:  TBLWTH  W4,[W1++]
02816:  MOV     #7F,W0
02818:  AND     W1,W0,W0
0281A:  BRA     NZ,2812
0281C:  MOV     #4001,W1
0281E:  CALL    2782
02822:  MOV     #12,W5
02824:  REPEAT  #3
02826:  MOV     [--W15],[W5--]
02828:  MOV     [--W15],W5
0282A:  RETURN  
....................  
.................... #list 
....................  
....................  
.................... //#FUSES PROTECT_HIGH            //General Segment Code Protect High Security 
.................... #FUSES WRTB                      //Boot block write protected 
.................... #FUSES CKSFSM                    //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES WDT                       //Watch Dog Timer 
.................... #FUSES WPOSTS14                  //Watch Dog Timer PreScalar 1:8192 
.................... #FUSES PR_PLL                    //Primary Oscillator with PLL 
.................... #FUSES HS                        //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOWRT                     //Program memory not write protected 
.................... //#fuses PUT128                    //Power On Reset Timer value 8ms 
.................... #use delay(clock=80M) 
*
006C4:  CP0     W0
006C6:  BTSC.B  42.1
006C8:  BRA     6DA
006CA:  REPEAT  #1C3B
006CC:  NOP     
006CE:  REPEAT  #3FFE
006D0:  NOP     
006D2:  REPEAT  #3FFE
006D4:  NOP     
006D6:  DEC     W0,W0
006D8:  BRA     NZ,6CA
006DA:  RETURN  
....................  
.................... #WORD PLLFBD=0x0746 // osc PLL div reg 
.................... #WORD U2BRG=0x0238 
.................... #WORD U2MODE=0x0230 
....................  
.................... #WORD ODCD = 0x06D2  
....................  
.................... #WORD CLKDIV=0x0744  // osc con reg 
.................... #BIT PLLPOST1=CLKDIV.7 
.................... #BIT PLLPOST0=CLKDIV.6 
.................... #BIT PLLPRE4=CLKDIV.4 
.................... #BIT PLLPRE3=CLKDIV.3 
.................... #BIT PLLPRE2=CLKDIV.2 
.................... #BIT PLLPRE1=CLKDIV.1 
.................... #BIT PLLPRE0=CLKDIV.0 
....................  
.................... #WORD LATA=0x02C4  
.................... #WORD LATB=0x02CA 
.................... #WORD LATD=0x02D6 
.................... #WORD LATF=0x02E2 
.................... #WORD LATG=0x02E8   
.................... #WORD LATC=0x02D0 
....................  
.................... #use spi(spi2, FORCE_HW) 
.................... #use standard_io(B)//(B_outputs=PIN_B1, PIN_B2) 
....................  
.................... #define STATUS 0x00     // ADC1256 Register map 
.................... #define MUX 0x01  
.................... #define ADCON 0x02 
.................... #define DRATE 0x03 
.................... #define IO 0x04 
.................... #define OFCO 0x05 
.................... #define OFC1 0x06 
.................... #define OFC2 0x07 
.................... #define FSCO 0x08 
.................... #define FSC1 0x09 
.................... #define FSC2 0x0A 
....................  
.................... #define uV 1000000 //basic 
.................... //#define uV 10000000 //basic 
.................... #define mV 1000 
....................  
.................... #WORD PORTB=0x02C8 
.................... #WORD TRISB=0x02C6 
.................... #BIT  TRB0=TRISB.0 
.................... #BIT  TRB1=TRISB.1 
.................... #BIT  CN1_TRIS=TRISB.3 
.................... #BIT  CN2_TRIS=TRISB.2 
.................... #BIT  CN4_TRIS=TRISB.4 
.................... #BIT  CN3_TRIS=TRISB.5 
.................... #BIT  CN1=PORTB.3 
.................... #BIT  CN4=PORTB.4 
.................... #BIT  CN2=PORTB.2 
.................... #BIT  CN3=PORTB.5 
.................... #BIT  XPORT_RST_n=TRISB.15 
.................... #BIT  Status_LED_TRIS=TRISB.13 
.................... #BIT  TRB14=TRISB.14 
.................... #BIT  XPORT_RST_TRIS=TRISB.15 
.................... #BIT  RB1=LATB.1 
.................... #BIT  RB0=LATB.0 
.................... #BIT  Status_LED=LATB.13 
....................  
.................... #WORD PORTC=0x02CE 
.................... #WORD TRISC=0x02CC 
.................... //#BIT RC13=LATC.13 
.................... #BIT RC14=LATC.14 
.................... #BIT RC13=PORTC.13 
.................... //#BIT RC14=PORTC.14 
.................... #BIT  TRC13=TRISC.13 
.................... #BIT  TRC14=TRISC.14 
.................... #BIT  TRC1=TRISC.1 
.................... #BIT  TRC2=TRISC.2 
.................... #BIT  TRC4=TRISC.4 
.................... //_______________________________________ 
.................... #WORD PORTD=0x02D4 
.................... #WORD TRISD=0x02D2 
.................... #WORD ODCD=0x06D2 
.................... #BIT  TRD0=TRISD.0 
.................... //#BIT  TRD1=TRISD.1 // ADC !DRDY описан ниже 
.................... //#BIT  TRD2=TRISD.2 
.................... //#BIT  TRD3=TRISD.3 
.................... #BIT  TRD4=TRISD.4 
.................... #BIT  TRD5=TRISD.5 
.................... #BIT  TRD6=TRISD.6 
.................... #BIT  TRD7=TRISD.7 
.................... #BIT  TRD8=TRISD.8 
.................... #BIT  TRD9=TRISD.9 
.................... #BIT  TRD10=TRISD.10 
.................... #BIT  TRD11=TRISD.11 
....................  
.................... #BIT  RD0=LATD.0 
.................... //#BIT  RD1=LATD.1 // ADC !DRDY описан ниже 
.................... //#BIT  RD2=LATD.2 
.................... //#BIT  RD3=LATD.3 
.................... #BIT  RD4=LATD.4 
.................... #BIT  RD5=LATD.5 
.................... #BIT  RD6=LATD.6 
.................... #BIT  RD7=LATD.7 
.................... #BIT  RD8=LATD.8 
.................... #BIT  RD9=LATD.9 
.................... #BIT  RD10=LATD.10 
.................... #BIT  RD11=LATD.11 
.................... //_________________________________________________ 
.................... #WORD PORTF=0x02E0 
.................... #WORD TRISF=0x02DE 
.................... #BIT  UART2_RX_TRIS=TRISF.4 
.................... #BIT  UART2_TX_TRIS=TRISF.5 
.................... //_________________________________________________ 
.................... #WORD PORTG=0x02E6 
.................... #WORD TRISG=0x02E4 
.................... #BIT RG12=LATG.12 
.................... #BIT RG13=LATG.13 
.................... #BIT LCD_RW=LATG.0 
.................... #BIT LCD_RS=LATG.1 
.................... #BIT LCD_E=LATG.14 
.................... #BIT RG15=LATG.15 
.................... #BIT SCK2=LATG.6 // SPI2 pins 
.................... #BIT SDI2=LATG.7 
.................... #BIT SDO2=LATG.8 
.................... //#BIT SS2=LATG.9 
.................... #BIT SCK2_TRIS=TRISG.6 // SPI2 tris 
.................... #BIT SDI2_TRIS=TRISG.7 
.................... #BIT SDO2_TRIS=TRISG.8 
.................... #BIT TRG12=TRISG.12 
.................... #BIT TRG13=TRISG.13 
.................... #BIT LCD_RW_TRIS=TRISG.0 
.................... #BIT LCD_RS_TRIS=TRISG.1 
.................... #BIT LCD_E_TRIS=TRISG.14 
....................  
.................... //#BIT SS2_TRIS=TRISG.9 
....................  
.................... #define ADC_Dout SDI2 //???? Din ?? 
.................... #define ADC_Din SDO2  //???? Dout ?? 
....................  
.................... #BIT  ADC_RESET_TRIS=TRISD.3 
.................... #BIT  ADC_RESET=LATD.3 
.................... #BIT  ADC_SYNC_TRIS=TRISD.2 
.................... #BIT  ADC_SYNC=LATD.2 
.................... #BIT  ADC_CS_TRIS=TRISG.9 
.................... #BIT  ADC_CS = LATG.9 
.................... #BIT  ADC_DRDY_TRIS = LATD.1 
.................... #BIT  ADC_DRDY = PORTD.1 
....................  
.................... #define FCY      40000000 
.................... #define BAUDRATE 9600                 
.................... #define BRGVAL   ((FCY/BAUDRATE)/16)-1 
....................  
.................... //#define Flash_adr1 0xAD00 // ADC sps variable location 
.................... //#define Flash_adr2 0xAE00 // average variable location 
....................  
.................... //#ORG Flash_adr1, Flash_adr2 // зарезервировал ячейки флэш для сохр. параметров 
....................  
.................... #define CK_FLASH_END       (getenv("PROGRAM_MEMORY")-1)       
.................... #define CK_FLASH_PAGE_SIZE (getenv("FLASH_ERASE_SIZE")/2)  
.................... #define CK_NUM_PAGES (CK_FLASH_END/CK_FLASH_PAGE_SIZE)  
....................  
.................... #define CK_USER_PAGE (CK_FLASH_PAGE_SIZE*(CK_NUM_PAGES-1))  
....................  
.................... #org CK_USER_PAGE,CK_FLASH_END {}  
....................  
....................  
....................  
....................    typedef unsigned int16 U16; 
....................    typedef unsigned int8 U8; 
....................    typedef unsigned int32 U32; 
....................    typedef signed int32 S32; 
....................    typedef signed int16 S16; 
....................    typedef signed int8 S8; 
....................  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
*
0173C:  MOV     W5,[W15++]
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
0173E:  MOV     94C,W0
01740:  MOV     94E,W1
01742:  MOV     #0,W2
01744:  MOV     #0,W3
01746:  CALL    16D4
0174A:  BRA     C,174E
0174C:  BRA     NZ,1754
....................       return(0.0); 
0174E:  MOV     #0,W0
01750:  MOV     #0,W1
01752:  BRA     1836
....................  
....................    y=x; 
01754:  PUSH    94C
01756:  POP     950
01758:  PUSH    94E
0175A:  POP     952
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
0175C:  MOV     #950,W5
0175E:  ADD     W5,#3,W5
01760:  MOV     W5,95C
....................     data1 = *(((unsigned int8 *)(&y))+3); 
01762:  MOV     #950,W5
01764:  ADD     W5,#3,W5
01766:  MOV     W5,W0
01768:  MOV     958,W4
0176A:  MOV.B   [W0+#0],W4L
0176C:  MOV     W4,958
0176E:  CLR.B   959
....................     data2 = *(((unsigned int8 *)(&y))+2); 
01770:  MOV     #950,W5
01772:  ADD     W5,#2,W5
01774:  MOV     W5,W0
01776:  MOV     95A,W4
01778:  MOV.B   [W0+#0],W4L
0177A:  MOV     W4,95A
0177C:  CLR.B   95B
....................     rotate_left(&data1,1);     
0177E:  MOV     #958,W1
01780:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7))     
01782:  BTSS.B  95A.7
01784:  BRA     1788
....................        bit_set(data1,0);     
01786:  BSET.B  958.0
....................     data1 = ((data1+127) >>1); 
01788:  MOV     #7F,W4
0178A:  MOV     958,W3
0178C:  ADD     W3,W4,W5
0178E:  MOV     W5,958
01790:  LSR     958
....................     bit_clear(data2,7); 
01792:  BCLR.B  95A.7
....................     if(bit_test(data1,0)) 
01794:  BTSS.B  958.0
01796:  BRA     179A
....................        bit_set(data2,7); 
01798:  BSET.B  95A.7
....................     data1 = data1 >>1; 
0179A:  LSR     958
....................     *(((unsigned int8 *)(&y))+3) = data1; 
0179C:  MOV     #950,W5
0179E:  ADD     W5,#3,W5
017A0:  MOV     W5,W0
017A2:  MOV     W0,W5
017A4:  MOV     958,W0
017A6:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
017A8:  MOV     #950,W5
017AA:  ADD     W5,#2,W5
017AC:  MOV     W5,W0
017AE:  MOV     W0,W5
017B0:  MOV     95A,W0
017B2:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
017B4:  PUSH    950
017B6:  POP     954
017B8:  PUSH    952
017BA:  POP     956
....................       y+=(x/y); 
017BC:  MOV     94C,W0
017BE:  MOV     94E,W1
017C0:  MOV     950,W2
017C2:  MOV     952,W3
017C4:  CALL    1460
017C8:  BCLR.B  43.0
017CA:  MOV     W0,W2
017CC:  MOV     W1,W3
017CE:  MOV     950,W0
017D0:  MOV     952,W1
017D2:  CALL    152A
017D6:  MOV     W0,950
017D8:  MOV     W1,952
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
017DA:  MOV     #950,W5
017DC:  ADD     W5,#3,W5
017DE:  MOV     W5,W0
017E0:  MOV     958,W4
017E2:  MOV.B   [W0+#0],W4L
017E4:  MOV     W4,958
017E6:  CLR.B   959
....................     data2 = *(((unsigned int8 *)(&y))+2); 
017E8:  MOV     #950,W5
017EA:  ADD     W5,#2,W5
017EC:  MOV     W5,W0
017EE:  MOV     95A,W4
017F0:  MOV.B   [W0+#0],W4L
017F2:  MOV     W4,95A
017F4:  CLR.B   95B
....................     rotate_left(&data1,1); 
017F6:  MOV     #958,W1
017F8:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7)) 
017FA:  BTSS.B  95A.7
017FC:  BRA     1800
....................        bit_set(data1,0);     
017FE:  BSET.B  958.0
....................     data1--; 
01800:  DEC     0958
....................     bit_clear(data2,7); 
01802:  BCLR.B  95A.7
....................     if(bit_test(data1,0)) 
01804:  BTSS.B  958.0
01806:  BRA     180A
....................        bit_set(data2,7); 
01808:  BSET.B  95A.7
....................     data1 = data1 >>1; 
0180A:  LSR     958
....................     *(((unsigned int8 *)(&y))+3) = data1; 
0180C:  MOV     #950,W5
0180E:  ADD     W5,#3,W5
01810:  MOV     W5,W0
01812:  MOV     W0,W5
01814:  MOV     958,W0
01816:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
01818:  MOV     #950,W5
0181A:  ADD     W5,#2,W5
0181C:  MOV     W5,W0
0181E:  MOV     W0,W5
01820:  MOV     95A,W0
01822:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................    } while(res != y); 
01824:  MOV     954,W0
01826:  MOV     956,W1
01828:  MOV     950,W2
0182A:  MOV     952,W3
0182C:  CALL    16D4
01830:  BRA     NZ,17B4
....................  
....................    return(res); 
01832:  MOV     954,W0
01834:  MOV     956,W1
01836:  MOV     [--W15],W5
01838:  RETURN  
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #use rs232(UART2,baud=9600,parity=N,bits=8) 
....................  
.................... static S32 ADC_RByte1=0; 
.................... static S32 ADC_RByte2=0; 
.................... static S32 ADC_RByte3=0; 
.................... static S32 ADC_RByte_Sum=0; 
.................... static S32 ADCresult=0; 
.................... static float Vin;                           
.................... static U8 PGA; 
....................    //static float Vref=2.5; 
.................... static U8 Sps_buf,Global_Ch_Number=0; 
.................... static S16 ADCaddCoef; 
.................... static float ADCmulCoef; 
.................... //volatile U16 Tenth_K, Hundredth_K, Thousandth_K  = 0; 
.................... U8 LCD_num_symb, LCD_num_symb_K = 1;                  // по умолчанию одна цифра для вывода Т на ЛСД 
.................... U16 flash_wr_U16 [] = {0,0,0,0};                      // заготовка массива для записи во флэш float 
.................... U16 flash_rd_U16 [4]; 
.................... U8 Sps_Wr = 0;                                        // скорость измерения АЦП 
.................... U8 CRC_Wr = 0;                                        // Контрольная сумма 
.................... //S32 Temper_int_K = 0; 
.................... //float Final_TK = 0.0; 
.................... float Max_Temp = 40.0;                                // Максимальная температура нагревателя 
.................... U16 T_Pulse = 10000;                                  // Число импульсов в периоде 
.................... U16 Number_Pulse = 0;                              // Кол-во импульсов в Duty_Cycle 
.................... U16 count = 0; 
.................... U16 Freq = 64535;                                     // Account starts with this number and finishes on 65535. 
....................                                                       // Interrupt occur with frequency F = 100kHz.                                                    
.................... U8 menu_item = 0; 
.................... volatile S8 menu_sel = 0; 
....................     
.................... U8 menu_fl = 0; 
.................... int1 meas_stop_fl = 0; 
.................... int1 LCD_clear_fl = 1; 
.................... int1 reset_fl = 0;                              // флаг сброса системы 
.................... U8 count_CN4 = 0;                               // счётчик для отсчитывания времени нажатия Кнопки 4 
.................... U8 count_CN3 = 0;                               // счётчик для отсчитывания времени нажатия Кнопки 3 
....................     
.................... U8 NumAver = 1;                                 // размер усреднения 
.................... U8 ADC_sps_var = 1;                             // переменная усреднения данных АЦП  
.................... U8 CRC1=0xFF,CRC2=0xFF, CRC_buf;                // константы EEPROM CRC 
.................... U32 temp  = 0;                                  // промежуточный буфер для вычислений T 
....................  
.................... float TmpInt = 0;                                   // Integral term 
.................... float P = 0;                                    // Proportional term 
.................... float TemperatureInCelsius = 0; 
.................... float TemperatureInKelvin = 0; 
.................... float K1 = 600.0;                               // Arbitrary coefficient 
.................... float K2 = 5.0;                                 // Arbitrary coefficient 
.................... unsigned int16 Integer_part = 0; 
.................... unsigned int8 Tenth = 0; 
....................     
.................... static unsigned int8 buf;                          // lcd buf 
.................... #BIT buf4 = buf.4  
.................... #BIT buf5 = buf.5 
.................... #BIT buf6 = buf.6 
.................... #BIT buf7 = buf.7 
....................  
.................... #include <MT-16S4A-2FLG.h> 
.................... #define Line_1    0x00 
.................... #define Line_2    0x40 
.................... #define Line_3    0x10 
.................... #define Line_4    0x50 
....................  
....................  
.................... static void LCDWriteNibble(unsigned char uc)       // Запись половины байта 
.................... {                                            
....................   uc = uc << 4;                                    // Align with bits 7-4 
*
006DC:  MOV.B   94A,W0L
006DE:  CLR.B   1
006E0:  SL      W0,#4,W0
006E2:  MOV.B   W0L,94A
....................   LCD_RW = 0; 
006E4:  BCLR.B  2E8.0
....................   buf = uc; 
006E6:  MOV.B   94A,W0L
006E8:  MOV.B   W0L,91B
....................   RG12 = buf4; 
006EA:  BCLR.B  2E9.4
006EC:  BTSC.B  91B.4
006EE:  BSET.B  2E9.4
....................   RG13 = buf5; 
006F0:  BCLR.B  2E9.5
006F2:  BTSC.B  91B.5
006F4:  BSET.B  2E9.5
....................   RB1 = buf6; 
006F6:  BCLR.B  2CA.1
006F8:  BTSC.B  91B.6
006FA:  BSET.B  2CA.1
....................   RB0 = buf7; 
006FC:  BCLR.B  2CA.0
006FE:  BTSC.B  91B.7
00700:  BSET.B  2CA.0
....................   delay_ms(1); 
00702:  REPEAT  #1C3E
00704:  NOP     
00706:  REPEAT  #3FFF
00708:  NOP     
0070A:  REPEAT  #3FFF
0070C:  NOP     
....................   LCD_E = 1; 
0070E:  BSET.B  2E9.6
....................   delay_us(2); 
00710:  REPEAT  #4E
00712:  NOP     
....................   LCD_E = 0;  
00714:  BCLR.B  2E9.6
00716:  RETURN  
.................... } 
....................  
.................... static void LCDWriteData(unsigned char uc) 
*
007BC:  MOV     W5,[W15++]
.................... { 
....................     LCD_RS=0; 
007BE:  BCLR.B  2E8.1
....................     delay_us(500); 
007C0:  REPEAT  #E1E
007C2:  NOP     
007C4:  REPEAT  #3FFF
007C6:  NOP     
....................     LCD_RS=1; 
007C8:  BSET.B  2E8.1
....................     LCD_RW=1;// ?????????????? ???????? ????????????? 
007CA:  BSET.B  2E8.0
....................     LCDWriteNibble(uc>>4);//???? ???????? ??????? 
007CC:  MOV     946,W5
007CE:  CLR.B   B
007D0:  CLR.B   B
007D2:  LSR     W5,#4,W5
007D4:  PUSH    94A
007D6:  MOV.B   W5L,[W15-#2]
007D8:  POP     94A
007DA:  CALL    6DC
....................     LCDWriteNibble(uc); 
007DE:  MOV.B   946,W0L
007E0:  MOV.B   W0L,94A
007E2:  CALL    6DC
007E6:  MOV     [--W15],W5
007E8:  RETURN  
.................... } 
....................  
.................... static void LCDCommand(unsigned char uc) 
*
00718:  MOV     W5,[W15++]
.................... { 
....................     LCD_RS=0; /* Instruction mode */ 
0071A:  BCLR.B  2E8.1
....................     delay_us(500); 
0071C:  REPEAT  #E1E
0071E:  NOP     
00720:  REPEAT  #3FFF
00722:  NOP     
....................     LCD_RW=1;// ?????????????? ???????? ????????????? 
00724:  BSET.B  2E8.0
....................     LCDWriteNibble(uc>>4); 
00726:  MOV     92E,W5
00728:  CLR.B   B
0072A:  CLR.B   B
0072C:  LSR     W5,#4,W5
0072E:  PUSH    94A
00730:  MOV.B   W5L,[W15-#2]
00732:  POP     94A
00734:  CALL    6DC
....................     LCDWriteNibble(uc);   
00738:  MOV.B   92E,W0L
0073A:  MOV.B   W0L,94A
0073C:  CALL    6DC
00740:  MOV     [--W15],W5
00742:  RETURN  
.................... } 
....................  
.................... static void LCDSetCursor(unsigned char ucPos) 
*
007FE:  MOV     W5,[W15++]
.................... { 
....................   LCDCommand(0x80 | ucPos); 
00800:  MOV     92A,W5
00802:  IOR     #80,W5
00804:  PUSH    92E
00806:  MOV.B   W5L,[W15-#2]
00808:  POP     92E
0080A:  CALL    718
0080E:  MOV     [--W15],W5
00810:  RETURN  
.................... } 
....................  
.................... static void LCDClear(void) 
.................... { 
....................    LCDCommand(0x1); 
*
007AE:  MOV.B   #1,W0L
007B0:  MOV.B   W0L,92E
007B2:  CALL    718
....................    Delay_us(200); 
007B6:  REPEAT  #1F3E
007B8:  NOP     
007BA:  RETURN  
.................... } 
....................  
.................... static void LCDInit(void) 
.................... { 
....................   LCD_E=0; 
*
00744:  BCLR.B  2E9.6
....................   LCD_RS=0; 
00746:  BCLR.B  2E8.1
....................   delay_ms(20); 
00748:  MOV     #14,W0
0074A:  CALL    6C4
....................   LCDWriteNibble(3); 
0074E:  MOV.B   #3,W0L
00750:  MOV.B   W0L,94A
00752:  CALL    6DC
....................   Delay_ms(40); 
00756:  MOV     #28,W0
00758:  CALL    6C4
....................   LCDWriteNibble(3); 
0075C:  MOV.B   #3,W0L
0075E:  MOV.B   W0L,94A
00760:  CALL    6DC
....................   Delay_ms(40); 
00764:  MOV     #28,W0
00766:  CALL    6C4
....................   LCDWriteNibble(3); 
0076A:  MOV.B   #3,W0L
0076C:  MOV.B   W0L,94A
0076E:  CALL    6DC
....................   Delay_ms(40); 
00772:  MOV     #28,W0
00774:  CALL    6C4
....................   LCDWriteNibble(2); 
00778:  MOV.B   #2,W0L
0077A:  MOV.B   W0L,94A
0077C:  CALL    6DC
....................   Delay_ms(40); 
00780:  MOV     #28,W0
00782:  CALL    6C4
....................  
.................... // --- Function Set --- // 
....................    LCDCommand(0x2A);      //Настройка 4-ёхбитного режима работы ЖКИ, страница 1 встроенного знакогенератора 
00786:  MOV.B   #2A,W0L
00788:  MOV.B   W0L,92E
0078A:  CALL    718
....................     
.................... // --- Display ON/OFF control --- // 
....................    LCDCommand(0x0C);      //Включение индикатора, курсор выключен 
0078E:  MOV.B   #C,W0L
00790:  MOV.B   W0L,92E
00792:  CALL    718
....................     
.................... // --- Clear Display --- // 
....................    LCDCommand(0x01);      //Очистка индикатора 
00796:  MOV.B   #1,W0L
00798:  MOV.B   W0L,92E
0079A:  CALL    718
....................     
.................... // --- Entry Mode Set --- // 
....................    LCDCommand(0x06);      //Установка режима ввода данных: сдвигать курсор вправо 
0079E:  MOV.B   #6,W0L
007A0:  MOV.B   W0L,92E
007A2:  CALL    718
....................   Delay_ms(20); 
007A6:  MOV     #14,W0
007A8:  CALL    6C4
007AC:  RETURN  
....................  } 
....................  
.................... static void LCDPutCh(char c) 
.................... { 
....................   LCDWriteData(c); 
*
007EA:  MOV.B   944,W0L
007EC:  MOV.B   W0L,946
007EE:  CALL    7BC
007F2:  RETURN  
.................... } 
....................  
.................... static void LCDMsg(char c) 
.................... { 
....................     LCDPutCh(c); 
007F4:  MOV.B   92C,W0L
007F6:  MOV.B   W0L,944
007F8:  CALL    7EA
007FC:  RETURN  
.................... } 
....................  
.................... static void LCDWelcome(void) 
*
00812:  MOV     W5,[W15++]
.................... { 
....................     LCDClear(); 
00814:  CALL    7AE
....................     LCDMsg(" "); 
00818:  MOV     #0,W5
0081A:  MOV     W5,W0
0081C:  CALL    200
00820:  IOR.B   #0,W0L
00822:  BTSC.B  42.1
00824:  BRA     830
00826:  INC     W5,W5
00828:  MOV.B   W0L,92C
0082A:  CALL    7F4
0082E:  BRA     81A
....................     //Delay_ms(2000); 
....................     LCDSetCursor(0x40); 
00830:  MOV.B   #40,W0L
00832:  MOV.B   W0L,92A
00834:  CALL    7FE
....................     LCDMsg("АнтикриостатV1.0"); 
00838:  MOV     #0,W5
0083A:  MOV     W5,W0
0083C:  CALL    20E
00840:  IOR.B   #0,W0L
00842:  BTSC.B  42.1
00844:  BRA     850
00846:  INC     W5,W5
00848:  MOV.B   W0L,92C
0084A:  CALL    7F4
0084E:  BRA     83A
....................     LCDSetCursor(0x50); 
00850:  MOV.B   #50,W0L
00852:  MOV.B   W0L,92A
00854:  CALL    7FE
....................     LCDMsg("___JINR_LHEP____"); 
00858:  MOV     #0,W5
0085A:  MOV     W5,W0
0085C:  CALL    22C
00860:  IOR.B   #0,W0L
00862:  BTSC.B  42.1
00864:  BRA     870
00866:  INC     W5,W5
00868:  MOV.B   W0L,92C
0086A:  CALL    7F4
0086E:  BRA     85A
....................     Delay_ms(2000); 
00870:  MOV     #7D0,W0
00872:  CALL    6C4
....................     LCDClear();    
00876:  CALL    7AE
0087A:  MOV     [--W15],W5
0087C:  RETURN  
.................... } 
....................  
.................... static void LCDPutU16(U32 _u16,U8 u8NumDigs) 
*
01C9E:  MOV     W5,[W15++]
.................... { 
....................     U32 u16a ,u16b;    
....................    u16a=_u16/10000; 
01CA0:  BCLR.B  43.0
01CA2:  MOV     92C,W0
01CA4:  MOV     92E,W1
01CA6:  MOV     #2710,W2
01CA8:  MOV     #0,W3
01CAA:  CALL    1C1A
01CAE:  MOV     W0,932
01CB0:  MOV     W1,934
....................    u16b=u16a*10000; 
01CB2:  MOV     932,W0
01CB4:  MOV     934,W1
01CB6:  MOV     #2710,W2
01CB8:  MOV     #0,W3
01CBA:  CALL    1C6E
01CBE:  MOV     W0,936
01CC0:  MOV     W1,938
....................  
....................     if (u8NumDigs>=5) 
01CC2:  MOV     930,W4
01CC4:  CP.B    W4L,#5
01CC6:  BRA     NC,1CD8
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01CC8:  MOV     #30,W4
01CCA:  MOV     932,W3
01CCC:  ADD.B   W3L,W4L,W5L
01CCE:  PUSH    944
01CD0:  MOV.B   W5L,[W15-#2]
01CD2:  POP     944
01CD4:  CALL    7EA
....................     } 
....................  
....................     _u16-=u16b; 
01CD8:  MOV     92C,W4
01CDA:  MOV     936,W3
01CDC:  SUB     W4,W3,W0
01CDE:  MOV     W0,92C
01CE0:  MOV     92E,W4
01CE2:  MOV     938,W3
01CE4:  SUBB    W4,W3,W0
01CE6:  MOV     W0,92E
....................     u16a=_u16/1000; 
01CE8:  BCLR.B  43.0
01CEA:  MOV     92C,W0
01CEC:  MOV     92E,W1
01CEE:  MOV     #3E8,W2
01CF0:  MOV     #0,W3
01CF2:  CALL    1C1A
01CF6:  MOV     W0,932
01CF8:  MOV     W1,934
....................     u16b=u16a*1000; 
01CFA:  MOV     932,W0
01CFC:  MOV     934,W1
01CFE:  MOV     #3E8,W2
01D00:  MOV     #0,W3
01D02:  CALL    1C6E
01D06:  MOV     W0,936
01D08:  MOV     W1,938
....................     if (u8NumDigs>=4) 
01D0A:  MOV     930,W4
01D0C:  CP.B    W4L,#4
01D0E:  BRA     NC,1D20
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01D10:  MOV     #30,W4
01D12:  MOV     932,W3
01D14:  ADD.B   W3L,W4L,W5L
01D16:  PUSH    944
01D18:  MOV.B   W5L,[W15-#2]
01D1A:  POP     944
01D1C:  CALL    7EA
....................     } 
....................  
....................     _u16-=u16b; 
01D20:  MOV     92C,W4
01D22:  MOV     936,W3
01D24:  SUB     W4,W3,W0
01D26:  MOV     W0,92C
01D28:  MOV     92E,W4
01D2A:  MOV     938,W3
01D2C:  SUBB    W4,W3,W0
01D2E:  MOV     W0,92E
....................     u16a=_u16/100; 
01D30:  BCLR.B  43.0
01D32:  MOV     92C,W0
01D34:  MOV     92E,W1
01D36:  MOV     #64,W2
01D38:  MOV     #0,W3
01D3A:  CALL    1C1A
01D3E:  MOV     W0,932
01D40:  MOV     W1,934
....................     u16b=u16a*100; 
01D42:  MOV     932,W0
01D44:  MOV     934,W1
01D46:  MOV     #64,W2
01D48:  MOV     #0,W3
01D4A:  CALL    1C6E
01D4E:  MOV     W0,936
01D50:  MOV     W1,938
....................     if (u8NumDigs>=3) 
01D52:  MOV     930,W4
01D54:  CP.B    W4L,#3
01D56:  BRA     NC,1D68
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01D58:  MOV     #30,W4
01D5A:  MOV     932,W3
01D5C:  ADD.B   W3L,W4L,W5L
01D5E:  PUSH    944
01D60:  MOV.B   W5L,[W15-#2]
01D62:  POP     944
01D64:  CALL    7EA
....................        
....................     } 
....................  
....................     _u16-=u16b; 
01D68:  MOV     92C,W4
01D6A:  MOV     936,W3
01D6C:  SUB     W4,W3,W0
01D6E:  MOV     W0,92C
01D70:  MOV     92E,W4
01D72:  MOV     938,W3
01D74:  SUBB    W4,W3,W0
01D76:  MOV     W0,92E
....................     u16a=_u16/10; 
01D78:  BCLR.B  43.0
01D7A:  MOV     92C,W0
01D7C:  MOV     92E,W1
01D7E:  MOV     #A,W2
01D80:  MOV     #0,W3
01D82:  CALL    1C1A
01D86:  MOV     W0,932
01D88:  MOV     W1,934
....................     u16b=u16a*10; 
01D8A:  MOV     932,W0
01D8C:  MOV     934,W1
01D8E:  MOV     #A,W2
01D90:  MOV     #0,W3
01D92:  CALL    1C6E
01D96:  MOV     W0,936
01D98:  MOV     W1,938
....................    if (u8NumDigs>=2) 
01D9A:  MOV     930,W4
01D9C:  CP.B    W4L,#2
01D9E:  BRA     NC,1DB0
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01DA0:  MOV     #30,W4
01DA2:  MOV     932,W3
01DA4:  ADD.B   W3L,W4L,W5L
01DA6:  PUSH    944
01DA8:  MOV.B   W5L,[W15-#2]
01DAA:  POP     944
01DAC:  CALL    7EA
....................     } 
....................  
....................     _u16-=u16b; 
01DB0:  MOV     92C,W4
01DB2:  MOV     936,W3
01DB4:  SUB     W4,W3,W0
01DB6:  MOV     W0,92C
01DB8:  MOV     92E,W4
01DBA:  MOV     938,W3
01DBC:  SUBB    W4,W3,W0
01DBE:  MOV     W0,92E
....................     if (u8NumDigs>=1) 
01DC0:  MOV     930,W4
01DC2:  CP.B    W4L,#1
01DC4:  BRA     NC,1DD6
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
01DC6:  MOV     #30,W4
01DC8:  MOV     92C,W3
01DCA:  ADD.B   W3L,W4L,W5L
01DCC:  PUSH    944
01DCE:  MOV.B   W5L,[W15-#2]
01DD0:  POP     944
01DD2:  CALL    7EA
....................     } 
01DD6:  MOV     [--W15],W5
01DD8:  RETURN  
....................    
.................... } 
....................  
.................... static void LCDPutU32(U32 _u16,U8 u8NumDigs) 
*
01E7C:  MOV     W5,[W15++]
.................... { 
....................     U32 u16a ,u16b; 
....................      
....................    u16a=_u16/10000000; 
01E7E:  BCLR.B  43.0
01E80:  MOV     92E,W0
01E82:  MOV     930,W1
01E84:  MOV     #9680,W2
01E86:  MOV     #98,W3
01E88:  CALL    1C1A
01E8C:  MOV     W0,934
01E8E:  MOV     W1,936
....................    u16b=u16a*10000000; 
01E90:  MOV     934,W0
01E92:  MOV     936,W1
01E94:  MOV     #9680,W2
01E96:  MOV     #98,W3
01E98:  CALL    1C6E
01E9C:  MOV     W0,938
01E9E:  MOV     W1,93A
....................  
....................     if (u8NumDigs>=8) 
01EA0:  MOV     932,W4
01EA2:  CP.B    W4L,#8
01EA4:  BRA     NC,1EB6
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01EA6:  MOV     #30,W4
01EA8:  MOV     934,W3
01EAA:  ADD.B   W3L,W4L,W5L
01EAC:  PUSH    944
01EAE:  MOV.B   W5L,[W15-#2]
01EB0:  POP     944
01EB2:  CALL    7EA
....................     } 
....................       _u16-=u16b; 
01EB6:  MOV     92E,W4
01EB8:  MOV     938,W3
01EBA:  SUB     W4,W3,W0
01EBC:  MOV     W0,92E
01EBE:  MOV     930,W4
01EC0:  MOV     93A,W3
01EC2:  SUBB    W4,W3,W0
01EC4:  MOV     W0,930
....................        
....................    u16a=_u16/1000000; 
01EC6:  BCLR.B  43.0
01EC8:  MOV     92E,W0
01ECA:  MOV     930,W1
01ECC:  MOV     #4240,W2
01ECE:  MOV     #F,W3
01ED0:  CALL    1C1A
01ED4:  MOV     W0,934
01ED6:  MOV     W1,936
....................    u16b=u16a*1000000; 
01ED8:  MOV     934,W0
01EDA:  MOV     936,W1
01EDC:  MOV     #4240,W2
01EDE:  MOV     #F,W3
01EE0:  CALL    1C6E
01EE4:  MOV     W0,938
01EE6:  MOV     W1,93A
....................        
....................     if (u8NumDigs>=7) 
01EE8:  MOV     932,W4
01EEA:  CP.B    W4L,#7
01EEC:  BRA     NC,1EFE
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01EEE:  MOV     #30,W4
01EF0:  MOV     934,W3
01EF2:  ADD.B   W3L,W4L,W5L
01EF4:  PUSH    944
01EF6:  MOV.B   W5L,[W15-#2]
01EF8:  POP     944
01EFA:  CALL    7EA
....................     } 
....................       _u16-=u16b; 
01EFE:  MOV     92E,W4
01F00:  MOV     938,W3
01F02:  SUB     W4,W3,W0
01F04:  MOV     W0,92E
01F06:  MOV     930,W4
01F08:  MOV     93A,W3
01F0A:  SUBB    W4,W3,W0
01F0C:  MOV     W0,930
....................        
....................    u16a=_u16/100000; 
01F0E:  BCLR.B  43.0
01F10:  MOV     92E,W0
01F12:  MOV     930,W1
01F14:  MOV     #86A0,W2
01F16:  MOV     #1,W3
01F18:  CALL    1C1A
01F1C:  MOV     W0,934
01F1E:  MOV     W1,936
....................    u16b=u16a*100000; 
01F20:  MOV     934,W0
01F22:  MOV     936,W1
01F24:  MOV     #86A0,W2
01F26:  MOV     #1,W3
01F28:  CALL    1C6E
01F2C:  MOV     W0,938
01F2E:  MOV     W1,93A
....................  
....................     if (u8NumDigs>=6) 
01F30:  MOV     932,W4
01F32:  CP.B    W4L,#6
01F34:  BRA     NC,1F46
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01F36:  MOV     #30,W4
01F38:  MOV     934,W3
01F3A:  ADD.B   W3L,W4L,W5L
01F3C:  PUSH    944
01F3E:  MOV.B   W5L,[W15-#2]
01F40:  POP     944
01F42:  CALL    7EA
....................     } 
....................  
....................     _u16-=u16b; 
01F46:  MOV     92E,W4
01F48:  MOV     938,W3
01F4A:  SUB     W4,W3,W0
01F4C:  MOV     W0,92E
01F4E:  MOV     930,W4
01F50:  MOV     93A,W3
01F52:  SUBB    W4,W3,W0
01F54:  MOV     W0,930
....................     u16a=_u16/10000; 
01F56:  BCLR.B  43.0
01F58:  MOV     92E,W0
01F5A:  MOV     930,W1
01F5C:  MOV     #2710,W2
01F5E:  MOV     #0,W3
01F60:  CALL    1C1A
01F64:  MOV     W0,934
01F66:  MOV     W1,936
....................     u16b=u16a*10000; 
01F68:  MOV     934,W0
01F6A:  MOV     936,W1
01F6C:  MOV     #2710,W2
01F6E:  MOV     #0,W3
01F70:  CALL    1C6E
01F74:  MOV     W0,938
01F76:  MOV     W1,93A
....................     if (u8NumDigs>=5) 
01F78:  MOV     932,W4
01F7A:  CP.B    W4L,#5
01F7C:  BRA     NC,1F8E
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01F7E:  MOV     #30,W4
01F80:  MOV     934,W3
01F82:  ADD.B   W3L,W4L,W5L
01F84:  PUSH    944
01F86:  MOV.B   W5L,[W15-#2]
01F88:  POP     944
01F8A:  CALL    7EA
....................     } 
....................  
....................     _u16-=u16b; 
01F8E:  MOV     92E,W4
01F90:  MOV     938,W3
01F92:  SUB     W4,W3,W0
01F94:  MOV     W0,92E
01F96:  MOV     930,W4
01F98:  MOV     93A,W3
01F9A:  SUBB    W4,W3,W0
01F9C:  MOV     W0,930
....................     u16a=_u16/1000; 
01F9E:  BCLR.B  43.0
01FA0:  MOV     92E,W0
01FA2:  MOV     930,W1
01FA4:  MOV     #3E8,W2
01FA6:  MOV     #0,W3
01FA8:  CALL    1C1A
01FAC:  MOV     W0,934
01FAE:  MOV     W1,936
....................     u16b=u16a*1000; 
01FB0:  MOV     934,W0
01FB2:  MOV     936,W1
01FB4:  MOV     #3E8,W2
01FB6:  MOV     #0,W3
01FB8:  CALL    1C6E
01FBC:  MOV     W0,938
01FBE:  MOV     W1,93A
....................     if (u8NumDigs>=4) 
01FC0:  MOV     932,W4
01FC2:  CP.B    W4L,#4
01FC4:  BRA     NC,1FD6
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
01FC6:  MOV     #30,W4
01FC8:  MOV     934,W3
01FCA:  ADD.B   W3L,W4L,W5L
01FCC:  PUSH    944
01FCE:  MOV.B   W5L,[W15-#2]
01FD0:  POP     944
01FD2:  CALL    7EA
....................     } 
....................  
....................     _u16-=u16b; 
01FD6:  MOV     92E,W4
01FD8:  MOV     938,W3
01FDA:  SUB     W4,W3,W0
01FDC:  MOV     W0,92E
01FDE:  MOV     930,W4
01FE0:  MOV     93A,W3
01FE2:  SUBB    W4,W3,W0
01FE4:  MOV     W0,930
....................     u16a=_u16/100; 
01FE6:  BCLR.B  43.0
01FE8:  MOV     92E,W0
01FEA:  MOV     930,W1
01FEC:  MOV     #64,W2
01FEE:  MOV     #0,W3
01FF0:  CALL    1C1A
01FF4:  MOV     W0,934
01FF6:  MOV     W1,936
....................     u16b=u16a*100; 
01FF8:  MOV     934,W0
01FFA:  MOV     936,W1
01FFC:  MOV     #64,W2
01FFE:  MOV     #0,W3
02000:  CALL    1C6E
02004:  MOV     W0,938
02006:  MOV     W1,93A
....................    if (u8NumDigs>=3) 
02008:  MOV     932,W4
0200A:  CP.B    W4L,#3
0200C:  BRA     NC,201E
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
0200E:  MOV     #30,W4
02010:  MOV     934,W3
02012:  ADD.B   W3L,W4L,W5L
02014:  PUSH    944
02016:  MOV.B   W5L,[W15-#2]
02018:  POP     944
0201A:  CALL    7EA
....................     } 
....................  
....................    _u16-=u16b; 
0201E:  MOV     92E,W4
02020:  MOV     938,W3
02022:  SUB     W4,W3,W0
02024:  MOV     W0,92E
02026:  MOV     930,W4
02028:  MOV     93A,W3
0202A:  SUBB    W4,W3,W0
0202C:  MOV     W0,930
....................     u16a=_u16/10; 
0202E:  BCLR.B  43.0
02030:  MOV     92E,W0
02032:  MOV     930,W1
02034:  MOV     #A,W2
02036:  MOV     #0,W3
02038:  CALL    1C1A
0203C:  MOV     W0,934
0203E:  MOV     W1,936
....................     u16b=u16a*10; 
02040:  MOV     934,W0
02042:  MOV     936,W1
02044:  MOV     #A,W2
02046:  MOV     #0,W3
02048:  CALL    1C6E
0204C:  MOV     W0,938
0204E:  MOV     W1,93A
....................    if (u8NumDigs>=2) 
02050:  MOV     932,W4
02052:  CP.B    W4L,#2
02054:  BRA     NC,2066
....................     { 
....................       LCDPutCh((U8)u16a+'0'); 
02056:  MOV     #30,W4
02058:  MOV     934,W3
0205A:  ADD.B   W3L,W4L,W5L
0205C:  PUSH    944
0205E:  MOV.B   W5L,[W15-#2]
02060:  POP     944
02062:  CALL    7EA
....................     } 
....................  
....................     _u16-=u16b; 
02066:  MOV     92E,W4
02068:  MOV     938,W3
0206A:  SUB     W4,W3,W0
0206C:  MOV     W0,92E
0206E:  MOV     930,W4
02070:  MOV     93A,W3
02072:  SUBB    W4,W3,W0
02074:  MOV     W0,930
....................     if (u8NumDigs>=1) 
02076:  MOV     932,W4
02078:  CP.B    W4L,#1
0207A:  BRA     NC,208C
....................     { 
....................       LCDPutCh((U8)_u16+'0'); 
0207C:  MOV     #30,W4
0207E:  MOV     92E,W3
02080:  ADD.B   W3L,W4L,W5L
02082:  PUSH    944
02084:  MOV.B   W5L,[W15-#2]
02086:  POP     944
02088:  CALL    7EA
....................     } 
0208C:  MOV     [--W15],W5
0208E:  RETURN  
....................    
.................... } 
....................  
.................... static void LCDPutS32(S32 s32a,U8 u8NumDigs) 
.................... { 
....................   char c='+'; 
....................  
....................   if (s32a<0) 
....................   { 
....................     s32a=-s32a; 
....................     c='-'; 
....................   } 
....................   LCDPutCh(c); 
....................   LCDPutU32((U32)s32a,u8NumDigs); 
.................... } 
....................  
.................... /* 
.................... static float sqrt_cpu_newton(float L) 
....................    { 
....................       float temp, div = L;  
....................       float rslt = (float)L;  
....................       if (L <= 0) return 0;  
....................       while (l) 
....................       { 
....................           temp = L/div + div;  
....................          div = temp >> 1;  
....................          div += temp & 1;  
....................          if (rslt > div) rslt = (U16)div;  
....................          else  
....................          { 
....................           if (l/rslt == rslt-1 && l%rslt==0) rslt--;  
....................           return rslt;  
....................           } 
....................       } 
....................    } 
....................    */ 
....................  
.................... #include <ADS1256.h> 
.................... static U8 RdReg(U8 RegName){ 
....................    U8 RegValue = 0;  
....................    //1st Command Byte: 0001 rrrr where rrrr is the address of the first register to read. 
....................    //2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to read – 1 
....................    ADC_CS = 0; 
....................    delay_us(1); 
....................    Spi_write2(0x10+RegName); // 1st Command Byte,??????? ?????? 
....................    Spi_write2(0x00); // 1st Command Byte, ?????? ?????? ???? ???? 
....................    delay_us(8); // 50 CLK_IN PEDIODS 
....................    RegValue = Spi_read2(0); 
....................    delay_us(1); 
....................    ADC_CS =1; 
....................    delay_us(1); 
....................    Return RegValue;   
.................... } 
....................  
.................... static void WrReg(U8 RegName,CommandByte) 
*
00B16:  MOV     W5,[W15++]
.................... { 
....................    ADC_CS = 0; 
00B18:  BCLR.B  2E9.1
....................    delay_us(5); 
00B1A:  REPEAT  #C6
00B1C:  NOP     
....................    Spi_write2(0x50+RegName); // 1st Command Byte: 0101 (0x50) rrrr where rrrr is the address to the first register to be written. 
00B1E:  MOV     92C,W4
00B20:  CLR.B   9
00B22:  MOV     #50,W3
00B24:  ADD     W3,W4,W5
00B26:  BCLR.B  260.6
00B28:  BTSS.B  260.0
00B2A:  BRA     B30
00B2C:  MOV.B   268,W0L
00B2E:  BRA     B28
00B30:  PUSH    268
00B32:  MOV.B   W5L,[W15-#2]
00B34:  POP     268
00B36:  BTSS.B  260.0
00B38:  BRA     B36
....................    delay_us(10); 
00B3A:  REPEAT  #18E
00B3C:  NOP     
....................    Spi_write2(0);         // 2nd Command Byte: 0000 nnnn where nnnn is the number of bytes to be written – 1. 
00B3E:  BCLR.B  260.6
00B40:  BTSS.B  260.0
00B42:  BRA     B48
00B44:  MOV.B   268,W0L
00B46:  BRA     B40
00B48:  CLR.B   268
00B4A:  BTSS.B  260.0
00B4C:  BRA     B4A
....................    delay_us(10); 
00B4E:  REPEAT  #18E
00B50:  NOP     
....................    Spi_write2(CommandByte); 
00B52:  BCLR.B  260.6
00B54:  BTSS.B  260.0
00B56:  BRA     B5C
00B58:  MOV.B   268,W0L
00B5A:  BRA     B54
00B5C:  MOV.B   92D,W0L
00B5E:  MOV.B   W0L,268
00B60:  BTSS.B  260.0
00B62:  BRA     B60
....................    delay_us(10); 
00B64:  REPEAT  #18E
00B66:  NOP     
....................    ADC_CS = 1; 
00B68:  BSET.B  2E9.1
....................    delay_us(50); 
00B6A:  REPEAT  #7CE
00B6C:  NOP     
00B6E:  MOV     [--W15],W5
00B70:  RETURN  
.................... } 
....................  
.................... static S32 ADC_RData(){             
....................  
....................      ADC_CS = 0; 
....................      delay_us(1); 
....................      Spi_write2(0x01); 
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      delay_us(1); 
....................      m1: 
....................      if(!ADC_DRDY){ 
....................      ADC_CS = 0; 
....................      delay_us(1); 
....................      ADC_Rbyte1 = Spi_read2(0); 
....................      ADC_Rbyte2 = Spi_read2(0); 
....................      ADC_Rbyte3 = Spi_read2(0); 
....................      delay_us(1); 
....................      ADC_CS = 1; 
....................      ADC_RByte_Sum = (ADC_Rbyte1<<16) + (ADC_Rbyte2<<8) + ADC_Rbyte3; 
....................      return ADC_RByte_Sum; 
....................      } 
....................      else goto m1; 
.................... } 
....................  
.................... static void ADC_StartRdContin(){ 
....................  
....................      ADC_CS = 0;        
*
00E42:  BCLR.B  2E9.1
....................      delay_us(1);                                          
00E44:  REPEAT  #26
00E46:  NOP     
....................      Spi_write2(0x03);              
00E48:  BCLR.B  260.6
00E4A:  BTSS.B  260.0
00E4C:  BRA     E52
00E4E:  MOV.B   268,W0L
00E50:  BRA     E4A
00E52:  MOV.B   #3,W0L
00E54:  MOV.B   W0L,268
00E56:  BTSS.B  260.0
00E58:  BRA     E56
....................      delay_us(1); 
00E5A:  REPEAT  #26
00E5C:  NOP     
....................      ADC_CS = 1; 
00E5E:  BSET.B  2E9.1
00E60:  RETURN  
.................... } 
....................  
.................... static S32 ADC_RdataC(){ 
*
00EE0:  MOV     W5,[W15++]
00EE2:  MOV     W6,[W15++]
....................      ADC_StartRdContin();    
00EE4:  CALL    E42
....................      While(ADC_DRDY) 
00EE8:  BTSS.B  2D4.1
00EEA:  BRA     EF4
....................      delay_us(1); 
00EEC:  REPEAT  #26
00EEE:  NOP     
00EF0:  GOTO    EE8
....................      ADC_CS = 0; 
00EF4:  BCLR.B  2E9.1
....................      delay_us(1); 
00EF6:  REPEAT  #26
00EF8:  NOP     
....................      ADC_Rbyte1 = Spi_read2(0); 
00EFA:  BCLR.B  260.6
00EFC:  BTSS.B  260.0
00EFE:  BRA     F04
00F00:  MOV.B   268,W0L
00F02:  BRA     EFC
00F04:  CLR.B   268
00F06:  BTSS.B  260.0
00F08:  BRA     F06
00F0A:  MOV.B   268,W0L
00F0C:  CLR.B   1
00F0E:  MOV     #0,W1
00F10:  MOV     W0,8B0
00F12:  MOV     W1,8B2
....................      ADC_Rbyte2 = Spi_read2(0); 
00F14:  BCLR.B  260.6
00F16:  BTSS.B  260.0
00F18:  BRA     F1E
00F1A:  MOV.B   268,W0L
00F1C:  BRA     F16
00F1E:  CLR.B   268
00F20:  BTSS.B  260.0
00F22:  BRA     F20
00F24:  MOV.B   268,W0L
00F26:  CLR.B   1
00F28:  MOV     #0,W1
00F2A:  MOV     W0,8B4
00F2C:  MOV     W1,8B6
....................      ADC_Rbyte3 = Spi_read2(0); 
00F2E:  BCLR.B  260.6
00F30:  BTSS.B  260.0
00F32:  BRA     F38
00F34:  MOV.B   268,W0L
00F36:  BRA     F30
00F38:  CLR.B   268
00F3A:  BTSS.B  260.0
00F3C:  BRA     F3A
00F3E:  MOV.B   268,W0L
00F40:  CLR.B   1
00F42:  MOV     #0,W1
00F44:  MOV     W0,8B8
00F46:  MOV     W1,8BA
....................      delay_us(1); 
00F48:  REPEAT  #26
00F4A:  NOP     
....................      ADC_CS = 1; 
00F4C:  BSET.B  2E9.1
....................      ADC_RByte_Sum = (ADC_Rbyte1<<24) + (ADC_Rbyte2<<16) + (ADC_Rbyte3<<8); 
00F4E:  MOV.B   8B0,W0L
00F50:  MOV.B   W0L,D
00F52:  CLR.B   W6
00F54:  CLR.B   B
00F56:  CLR.B   W5
00F58:  MOV     8B4,W1
00F5A:  MOV     #0,W0
00F5C:  ADD     W0,W5,W5
00F5E:  ADDC    W1,W6,W6
00F60:  MOV.B   8BA,W0L
00F62:  MOV.B   W0L,3
00F64:  MOV.B   8B9,W0L
00F66:  MOV.B   W0L,W1L
00F68:  MOV.B   8B8,W0L
00F6A:  MOV.B   W0L,1
00F6C:  CLR.B   W0
00F6E:  ADD     W0,W5,W0
00F70:  MOV     W0,8BC
00F72:  ADDC    W1,W6,W0
00F74:  MOV     W0,8BE
....................      return ADC_RByte_Sum/256; 
00F76:  BCLR.B  43.0
00F78:  MOV     8BC,W0
00F7A:  MOV     8BE,W1
00F7C:  MOV     #100,W2
00F7E:  MOV     #0,W3
00F80:  CALL    E62
00F84:  MOV.D   W0,W0
00F86:  MOV     [--W15],W6
00F88:  MOV     [--W15],W5
00F8A:  RETURN  
....................      } 
....................  
.................... static void ADC_StopRd(){ 
....................    ADC_CS = 0; 
*
00C08:  BCLR.B  2E9.1
....................    delay_us(5); 
00C0A:  REPEAT  #C6
00C0C:  NOP     
....................    Spi_write2(0x0F);   
00C0E:  BCLR.B  260.6
00C10:  BTSS.B  260.0
00C12:  BRA     C18
00C14:  MOV.B   268,W0L
00C16:  BRA     C10
00C18:  MOV.B   #F,W0L
00C1A:  MOV.B   W0L,268
00C1C:  BTSS.B  260.0
00C1E:  BRA     C1C
....................    delay_us(5); 
00C20:  REPEAT  #C6
00C22:  NOP     
....................    ADC_CS = 1; 
00C24:  BSET.B  2E9.1
....................    delay_us(50); 
00C26:  REPEAT  #7CE
00C28:  NOP     
00C2A:  RETURN  
....................  
.................... } 
....................  
.................... static void ADC_sps_set(U8 SPS){ 
....................    ADC_StopRd();                                                               
00C2C:  CALL    C08
....................    Sps_buf = SPS; 
00C30:  MOV.B   91C,W0L
00C32:  MOV.B   W0L,8C9
....................    WrReg(DRATE,SPS);                           
00C34:  MOV.B   #3,W0L
00C36:  MOV.B   W0L,92C
00C38:  MOV.B   91C,W0L
00C3A:  MOV.B   W0L,92D
00C3C:  CALL    B16
00C40:  RETURN  
.................... }  
....................  
.................... static void ADC_SelfCal(){                     
....................    ADC_CS = 0; 
*
00CDE:  BCLR.B  2E9.1
....................    delay_us(1); 
00CE0:  REPEAT  #26
00CE2:  NOP     
....................    Spi_write2(0xF0); 
00CE4:  BCLR.B  260.6
00CE6:  BTSS.B  260.0
00CE8:  BRA     CEE
00CEA:  MOV.B   268,W0L
00CEC:  BRA     CE6
00CEE:  MOV.B   #F0,W0L
00CF0:  MOV.B   W0L,268
00CF2:  BTSS.B  260.0
00CF4:  BRA     CF2
....................     delay_us(1); 
00CF6:  REPEAT  #26
00CF8:  NOP     
....................    ADC_CS = 1;   
00CFA:  BSET.B  2E9.1
....................    Switch (Sps_buf) {    
00CFC:  MOV.B   8C9,W0L
00CFE:  CLR.B   1
00D00:  XOR     #F0,W0
00D02:  BRA     Z,D32
00D04:  XOR     #10,W0
00D06:  BRA     Z,D3A
00D08:  XOR     #30,W0
00D0A:  BRA     Z,D42
00D0C:  XOR     #10,W0
00D0E:  BRA     Z,D4A
00D10:  XOR     #70,W0
00D12:  BRA     Z,D56
00D14:  XOR     #11,W0
00D16:  BRA     Z,D62
00D18:  XOR     #33,W0
00D1A:  BRA     Z,D76
00D1C:  XOR     #10,W0
00D1E:  BRA     Z,D80
00D20:  XOR     #E1,W0
00D22:  BRA     Z,D8E
00D24:  XOR     #20,W0
00D26:  BRA     Z,D98
00D28:  XOR     #60,W0
00D2A:  BRA     Z,DA2
00D2C:  XOR     #30,W0
00D2E:  BRA     Z,DAC
00D30:  BRA     DB6
....................       case 0xF0:    
....................        delay_us(220);         
00D32:  REPEAT  #225E
00D34:  NOP     
....................         break;                       
00D36:  GOTO    DB6
....................        
....................       case 0xE0: 
....................        delay_us(255);  
00D3A:  REPEAT  #27D6
00D3C:  NOP     
....................         break; 
00D3E:  GOTO    DB6
....................          
....................       case 0xD0: 
....................        delay_us(315);  
00D42:  REPEAT  #3136
00D44:  NOP     
....................         break; 
00D46:  GOTO    DB6
....................          
....................       case 0xC0: 
....................        delay_us(445);  
00D4A:  REPEAT  #586
00D4C:  NOP     
00D4E:  REPEAT  #3FFF
00D50:  NOP     
....................         break; 
00D52:  GOTO    DB6
....................          
....................       case 0xB0: 
....................        delay_us(685);  
00D56:  REPEAT  #2B06
00D58:  NOP     
00D5A:  REPEAT  #3FFF
00D5C:  NOP     
....................         break; 
00D5E:  GOTO    DB6
....................          
....................       case 0xA1: 
....................        delay_ms(1); 
00D62:  REPEAT  #1C3E
00D64:  NOP     
00D66:  REPEAT  #3FFF
00D68:  NOP     
00D6A:  REPEAT  #3FFF
00D6C:  NOP     
....................        delay_us(185);                
00D6E:  REPEAT  #1CE6
00D70:  NOP     
....................         break;       
00D72:  GOTO    DB6
....................          
....................       case 0x92: 
....................        delay_ms(5); 
00D76:  MOV     #5,W0
00D78:  CALL    6C4
....................         break; 
00D7C:  GOTO    DB6
....................          
....................       case 0x82: 
....................        delay_ms(10); 
00D80:  MOV     #A,W0
00D82:  CALL    6C4
....................        delay_us(200); 
00D86:  REPEAT  #1F3E
00D88:  NOP     
....................         break; 
00D8A:  GOTO    DB6
....................                     
....................       case 0x63: 
....................        delay_ms(21);  
00D8E:  MOV     #15,W0
00D90:  CALL    6C4
....................         break; 
00D94:  GOTO    DB6
....................          
....................       case 0x43: 
....................        delay_ms(41);  
00D98:  MOV     #29,W0
00D9A:  CALL    6C4
....................         break; 
00D9E:  GOTO    DB6
....................          
....................       case 0x23: 
....................        delay_ms(101);  
00DA2:  MOV     #65,W0
00DA4:  CALL    6C4
....................         break;          
00DA8:  GOTO    DB6
....................              
....................       case 0x13: 
....................        delay_ms(201);  
00DAC:  MOV     #C9,W0
00DAE:  CALL    6C4
....................         break;                           
00DB2:  GOTO    DB6
....................      }     
00DB6:  RETURN  
.................... } 
....................  
.................... static void ADC_setCh(U8 Ch_Number){ 
....................    ADC_StopRd(); 
*
00F8C:  CALL    C08
....................    Global_Ch_Number = Ch_Number; 
00F90:  MOV.B   92A,W0L
00F92:  MOV.B   W0L,8CA
....................    Switch (Ch_Number) { 
00F94:  MOV.B   92A,W0L
00F96:  CLR.B   1
00F98:  XOR     #2,W0
00F9A:  BRA     Z,FA2
00F9C:  XOR     #3,W0
00F9E:  BRA     Z,FB2
00FA0:  BRA     FC2
....................  
....................     //case 4:   WrReg(MUX,0x76); //7 & 6              
....................            //break; 
.................... //-------------------------------- 
....................     //case 3: WrReg(MUX,0x54);     
....................            //break; 
.................... //--------------------------------            
....................     case 2: WrReg(MUX,0x01);         
00FA2:  MOV.B   #1,W0L
00FA4:  MOV.B   W0L,92C
00FA6:  MOV.B   #1,W0L
00FA8:  MOV.B   W0L,92D
00FAA:  CALL    B16
....................            break; 
00FAE:  GOTO    FC2
.................... //--------------------------------     
....................     case 1: WrReg(MUX,0x23);     
00FB2:  MOV.B   #1,W0L
00FB4:  MOV.B   W0L,92C
00FB6:  MOV.B   #23,W0L
00FB8:  MOV.B   W0L,92D
00FBA:  CALL    B16
....................            break; 
00FBE:  GOTO    FC2
....................     //default:printf("bad cmd");   
....................             } 
....................  
....................    ADC_SelfCal(); 
00FC2:  CALL    CDE
....................    ADC_StartRdContin(); 
00FC6:  CALL    E42
....................    ADC_RdataC(); 
00FCA:  CALL    EE0
....................    ADC_RdataC(); 
00FCE:  CALL    EE0
....................    ADC_RdataC(); 
00FD2:  CALL    EE0
....................    ADC_RdataC(); 
00FD6:  CALL    EE0
00FDA:  RETURN  
.................... } 
....................  
.................... static S32 Read_ADC_vol_in(S32 k){ 
*
0132A:  MOV     W5,[W15++]
0132C:  MOV     #C,W5
0132E:  REPEAT  #4
01330:  MOV     [W5++],[W15++]
....................     S32 VinInt; 
....................     ADCresult = ADC_RDataC(); 
01332:  CALL    EE0
01336:  MOV     W0,8C0
01338:  MOV     W1,8C2
....................     ADCresult=ADCresult+ADCaddCoef; // Аддитивная ошибка, ошибка смещения  
0133A:  MOV     8CC,W0
0133C:  CLR     W1
0133E:  BTSC    W0.F
01340:  SETM    W1
01342:  ADD     8C0
01344:  MOV     W1,W0
01346:  ADDC    8C2,W0
01348:  MOV     W0,8C2
....................     Vin = ((ADCresult*5)/(8388608.0*PGA))*ADCmulCoef; 
0134A:  MOV     8C0,W0
0134C:  MOV     8C2,W1
0134E:  MOV     #5,W2
01350:  MOV     #0,W3
01352:  CALL    FDC
01356:  MOV     W0,W5
01358:  MOV     W1,W6
0135A:  MOV     #0,W1
0135C:  MOV     #0,W2
0135E:  MOV     #0,W3
01360:  MOV.B   8C8,W0L
01362:  CLR.B   1
01364:  CALL    8AC
01368:  MOV     W5,[W15++]
0136A:  MOV     W6,[W15++]
0136C:  MOV     W0,W4
0136E:  MOV     W1,W5
01370:  MOV     W2,W6
01372:  MOV     W3,W7
01374:  MOV     #0,W0
01376:  MOV     #0,W1
01378:  MOV     #0,W2
0137A:  MOV     #4160,W3
0137C:  CALL    101E
01380:  MOV     [--W15],W6
01382:  MOV     [--W15],W5
01384:  MOV     W0,W7
01386:  MOV     W1,W8
01388:  MOV     W2,W9
0138A:  MOV     W3,W10
0138C:  MOV     W5,W0
0138E:  MOV     W6,W1
01390:  CLR     W3
01392:  BTSC    W1.F
01394:  SETM    W3
01396:  MOV     W3,W2
01398:  CALL    112E
0139C:  MOV     W5,[W15++]
0139E:  MOV     W6,[W15++]
013A0:  MOV     W7,[W15++]
013A2:  MOV     W7,W4
013A4:  MOV     W8,W5
013A6:  MOV     W9,W6
013A8:  MOV     W10,W7
013AA:  CALL    910
013AE:  MOV     [--W15],W7
013B0:  MOV     [--W15],W6
013B2:  MOV     [--W15],W5
013B4:  MOV     W0,W5
013B6:  MOV     W1,W6
013B8:  MOV     W2,W7
013BA:  MOV     W3,W8
013BC:  MOV     8D0,W2
013BE:  MOV     8CE,W1
013C0:  MOV     #0,W0
013C2:  CALL    1192
013C6:  MOV     W5,[W15++]
013C8:  MOV     W6,[W15++]
013CA:  MOV     W7,[W15++]
013CC:  MOV     W0,W4
013CE:  MOV     W5,W0
013D0:  MOV     W1,W5
013D2:  MOV     W6,W1
013D4:  MOV     W2,W6
013D6:  MOV     W7,W2
013D8:  MOV     W3,W7
013DA:  MOV     W8,W3
013DC:  CALL    101E
013E0:  MOV     [--W15],W7
013E2:  MOV     [--W15],W6
013E4:  MOV     [--W15],W5
013E6:  CALL    A18
013EA:  MOV     W1,8C4
013EC:  MOV     W2,8C6
....................     VinInt = Vin*k; 
013EE:  MOV     952,W0
013F0:  MOV     954,W1
013F2:  CALL    11D8
013F6:  MOV     W0,W2
013F8:  MOV     W1,W3
013FA:  MOV     8C4,W0
013FC:  MOV     8C6,W1
013FE:  CALL    1226
01402:  CALL    12EA
01406:  MOV     W0,956
01408:  MOV     W1,958
....................     return VinInt; 
0140A:  MOV     956,W0
0140C:  MOV     958,W1
0140E:  MOV     #14,W5
01410:  REPEAT  #4
01412:  MOV     [--W15],[W5--]
01414:  MOV     [--W15],W5
01416:  RETURN  
.................... }                
....................  
.................... static S32 ADC_vol_average(U8 NumSamples){   
01418:  CLR     94C
0141A:  CLR     94E
....................    S32 A,Sum = 0;                
....................    U8 i; 
....................     
....................    for (i = 0; i < NumSamples; i++){       
0141C:  CLR.B   947
0141E:  MOV.B   947,W0L
01420:  MOV     946,W4
01422:  CP.B    W4L,W0L
01424:  BRA     LEU,144A
....................       A = Read_ADC_vol_in(uV); 
01426:  MOV     #4240,W4
01428:  MOV     W4,952
0142A:  MOV     #F,W4
0142C:  MOV     W4,954
0142E:  CALL    132A
01432:  MOV     W0,948
01434:  MOV     W1,94A
....................       Sum = Sum + A;     
01436:  MOV     94C,W0
01438:  ADD     948,W0
0143A:  MOV     W0,94C
0143C:  MOV     94A,W4
0143E:  MOV     94E,W3
01440:  ADDC    W3,W4,W0
01442:  MOV     W0,94E
01444:  INC.B   0947
01446:  GOTO    141E
....................    }                                   
....................    return Sum/NumSamples; 
0144A:  BCLR.B  43.0
0144C:  MOV.B   946,W0L
0144E:  MOV.B   W0L,4
01450:  CLR.B   5
01452:  MOV     #0,W3
01454:  MOV     94C,W0
01456:  MOV     94E,W1
01458:  CALL    E62
0145C:  MOV.D   W0,W0
0145E:  RETURN  
.................... } 
....................  
.................... static void ADC_set_PGA(u8 PGA_val){ 
....................    
....................   PGA = PGA_val; 
*
00B72:  MOV.B   91C,W0L
00B74:  MOV.B   W0L,8C8
....................  
....................    switch (PGA_val){ 
00B76:  MOV.B   91C,W0L
00B78:  CLR.B   1
00B7A:  XOR     #1,W0
00B7C:  BRA     Z,B98
00B7E:  XOR     #3,W0
00B80:  BRA     Z,BA6
00B82:  XOR     #6,W0
00B84:  BRA     Z,BB6
00B86:  XOR     #C,W0
00B88:  BRA     Z,BC6
00B8A:  XOR     #18,W0
00B8C:  BRA     Z,BD6
00B8E:  XOR     #30,W0
00B90:  BRA     Z,BE6
00B92:  XOR     #60,W0
00B94:  BRA     Z,BF6
00B96:  BRA     C06
....................       case 1: 
....................        WrReg(ADCON,0); 
00B98:  MOV.B   #2,W0L
00B9A:  MOV.B   W0L,92C
00B9C:  CLR.B   92D
00B9E:  CALL    B16
....................       break; 
00BA2:  GOTO    C06
....................        
....................       case 2: 
....................        WrReg(ADCON,1); 
00BA6:  MOV.B   #2,W0L
00BA8:  MOV.B   W0L,92C
00BAA:  MOV.B   #1,W0L
00BAC:  MOV.B   W0L,92D
00BAE:  CALL    B16
....................       break; 
00BB2:  GOTO    C06
....................        
....................       case 4: 
....................        WrReg(ADCON,2); 
00BB6:  MOV.B   #2,W0L
00BB8:  MOV.B   W0L,92C
00BBA:  MOV.B   #2,W0L
00BBC:  MOV.B   W0L,92D
00BBE:  CALL    B16
....................       break; 
00BC2:  GOTO    C06
....................        
....................       case 8: 
....................        WrReg(ADCON,3); 
00BC6:  MOV.B   #2,W0L
00BC8:  MOV.B   W0L,92C
00BCA:  MOV.B   #3,W0L
00BCC:  MOV.B   W0L,92D
00BCE:  CALL    B16
....................       break; 
00BD2:  GOTO    C06
....................        
....................       case 16: 
....................        WrReg(ADCON,4); 
00BD6:  MOV.B   #2,W0L
00BD8:  MOV.B   W0L,92C
00BDA:  MOV.B   #4,W0L
00BDC:  MOV.B   W0L,92D
00BDE:  CALL    B16
....................       break; 
00BE2:  GOTO    C06
....................        
....................       case 32: 
....................        WrReg(ADCON,5); 
00BE6:  MOV.B   #2,W0L
00BE8:  MOV.B   W0L,92C
00BEA:  MOV.B   #5,W0L
00BEC:  MOV.B   W0L,92D
00BEE:  CALL    B16
....................       break; 
00BF2:  GOTO    C06
....................        
....................       case 64: 
....................        WrReg(ADCON,6); 
00BF6:  MOV.B   #2,W0L
00BF8:  MOV.B   W0L,92C
00BFA:  MOV.B   #6,W0L
00BFC:  MOV.B   W0L,92D
00BFE:  CALL    B16
....................       break;  
00C02:  GOTO    C06
....................    } 
00C06:  RETURN  
.................... } 
....................  
.................... static void ADC_wakeUp(){ 
....................    ADC_CS = 1;                          
*
00AF6:  BSET.B  2E9.1
....................    ADC_RESET = 0; //When using the RESET pin, take it low to force a reset. 
00AF8:  BCLR.B  2D6.3
....................    delay_us(100); 
00AFA:  REPEAT  #F9E
00AFC:  NOP     
....................    ADC_RESET = 1; 
00AFE:  BSET.B  2D6.3
....................    ADC_SYNC =0; 
00B00:  BCLR.B  2D6.2
....................    delay_us(100); 
00B02:  REPEAT  #F9E
00B04:  NOP     
....................    ADC_SYNC = 1; //To use the SYNC/PDWN pin, take it low and then high 
00B06:  BSET.B  2D6.2
....................    delay_ms(1); 
00B08:  REPEAT  #1C3E
00B0A:  NOP     
00B0C:  REPEAT  #3FFF
00B0E:  NOP     
00B10:  REPEAT  #3FFF
00B12:  NOP     
00B14:  RETURN  
.................... }  
....................  
.................... static void ADC_init(){   
....................    WrReg(STATUS,2); 
*
00C42:  CLR.B   92C
00C44:  MOV.B   #2,W0L
00C46:  MOV.B   W0L,92D
00C48:  CALL    B16
....................    ADC_set_PGA(8);    // 
00C4C:  MOV.B   #8,W0L
00C4E:  MOV.B   W0L,91C
00C50:  CALL    B72
....................    if(ADC_sps_var>7)  ADC_sps_var = 7; 
00C54:  MOV     8F8,W4
00C56:  CP.B    W4L,#7
00C58:  BRA     LEU,C5E
00C5A:  MOV.B   #7,W0L
00C5C:  MOV.B   W0L,8F8
....................    if(ADC_sps_var==0) ADC_sps_var = 1; 
00C5E:  CP0.B   8F8
00C60:  BRA     NZ,C66
00C62:  MOV.B   #1,W0L
00C64:  MOV.B   W0L,8F8
....................    switch (ADC_sps_var){                // передача величины скорости измерений АЦП  
00C66:  MOV.B   8F8,W0L
00C68:  CLR.B   1
00C6A:  XOR     #1,W0
00C6C:  BRA     Z,C88
00C6E:  XOR     #3,W0
00C70:  BRA     Z,C94
00C72:  XOR     #1,W0
00C74:  BRA     Z,CA0
00C76:  XOR     #7,W0
00C78:  BRA     Z,CAC
00C7A:  XOR     #1,W0
00C7C:  BRA     Z,CB8
00C7E:  XOR     #3,W0
00C80:  BRA     Z,CC4
00C82:  XOR     #1,W0
00C84:  BRA     Z,CD0
00C86:  BRA     CDC
....................       case 1: ADC_sps_set(0x23);  break; // 10   sps 
00C88:  MOV.B   #23,W0L
00C8A:  MOV.B   W0L,91C
00C8C:  CALL    C2C
00C90:  GOTO    CDC
....................       case 2: ADC_sps_set(0x43);  break; // 25   sps 
00C94:  MOV.B   #43,W0L
00C96:  MOV.B   W0L,91C
00C98:  CALL    C2C
00C9C:  GOTO    CDC
....................       case 3: ADC_sps_set(0x63);  break; // 50   sps 
00CA0:  MOV.B   #63,W0L
00CA2:  MOV.B   W0L,91C
00CA4:  CALL    C2C
00CA8:  GOTO    CDC
....................       case 4: ADC_sps_set(0x82);  break; // 100  sps 
00CAC:  MOV.B   #82,W0L
00CAE:  MOV.B   W0L,91C
00CB0:  CALL    C2C
00CB4:  GOTO    CDC
....................       case 5: ADC_sps_set(0x91);  break; // 500  sps 
00CB8:  MOV.B   #91,W0L
00CBA:  MOV.B   W0L,91C
00CBC:  CALL    C2C
00CC0:  GOTO    CDC
....................       case 6: ADC_sps_set(0xA1);  break; // 1000 sps 
00CC4:  MOV.B   #A1,W0L
00CC6:  MOV.B   W0L,91C
00CC8:  CALL    C2C
00CCC:  GOTO    CDC
....................       case 7: ADC_sps_set(0xC0);  break; // 3750 sps 
00CD0:  MOV.B   #C0,W0L
00CD2:  MOV.B   W0L,91C
00CD4:  CALL    C2C
00CD8:  GOTO    CDC
....................    } 
00CDC:  RETURN  
.................... } 
....................  
.................... static float ADC_vol_to_T(){                 // Rt = R[1 + A * t + B * t^2] 
*
0183A:  MOV     W5,[W15++]
0183C:  MOV     W6,[W15++]
0183E:  MOV     W7,[W15++]
01840:  MOV     W8,[W15++]
01842:  CLR     92A
01844:  CLR     92C
01846:  CLR     92E
01848:  MOV     #447A,W4
0184A:  MOV     W4,930
0184C:  CLR     932
0184E:  CLR     934
01850:  CLR     936
01852:  CLR     938
01854:  CLR     93A
01856:  CLR     93C
01858:  MOV     #1132,W4
0185A:  MOV     W4,93E
0185C:  MOV     #3B80,W4
0185E:  MOV     W4,940
01860:  MOV     #57F,W4
01862:  MOV     W4,942
01864:  MOV     #B51B,W4
01866:  MOV     W4,944
....................    float Final_T = 0.0; 
....................    float R = 1000;                           // Данные из DataSheet R=1000 Ом 
....................    float Rt = 0; 
....................    float D = 0; 
....................    float X = 0; 
....................    float A = 0.0039083;                      // Некий коэффициент. Данные из Resistance Temperature Detectors (RTDs) 
....................    float B = -0.0000005775;                  // Некий коэффициент. Данные из Resistance Temperature Detectors (RTDs) 
....................    temp = ADC_vol_average(NumAver);          
01868:  MOV.B   8F7,W0L
0186A:  MOV.B   W0L,946
0186C:  CALL    1418
01870:  MOV     W0,8FC
01872:  MOV     W1,8FE
....................      
....................    Rt = temp/10.0;                           // Приводим к Омам 
01874:  MOV     8FC,W0
01876:  MOV     8FE,W1
01878:  MOV     #0,W2
0187A:  MOV     #0,W3
0187C:  CALL    8AC
01880:  MOV     #0,W4
01882:  MOV     #0,W5
01884:  MOV     #0,W6
01886:  MOV     #4024,W7
01888:  CALL    910
0188C:  CALL    A18
01890:  MOV     W1,932
01892:  MOV     W2,934
....................    D = 1 - (Rt/R);                           
01894:  MOV     932,W0
01896:  MOV     934,W1
01898:  MOV     92E,W2
0189A:  MOV     930,W3
0189C:  CALL    1460
018A0:  BSET.B  43.0
018A2:  MOV     W0,W2
018A4:  MOV     W1,W3
018A6:  MOV     #0,W0
018A8:  MOV     #3F80,W1
018AA:  CALL    152A
018AE:  MOV     W0,936
018B0:  MOV     W1,938
....................    X = A*A - (4 * B * D); 
018B2:  MOV     93E,W0
018B4:  MOV     940,W1
018B6:  MOV     93E,W2
018B8:  MOV     940,W3
018BA:  CALL    1226
018BE:  MOV     W0,W5
018C0:  MOV     W1,W6
018C2:  MOV     #0,W0
018C4:  MOV     #4080,W1
018C6:  MOV     942,W2
018C8:  MOV     944,W3
018CA:  CALL    1226
018CE:  MOV     W0,W7
018D0:  MOV     W1,W8
018D2:  MOV     W7,W0
018D4:  MOV     W8,W1
018D6:  MOV     936,W2
018D8:  MOV     938,W3
018DA:  CALL    1226
018DE:  BSET.B  43.0
018E0:  MOV     W0,W2
018E2:  MOV     W1,W3
018E4:  MOV     W5,W0
018E6:  MOV     W6,W1
018E8:  CALL    152A
018EC:  MOV     W0,93A
018EE:  MOV     W1,93C
....................    Final_T = (-A + sqrt(X))/(2*B);           // Температура в градусах Цельсия     
018F0:  MOV     93E,W5
018F2:  MOV     940,W6
018F4:  BTG     W6.F
018F6:  PUSH    93A
018F8:  POP     94C
018FA:  PUSH    93C
018FC:  POP     94E
018FE:  CALL    173C
01902:  BCLR.B  43.0
01904:  MOV     W0,W2
01906:  MOV     W1,W3
01908:  MOV     W5,W0
0190A:  MOV     W6,W1
0190C:  CALL    152A
01910:  MOV     W0,W5
01912:  MOV     W1,W6
01914:  MOV     #0,W0
01916:  MOV     #4000,W1
01918:  MOV     942,W2
0191A:  MOV     944,W3
0191C:  CALL    1226
01920:  MOV     W0,W2
01922:  MOV     W1,W3
01924:  MOV     W5,W0
01926:  MOV     W6,W1
01928:  CALL    1460
0192C:  MOV     W0,92A
0192E:  MOV     W1,92C
....................    return Final_T; 
01930:  MOV     92A,W0
01932:  MOV     92C,W1
01934:  MOV     [--W15],W8
01936:  MOV     [--W15],W7
01938:  MOV     [--W15],W6
0193A:  MOV     [--W15],W5
0193C:  RETURN  
....................   } 
....................  
....................  
.................... /*############################################################################*/ 
.................... /* Функция записи во flash */ 
.................... static void Wr_Flash2(){ 
*
0282C:  MOV     910,W0
0282E:  MOV     912,W1
02830:  MOV     #0,W2
02832:  MOV     #4120,W3
02834:  CALL    1226
02838:  CALL    1BBC
0283C:  MOV     W0,91C
0283E:  MOV     914,W0
02840:  MOV     916,W1
02842:  MOV     #0,W2
02844:  MOV     #4120,W3
02846:  CALL    1226
0284A:  CALL    1BBC
0284E:  MOV.B   W0L,91E
....................   U16 K1_int = K1 * 10; 
....................   U8 K2_int = K2 * 10; 
....................    
....................   flash_wr_U16[0] = K1_int; 
02850:  PUSH    91C
02852:  POP     8D4
....................   flash_wr_U16[1] = K2_int; 
02854:  MOV.B   91E,W0L
02856:  MOV.B   W0L,8D6
02858:  CLR.B   8D7
....................   flash_wr_U16[2] = Sps_Wr; 
0285A:  MOV.B   8D3,W0L
0285C:  MOV.B   W0L,8D8
0285E:  CLR.B   8D9
....................   flash_wr_U16[3] = CRC_wr; 
02860:  MOV.B   8E4,W0L
02862:  MOV.B   W0L,8DA
02864:  CLR.B   8DB
....................    
....................   write_program_memory(CK_USER_PAGE,flash_wr_U16,8); 
02866:  MOV     #5000,W0
02868:  MOV     #1,W1
0286A:  MOV     #8D4,W2
0286C:  MOV     #8,W3
0286E:  CALL    27AA
02872:  RETURN  
.................... } 
....................  
.................... /* Функция чтения из flash */ 
.................... static void Rd_Flash2(){ 
*
00A5C:  MOV     W5,[W15++]
00A5E:  MOV     W6,[W15++]
00A60:  MOV     W7,[W15++]
....................   read_program_memory(CK_USER_PAGE,flash_rd_U16,8); 
00A62:  MOV     #5000,W0
00A64:  MOV     #1,W1
00A66:  MOV     #8DC,W2
00A68:  MOV     #8,W3
00A6A:  CALL    87E
.................... // delay_ms(1); 
....................   K1 = flash_rd_U16[0] / 10.0; 
00A6E:  MOV     8DC,W0
00A70:  MOV     #0,W1
00A72:  MOV     #0,W2
00A74:  MOV     #0,W3
00A76:  CALL    8AC
00A7A:  MOV     #0,W4
00A7C:  MOV     #0,W5
00A7E:  MOV     #0,W6
00A80:  MOV     #4024,W7
00A82:  CALL    910
00A86:  CALL    A18
00A8A:  MOV     W1,910
00A8C:  MOV     W2,912
....................   K2 = flash_rd_U16[1] / 10.0; 
00A8E:  MOV     8DE,W0
00A90:  MOV     #0,W1
00A92:  MOV     #0,W2
00A94:  MOV     #0,W3
00A96:  CALL    8AC
00A9A:  MOV     #0,W4
00A9C:  MOV     #0,W5
00A9E:  MOV     #0,W6
00AA0:  MOV     #4024,W7
00AA2:  CALL    910
00AA6:  CALL    A18
00AAA:  MOV     W1,914
00AAC:  MOV     W2,916
....................   ADC_sps_var = flash_rd_U16[2]; 
00AAE:  MOV.B   8E0,W0L
00AB0:  MOV.B   W0L,8F8
....................   CRC_buf = flash_rd_U16[3]; 
00AB2:  MOV.B   8E2,W0L
00AB4:  MOV.B   W0L,8FB
00AB6:  MOV     [--W15],W7
00AB8:  MOV     [--W15],W6
00ABA:  MOV     [--W15],W5
00ABC:  RETURN  
.................... } 
....................                 
.................... /* 
....................   Name  : CRC-16 
....................   Poly  : 0x8005    x^16 + x^15 + x^2 + 1 
....................   Init  : 0xFFFF 
....................   Revert: true 
....................   XorOut: 0x0000 
....................   Check : 0x4B37 ("123456789") 
....................   MaxLen: 4095 байт (32767 бит) - обнаружение 
....................     одинарных, двойных, тройных и всех нечетных ошибок 
.................... */ 
.................... const unsigned int8 CRC16Table[256] = { 
....................     0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 
....................     0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440, 
....................     0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 
....................     0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841, 
....................     0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 
....................     0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41, 
....................     0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 
....................     0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040, 
....................     0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 
....................     0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441, 
....................     0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 
....................     0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 
....................     0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 
....................     0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40, 
....................     0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 
....................     0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041, 
....................     0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 
....................     0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441, 
....................     0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 
....................     0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 
....................     0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 
....................     0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 
....................     0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640, 
....................     0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 
....................     0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241, 
....................     0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440, 
....................     0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 
....................     0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 
....................     0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 
....................     0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 
....................     0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 
....................     0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040  
.................... }; 
....................   
.................... unsigned int8 CRC16(unsigned int16 * pcBlock, unsigned int16 len){             // * pcBlock - указатель на массив, на который считается CRC16 
00ABE:  MOV     W5,[W15++]
00AC0:  MOV     W6,[W15++]
00AC2:  SETM.B  920
....................                                                                               // len - кол-во элементов в этом массиве 
....................     unsigned int8 crc = 0xFFFF; 
....................   
....................     while (len--) 
00AC4:  MOV     91E,W0
00AC6:  DEC     091E
00AC8:  CP0     W0
00ACA:  BRA     Z,AEC
....................         crc = (crc >> 8) ^ CRC16Table[(crc & 0xFF) ^ *pcBlock++]; 
00ACC:  MOV     #0,W5
00ACE:  MOV     920,W6
00AD0:  AND     #FF,W6
00AD2:  MOV     91C,W0
00AD4:  INC2    091C
00AD6:  MOV     W0,W4
00AD8:  MOV     [W4],W0
00ADA:  XOR     W6,W0,W6
00ADC:  MOV     W6,W0
00ADE:  CALL    24A
00AE2:  MOV.B   W0L,920
00AE4:  MOV     W5,W0
00AE6:  XOR.B   920
00AE8:  GOTO    AC4
....................   
....................     return crc; 
00AEC:  MOV.B   920,W0L
00AEE:  MOV.B   W0L,0
00AF0:  MOV     [--W15],W6
00AF2:  MOV     [--W15],W5
00AF4:  RETURN  
.................... } 
....................  
.................... static void OscSetup(){ 
....................   U2BRG = 259;// BAUD Rate Setting for 9600 
*
00632:  MOV     #103,W4
00634:  MOV     W4,238
....................   U2MODE = 0b1010101010010000; 
00636:  MOV     #AA90,W4
00638:  MOV     W4,230
....................   PLLFBD = 30; // ???. ????. ??????? PLL M = 30 
0063A:  MOV     #1E,W4
0063C:  MOV     W4,746
....................    
....................   PLLPRE4 = 0; // ???. ????. ??????? PLL N1 = 2 
0063E:  BCLR.B  744.4
....................   PLLPRE3 = 0; 
00640:  BCLR.B  744.3
....................   PLLPRE2 = 0; 
00642:  BCLR.B  744.2
....................   PLLPRE1 = 0; 
00644:  BCLR.B  744.1
....................   PLLPRE0 = 0; 
00646:  BCLR.B  744.0
....................    
....................   PLLPOST0=0; // ???. ????. ??????? PLL N2 = 2 
00648:  BCLR.B  744.6
....................   PLLPOST1=0;    
0064A:  BCLR.B  744.7
0064C:  RETURN  
....................    } 
....................  
.................... static void EnableInt (){ 
....................   ENABLE_INTERRUPTS(INTR_GLOBAL); 
0064E:  BCLR.B  81.7
00650:  CLR     42
00652:  BSET.B  81.7
....................   enable_interrupts(INTR_CN_PIN|PIN_B5); 
00654:  BSET.B  60.7
00656:  BSET.B  96.3
....................   enable_interrupts(INTR_CN_PIN|PIN_B4); 
00658:  BSET.B  60.6
0065A:  BSET.B  96.3
....................   enable_interrupts(INTR_CN_PIN|PIN_B3); 
0065C:  BSET.B  60.5
0065E:  BSET.B  96.3
....................   enable_interrupts(INTR_CN_PIN|PIN_B2); 
00660:  BSET.B  60.4
00662:  BSET.B  96.3
....................   enable_interrupts(INT_TIMER2);                                  // Включение прерывание по таймеру 2 
00664:  BSET.B  94.7
....................   enable_interrupts(INT_TIMER1); 
00666:  BSET.B  94.3
....................   EXT_INT_EDGE(L_TO_H); 
00668:  BCLR.B  82.0
0066A:  RETURN  
.................... } 
....................  
.................... static void DisableInt (){ 
....................   DISABLE_INTERRUPTS(INTR_GLOBAL); 
*
0193E:  BCLR.B  81.7
01940:  MOV     #E0,W4
01942:  MOV     W4,42
01944:  BSET.B  81.7
....................   disable_interrupts(INTR_CN_PIN|PIN_B5); 
01946:  BCLR.B  60.7
....................   disable_interrupts(INTR_CN_PIN|PIN_B4); 
01948:  BCLR.B  60.6
....................   disable_interrupts(INTR_CN_PIN|PIN_B3); 
0194A:  BCLR.B  60.5
....................   disable_interrupts(INTR_CN_PIN|PIN_B2); 
0194C:  BCLR.B  60.4
0194E:  RETURN  
.................... } 
....................  
.................... static void MCU_init(){ 
....................    setup_timer1(TMR_INTERNAL | TMR_DIV_BY_64);                     // таймер 1 сбрасывает собачий таймер 
*
0066C:  CLR     104
0066E:  SETM    102
00670:  MOV     #8020,W4
00672:  MOV     W4,104
....................    set_timer1(20000);                                              //reset the timer.    
00674:  MOV     #4E20,W4
00676:  MOV     W4,100
....................    SETUP_TIMER2(TMR_INTERNAL | TMR_DIV_BY_1);                     // Настройка таймера 2. Предделитель = 8. 
00678:  CLR     110
0067A:  SETM    10C
0067C:  MOV     #8000,W4
0067E:  MOV     W4,110
....................    SET_TIMER2(Freq);                                              // Задание параметра таймера, от которого он будет считать 
00680:  PUSH    8F0
00682:  POP     106
....................    
....................    SETUP_SPI2(SPI_MASTER|SPI_SCK_IDLE_LOW|SPI_XMIT_H_TO_L|SPI_MODE_8B|SPI_SAMPLE_AT_END|SPI_SS_DISABLED|SPI_CLK_DIV_128); 
00684:  BCLR.B  261.7
00686:  BCLR.B  260.6
00688:  MOV     #221,W4
0068A:  MOV     W4,262
0068C:  BSET.B  261.7
....................   
....................    SCK2_TRIS=0; // SPI2 tris 
0068E:  BCLR.B  2E4.6
....................    SDI2_TRIS=1; 
00690:  BSET.B  2E4.7
....................    SDO2_TRIS=0; 
00692:  BCLR.B  2E5.0
....................  
....................    TRG12 = 0; // lcd buf tris 
00694:  BCLR.B  2E5.4
....................    TRG13 = 0; 
00696:  BCLR.B  2E5.5
....................    TRB1 = 0; 
00698:  BCLR.B  2C6.1
....................    TRB0 = 0; 
0069A:  BCLR.B  2C6.0
....................   
....................    LCD_RS_TRIS=0; 
0069C:  BCLR.B  2E4.1
....................    LCD_RW_TRIS=0; 
0069E:  BCLR.B  2E4.0
....................    LCD_E_TRIS=0; 
006A0:  BCLR.B  2E5.6
....................   
....................    ADC_CS_TRIS=0; 
006A2:  BCLR.B  2E5.1
....................    ADC_RESET_TRIS=0; 
006A4:  BCLR.B  2D2.3
....................    ADC_SYNC_TRIS=0; 
006A6:  BCLR.B  2D2.2
....................    ADC_DRDY_TRIS=1; // опрос готовнсти данных АЦП 
006A8:  BSET.B  2D6.1
....................    Status_LED_TRIS = 0; 
006AA:  BCLR.B  2C7.5
....................   
....................    UART2_RX_TRIS=1; 
006AC:  BSET.B  2DE.4
....................    UART2_TX_TRIS=0; 
006AE:  BCLR.B  2DE.5
....................    XPORT_RST_TRIS=0; 
006B0:  BCLR.B  2C7.7
....................   
....................    XPORT_RST_n = 0; 
006B2:  BCLR.B  2C7.7
....................    delay_us(500); 
006B4:  REPEAT  #E1E
006B6:  NOP     
006B8:  REPEAT  #3FFF
006BA:  NOP     
....................    XPORT_RST_n = 1; 
006BC:  BSET.B  2C7.7
....................    EnableInt(); 
006BE:  CALL    64E
006C2:  RETURN  
....................    } 
....................  
.................... static void Bpush_delay(){  
*
024A0:  CLR     91C
....................    U16 counter = 0;    
....................    do {counter++;}  
024A2:  INC     091C
....................    while (counter < 2000);    
024A4:  MOV     91C,W4
024A6:  MOV     #7D0,W3
024A8:  CP      W3,W4
024AA:  BRA     GTU,24A2
024AC:  RETURN  
....................    } 
....................  
.................... static void LCD_print_menu(){ 
024AE:  MOV     W5,[W15++]
....................    LCDsetCursor(Line_1); 
024B0:  CLR.B   92A
024B2:  CALL    7FE
....................    LCDMsg("ADC sps set  "); 
024B6:  MOV     #0,W5
024B8:  MOV     W5,W0
024BA:  CALL    312
024BE:  IOR.B   #0,W0L
024C0:  BTSC.B  42.1
024C2:  BRA     24CE
024C4:  INC     W5,W5
024C6:  MOV.B   W0L,92C
024C8:  CALL    7F4
024CC:  BRA     24B8
....................    LCDsetCursor(Line_2); 
024CE:  MOV.B   #40,W0L
024D0:  MOV.B   W0L,92A
024D2:  CALL    7FE
....................    LCDMsg("Коэф. K1 set "); 
024D6:  MOV     #0,W5
024D8:  MOV     W5,W0
024DA:  CALL    32C
024DE:  IOR.B   #0,W0L
024E0:  BTSC.B  42.1
024E2:  BRA     24EE
024E4:  INC     W5,W5
024E6:  MOV.B   W0L,92C
024E8:  CALL    7F4
024EC:  BRA     24D8
....................    LCDsetCursor(Line_3); 
024EE:  MOV.B   #10,W0L
024F0:  MOV.B   W0L,92A
024F2:  CALL    7FE
....................    LCDMsg("Коэф. K2 set "); 
024F6:  MOV     #0,W5
024F8:  MOV     W5,W0
024FA:  CALL    346
024FE:  IOR.B   #0,W0L
02500:  BTSC.B  42.1
02502:  BRA     250E
02504:  INC     W5,W5
02506:  MOV.B   W0L,92C
02508:  CALL    7F4
0250C:  BRA     24F8
....................    LCDsetCursor(Line_4); 
0250E:  MOV.B   #50,W0L
02510:  MOV.B   W0L,92A
02512:  CALL    7FE
....................    LCDMsg("Reset device "); 
02516:  MOV     #0,W5
02518:  MOV     W5,W0
0251A:  CALL    360
0251E:  IOR.B   #0,W0L
02520:  BTSC.B  42.1
02522:  BRA     252E
02524:  INC     W5,W5
02526:  MOV.B   W0L,92C
02528:  CALL    7F4
0252C:  BRA     2518
0252E:  MOV     [--W15],W5
02530:  RETURN  
....................    } 
....................  
.................... // Передвижение по меню 
.................... static void LCD_main_menu (void) { 
02532:  MOV     W5,[W15++]
....................    LCD_print_menu(); 
02534:  CALL    24AE
....................    switch (menu_sel){ 
02538:  MOV.B   8F2,W0L
0253A:  CLR.B   1
0253C:  XOR     #0,W0
0253E:  BRA     Z,254E
02540:  XOR     #1,W0
02542:  BRA     Z,25DA
02544:  XOR     #3,W0
02546:  BRA     Z,2666
02548:  XOR     #1,W0
0254A:  BRA     Z,26F2
0254C:  BRA     277E
....................       case 0:  
....................          LCDsetCursor(0x0D); LCDMsg(0x91); LCDMsg("- "); 
0254E:  MOV.B   #D,W0L
02550:  MOV.B   W0L,92A
02552:  CALL    7FE
02556:  MOV.B   #91,W0L
02558:  MOV.B   W0L,92C
0255A:  CALL    7F4
0255E:  MOV     #0,W5
02560:  MOV     W5,W0
02562:  CALL    37A
02566:  IOR.B   #0,W0L
02568:  BTSC.B  42.1
0256A:  BRA     2576
0256C:  INC     W5,W5
0256E:  MOV.B   W0L,92C
02570:  CALL    7F4
02574:  BRA     2560
....................          LCDsetCursor(0x4D); LCDMsg("   "); // стирание стрелки от предыдущего 
02576:  MOV.B   #4D,W0L
02578:  MOV.B   W0L,92A
0257A:  CALL    7FE
0257E:  MOV     #0,W5
02580:  MOV     W5,W0
02582:  CALL    38A
02586:  IOR.B   #0,W0L
02588:  BTSC.B  42.1
0258A:  BRA     2596
0258C:  INC     W5,W5
0258E:  MOV.B   W0L,92C
02590:  CALL    7F4
02594:  BRA     2580
....................          LCDsetCursor(0x1D); LCDMsg("   "); // элемента меню 
02596:  MOV.B   #1D,W0L
02598:  MOV.B   W0L,92A
0259A:  CALL    7FE
0259E:  MOV     #0,W5
025A0:  MOV     W5,W0
025A2:  CALL    38A
025A6:  IOR.B   #0,W0L
025A8:  BTSC.B  42.1
025AA:  BRA     25B6
025AC:  INC     W5,W5
025AE:  MOV.B   W0L,92C
025B0:  CALL    7F4
025B4:  BRA     25A0
....................          LCDsetCursor(0x5D); LCDMsg("   "); 
025B6:  MOV.B   #5D,W0L
025B8:  MOV.B   W0L,92A
025BA:  CALL    7FE
025BE:  MOV     #0,W5
025C0:  MOV     W5,W0
025C2:  CALL    38A
025C6:  IOR.B   #0,W0L
025C8:  BTSC.B  42.1
025CA:  BRA     25D6
025CC:  INC     W5,W5
025CE:  MOV.B   W0L,92C
025D0:  CALL    7F4
025D4:  BRA     25C0
....................          break; 
025D6:  GOTO    277E
....................      
....................       case 1:  
....................          LCDsetCursor(0x0D); LCDMsg("   "); 
025DA:  MOV.B   #D,W0L
025DC:  MOV.B   W0L,92A
025DE:  CALL    7FE
025E2:  MOV     #0,W5
025E4:  MOV     W5,W0
025E6:  CALL    38A
025EA:  IOR.B   #0,W0L
025EC:  BTSC.B  42.1
025EE:  BRA     25FA
025F0:  INC     W5,W5
025F2:  MOV.B   W0L,92C
025F4:  CALL    7F4
025F8:  BRA     25E4
....................          LCDsetCursor(0x4D); LCDMsg(0x91); LCDMsg("- "); // стирание стрелки от предыдущего 
025FA:  MOV.B   #4D,W0L
025FC:  MOV.B   W0L,92A
025FE:  CALL    7FE
02602:  MOV.B   #91,W0L
02604:  MOV.B   W0L,92C
02606:  CALL    7F4
0260A:  MOV     #0,W5
0260C:  MOV     W5,W0
0260E:  CALL    37A
02612:  IOR.B   #0,W0L
02614:  BTSC.B  42.1
02616:  BRA     2622
02618:  INC     W5,W5
0261A:  MOV.B   W0L,92C
0261C:  CALL    7F4
02620:  BRA     260C
....................          LCDsetCursor(0x1D); LCDMsg("   "); // элемента меню 
02622:  MOV.B   #1D,W0L
02624:  MOV.B   W0L,92A
02626:  CALL    7FE
0262A:  MOV     #0,W5
0262C:  MOV     W5,W0
0262E:  CALL    38A
02632:  IOR.B   #0,W0L
02634:  BTSC.B  42.1
02636:  BRA     2642
02638:  INC     W5,W5
0263A:  MOV.B   W0L,92C
0263C:  CALL    7F4
02640:  BRA     262C
....................          LCDsetCursor(0x5D); LCDMsg("   "); 
02642:  MOV.B   #5D,W0L
02644:  MOV.B   W0L,92A
02646:  CALL    7FE
0264A:  MOV     #0,W5
0264C:  MOV     W5,W0
0264E:  CALL    38A
02652:  IOR.B   #0,W0L
02654:  BTSC.B  42.1
02656:  BRA     2662
02658:  INC     W5,W5
0265A:  MOV.B   W0L,92C
0265C:  CALL    7F4
02660:  BRA     264C
....................          break; 
02662:  GOTO    277E
....................      
....................       case 2:  
....................          LCDsetCursor(0x0D); LCDMsg("   "); 
02666:  MOV.B   #D,W0L
02668:  MOV.B   W0L,92A
0266A:  CALL    7FE
0266E:  MOV     #0,W5
02670:  MOV     W5,W0
02672:  CALL    38A
02676:  IOR.B   #0,W0L
02678:  BTSC.B  42.1
0267A:  BRA     2686
0267C:  INC     W5,W5
0267E:  MOV.B   W0L,92C
02680:  CALL    7F4
02684:  BRA     2670
....................          LCDsetCursor(0x4D); LCDMsg("   "); // стирание стрелки от предыдущего 
02686:  MOV.B   #4D,W0L
02688:  MOV.B   W0L,92A
0268A:  CALL    7FE
0268E:  MOV     #0,W5
02690:  MOV     W5,W0
02692:  CALL    38A
02696:  IOR.B   #0,W0L
02698:  BTSC.B  42.1
0269A:  BRA     26A6
0269C:  INC     W5,W5
0269E:  MOV.B   W0L,92C
026A0:  CALL    7F4
026A4:  BRA     2690
....................          LCDsetCursor(0x1D); LCDMsg(0x91); LCDMsg("- "); // элемента меню 
026A6:  MOV.B   #1D,W0L
026A8:  MOV.B   W0L,92A
026AA:  CALL    7FE
026AE:  MOV.B   #91,W0L
026B0:  MOV.B   W0L,92C
026B2:  CALL    7F4
026B6:  MOV     #0,W5
026B8:  MOV     W5,W0
026BA:  CALL    37A
026BE:  IOR.B   #0,W0L
026C0:  BTSC.B  42.1
026C2:  BRA     26CE
026C4:  INC     W5,W5
026C6:  MOV.B   W0L,92C
026C8:  CALL    7F4
026CC:  BRA     26B8
....................          LCDsetCursor(0x5D); LCDMsg("   "); 
026CE:  MOV.B   #5D,W0L
026D0:  MOV.B   W0L,92A
026D2:  CALL    7FE
026D6:  MOV     #0,W5
026D8:  MOV     W5,W0
026DA:  CALL    38A
026DE:  IOR.B   #0,W0L
026E0:  BTSC.B  42.1
026E2:  BRA     26EE
026E4:  INC     W5,W5
026E6:  MOV.B   W0L,92C
026E8:  CALL    7F4
026EC:  BRA     26D8
....................          break; 
026EE:  GOTO    277E
....................      
....................       case 3:  
....................          LCDsetCursor(0x0D); LCDMsg("   "); 
026F2:  MOV.B   #D,W0L
026F4:  MOV.B   W0L,92A
026F6:  CALL    7FE
026FA:  MOV     #0,W5
026FC:  MOV     W5,W0
026FE:  CALL    38A
02702:  IOR.B   #0,W0L
02704:  BTSC.B  42.1
02706:  BRA     2712
02708:  INC     W5,W5
0270A:  MOV.B   W0L,92C
0270C:  CALL    7F4
02710:  BRA     26FC
....................          LCDsetCursor(0x4D); LCDMsg("   "); // стирание стрелки от предыдущего 
02712:  MOV.B   #4D,W0L
02714:  MOV.B   W0L,92A
02716:  CALL    7FE
0271A:  MOV     #0,W5
0271C:  MOV     W5,W0
0271E:  CALL    38A
02722:  IOR.B   #0,W0L
02724:  BTSC.B  42.1
02726:  BRA     2732
02728:  INC     W5,W5
0272A:  MOV.B   W0L,92C
0272C:  CALL    7F4
02730:  BRA     271C
....................          LCDsetCursor(0x1D); LCDMsg("   "); // элемента меню 
02732:  MOV.B   #1D,W0L
02734:  MOV.B   W0L,92A
02736:  CALL    7FE
0273A:  MOV     #0,W5
0273C:  MOV     W5,W0
0273E:  CALL    38A
02742:  IOR.B   #0,W0L
02744:  BTSC.B  42.1
02746:  BRA     2752
02748:  INC     W5,W5
0274A:  MOV.B   W0L,92C
0274C:  CALL    7F4
02750:  BRA     273C
....................          LCDsetCursor(0x5D); LCDMsg(0x91); LCDMsg("- "); 
02752:  MOV.B   #5D,W0L
02754:  MOV.B   W0L,92A
02756:  CALL    7FE
0275A:  MOV.B   #91,W0L
0275C:  MOV.B   W0L,92C
0275E:  CALL    7F4
02762:  MOV     #0,W5
02764:  MOV     W5,W0
02766:  CALL    37A
0276A:  IOR.B   #0,W0L
0276C:  BTSC.B  42.1
0276E:  BRA     277A
02770:  INC     W5,W5
02772:  MOV.B   W0L,92C
02774:  CALL    7F4
02778:  BRA     2764
....................          break; 
0277A:  GOTO    277E
....................       }   
0277E:  MOV     [--W15],W5
02780:  RETURN  
....................    } 
....................  
.................... // Полная перезагрузка системы 
.................... static void Full_dev_reset(){ 
*
00DB8:  MOV     W5,[W15++]
....................    LCDClear(); 
00DBA:  CALL    7AE
....................    LCDsetCursor(Line_1); 
00DBE:  CLR.B   92A
00DC0:  CALL    7FE
....................    LCDMsg("   Reset done"); 
00DC4:  MOV     #0,W5
00DC6:  MOV     W5,W0
00DC8:  CALL    39A
00DCC:  IOR.B   #0,W0L
00DCE:  BTSC.B  42.1
00DD0:  BRA     DDC
00DD2:  INC     W5,W5
00DD4:  MOV.B   W0L,92C
00DD6:  CALL    7F4
00DDA:  BRA     DC6
....................    LCDsetCursor(Line_3); 
00DDC:  MOV.B   #10,W0L
00DDE:  MOV.B   W0L,92A
00DE0:  CALL    7FE
....................    LCDMsg("Starting device!"); 
00DE4:  MOV     #0,W5
00DE6:  MOV     W5,W0
00DE8:  CALL    3B4
00DEC:  IOR.B   #0,W0L
00DEE:  BTSC.B  42.1
00DF0:  BRA     DFC
00DF2:  INC     W5,W5
00DF4:  MOV.B   W0L,92C
00DF6:  CALL    7F4
00DFA:  BRA     DE6
....................    delay_ms(1000); 
00DFC:  MOV     #3E8,W0
00DFE:  CALL    6C4
....................    OscSetup(); 
00E02:  CALL    632
....................    MCU_init(); 
00E06:  CALL    66C
....................    LCDInit(); 
00E0A:  CALL    744
....................    reset_fl = 0; 
00E0E:  BCLR.B  8F4.2
....................    ADC_wakeUp(); 
00E10:  CALL    AF6
....................    ADC_wakeUp();  
00E14:  CALL    AF6
....................    ADC_init(); 
00E18:  CALL    C42
....................    ADC_set_PGA(8); 
00E1C:  MOV.B   #8,W0L
00E1E:  MOV.B   W0L,91C
00E20:  CALL    B72
....................    ADC_sps_set(0x23); //0x023 - 10 sps, 0x43 - 25 sps, 0x63 - 50 sps 
00E24:  MOV.B   #23,W0L
00E26:  MOV.B   W0L,91C
00E28:  CALL    C2C
....................                      //0x82 - 100 sps, 0x91 - 500 sps 
....................                      //0xA1 - 1000 sps, 0xC0 - 3750 sps 
....................    ADC_SelfCal(); 
00E2C:  CALL    CDE
....................    meas_stop_fl = 0; // вкл. режим измерений 
00E30:  BCLR.B  8F4.0
....................    menu_fl = 0;      // отключение меню 
00E32:  CLR.B   8F3
....................    menu_item = 0;    // сброс элемента меню 
00E34:  CLR.B   8E5
....................    NumAver = 1;      // сброс величины усреднения данных АЦП 
00E36:  MOV.B   #1,W0L
00E38:  MOV.B   W0L,8F7
....................    LCDClear();       // очистка дисплея 
00E3A:  CALL    7AE
00E3E:  MOV     [--W15],W5
00E40:  RETURN  
....................    } 
....................  
.................... /* Функция для разбивания переменной в float, чтобы далее её 
....................    можно было вывести на дисплей.*/ 
.................... static void Destroy_float (float Variable_float){              
*
0288C:  MOV     W5,[W15++]
0288E:  MOV     W6,[W15++]
....................    Integer_part = Variable_float;                                                               // Получение целой части 
02890:  MOV     91C,W0
02892:  MOV     91E,W1
02894:  CALL    1BBC
02898:  MOV     W0,918
....................    Tenth = (Variable_float - Integer_part) * 10;                                                // Получение десятых долей   
0289A:  MOV     918,W0
0289C:  CALL    1DDA
028A0:  BSET.B  43.0
028A2:  MOV     W0,W2
028A4:  MOV     W1,W3
028A6:  MOV     91C,W0
028A8:  MOV     91E,W1
028AA:  CALL    152A
028AE:  MOV     W0,W5
028B0:  MOV     W1,W6
028B2:  MOV     W5,W0
028B4:  MOV     W6,W1
028B6:  MOV     #0,W2
028B8:  MOV     #4120,W3
028BA:  CALL    1226
028BE:  CALL    1BBC
028C2:  MOV.B   W0L,91A
028C4:  MOV     [--W15],W6
028C6:  MOV     [--W15],W5
028C8:  RETURN  
.................... } 
....................  
.................... /* Функция, которая выводит значение какой-либо цифры после запятой*/ 
.................... /* This function ... */ 
....................  
.................... static unsigned int8 Remainder (float Parameter, unsigned int8 Digit){           // Digit - порядковый номер цифры после запятой, которую нужно вывести 
*
01E14:  MOV     W5,[W15++]
01E16:  MOV     W6,[W15++]
01E18:  CLR     930
01E1A:  CLR     932
01E1C:  CLR.B   92F
01E1E:  CLR.B   934
01E20:  MOV.B   #1,W0L
01E22:  MOV.B   W0L,935
....................                                                                                  // Parameter - число, дробную часть которого нужно вывести 
....................    unsigned int32 Temporary = 0;                                                 // Временная переменная 
.................... //   unsigned int8 N = 0;                                                        // Временная переменная 
....................    unsigned int8 ValueDigit = 0;                                                 // Значение цифры 
....................    unsigned int8 i = 0; 
....................    unsigned int8 Degree = 1; 
.................... //   N = Digit + 1; 
....................    for(i = 1; i <= Digit; i++){ 
01E24:  MOV.B   #1,W0L
01E26:  MOV.B   W0L,934
01E28:  MOV.B   934,W0L
01E2A:  MOV     92E,W4
01E2C:  CP.B    W4L,W0L
01E2E:  BRA     NC,1E3E
....................       Degree = Degree * 10; 
01E30:  MOV     934,W4
01E32:  LSR     W4,#8,W4
01E34:  MUL.UU  W4,#A,W0
01E36:  MOV.B   W0L,935
01E38:  INC.B   0934
01E3A:  GOTO    1E28
....................    }   
....................    Temporary = (abs(Parameter)) * Degree; 
01E3E:  MOV     92A,W0
01E40:  MOV     92C,W1
01E42:  BCLR    W1.F
01E44:  MOV     W0,W5
01E46:  MOV     W1,W6
01E48:  MOV.B   935,W0L
01E4A:  CLR.B   1
01E4C:  CALL    1DDA
01E50:  MOV     W0,W2
01E52:  MOV     W1,W3
01E54:  MOV     W5,W0
01E56:  MOV     W6,W1
01E58:  CALL    1226
01E5C:  CALL    12EA
01E60:  MOV     W0,930
01E62:  MOV     W1,932
....................    ValueDigit = Temporary % 10;       
01E64:  BSET.B  43.0
01E66:  MOV     930,W0
01E68:  MOV     932,W1
01E6A:  MOV     #A,W2
01E6C:  MOV     #0,W3
01E6E:  CALL    1C1A
01E72:  MOV.B   W0L,92F
....................    return ValueDigit; 
01E74:  MOV.B   92F,W0L
01E76:  MOV     [--W15],W6
01E78:  MOV     [--W15],W5
01E7A:  RETURN  
.................... } 
....................  
.................... /* Функция отделяет целую часть и, в случае отрицательной температуры убирает знак минус */ 
.................... /* This function delet fractional part and delet minus if temperature is negative */ 
....................  
.................... static unsigned int16 PositiveTemperature(){ 
*
01BE8:  CLR     92A
....................    unsigned int16 IntegerPartPosTemp = 0; 
....................    if (TemperatureInCelsius >= 0){ 
01BEA:  MOV     #0,W0
01BEC:  MOV     #0,W1
01BEE:  MOV     908,W2
01BF0:  MOV     90A,W3
01BF2:  CALL    16D4
01BF6:  BRA     C,1BFA
01BF8:  BRA     NZ,1C08
....................       IntegerPartPosTemp = TemperatureInCelsius;                                 // Беззнаковой переменной int16 присваивается знаковая переменная float32. В 
01BFA:  MOV     908,W0
01BFC:  MOV     90A,W1
01BFE:  CALL    1BBC
01C02:  MOV     W0,92A
....................                                                                                  // результате получим положительную целую величину. Дробная часть отбрасывается. 
....................    } 
01C04:  GOTO    1C14
....................    else 
....................       IntegerPartPosTemp = abs(TemperatureInCelsius);                            // Беззнаковой переменной int16 присваивается знаковая переменная float32 умноженная на 
01C08:  MOV     908,W0
01C0A:  MOV     90A,W1
01C0C:  BCLR    W1.F
01C0E:  CALL    1BBC
01C12:  MOV     W0,92A
....................                                                                                  // минус 1. В результате получим положительную целую величину. Дробная часть отбрасывается. 
....................    return IntegerPartPosTemp; 
01C14:  PUSH    92A
01C16:  POP     0
01C18:  RETURN  
.................... } 
....................  
.................... static void ADC_rd_and_print_ch(U8 chanel){ 
*
02090:  MOV     W5,[W15++]
02092:  MOV     W6,[W15++]
02094:  MOV     W9,[W15++]
02096:  MOV     W10,[W15++]
02098:  CLR     91E
0209A:  CLR     920
0209C:  CLR     922
0209E:  CLR     924
020A0:  CLR.B   927
....................    unsigned int16 IntegerPartTempInKelvin = 0; 
....................    S32 Temporary_K = 0; 
....................    unsigned int16 Temporary = 0; 
....................    unsigned int8 Tenth_C, Hundredth_C, Thousandth_C = 0; 
....................    ADC_setCh(chanel); 
020A2:  MOV.B   91C,W0L
020A4:  MOV.B   W0L,92A
020A6:  CALL    F8C
....................    ADCaddCoef =0;                                                                // смещение нуля для канала  
020AA:  CLR     8CC
....................    ADCmulCoef =1;                                                                // мультипликат. ошибка для канала  
020AC:  CLR     8CE
020AE:  MOV     #3F80,W4
020B0:  MOV     W4,8D0
....................  
....................    TemperatureInCelsius = ADC_vol_to_T();                                        // Считывается значение температуры и засовыается в переменную TemperatureInCelsius 
020B2:  CALL    183A
020B6:  MOV     W0,908
020B8:  MOV     W1,90A
....................    DisableInt(); 
020BA:  CALL    193E
....................    printf("%f \n\r",TemperatureInCelsius); 
020BE:  MOV     90A,W2
020C0:  MOV     908,W1
020C2:  MOV     #0,W0
020C4:  CALL    1192
020C8:  MOV     #2,W9
020CA:  MOV     #8008,W10
020CC:  CALL    1A3A
020D0:  BTSC.B  233.1
020D2:  BRA     20D0
020D4:  MOV     #20,W4
020D6:  MOV     W4,234
020D8:  BTSC.B  233.1
020DA:  BRA     20D8
020DC:  MOV     #A,W4
020DE:  MOV     W4,234
020E0:  BTSC.B  233.1
020E2:  BRA     20E0
020E4:  MOV     #D,W4
020E6:  MOV     W4,234
....................    EnableInt(); 
020E8:  CALL    64E
....................  
....................    if (PositiveTemperature() >= 0 & PositiveTemperature() < 10) LCD_num_symb = 1;//  
020EC:  CALL    1BE8
020F0:  MOV     W0,W5
020F2:  CALL    1BE8
020F6:  MOV     W0,W5
020F8:  CP      W5,#A
020FA:  BRA     NC,2102
020FC:  CLR.B   W0
020FE:  GOTO    2104
02102:  MOV.B   #1,W0L
02104:  AND.B   W0L,#1,W0L
02106:  CP0.B   W0L
02108:  BRA     Z,210E
0210A:  MOV.B   #1,W0L
0210C:  MOV.B   W0L,8CB
....................    if (PositiveTemperature() >= 10) LCD_num_symb = 2;                            // Определение кол-ва цифр в целой части 
0210E:  CALL    1BE8
02112:  MOV     W0,W5
02114:  CP      W5,#A
02116:  BRA     NC,211C
02118:  MOV.B   #2,W0L
0211A:  MOV.B   W0L,8CB
....................    if (PositiveTemperature() >= 100) LCD_num_symb = 3;                           // 
0211C:  CALL    1BE8
02120:  MOV     W0,W5
02122:  MOV     #64,W4
02124:  CP      W4,W5
02126:  BRA     GTU,212C
02128:  MOV.B   #3,W0L
0212A:  MOV.B   W0L,8CB
....................     
.................... // Вывод в первую строку дисплея///////////////////////////////////// 
....................    LCDsetCursor(Line_1); 
0212C:  CLR.B   92A
0212E:  CALL    7FE
....................    LCDMsg("T="); 
02132:  MOV     #0,W5
02134:  MOV     W5,W0
02136:  CALL    3D2
0213A:  IOR.B   #0,W0L
0213C:  BTSC.B  42.1
0213E:  BRA     214A
02140:  INC     W5,W5
02142:  MOV.B   W0L,92C
02144:  CALL    7F4
02148:  BRA     2134
....................    if (TemperatureInCelsius < 0){ 
0214A:  MOV     908,W0
0214C:  MOV     90A,W1
0214E:  MOV     #0,W2
02150:  MOV     #0,W3
02152:  CALL    16D4
02156:  BRA     NC,218A
....................       LCDMsg("-"); 
02158:  MOV     #0,W5
0215A:  MOV     W5,W0
0215C:  CALL    3E2
02160:  IOR.B   #0,W0L
02162:  BTSC.B  42.1
02164:  BRA     2170
02166:  INC     W5,W5
02168:  MOV.B   W0L,92C
0216A:  CALL    7F4
0216E:  BRA     215A
....................       LCDPutU16(PositiveTemperature(),LCD_num_symb); 
02170:  CALL    1BE8
02174:  MOV     W0,W5
02176:  MOV     W0,[W15++]
02178:  MOV.B   8CB,W0L
0217A:  MOV.B   W0L,930
0217C:  MOV     [--W15],W0
0217E:  MOV     W5,92C
02180:  CLR     92E
02182:  CALL    1C9E
....................       } 
02186:  GOTO    21A0
....................    else LCDPutU16(PositiveTemperature(),LCD_num_symb);                           // Вывод на дисплей целой части температуры в градусах Цельсия 
0218A:  CALL    1BE8
0218E:  MOV     W0,W5
02190:  MOV     W0,[W15++]
02192:  MOV.B   8CB,W0L
02194:  MOV.B   W0L,930
02196:  MOV     [--W15],W0
02198:  MOV     W5,92C
0219A:  CLR     92E
0219C:  CALL    1C9E
....................    LCDMsg("."); 
021A0:  MOV     #0,W5
021A2:  MOV     W5,W0
021A4:  CALL    3F0
021A8:  IOR.B   #0,W0L
021AA:  BTSC.B  42.1
021AC:  BRA     21B8
021AE:  INC     W5,W5
021B0:  MOV.B   W0L,92C
021B2:  CALL    7F4
021B6:  BRA     21A2
....................    LCDPutU16(Remainder(TemperatureInCelsius,1),1);                               // Вывод на дисплей десятичной доли температуры в градусах Цельсия 
021B8:  MOV.B   #1,W0L
021BA:  MOV.B   W0L,92E
021BC:  PUSH    908
021BE:  POP     92A
021C0:  PUSH    90A
021C2:  POP     92C
021C4:  CALL    1E14
021C8:  MOV.B   W0L,W5L
021CA:  PUSH    92C
021CC:  MOV.B   W5L,[W15-#2]
021CE:  POP     92C
021D0:  CLR.B   92D
021D2:  CLR     92E
021D4:  MOV     W0,[W15++]
021D6:  MOV.B   #1,W0L
021D8:  MOV.B   W0L,930
021DA:  MOV     [--W15],W0
021DC:  CALL    1C9E
....................    LCDPutU16(Remainder(TemperatureInCelsius,2),1);                               // Вывод на дисплей сотой доли температуры в градусах Цельсия 
021E0:  MOV.B   #2,W0L
021E2:  MOV.B   W0L,92E
021E4:  PUSH    908
021E6:  POP     92A
021E8:  PUSH    90A
021EA:  POP     92C
021EC:  CALL    1E14
021F0:  MOV.B   W0L,W5L
021F2:  PUSH    92C
021F4:  MOV.B   W5L,[W15-#2]
021F6:  POP     92C
021F8:  CLR.B   92D
021FA:  CLR     92E
021FC:  MOV     W0,[W15++]
021FE:  MOV.B   #1,W0L
02200:  MOV.B   W0L,930
02202:  MOV     [--W15],W0
02204:  CALL    1C9E
....................    LCDPutch(0xb0);LCDMsg("C "); 
02208:  MOV.B   #B0,W0L
0220A:  MOV.B   W0L,944
0220C:  CALL    7EA
02210:  MOV     #0,W5
02212:  MOV     W5,W0
02214:  CALL    3FE
02218:  IOR.B   #0,W0L
0221A:  BTSC.B  42.1
0221C:  BRA     2228
0221E:  INC     W5,W5
02220:  MOV.B   W0L,92C
02222:  CALL    7F4
02226:  BRA     2212
....................    LCDPutU16(Number_Pulse,5); 
02228:  MOV.B   #5,W0L
0222A:  MOV.B   W0L,930
0222C:  PUSH    8EC
0222E:  POP     92C
02230:  CLR     92E
02232:  CALL    1C9E
....................  
.................... // Вывод во вторую строку дисплея //////////////////////////// 
....................    LCDsetCursor(Line_2); 
02236:  MOV.B   #40,W0L
02238:  MOV.B   W0L,92A
0223A:  CALL    7FE
....................    LCDMsg("T="); 
0223E:  MOV     #0,W5
02240:  MOV     W5,W0
02242:  CALL    3D2
02246:  IOR.B   #0,W0L
02248:  BTSC.B  42.1
0224A:  BRA     2256
0224C:  INC     W5,W5
0224E:  MOV.B   W0L,92C
02250:  CALL    7F4
02254:  BRA     2240
....................    TemperatureInKelvin = TemperatureInCelsius + 273.15; 
02256:  BCLR.B  43.0
02258:  MOV     908,W0
0225A:  MOV     90A,W1
0225C:  MOV     #9333,W2
0225E:  MOV     #4388,W3
02260:  CALL    152A
02264:  MOV     W0,90C
02266:  MOV     W1,90E
....................    IntegerPartTempInKelvin = TemperatureInKelvin; 
02268:  MOV     90C,W0
0226A:  MOV     90E,W1
0226C:  CALL    1BBC
02270:  MOV     W0,91E
....................     
....................    if (TemperatureInKelvin < 10) {LCD_num_symb_K = 1;}                           // 
02272:  MOV     90C,W0
02274:  MOV     90E,W1
02276:  MOV     #0,W2
02278:  MOV     #4120,W3
0227A:  CALL    16D4
0227E:  BRA     NC,2284
02280:  MOV.B   #1,W0L
02282:  MOV.B   W0L,8D2
....................    if (TemperatureInKelvin >= 10){LCD_num_symb_K = 2;}                           // Определение кол-ва цифр в целой части 
02284:  MOV     #0,W0
02286:  MOV     #4120,W1
02288:  MOV     90C,W2
0228A:  MOV     90E,W3
0228C:  CALL    16D4
02290:  BRA     C,2294
02292:  BRA     NZ,2298
02294:  MOV.B   #2,W0L
02296:  MOV.B   W0L,8D2
....................    if (TemperatureInKelvin >= 100){LCD_num_symb_K = 3;}                          // 
02298:  MOV     #0,W0
0229A:  MOV     #42C8,W1
0229C:  MOV     90C,W2
0229E:  MOV     90E,W3
022A0:  CALL    16D4
022A4:  BRA     C,22A8
022A6:  BRA     NZ,22AC
022A8:  MOV.B   #3,W0L
022AA:  MOV.B   W0L,8D2
....................    
....................    LCDPutU16(IntegerPartTempInKelvin,LCD_num_symb_K);                            // Вывод на дисплей целой части температуры в градусах Кельвина 
022AC:  MOV.B   8D2,W0L
022AE:  MOV.B   W0L,930
022B0:  PUSH    91E
022B2:  POP     92C
022B4:  CLR     92E
022B6:  CALL    1C9E
....................    LCDMsg("."); 
022BA:  MOV     #0,W5
022BC:  MOV     W5,W0
022BE:  CALL    3F0
022C2:  IOR.B   #0,W0L
022C4:  BTSC.B  42.1
022C6:  BRA     22D2
022C8:  INC     W5,W5
022CA:  MOV.B   W0L,92C
022CC:  CALL    7F4
022D0:  BRA     22BC
....................    LCDPutU16(Remainder(TemperatureInKelvin,1),1);                                // Вывод на дисплей десятичной доли температуры в градусах Цельсия 
022D2:  MOV.B   #1,W0L
022D4:  MOV.B   W0L,92E
022D6:  PUSH    90C
022D8:  POP     92A
022DA:  PUSH    90E
022DC:  POP     92C
022DE:  CALL    1E14
022E2:  MOV.B   W0L,W5L
022E4:  PUSH    92C
022E6:  MOV.B   W5L,[W15-#2]
022E8:  POP     92C
022EA:  CLR.B   92D
022EC:  CLR     92E
022EE:  MOV     W0,[W15++]
022F0:  MOV.B   #1,W0L
022F2:  MOV.B   W0L,930
022F4:  MOV     [--W15],W0
022F6:  CALL    1C9E
....................    LCDPutU16(Remainder(TemperatureInKelvin,2),1);                                // Вывод на дисплей сотой доли температуры в градусах Цельсия 
022FA:  MOV.B   #2,W0L
022FC:  MOV.B   W0L,92E
022FE:  PUSH    90C
02300:  POP     92A
02302:  PUSH    90E
02304:  POP     92C
02306:  CALL    1E14
0230A:  MOV.B   W0L,W5L
0230C:  PUSH    92C
0230E:  MOV.B   W5L,[W15-#2]
02310:  POP     92C
02312:  CLR.B   92D
02314:  CLR     92E
02316:  MOV     W0,[W15++]
02318:  MOV.B   #1,W0L
0231A:  MOV.B   W0L,930
0231C:  MOV     [--W15],W0
0231E:  CALL    1C9E
....................    LCDPutch(0xb0);LCDMsg("K"); 
02322:  MOV.B   #B0,W0L
02324:  MOV.B   W0L,944
02326:  CALL    7EA
0232A:  MOV     #0,W5
0232C:  MOV     W5,W0
0232E:  CALL    40E
02332:  IOR.B   #0,W0L
02334:  BTSC.B  42.1
02336:  BRA     2342
02338:  INC     W5,W5
0233A:  MOV.B   W0L,92C
0233C:  CALL    7F4
02340:  BRA     232C
....................     
.................... //   if(LCD_num_symb_K==1){LCDPutch(0xb0);LCDMsg("K        ");}  // Очистка строки  
.................... //   if(LCD_num_symb_K==2){LCDPutch(0xb0);LCDMsg("K       "); } 
.................... //   if(LCD_num_symb_K==3){LCDPutch(0xb0);LCDMsg("K      "); } 
....................  
.................... // Вывод в третью строку дисплея //////////////////////////// 
....................    LCDsetCursor(Line_3); 
02342:  MOV.B   #10,W0L
02344:  MOV.B   W0L,92A
02346:  CALL    7FE
.................... //   LCDMsg("Tmin=-196");LCDPutch(0xb0);LCDMsg("C"); 
....................    LCDMsg("Интегр. "); LCDPutU32(TmpInt,7); 
0234A:  MOV     #0,W5
0234C:  MOV     W5,W0
0234E:  CALL    41C
02352:  IOR.B   #0,W0L
02354:  BTSC.B  42.1
02356:  BRA     2362
02358:  INC     W5,W5
0235A:  MOV.B   W0L,92C
0235C:  CALL    7F4
02360:  BRA     234C
02362:  MOV     900,W0
02364:  MOV     902,W1
02366:  CALL    12EA
0236A:  MOV     W0,W5
0236C:  MOV     W1,W6
0236E:  MOV     W0,[W15++]
02370:  MOV.B   #7,W0L
02372:  MOV.B   W0L,932
02374:  MOV     [--W15],W0
02376:  MOV     W5,92E
02378:  MOV     W6,930
0237A:  CALL    1E7C
....................  
.................... // Вывод в четвёртую строку дисплея //////////////////////////// 
....................    LCDsetCursor(Line_4);  
0237E:  MOV.B   #50,W0L
02380:  MOV.B   W0L,92A
02382:  CALL    7FE
.................... //   LCDMsg("Tmax=150");LCDPutch(0xb0);LCDMsg("C"); 
....................    LCDMsg("Пропорц. "); LCDPutU32(P,7); 
02386:  MOV     #0,W5
02388:  MOV     W5,W0
0238A:  CALL    432
0238E:  IOR.B   #0,W0L
02390:  BTSC.B  42.1
02392:  BRA     239E
02394:  INC     W5,W5
02396:  MOV.B   W0L,92C
02398:  CALL    7F4
0239C:  BRA     2388
0239E:  MOV     904,W0
023A0:  MOV     906,W1
023A2:  CALL    12EA
023A6:  MOV     W0,W5
023A8:  MOV     W1,W6
023AA:  MOV     W0,[W15++]
023AC:  MOV.B   #7,W0L
023AE:  MOV.B   W0L,932
023B0:  MOV     [--W15],W0
023B2:  MOV     W5,92E
023B4:  MOV     W6,930
023B6:  CALL    1E7C
023BA:  MOV     [--W15],W10
023BC:  MOV     [--W15],W9
023BE:  MOV     [--W15],W6
023C0:  MOV     [--W15],W5
023C2:  RETURN  
.................... } 
....................  
.................... /* Функция для сохранения данных во flash*/ 
.................... static void save_to_flash(){ 
....................    CRC_Wr = CRC16(flash_wr_U16,2); 
*
02874:  MOV     #8D4,W4
02876:  MOV     W4,91C
02878:  MOV     #2,W4
0287A:  MOV     W4,91E
0287C:  CALL    ABE
02880:  MOV.B   W0L,8E4
....................    Sps_Wr = ADC_sps_var; 
02882:  MOV.B   8F8,W0L
02884:  MOV.B   W0L,8D3
....................    Wr_Flash2(); 
02886:  CALL    282C
0288A:  RETURN  
....................    }  
....................  
.................... // Предотвращение дребезга контактов 
.................... #int_cni 
.................... static void cn_irq_handler(void) { 
*
0056A:  PUSH    42
0056C:  PUSH    36
0056E:  PUSH    32
00570:  MOV     W0,[W15++]
00572:  MOV     #2,W0
00574:  REPEAT  #C
00576:  MOV     [W0++],[W15++]
....................    meas_stop_fl = 1;                                              // взвод флага остановки измерений 
00578:  BSET.B  8F4.0
....................    menu_fl = 1;                                                   // взвод флага перехода в меню 
0057A:  MOV.B   #1,W0L
0057C:  MOV.B   W0L,8F3
....................        
....................    if (menu_item == 1){ 
0057E:  MOV     8E4,W4
00580:  LSR     W4,#8,W4
00582:  CP.B    W4L,#1
00584:  BRA     NZ,59C
....................       if (menu_sel > 3) menu_sel = 0; 
00586:  MOV.B   8F2,W0L
00588:  SE      W0,W0
0058A:  CP      W0,#3
0058C:  BRA     LE,590
0058E:  CLR.B   8F2
....................       if (menu_sel < 0) menu_sel = 3; 
00590:  MOV.B   8F2,W0L
00592:  SE      W0,W0
00594:  CP      W0,#0
00596:  BRA     GE,59C
00598:  MOV.B   #3,W0L
0059A:  MOV.B   W0L,8F2
....................       } 
....................    if (CN1 == 1) { 
0059C:  BTSS.B  2C8.3
0059E:  BRA     5A4
....................       menu_item = 0; 
005A0:  CLR.B   8E5
....................       LCD_clear_fl = 1; 
005A2:  BSET.B  8F4.1
....................       } 
....................    if (CN2==1) menu_item = 1; 
005A4:  BTSS.B  2C8.2
005A6:  BRA     5AC
005A8:  MOV.B   #1,W0L
005AA:  MOV.B   W0L,8E5
....................    if (CN3==1) menu_sel--; 
005AC:  BTSS.B  2C8.5
005AE:  BRA     5B2
005B0:  DEC.B   08F2
....................    if (CN4==1) menu_sel++; 
005B2:  BTSS.B  2C8.4
005B4:  BRA     5B8
005B6:  INC.B   08F2
....................    clear_interrupt(INTR_CN_PIN); 
005B8:  BCLR.B  82.7
.................... } 
....................  
005BA:  BCLR.B  86.3
005BC:  MOV     #1A,W0
005BE:  REPEAT  #C
005C0:  MOV     [--W15],[W0--]
005C2:  MOV     [--W15],W0
005C4:  POP     32
005C6:  POP     36
005C8:  POP     42
005CA:  RETFIE  
.................... #int_timer1 
.................... static void timer1_irq_handler(void) { 
005CC:  PUSH    42
005CE:  PUSH    36
005D0:  PUSH    32
005D2:  MOV     W0,[W15++]
005D4:  MOV     #2,W0
005D6:  REPEAT  #C
005D8:  MOV     [W0++],[W15++]
....................    restart_wdt();                                  // сбос собачего таймера 
005DA:  CLRWDT  
....................    set_timer1(20000);                              //reset the timer. 
005DC:  MOV     #4E20,W4
005DE:  MOV     W4,100
....................    clear_interrupt(int_timer1); 
005E0:  BCLR.B  84.3
....................    } 
....................  
.................... /* Во время прерывания, таймер 2 устанавливаем заново и прибавляем к переменной "count" 1. 
.................... Если переменная "count" сравняется с кол-вом импульсов в "Number_Pulse", то 
.................... нагреватель отключится. Когда переменная "count" станет равной кол-ву импульсов 
.................... во всём периоде, то нагреватель включится и переменная "count" обнулится. 
.................... */ 
.................... /* When variable "count" will equal number unit impuls, pin RD11 will fall. 
.................... When variable "count" will equal number impuls in period, pin RD11 will rise. 
.................... */ 
005E2:  BCLR.B  84.3
005E4:  MOV     #1A,W0
005E6:  REPEAT  #C
005E8:  MOV     [--W15],[W0--]
005EA:  MOV     [--W15],W0
005EC:  POP     32
005EE:  POP     36
005F0:  POP     42
005F2:  RETFIE  
.................... #int_timer2                                                        // Обработчик прерывания по таймеру 2 
.................... static void timer2_isr_handler(void) { 
005F4:  PUSH    42
005F6:  PUSH    36
005F8:  PUSH    32
005FA:  MOV     W0,[W15++]
005FC:  MOV     #2,W0
005FE:  REPEAT  #C
00600:  MOV     [W0++],[W15++]
....................    set_timer2(Freq);                                               // reset the timer. 
00602:  PUSH    8F0
00604:  POP     106
....................    count++; 
00606:  INC     08EE
....................     
....................    if(count >= Number_Pulse) RD11 = 0; 
00608:  MOV     8EC,W0
0060A:  MOV     8EE,W4
0060C:  CP      W4,W0
0060E:  BRA     NC,612
00610:  BCLR.B  2D7.3
....................    if(count >= T_Pulse) { 
00612:  MOV     8EA,W0
00614:  MOV     8EE,W4
00616:  CP      W4,W0
00618:  BRA     NC,61E
....................       RD11 = 1; 
0061A:  BSET.B  2D7.3
....................       count = 0; 
0061C:  CLR     8EE
....................       }   
....................    clear_interrupt(int_timer2); 
0061E:  BCLR.B  84.7
00620:  BCLR.B  84.7
00622:  MOV     #1A,W0
00624:  REPEAT  #C
00626:  MOV     [--W15],[W0--]
00628:  MOV     [--W15],W0
0062A:  POP     32
0062C:  POP     36
0062E:  POP     42
00630:  RETFIE  
.................... } 
....................  
.................... /*Как получается ПИД-регулятор? Берём разницу между текущей температурой и нужной, 
.................... умножаем на настраиваемый коэффициент, получаем мощность, которую надо выдать в 
.................... данный момент. Это пропорциональная составляющая, она работает в момент появления 
.................... рассогласования — то есть моментально откликается как на изменение уставки, так 
.................... и на поведение объекта. 
.................... Чтобы компенсировать «внешние» воздействия, в цепь добавляют интегральную составляющую. 
.................... Всё рассогласование, которое было в системе, идёт на интегратор (соответственно, 
.................... как только мы перегрели — сумма уменьшается, пока недогрето — сумма увеличивается). 
.................... И накопленный интеграл, со своим коэффициентом, даёт свою прибавку-убавку к мощности. 
.................... В результате такого подхода, при стационарном процессе, через некоторое время интеграл 
.................... подбирает такой вклад в сумму с мощностью, который компенсирует потери окружающей 
.................... среды, и колебания исчезают — интеграл становится стабильным, поэтому величина 
.................... выдаваемой мощности становится постоянной. Причем, так как при этом держится нужная 
.................... температура, рассогласование отсутствует, пропорциональная составляющая не работает 
.................... вообще. 
.................... */ 
....................  
.................... static void PI_regulator(){ 
*
023C4:  CLR     91C
023C6:  CLR     91E
....................    float Tmp = 0;   
.................... //   float P = 0;                                                                  // Proportional term 
....................    if (TemperatureInCelsius >= 60) RD11 = 0;                                     // Средство защиты от несрабатывания контроля температуры 
023C8:  MOV     #0,W0
023CA:  MOV     #4270,W1
023CC:  MOV     908,W2
023CE:  MOV     90A,W3
023D0:  CALL    16D4
023D4:  BRA     C,23D8
023D6:  BRA     NZ,23DA
023D8:  BCLR.B  2D7.3
.................... // Регулировка должна происходить только в случае, когда число 
.................... // импульсов в Duty Cycle меньше числа импульсов в периоде. 
.................... //   if (Number_Pulse <= T_Pulse){ 
....................  
.................... // До тех пор, пока разница между  измеряемой температурой и необходимой 
.................... // не составит 5 градусов, интегральный член не учитываем. 
....................       if (TemperatureInCelsius >= (Max_Temp - 5.0)){ 
023DA:  BSET.B  43.0
023DC:  MOV     8E6,W0
023DE:  MOV     8E8,W1
023E0:  MOV     #0,W2
023E2:  MOV     #40A0,W3
023E4:  CALL    152A
023E8:  MOV     908,W2
023EA:  MOV     90A,W3
023EC:  CALL    16D4
023F0:  BRA     C,23F4
023F2:  BRA     NZ,2472
....................          Tmp = Max_Temp - TemperatureInCelsius; 
023F4:  BSET.B  43.0
023F6:  MOV     8E6,W0
023F8:  MOV     8E8,W1
023FA:  MOV     908,W2
023FC:  MOV     90A,W3
023FE:  CALL    152A
02402:  MOV     W0,91C
02404:  MOV     W1,91E
....................          TmpInt = TmpInt + Tmp * K2;                                                   // Integral term 
02406:  MOV     91C,W0
02408:  MOV     91E,W1
0240A:  MOV     914,W2
0240C:  MOV     916,W3
0240E:  CALL    1226
02412:  BCLR.B  43.0
02414:  MOV     W0,W2
02416:  MOV     W1,W3
02418:  MOV     900,W0
0241A:  MOV     902,W1
0241C:  CALL    152A
02420:  MOV     W0,900
02422:  MOV     W1,902
....................          if (TmpInt < 0) TmpInt = 0; 
02424:  MOV     900,W0
02426:  MOV     902,W1
02428:  MOV     #0,W2
0242A:  MOV     #0,W3
0242C:  CALL    16D4
02430:  BRA     NC,2436
02432:  CLR     900
02434:  CLR     902
....................          if (Tmp <= 0) Tmp = 0; 
02436:  MOV     91C,W0
02438:  MOV     91E,W1
0243A:  MOV     #0,W2
0243C:  MOV     #0,W3
0243E:  CALL    16D4
02442:  BRA     C,2446
02444:  BRA     NZ,244A
02446:  CLR     91C
02448:  CLR     91E
....................  
....................          P = K1 * Tmp;                                                                 // Proportional term 
0244A:  MOV     910,W0
0244C:  MOV     912,W1
0244E:  MOV     91C,W2
02450:  MOV     91E,W3
02452:  CALL    1226
02456:  MOV     W0,904
02458:  MOV     W1,906
....................          Number_Pulse = (unsigned int16)(P + TmpInt); 
0245A:  BCLR.B  43.0
0245C:  MOV     904,W0
0245E:  MOV     906,W1
02460:  MOV     900,W2
02462:  MOV     902,W3
02464:  CALL    152A
02468:  CALL    1BBC
0246C:  MOV     W0,8EC
....................       } 
0246E:  GOTO    249E
....................       else{ 
....................          Tmp = Max_Temp - TemperatureInCelsius; 
02472:  BSET.B  43.0
02474:  MOV     8E6,W0
02476:  MOV     8E8,W1
02478:  MOV     908,W2
0247A:  MOV     90A,W3
0247C:  CALL    152A
02480:  MOV     W0,91C
02482:  MOV     W1,91E
....................          P = K1 * Tmp; 
02484:  MOV     910,W0
02486:  MOV     912,W1
02488:  MOV     91C,W2
0248A:  MOV     91E,W3
0248C:  CALL    1226
02490:  MOV     W0,904
02492:  MOV     W1,906
....................          Number_Pulse = (unsigned int16)(P); 
02494:  MOV     904,W0
02496:  MOV     906,W1
02498:  CALL    1BBC
0249C:  MOV     W0,8EC
....................       } 
0249E:  RETURN  
.................... //   } 
.................... //   else Number_Pulse = Number_Pulse / 2; 
.................... //   if (Number_Pulse >= T_Pulse) Number_Pulse = T_Pulse; 
.................... } 
....................  
.................... /*############################################################################*/ 
....................  
.................... static void main(){  
*
028CA:  MOV     #2780,W15
028CC:  MOV     #27FF,W0
028CE:  MOV     W0,20
028D0:  NOP     
028D2:  MOV     #4444,W0
028D4:  MOV     W0,A4
028D6:  MOV     #4444,W0
028D8:  MOV     W0,A6
028DA:  MOV     #4444,W0
028DC:  MOV     W0,AC
028DE:  BSET.B  81.7
028E0:  BCLR.B  261.7
028E2:  BCLR.B  2E5.0
028E4:  BSET.B  2E4.7
028E6:  BCLR.B  2E4.6
028E8:  BCLR.B  260.6
028EA:  MOV     #3B,W4
028EC:  MOV     W4,262
028EE:  BSET.B  261.7
028F0:  MOV     #8000,W4
028F2:  MOV     W4,230
028F4:  MOV     #400,W4
028F6:  MOV     W4,232
028F8:  MOV     #103,W4
028FA:  MOV     W4,238
028FC:  CLR     8B0
028FE:  CLR     8B2
02900:  CLR     8B4
02902:  CLR     8B6
02904:  CLR     8B8
02906:  CLR     8BA
02908:  CLR     8BC
0290A:  CLR     8BE
0290C:  CLR     8C0
0290E:  CLR     8C2
02910:  CLR.B   8CA
02912:  MOV.B   #1,W0L
02914:  MOV.B   W0L,8D2
02916:  CLR.B   8D3
02918:  CLR.B   8E4
0291A:  CLR     8E6
0291C:  MOV     #4220,W4
0291E:  MOV     W4,8E8
02920:  MOV     #2710,W4
02922:  MOV     W4,8EA
02924:  CLR     8EC
02926:  CLR     8EE
02928:  MOV     #FC17,W4
0292A:  MOV     W4,8F0
0292C:  CLR.B   8E5
0292E:  CLR.B   8F2
02930:  CLR.B   8F3
02932:  BCLR.B  8F4.0
02934:  BSET.B  8F4.1
02936:  BCLR.B  8F4.2
02938:  CLR.B   8F5
0293A:  CLR.B   8F6
0293C:  MOV.B   #1,W0L
0293E:  MOV.B   W0L,8F7
02940:  MOV.B   #1,W0L
02942:  MOV.B   W0L,8F8
02944:  MOV.B   #FF,W0L
02946:  MOV.B   W0L,8F9
02948:  SETM.B  8FA
0294A:  CLR     8FC
0294C:  CLR     8FE
0294E:  CLR     900
02950:  CLR     902
02952:  CLR     904
02954:  CLR     906
02956:  CLR     908
02958:  CLR     90A
0295A:  CLR     90C
0295C:  CLR     90E
0295E:  CLR     910
02960:  MOV     #4416,W4
02962:  MOV     W4,912
02964:  CLR     914
02966:  MOV     #40A0,W4
02968:  MOV     W4,916
0296A:  CLR     918
0296C:  CLR.B   91A
0296E:  SETM    32C
02970:  SETM    32A
02972:  BRA     2A16
02974:  DATA    C0,06,08
02976:  DATA    00,00,00
02978:  DATA    4B,F0,3F
0297A:  DATA    5C,0A,58
0297C:  DATA    F6,3B,8F
0297E:  DATA    00,C0,3C
02980:  DATA    8B,28,AC
02982:  DATA    3C,BE,F6
02984:  DATA    3F,D2,D5
02986:  DATA    44,16,8C
02988:  DATA    15,D7,BF
0298A:  DATA    69,00,5A
0298C:  DATA    2E,1B,87
0298E:  DATA    99,3F,9A
02990:  DATA    5F,AD,4B
02992:  DATA    91,E4,01
02994:  DATA    C0,5D,11
02996:  DATA    2F,92,E4
02998:  DATA    81,FB,3F
0299A:  DATA    38,DA,91
0299C:  DATA    80,9D,C5
0299E:  DATA    E0,BF,6F
029A0:  DATA    12,C0,B4
029A2:  DATA    C3,09,AB
029A4:  DATA    3F,6B,C1
029A6:  DATA    03,4E,C1
029A8:  DATA    B5,45,BF
029AA:  DATA    F7,40,05
029AC:  DATA    FF,00,5A
029AE:  DATA    EF,3F,F3
029B0:  DATA    A3,E2,F7
029B2:  DATA    D7,FF,01
029B4:  DATA    40,C0,B4
029B6:  DATA    FF,05,3C
029B8:  DATA    58,FC,3F
029BA:  DATA    3B,D3,C0
029BC:  DATA    B5,BA,8C
029BE:  DATA    E2,3F,39
029C0:  DATA    D3,C7,3D
029C2:  DATA    41,79,B2
029C4:  DATA    3F,87,0D
029C6:  DATA    3C,50,D0
029C8:  DATA    AF,62,3F
029CA:  DATA    30,4B,8D
029CC:  DATA    A2,82,AA
029CE:  DATA    04,40,09
029D0:  DATA    A0,40,4A
029D2:  DATA    05,76,03
029D4:  DATA    40,EC,9E
029D6:  DATA    37,88,A6
029D8:  DATA    44,F0,3F
029DA:  DATA    8F,12,8D
029DC:  DATA    29,9A,5B
029DE:  DATA    C7,3F,0E
029E0:  DATA    E0,80,7C
029E2:  DATA    A1,D8,86
029E4:  DATA    3F,29,4B
029E6:  DATA    FB,95,C2
029E8:  DATA    37,1A,3F
029EA:  DATA    C0,06,08
029EC:  DATA    C4,00,C0
029EE:  DATA    06,08,CC
029F0:  DATA    00,C0,08
029F2:  DATA    08,D4,00
029F4:  DATA    80,01,09
029F6:  DATA    1B,00,00
029F8:  DATA    00,00,00
029FA:  INC     W2,W2
029FC:  CP      W2,#1
029FE:  BRA     NZ,2A08
02A00:  TBLRDL  [W1],W3
02A02:  TBLRDH  [W1++],W4
02A04:  MOV.B   6,W0L
02A06:  RETURN  
02A08:  CP      W2,#2
02A0A:  BRA     NZ,2A10
02A0C:  MOV.B   7,W0L
02A0E:  RETURN  
02A10:  MOV.B   8,W0L
02A12:  CLR     W2
02A14:  RETURN  
02A16:  MOV     #0,W6
02A18:  MOV     #0,W0
02A1A:  MOV     W0,32
02A1C:  MOV     #2974,W0
02A1E:  MOV     W0,W1
02A20:  CLR     W2
02A22:  CALL    29FA
02A26:  MOV.B   W0L,B
02A28:  CALL    29FA
02A2C:  MOV.B   W0L,A
02A2E:  CP0     W5
02A30:  BRA     Z,2A64
02A32:  BTSS    W5.F
02A34:  BRA     2A44
02A36:  CALL    29FA
02A3A:  MOV.B   W0L,D
02A3C:  CALL    29FA
02A40:  MOV.B   W0L,C
02A42:  BCLR    W5.F
02A44:  BTSS    W5.E
02A46:  BRA     2A58
02A48:  BCLR    W5.E
02A4A:  DEC     W5,W5
02A4C:  CALL    29FA
02A50:  MOV.B   W0L,W7L
02A52:  REPEAT  W5
02A54:  MOV.B   W7L,[W6++]
02A56:  BRA     2A22
02A58:  CALL    29FA
02A5C:  MOV.B   W0L,[W6++]
02A5E:  DEC     W5,W5
02A60:  BRA     NZ,2A58
02A62:  BRA     2A22
....................    TRD11 = 0;                                    // На выход 
02A64:  BCLR.B  2D3.3
....................    RD11 = 0;                                     // Нагреватель выключен 
02A66:  BCLR.B  2D7.3
....................    
....................    Status_LED_TRIS = 0; 
02A68:  BCLR.B  2C7.5
....................    Status_LED = 0; 
02A6A:  BCLR.B  2CB.5
....................    
....................    TRC14 = 0;                                    // Пин RC14 настраивается на выход 
02A6C:  BCLR.B  2CD.6
....................    RC14 = 0;                                     // Обнулили пин 
02A6E:  BCLR.B  2D1.6
....................    
....................    TRD0 = 0;                                     // Пин RC14 настраивается на выход 
02A70:  BCLR.B  2D2.0
....................    RD0 = 0;                                      // Обнулили пин 
02A72:  BCLR.B  2D6.0
....................    
....................    OscSetup(); 
02A74:  CALL    632
....................    MCU_init();         
02A78:  CALL    66C
....................  
....................    LCDInit(); 
02A7C:  CALL    744
....................    LCDwelcome(); 
02A80:  CALL    812
....................   //Rd_Flash2(); 
....................    
....................  
....................    LCDSetCursor(Line_1); 
02A84:  CLR.B   92A
02A86:  CALL    7FE
....................    LCDMsg("  Reading data"); 
02A8A:  MOV     #0,W5
02A8C:  MOV     W5,W0
02A8E:  CALL    448
02A92:  IOR.B   #0,W0L
02A94:  BTSC.B  42.1
02A96:  BRA     2AA2
02A98:  INC     W5,W5
02A9A:  MOV.B   W0L,92C
02A9C:  CALL    7F4
02AA0:  BRA     2A8C
....................    LCDSetCursor(Line_2); 
02AA2:  MOV.B   #40,W0L
02AA4:  MOV.B   W0L,92A
02AA6:  CALL    7FE
....................    LCDMsg("   from ROM..."); 
02AAA:  MOV     #0,W5
02AAC:  MOV     W5,W0
02AAE:  CALL    464
02AB2:  IOR.B   #0,W0L
02AB4:  BTSC.B  42.1
02AB6:  BRA     2AC2
02AB8:  INC     W5,W5
02ABA:  MOV.B   W0L,92C
02ABC:  CALL    7F4
02AC0:  BRA     2AAC
....................    
....................    Rd_Flash2();                                   // чтение денных из флеш для расчета контр. суммы 
02AC2:  CALL    A5C
....................    crc1 = CRC_buf;                               // сохраненная контр. сумма     
02AC6:  MOV.B   8FB,W0L
02AC8:  MOV.B   W0L,8F9
....................    crc2 = CRC16(flash_rd_U16,2);                 // текущая контр. сумма. 
02ACA:  MOV     #8DC,W4
02ACC:  MOV     W4,91C
02ACE:  MOV     #2,W4
02AD0:  MOV     W4,91E
02AD2:  CALL    ABE
02AD6:  MOV.B   W0L,8FA
....................    
....................    LCDSetCursor(Line_3); 
02AD8:  MOV.B   #10,W0L
02ADA:  MOV.B   W0L,92A
02ADC:  CALL    7FE
....................    
....................    if (crc1==crc2){LCDMsg("       OK!");} 
02AE0:  MOV.B   8F9,W0L
02AE2:  CP.B    8FA
02AE4:  BRA     NZ,2B02
02AE6:  MOV     #0,W5
02AE8:  MOV     W5,W0
02AEA:  CALL    480
02AEE:  IOR.B   #0,W0L
02AF0:  BTSC.B  42.1
02AF2:  BRA     2AFE
02AF4:  INC     W5,W5
02AF6:  MOV.B   W0L,92C
02AF8:  CALL    7F4
02AFC:  BRA     2AE8
02AFE:  GOTO    2B22
....................    else { 
....................       LCDMsg("   CRC error!"); 
02B02:  MOV     #0,W5
02B04:  MOV     W5,W0
02B06:  CALL    498
02B0A:  IOR.B   #0,W0L
02B0C:  BTSC.B  42.1
02B0E:  BRA     2B1A
02B10:  INC     W5,W5
02B12:  MOV.B   W0L,92C
02B14:  CALL    7F4
02B18:  BRA     2B04
....................       ADC_sps_var = 3;                              // сброс значений по умолчанию,  
02B1A:  MOV.B   #3,W0L
02B1C:  MOV.B   W0L,8F8
....................       NumAver = 1;                                  // т.к. произошел сбой контр. суммы 
02B1E:  MOV.B   #1,W0L
02B20:  MOV.B   W0L,8F7
....................       } 
....................  
....................    ADC_wakeUp();                             // Сброс АЦП  
02B22:  CALL    AF6
....................    ADC_wakeUp();                             // перед инициализацией 
02B26:  CALL    AF6
....................    ADC_init();                               // Инициализация АЦП 
02B2A:  CALL    C42
....................    ADC_SelfCal();                            // Автокалибровка АЦП 
02B2E:  CALL    CDE
....................    delay_ms(1000); 
02B32:  MOV     #3E8,W0
02B34:  CALL    6C4
....................    
....................    LCDclear(); 
02B38:  CALL    7AE
.................... //   T_Pulse = 10000; 
.................... //   Number_Pulse = 1000; 
.................... //   TmpInt = 0; 
....................    K1 = 600.0; 
02B3C:  CLR     910
02B3E:  MOV     #4416,W4
02B40:  MOV     W4,912
....................    K2 = 5.0; 
02B42:  CLR     914
02B44:  MOV     #40A0,W4
02B46:  MOV     W4,916
....................    
.................... /*############################################################################*/   
....................  
....................    while(true){ 
.................... //      Status_LED = RD11; 
.................... /*      delay_ms(200); 
....................       Status_LED = 0; 
....................       delay_ms(200); 
....................       */ 
.................... //      PI_regulator();                                                                     // Включается регулятор 
....................     
....................       if (reset_fl)     {Full_dev_reset();}                                               // полный сброс системы 
02B48:  BTSS.B  8F4.2
02B4A:  BRA     2B50
02B4C:  CALL    DB8
....................       if (!meas_stop_fl){ADC_rd_and_print_ch(2);}                                         // чтение четырех каналов АЦП,                                                                                     
02B50:  BTSC.B  8F4.0
02B52:  BRA     2B5C
02B54:  MOV.B   #2,W0L
02B56:  MOV.B   W0L,91C
02B58:  CALL    2090
....................                                                                                           // вывод на дисплей и UART 
....................       PI_regulator();                                                                     // Включается регулятор 
02B5C:  CALL    23C4
....................       if (menu_fl){                                                                       // вызов и обработка меню  
02B60:  CP0.B   8F3
02B62:  BRA     Z,316A
....................          if (LCD_clear_fl){LCD_clear_fl = 0; LCDClear();}                                 // очистка экрана  
02B64:  BTSS.B  8F4.1
02B66:  BRA     2B6E
02B68:  BCLR.B  8F4.1
02B6A:  CALL    7AE
....................          Bpush_delay();                                                                   // подавление дребезга кнопок         
02B6E:  CALL    24A0
....................          switch (menu_item){                                                              // древо меню                                                    
02B72:  MOV.B   8E5,W0L
02B74:  CLR.B   1
02B76:  XOR     #0,W0
02B78:  BRA     Z,2B90
02B7A:  XOR     #1,W0
02B7C:  BRA     Z,2B96
02B7E:  XOR     #3,W0
02B80:  BRA     Z,2C36
02B82:  XOR     #1,W0
02B84:  BRA     Z,2DB8
02B86:  XOR     #7,W0
02B88:  BRA     Z,2F78
02B8A:  XOR     #1,W0
02B8C:  BRA     Z,30EA
02B8E:  BRA     316A
....................             case 0: 
....................                meas_stop_fl = 0; break;                                                   // возврат в измерения  
02B90:  BCLR.B  8F4.0
02B92:  GOTO    316A
....................             case 1:  
....................                LCD_main_menu();                                                           // ADC average set 
02B96:  CALL    2532
....................                if  (CN2 == 1){ 
02B9A:  BTSS.B  2C8.2
02B9C:  BRA     2C32
....................                   Bpush_delay(); 
02B9E:  CALL    24A0
....................                   if ((CN2 == 1) & (menu_sel==0)){                                        // ADC sps set menu 
02BA2:  CLR     W0
02BA4:  BTSC.B  2C8.2
02BA6:  INC     W0,W0
02BA8:  MOV.B   W0L,W6L
02BAA:  MOV.B   8F2,W0L
02BAC:  SE      W0,W0
02BAE:  CP0     W0
02BB0:  BRA     Z,2BB8
02BB2:  CLR.B   W0
02BB4:  GOTO    2BBA
02BB8:  MOV.B   #1,W0L
02BBA:  AND.B   W6L,W0L,W0L
02BBC:  CP0.B   W0L
02BBE:  BRA     Z,2BC6
....................                      LCD_clear_fl = 1; menu_item = 2; }                        
02BC0:  BSET.B  8F4.1
02BC2:  MOV.B   #2,W0L
02BC4:  MOV.B   W0L,8E5
....................                   if ((CN2 == 1) & (menu_sel==1)){                                        // К1 
02BC6:  CLR     W0
02BC8:  BTSC.B  2C8.2
02BCA:  INC     W0,W0
02BCC:  MOV.B   W0L,W6L
02BCE:  MOV.B   8F2,W0L
02BD0:  SE      W0,W0
02BD2:  CP      W0,#1
02BD4:  BRA     Z,2BDC
02BD6:  CLR.B   W0
02BD8:  GOTO    2BDE
02BDC:  MOV.B   #1,W0L
02BDE:  AND.B   W6L,W0L,W0L
02BE0:  CP0.B   W0L
02BE2:  BRA     Z,2BEA
....................                      LCD_clear_fl = 1; menu_item = 3; }                     
02BE4:  BSET.B  8F4.1
02BE6:  MOV.B   #3,W0L
02BE8:  MOV.B   W0L,8E5
....................                   if ((CN2 == 1) & (menu_sel==2)){                                        // К2 
02BEA:  CLR     W0
02BEC:  BTSC.B  2C8.2
02BEE:  INC     W0,W0
02BF0:  MOV.B   W0L,W6L
02BF2:  MOV.B   8F2,W0L
02BF4:  SE      W0,W0
02BF6:  CP      W0,#2
02BF8:  BRA     Z,2C00
02BFA:  CLR.B   W0
02BFC:  GOTO    2C02
02C00:  MOV.B   #1,W0L
02C02:  AND.B   W6L,W0L,W0L
02C04:  CP0.B   W0L
02C06:  BRA     Z,2C0E
....................                      LCD_clear_fl = 1; menu_item = 4; }                       
02C08:  BSET.B  8F4.1
02C0A:  MOV.B   #4,W0L
02C0C:  MOV.B   W0L,8E5
....................                   if ((CN2 == 1) & (menu_sel==3)){                                        // Reset device 
02C0E:  CLR     W0
02C10:  BTSC.B  2C8.2
02C12:  INC     W0,W0
02C14:  MOV.B   W0L,W6L
02C16:  MOV.B   8F2,W0L
02C18:  SE      W0,W0
02C1A:  CP      W0,#3
02C1C:  BRA     Z,2C24
02C1E:  CLR.B   W0
02C20:  GOTO    2C26
02C24:  MOV.B   #1,W0L
02C26:  AND.B   W6L,W0L,W0L
02C28:  CP0.B   W0L
02C2A:  BRA     Z,2C32
....................                      LCD_clear_fl = 1; menu_item = 5; }} 
02C2C:  BSET.B  8F4.1
02C2E:  MOV.B   #5,W0L
02C30:  MOV.B   W0L,8E5
....................                break; 
02C32:  GOTO    316A
....................             case 2:                                                                       // ADC sps set menu   
....................                LCDsetCursor(Line_1); 
02C36:  CLR.B   92A
02C38:  CALL    7FE
....................                LCDMsg("Samples per sec."); 
02C3C:  MOV     #0,W5
02C3E:  MOV     W5,W0
02C40:  CALL    4B2
02C44:  IOR.B   #0,W0L
02C46:  BTSC.B  42.1
02C48:  BRA     2C54
02C4A:  INC     W5,W5
02C4C:  MOV.B   W0L,92C
02C4E:  CALL    7F4
02C52:  BRA     2C3E
....................                LCDsetCursor(Line_3); 
02C54:  MOV.B   #10,W0L
02C56:  MOV.B   W0L,92A
02C58:  CALL    7FE
....................                if(CN4){Bpush_delay(); if(CN4) ADC_sps_var=ADC_sps_var-1; delay_ms(200);} 
02C5C:  BTSS.B  2C8.4
02C5E:  BRA     2C74
02C60:  CALL    24A0
02C64:  BTSS.B  2C8.4
02C66:  BRA     2C6E
02C68:  MOV     8F8,W4
02C6A:  SUB.B   W4L,#1,W0L
02C6C:  MOV.B   W0L,8F8
02C6E:  MOV     #C8,W0
02C70:  CALL    6C4
....................                if(CN3){Bpush_delay(); if(CN3) ADC_sps_var=ADC_sps_var+1; delay_ms(200);} 
02C74:  BTSS.B  2C8.5
02C76:  BRA     2C8E
02C78:  CALL    24A0
02C7C:  BTSS.B  2C8.5
02C7E:  BRA     2C88
02C80:  MOV     8F8,W4
02C82:  ADD.B   W4L,#1,W4L
02C84:  MOV.B   W4L,W0L
02C86:  MOV.B   W0L,8F8
02C88:  MOV     #C8,W0
02C8A:  CALL    6C4
....................                if(ADC_sps_var>7)  ADC_sps_var = 7; 
02C8E:  MOV     8F8,W4
02C90:  CP.B    W4L,#7
02C92:  BRA     LEU,2C98
02C94:  MOV.B   #7,W0L
02C96:  MOV.B   W0L,8F8
....................                if(ADC_sps_var==0) ADC_sps_var = 1; 
02C98:  CP0.B   8F8
02C9A:  BRA     NZ,2CA0
02C9C:  MOV.B   #1,W0L
02C9E:  MOV.B   W0L,8F8
....................                switch (ADC_sps_var){                                                      // передача величины скорости измерений АЦП  
02CA0:  MOV.B   8F8,W0L
02CA2:  CLR.B   1
02CA4:  XOR     #1,W0
02CA6:  BRA     Z,2CC2
02CA8:  XOR     #3,W0
02CAA:  BRA     Z,2CE4
02CAC:  XOR     #1,W0
02CAE:  BRA     Z,2D06
02CB0:  XOR     #7,W0
02CB2:  BRA     Z,2D28
02CB4:  XOR     #1,W0
02CB6:  BRA     Z,2D4A
02CB8:  XOR     #3,W0
02CBA:  BRA     Z,2D6C
02CBC:  XOR     #1,W0
02CBE:  BRA     Z,2D8E
02CC0:  BRA     2DB0
....................                   case 1: ADC_sps_set(0x23); LCDsetCursor(0x16); LCDputU16(10,4);  break; // 10   sps 
02CC2:  MOV.B   #23,W0L
02CC4:  MOV.B   W0L,91C
02CC6:  CALL    C2C
02CCA:  MOV.B   #16,W0L
02CCC:  MOV.B   W0L,92A
02CCE:  CALL    7FE
02CD2:  MOV.B   #4,W0L
02CD4:  MOV.B   W0L,930
02CD6:  MOV     #A,W4
02CD8:  MOV     W4,92C
02CDA:  CLR     92E
02CDC:  CALL    1C9E
02CE0:  GOTO    2DB0
....................                   case 2: ADC_sps_set(0x43); LCDsetCursor(0x16); LCDputU16(25,4);  break; // 25   sps 
02CE4:  MOV.B   #43,W0L
02CE6:  MOV.B   W0L,91C
02CE8:  CALL    C2C
02CEC:  MOV.B   #16,W0L
02CEE:  MOV.B   W0L,92A
02CF0:  CALL    7FE
02CF4:  MOV.B   #4,W0L
02CF6:  MOV.B   W0L,930
02CF8:  MOV     #19,W4
02CFA:  MOV     W4,92C
02CFC:  CLR     92E
02CFE:  CALL    1C9E
02D02:  GOTO    2DB0
....................                   case 3: ADC_sps_set(0x63); LCDsetCursor(0x16); LCDputU16(50,4);  break; // 50   sps 
02D06:  MOV.B   #63,W0L
02D08:  MOV.B   W0L,91C
02D0A:  CALL    C2C
02D0E:  MOV.B   #16,W0L
02D10:  MOV.B   W0L,92A
02D12:  CALL    7FE
02D16:  MOV.B   #4,W0L
02D18:  MOV.B   W0L,930
02D1A:  MOV     #32,W4
02D1C:  MOV     W4,92C
02D1E:  CLR     92E
02D20:  CALL    1C9E
02D24:  GOTO    2DB0
....................                   case 4: ADC_sps_set(0x82); LCDsetCursor(0x16); LCDputU16(100,4); break; // 100  sps 
02D28:  MOV.B   #82,W0L
02D2A:  MOV.B   W0L,91C
02D2C:  CALL    C2C
02D30:  MOV.B   #16,W0L
02D32:  MOV.B   W0L,92A
02D34:  CALL    7FE
02D38:  MOV.B   #4,W0L
02D3A:  MOV.B   W0L,930
02D3C:  MOV     #64,W4
02D3E:  MOV     W4,92C
02D40:  CLR     92E
02D42:  CALL    1C9E
02D46:  GOTO    2DB0
....................                   case 5: ADC_sps_set(0x91); LCDsetCursor(0x16); LCDputU16(500,4); break; // 500  sps 
02D4A:  MOV.B   #91,W0L
02D4C:  MOV.B   W0L,91C
02D4E:  CALL    C2C
02D52:  MOV.B   #16,W0L
02D54:  MOV.B   W0L,92A
02D56:  CALL    7FE
02D5A:  MOV.B   #4,W0L
02D5C:  MOV.B   W0L,930
02D5E:  MOV     #1F4,W4
02D60:  MOV     W4,92C
02D62:  CLR     92E
02D64:  CALL    1C9E
02D68:  GOTO    2DB0
....................                   case 6: ADC_sps_set(0xA1); LCDsetCursor(0x16); LCDputU16(1000,4);break; // 1000 sps 
02D6C:  MOV.B   #A1,W0L
02D6E:  MOV.B   W0L,91C
02D70:  CALL    C2C
02D74:  MOV.B   #16,W0L
02D76:  MOV.B   W0L,92A
02D78:  CALL    7FE
02D7C:  MOV.B   #4,W0L
02D7E:  MOV.B   W0L,930
02D80:  MOV     #3E8,W4
02D82:  MOV     W4,92C
02D84:  CLR     92E
02D86:  CALL    1C9E
02D8A:  GOTO    2DB0
....................                   case 7: ADC_sps_set(0xC0); LCDsetCursor(0x16); LCDputU16(3750,4);break; // 3750 sps 
02D8E:  MOV.B   #C0,W0L
02D90:  MOV.B   W0L,91C
02D92:  CALL    C2C
02D96:  MOV.B   #16,W0L
02D98:  MOV.B   W0L,92A
02D9A:  CALL    7FE
02D9E:  MOV.B   #4,W0L
02DA0:  MOV.B   W0L,930
02DA2:  MOV     #EA6,W4
02DA4:  MOV     W4,92C
02DA6:  CLR     92E
02DA8:  CALL    1C9E
02DAC:  GOTO    2DB0
....................                   }      
....................                save_to_flash(); 
02DB0:  CALL    2874
....................                break;   
02DB4:  GOTO    316A
....................             case 3:                                                                       // K1   
....................                LCDsetCursor(Line_1); 
02DB8:  CLR.B   92A
02DBA:  CALL    7FE
....................                LCDMsg(" Коэффициент К1 "); 
02DBE:  MOV     #0,W5
02DC0:  MOV     W5,W0
02DC2:  CALL    4D0
02DC6:  IOR.B   #0,W0L
02DC8:  BTSC.B  42.1
02DCA:  BRA     2DD6
02DCC:  INC     W5,W5
02DCE:  MOV.B   W0L,92C
02DD0:  CALL    7F4
02DD4:  BRA     2DC0
....................                LCDsetCursor(Line_3);                
02DD6:  MOV.B   #10,W0L
02DD8:  MOV.B   W0L,92A
02DDA:  CALL    7FE
....................                if(CN4 == 1){ 
02DDE:  BTSS.B  2C8.4
02DE0:  BRA     2E74
....................                   Bpush_delay(); 
02DE2:  CALL    24A0
....................                   if(CN4 == 1){ 
02DE6:  BTSS.B  2C8.4
02DE8:  BRA     2E70
....................                      count_CN4++;                                                         // Для ускорения декремента, если долго жать кнопку 
02DEA:  INC.B   08F5
....................                      if (count_CN4 <= 20) K1 = K1 - 0.1; 
02DEC:  MOV     8F4,W4
02DEE:  LSR     W4,#8,W4
02DF0:  CP.B    W4L,#14
02DF2:  BRA     GTU,2E06
02DF4:  BSET.B  43.0
02DF6:  MOV     910,W0
02DF8:  MOV     912,W1
02DFA:  MOV     #CCCD,W2
02DFC:  MOV     #3DCC,W3
02DFE:  CALL    152A
02E02:  MOV     W0,910
02E04:  MOV     W1,912
....................                      if (count_CN4 >= 21) {K1 = K1 - 1.0; K1 = K1 - 0.1;} 
02E06:  MOV     8F4,W4
02E08:  LSR     W4,#8,W4
02E0A:  CP.B    W4L,#15
02E0C:  BRA     NC,2E32
02E0E:  BSET.B  43.0
02E10:  MOV     910,W0
02E12:  MOV     912,W1
02E14:  MOV     #0,W2
02E16:  MOV     #3F80,W3
02E18:  CALL    152A
02E1C:  MOV     W0,910
02E1E:  MOV     W1,912
02E20:  BSET.B  43.0
02E22:  MOV     910,W0
02E24:  MOV     912,W1
02E26:  MOV     #CCCD,W2
02E28:  MOV     #3DCC,W3
02E2A:  CALL    152A
02E2E:  MOV     W0,910
02E30:  MOV     W1,912
....................                      if (count_CN4 >= 40) K1 = K1 - 10.0; 
02E32:  MOV     8F4,W4
02E34:  LSR     W4,#8,W4
02E36:  MOV     #28,W3
02E38:  CP.B    W3L,W4L
02E3A:  BRA     GTU,2E4E
02E3C:  BSET.B  43.0
02E3E:  MOV     910,W0
02E40:  MOV     912,W1
02E42:  MOV     #0,W2
02E44:  MOV     #4120,W3
02E46:  CALL    152A
02E4A:  MOV     W0,910
02E4C:  MOV     W1,912
....................                      if (count_CN4 >= 60) K1 = K1 - 100.0; 
02E4E:  MOV     8F4,W4
02E50:  LSR     W4,#8,W4
02E52:  MOV     #3C,W3
02E54:  CP.B    W3L,W4L
02E56:  BRA     GTU,2E6A
02E58:  BSET.B  43.0
02E5A:  MOV     910,W0
02E5C:  MOV     912,W1
02E5E:  MOV     #0,W2
02E60:  MOV     #42C8,W3
02E62:  CALL    152A
02E66:  MOV     W0,910
02E68:  MOV     W1,912
....................                      delay_ms(80); 
02E6A:  MOV     #50,W0
02E6C:  CALL    6C4
....................                      }                                                                    // декремент коэффициента К1                  
....................                   } 
02E70:  GOTO    2E7A
....................                   else if(CN4 == 0) count_CN4 = 0;   
02E74:  BTSC.B  2C8.4
02E76:  BRA     2E7A
02E78:  CLR.B   8F5
....................                if(CN3 == 1){ 
02E7A:  BTSS.B  2C8.5
02E7C:  BRA     2F0A
....................                   Bpush_delay(); 
02E7E:  CALL    24A0
....................                   if(CN3 == 1){ 
02E82:  BTSS.B  2C8.5
02E84:  BRA     2F06
....................                      count_CN3++;                                                         // Для ускорения инкремента, если долго держать кнопку 
02E86:  INC.B   08F6
....................                      if (count_CN3 <= 20) K1 = K1 + 0.1; 
02E88:  MOV     8F6,W4
02E8A:  CP.B    W4L,#14
02E8C:  BRA     GTU,2EA0
02E8E:  BCLR.B  43.0
02E90:  MOV     910,W0
02E92:  MOV     912,W1
02E94:  MOV     #CCCD,W2
02E96:  MOV     #3DCC,W3
02E98:  CALL    152A
02E9C:  MOV     W0,910
02E9E:  MOV     W1,912
....................                      if (count_CN3 >= 21) {K1 = K1 + 1.0; K1 = K1 + 0.1;} 
02EA0:  MOV     8F6,W4
02EA2:  CP.B    W4L,#15
02EA4:  BRA     NC,2ECA
02EA6:  BCLR.B  43.0
02EA8:  MOV     910,W0
02EAA:  MOV     912,W1
02EAC:  MOV     #0,W2
02EAE:  MOV     #3F80,W3
02EB0:  CALL    152A
02EB4:  MOV     W0,910
02EB6:  MOV     W1,912
02EB8:  BCLR.B  43.0
02EBA:  MOV     910,W0
02EBC:  MOV     912,W1
02EBE:  MOV     #CCCD,W2
02EC0:  MOV     #3DCC,W3
02EC2:  CALL    152A
02EC6:  MOV     W0,910
02EC8:  MOV     W1,912
....................                      if (count_CN3 >= 40) K1 = K1 + 10.0; 
02ECA:  MOV     8F6,W4
02ECC:  MOV     #28,W3
02ECE:  CP.B    W3L,W4L
02ED0:  BRA     GTU,2EE4
02ED2:  BCLR.B  43.0
02ED4:  MOV     910,W0
02ED6:  MOV     912,W1
02ED8:  MOV     #0,W2
02EDA:  MOV     #4120,W3
02EDC:  CALL    152A
02EE0:  MOV     W0,910
02EE2:  MOV     W1,912
....................                      if (count_CN4 >= 60) K1 = K1 + 100.0; 
02EE4:  MOV     8F4,W4
02EE6:  LSR     W4,#8,W4
02EE8:  MOV     #3C,W3
02EEA:  CP.B    W3L,W4L
02EEC:  BRA     GTU,2F00
02EEE:  BCLR.B  43.0
02EF0:  MOV     910,W0
02EF2:  MOV     912,W1
02EF4:  MOV     #0,W2
02EF6:  MOV     #42C8,W3
02EF8:  CALL    152A
02EFC:  MOV     W0,910
02EFE:  MOV     W1,912
....................                      delay_ms(80); 
02F00:  MOV     #50,W0
02F02:  CALL    6C4
....................                      }                  
....................                   } 
02F06:  GOTO    2F10
....................                   else if(CN3 == 0) count_CN3 = 0; 
02F0A:  BTSC.B  2C8.5
02F0C:  BRA     2F10
02F0E:  CLR.B   8F6
....................                if (K1 <= 1) K1 = 1; 
02F10:  MOV     910,W0
02F12:  MOV     912,W1
02F14:  MOV     #0,W2
02F16:  MOV     #3F80,W3
02F18:  CALL    16D4
02F1C:  BRA     C,2F20
02F1E:  BRA     NZ,2F26
02F20:  CLR     910
02F22:  MOV     #3F80,W4
02F24:  MOV     W4,912
....................                Destroy_float(K1);                                                         // Разбивка коэффициента К1 на целую часть и остаток 
02F26:  PUSH    910
02F28:  POP     91C
02F2A:  PUSH    912
02F2C:  POP     91E
02F2E:  CALL    288C
....................                LCDsetCursor(0x16); 
02F32:  MOV.B   #16,W0L
02F34:  MOV.B   W0L,92A
02F36:  CALL    7FE
....................                LCDputU16(Integer_part,4); LCDMsg(","); LCDputU16(Tenth,1);                // Вывод на дисплей коэффициента К1           
02F3A:  MOV.B   #4,W0L
02F3C:  MOV.B   W0L,930
02F3E:  PUSH    918
02F40:  POP     92C
02F42:  CLR     92E
02F44:  CALL    1C9E
02F48:  MOV     #0,W5
02F4A:  MOV     W5,W0
02F4C:  CALL    4EE
02F50:  IOR.B   #0,W0L
02F52:  BTSC.B  42.1
02F54:  BRA     2F60
02F56:  INC     W5,W5
02F58:  MOV.B   W0L,92C
02F5A:  CALL    7F4
02F5E:  BRA     2F4A
02F60:  MOV.B   91A,W0L
02F62:  MOV.B   W0L,92C
02F64:  CLR.B   92D
02F66:  CLR     92E
02F68:  MOV.B   #1,W0L
02F6A:  MOV.B   W0L,930
02F6C:  CALL    1C9E
....................                save_to_flash(); 
02F70:  CALL    2874
....................                break;               
02F74:  GOTO    316A
....................             case 4:                                                                       // K2   
....................                LCDsetCursor(Line_1); 
02F78:  CLR.B   92A
02F7A:  CALL    7FE
....................                LCDMsg(" Коэффициент К2 "); 
02F7E:  MOV     #0,W5
02F80:  MOV     W5,W0
02F82:  CALL    4FC
02F86:  IOR.B   #0,W0L
02F88:  BTSC.B  42.1
02F8A:  BRA     2F96
02F8C:  INC     W5,W5
02F8E:  MOV.B   W0L,92C
02F90:  CALL    7F4
02F94:  BRA     2F80
....................                LCDsetCursor(Line_3); 
02F96:  MOV.B   #10,W0L
02F98:  MOV.B   W0L,92A
02F9A:  CALL    7FE
....................                if(CN4 == 1){ 
02F9E:  BTSS.B  2C8.4
02FA0:  BRA     3018
....................                   Bpush_delay(); 
02FA2:  CALL    24A0
....................                   if(CN4 == 1){ 
02FA6:  BTSS.B  2C8.4
02FA8:  BRA     3014
....................                      count_CN4++;                                                         // Для ускорения декремента, если долго держать кнопку 
02FAA:  INC.B   08F5
....................                      if (count_CN4 <= 20) K2 = K2 - 0.1; 
02FAC:  MOV     8F4,W4
02FAE:  LSR     W4,#8,W4
02FB0:  CP.B    W4L,#14
02FB2:  BRA     GTU,2FC6
02FB4:  BSET.B  43.0
02FB6:  MOV     914,W0
02FB8:  MOV     916,W1
02FBA:  MOV     #CCCD,W2
02FBC:  MOV     #3DCC,W3
02FBE:  CALL    152A
02FC2:  MOV     W0,914
02FC4:  MOV     W1,916
....................                      if (count_CN4 >= 21) {K2 = K2 - 1.0; K2 = K2 - 0.1;} 
02FC6:  MOV     8F4,W4
02FC8:  LSR     W4,#8,W4
02FCA:  CP.B    W4L,#15
02FCC:  BRA     NC,2FF2
02FCE:  BSET.B  43.0
02FD0:  MOV     914,W0
02FD2:  MOV     916,W1
02FD4:  MOV     #0,W2
02FD6:  MOV     #3F80,W3
02FD8:  CALL    152A
02FDC:  MOV     W0,914
02FDE:  MOV     W1,916
02FE0:  BSET.B  43.0
02FE2:  MOV     914,W0
02FE4:  MOV     916,W1
02FE6:  MOV     #CCCD,W2
02FE8:  MOV     #3DCC,W3
02FEA:  CALL    152A
02FEE:  MOV     W0,914
02FF0:  MOV     W1,916
....................                      if (count_CN4 >= 40) K2 = K2 - 10.0; 
02FF2:  MOV     8F4,W4
02FF4:  LSR     W4,#8,W4
02FF6:  MOV     #28,W3
02FF8:  CP.B    W3L,W4L
02FFA:  BRA     GTU,300E
02FFC:  BSET.B  43.0
02FFE:  MOV     914,W0
03000:  MOV     916,W1
03002:  MOV     #0,W2
03004:  MOV     #4120,W3
03006:  CALL    152A
0300A:  MOV     W0,914
0300C:  MOV     W1,916
....................                      delay_ms(80); 
0300E:  MOV     #50,W0
03010:  CALL    6C4
....................                      }                                                                    // декремент коэффициента К2                  
....................                   } 
03014:  GOTO    301E
....................                   else if(CN4 == 0) count_CN4 = 0;   
03018:  BTSC.B  2C8.4
0301A:  BRA     301E
0301C:  CLR.B   8F5
....................                if(CN3 == 1){ 
0301E:  BTSS.B  2C8.5
03020:  BRA     3092
....................                   Bpush_delay(); 
03022:  CALL    24A0
....................                   if(CN3 == 1){ 
03026:  BTSS.B  2C8.5
03028:  BRA     308E
....................                      count_CN3++;                                                         // Для ускорения инкремента, если долго держать кнопку 
0302A:  INC.B   08F6
....................                      if (count_CN3 <= 20) K2 = K2 + 0.1; 
0302C:  MOV     8F6,W4
0302E:  CP.B    W4L,#14
03030:  BRA     GTU,3044
03032:  BCLR.B  43.0
03034:  MOV     914,W0
03036:  MOV     916,W1
03038:  MOV     #CCCD,W2
0303A:  MOV     #3DCC,W3
0303C:  CALL    152A
03040:  MOV     W0,914
03042:  MOV     W1,916
....................                      if (count_CN3 >= 21) {K2 = K2 + 1.0; K2 = K2 + 0.1;} 
03044:  MOV     8F6,W4
03046:  CP.B    W4L,#15
03048:  BRA     NC,306E
0304A:  BCLR.B  43.0
0304C:  MOV     914,W0
0304E:  MOV     916,W1
03050:  MOV     #0,W2
03052:  MOV     #3F80,W3
03054:  CALL    152A
03058:  MOV     W0,914
0305A:  MOV     W1,916
0305C:  BCLR.B  43.0
0305E:  MOV     914,W0
03060:  MOV     916,W1
03062:  MOV     #CCCD,W2
03064:  MOV     #3DCC,W3
03066:  CALL    152A
0306A:  MOV     W0,914
0306C:  MOV     W1,916
....................                      if (count_CN3 >= 40) K2 = K2 + 10.0; 
0306E:  MOV     8F6,W4
03070:  MOV     #28,W3
03072:  CP.B    W3L,W4L
03074:  BRA     GTU,3088
03076:  BCLR.B  43.0
03078:  MOV     914,W0
0307A:  MOV     916,W1
0307C:  MOV     #0,W2
0307E:  MOV     #4120,W3
03080:  CALL    152A
03084:  MOV     W0,914
03086:  MOV     W1,916
....................                      delay_ms(80); 
03088:  MOV     #50,W0
0308A:  CALL    6C4
....................                      }                  
....................                   } 
0308E:  GOTO    3098
....................                   else if(CN3 == 0) count_CN3 = 0; 
03092:  BTSC.B  2C8.5
03094:  BRA     3098
03096:  CLR.B   8F6
....................                LCDsetCursor(0x16); 
03098:  MOV.B   #16,W0L
0309A:  MOV.B   W0L,92A
0309C:  CALL    7FE
....................                Destroy_float(K2);                                                         // Разбивка коэффициента К2 на целую часть и остаток 
030A0:  PUSH    914
030A2:  POP     91C
030A4:  PUSH    916
030A6:  POP     91E
030A8:  CALL    288C
....................                LCDputU16(Integer_part,2); LCDMsg(","); LCDputU16(Tenth,1);                // Вывод на дисплей коэффициента К2 
030AC:  MOV.B   #2,W0L
030AE:  MOV.B   W0L,930
030B0:  PUSH    918
030B2:  POP     92C
030B4:  CLR     92E
030B6:  CALL    1C9E
030BA:  MOV     #0,W5
030BC:  MOV     W5,W0
030BE:  CALL    4EE
030C2:  IOR.B   #0,W0L
030C4:  BTSC.B  42.1
030C6:  BRA     30D2
030C8:  INC     W5,W5
030CA:  MOV.B   W0L,92C
030CC:  CALL    7F4
030D0:  BRA     30BC
030D2:  MOV.B   91A,W0L
030D4:  MOV.B   W0L,92C
030D6:  CLR.B   92D
030D8:  CLR     92E
030DA:  MOV.B   #1,W0L
030DC:  MOV.B   W0L,930
030DE:  CALL    1C9E
....................                save_to_flash(); 
030E2:  CALL    2874
....................                break;                
030E6:  GOTO    316A
....................             case 5:                                                                       // Reset menu 
....................                LCDsetCursor(Line_1); 
030EA:  CLR.B   92A
030EC:  CALL    7FE
....................                LCDMsg(" Reset device?"); 
030F0:  MOV     #0,W5
030F2:  MOV     W5,W0
030F4:  CALL    51A
030F8:  IOR.B   #0,W0L
030FA:  BTSC.B  42.1
030FC:  BRA     3108
030FE:  INC     W5,W5
03100:  MOV.B   W0L,92C
03102:  CALL    7F4
03106:  BRA     30F2
....................                LCDsetCursor(Line_3); 
03108:  MOV.B   #10,W0L
0310A:  MOV.B   W0L,92A
0310C:  CALL    7FE
....................                LCDMsg("    Yes -> +"); 
03110:  MOV     #0,W5
03112:  MOV     W5,W0
03114:  CALL    536
03118:  IOR.B   #0,W0L
0311A:  BTSC.B  42.1
0311C:  BRA     3128
0311E:  INC     W5,W5
03120:  MOV.B   W0L,92C
03122:  CALL    7F4
03126:  BRA     3112
....................                LCDsetCursor(Line_4); 
03128:  MOV.B   #50,W0L
0312A:  MOV.B   W0L,92A
0312C:  CALL    7FE
....................                LCDMsg("    No  -> -"); 
03130:  MOV     #0,W5
03132:  MOV     W5,W0
03134:  CALL    550
03138:  IOR.B   #0,W0L
0313A:  BTSC.B  42.1
0313C:  BRA     3148
0313E:  INC     W5,W5
03140:  MOV.B   W0L,92C
03142:  CALL    7F4
03146:  BRA     3132
....................                if(CN3){Bpush_delay(); if(CN3) {reset_fl = 1;}}                            // поднятие флага RESET для сброса всей системы 
03148:  BTSS.B  2C8.5
0314A:  BRA     3156
0314C:  CALL    24A0
03150:  BTSS.B  2C8.5
03152:  BRA     3156
03154:  BSET.B  8F4.2
....................                if(CN4){Bpush_delay(); if(CN4) {menu_item= 1;}}                            // отмена и выход в меню         
03156:  BTSS.B  2C8.4
03158:  BRA     3166
0315A:  CALL    24A0
0315E:  BTSS.B  2C8.4
03160:  BRA     3166
03162:  MOV.B   #1,W0L
03164:  MOV.B   W0L,8E5
....................                break; 
03166:  GOTO    316A
....................             }   
....................          }   
0316A:  GOTO    2B48
....................       } 
.................... } 
.................... /*############################################################################*/ 
0316E:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 00CE   WRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0083   PR_PLL IESO
          H: FF00  
   Word  5L: 0006   HS NOOSCIO CKSFSM
          H: FF00  
   Word  6L: 00DD   WPOSTS14 WPRES128 WINDIS WDT
          H: FF00  
   Word  7L: 00E7   PUT128
          H: FF00  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: FF00  
